<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>大数据经典文章解读</title>
      <link href="/2022/03/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%96%87%E7%AB%A0%E8%A7%A3%E8%AF%BB/"/>
      <url>/2022/03/22/%E5%A4%A7%E6%95%B0%E6%8D%AE%E6%96%87%E7%AB%A0%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="The-Google-File-System-（一）：-Master的三个身份"><a href="#The-Google-File-System-（一）：-Master的三个身份" class="headerlink" title="The Google File System （一）： Master的三个身份"></a>The Google File System （一）： Master的三个身份</h3><h4 id="GFS的设计决策"><a href="#GFS的设计决策" class="headerlink" title="GFS的设计决策"></a>GFS的设计决策</h4><ul><li><p>第一个以工程上”简单“作为设计原则</p><p>GFS 直接使用了 Linux 服务上的普通文件作为基础存储层，并且选择了最简单的单 Master 设计。单 Master 让 GFS 的架构变得非常简单，避免了需要管理复杂的一致性问题。不过它也带来了很多限制，比如一旦 Master 出现故障，整个集群就无法写入数据，而恢复 Master 则需要运维人员手动操作，所以 GFS 其实算不上一个高可用的系统。</p></li><li><p>第二个是根据硬件特性来进行设计取舍</p></li><li><p>第三个是根据实际应用特性，放宽了数据一致性(Consistency)的选择</p></li></ul><p><img src="https://static001.geekbang.org/resource/image/15/15/158149b378d1d5b383078b3ee3440915.jpg?wh=1920x947" alt></p><p><strong>1、相对于存储数据的 Chunkserver，Master 是一个目录服务</strong></p><p>在 GFS 里面，会把每一个文件按照 64MB 一块的大小，切分成一个个 chunk。每个 chunk 都会有一个在 GFS 上的唯一的 handle，这个 handle 其实就是一个编号，能够唯一标识出具体的 chunk。然后每一个 chunk，都会以一个文件的形式，放在 chunkserver 上。</p><p>而 chunkserver，会负责和 master 以及 GFS 的客户端进行 RPC 通信，完成实际的数据读写操作。当然，为了确保数据不会因为某一个 chunkserver 坏了就丢失了，每个 chunk 都会存上整整三份副本（replica）。其中一份是主数据（primary），两份是副数据（secondary），当三份数据出现不一致的时候，就以主数据为准。有了三个副本，不仅可以防止因为各种原因丢数据，还可以在有很多并发读取的时候，分摊系统读取的压力。</p><p><img src="https://static001.geekbang.org/resource/image/4c/2e/4ccb89f66276af2ce19c1fc83fdb432e.jpg?wh=2000x1504" alt></p><p><strong>2、相对于为了灾难恢复的 Backup Master，它是一个同步复制的主从架构下的主节点；</strong></p><p>主从服务器进行数据的同步复制，确保Master节点故障了，有backup节点可用，保障可用性，只有所有的backup Master写入成功，才算成功</p><p>为了缓解Master节点压力，Master的所有数据都是保存在内存里，Master会通过记录操作日志和定期生成对应的CheckPoints进行持久化，也就是写到硬盘上，Master节点重启时，会读取最新的CheckPoints，然后重放之后的操作日志进行恢复。</p><p><img src="https://static001.geekbang.org/resource/image/19/c1/199f3ddb59c4d0a0233f9b71549a85c1.jpg?wh=1920x1444" alt></p><p><strong>3、相对于为了保障读数据的可用性而设立的 Shadow Master，它是一个异步复制的主从架构下的主节点。</strong></p><p>为了保障节点挂了，进行新节点切换，快速恢复期间，数据仍然可读，加入了一系列的影子Master, 走数据的异步复制。</p><p><img src="https://static001.geekbang.org/resource/image/7a/2d/7a312ed6bda66ce6e8b112yyfb77c82d.jpg?wh=1920x1444" alt></p><p>客户端读取数据的整个过程指令流向</p><p><img src="https://static001.geekbang.org/resource/image/71/95/7124aa76c1ec715b2a29613b5f065d95.jpg?wh=2000x1504" alt></p><h3 id="The-Google-File-System-（二）：-如何应对网络瓶颈？"><a href="#The-Google-File-System-（二）：-如何应对网络瓶颈？" class="headerlink" title="The Google File System （二）： 如何应对网络瓶颈？"></a>The Google File System （二）： 如何应对网络瓶颈？</h3><h4 id="GFS的数据写入"><a href="#GFS的数据写入" class="headerlink" title="GFS的数据写入"></a><strong>GFS的数据写入</strong></h4><p><img src="https://static001.geekbang.org/resource/image/cd/e6/cd111d95dde55f57eb7cecf23da4e7e6.jpg?wh=1920x1080" alt></p><ul><li>第一步，客户端会去问 master 要写入的数据，应该在哪些 chunkserver 上。</li><li>第二步，和读数据一样，master 会告诉客户端所有的次副本（secondary replica）所在的 chunkserver。这还不够，master 还会告诉客户端哪个 replica 是“老大”，也就是主副本（primary replica），数据此时以它为准。</li><li>第三步，拿到数据应该写到哪些 chunkserver 里之后，客户端会把要写的数据发给所有的 replica。不过此时，chunkserver 拿到发过来的数据后还不会真的写下来，只会把数据放到LRU缓冲区里</li><li>第四步，等到所有次副本都接收完数据后，客户端就会发送一个写请求给到主副本。</li><li>第五步，主副本会把对应的写请求转发给所有的次副本，所有次副本会和主副本以同样的数据写入顺序，把数据写入到硬盘上。</li><li>第六步，次副本的数据写入完成之后，会回复主副本，我也把数据和你一样写完了。</li><li>第七步，主副本再去告诉客户端，这个数据写入成功了。而如果在任何一个副本写入数据的过程中出错了，这个出错都会告诉客户端，也就意味着这次写入其实失败了。</li></ul><h4 id="GFS解决网络带宽瓶颈的方法"><a href="#GFS解决网络带宽瓶颈的方法" class="headerlink" title="GFS解决网络带宽瓶颈的方法"></a>GFS解决网络带宽瓶颈的方法</h4><ul><li>分离控制流和数据流：Master只做元数据管理，数据写入不通过Master，从而避免了Master成为瓶颈 ，实际的数据传输过程和提供写入指令的动作是完全分离的。</li><li>流水式的网络数据传输，客户端传输数据，传输给到网络里离自己最近的次副本A，然后副本A一边接收数据，一边把数据传输给距离自己最近的另外一个副本。</li><li>独特的Snapshot操作：文件复制指令，客户端下发复制指令，指令通过控制流，下发到主副本服务器，次副本服务器，会在chunkserver本地执行数据复制，不再需要通过网络传输进行复制。</li></ul><h3 id="MapReduce（一）：源起Unix的设计思想"><a href="#MapReduce（一）：源起Unix的设计思想" class="headerlink" title="MapReduce（一）：源起Unix的设计思想"></a>MapReduce（一）：源起Unix的设计思想</h3><h4 id="MapReduce-编程模型"><a href="#MapReduce-编程模型" class="headerlink" title="MapReduce 编程模型"></a>MapReduce 编程模型</h4><p>Map 函数，顾名思义就是一个映射函数，它会接受一个 key-value 对，然后把这个 key-value 对转换成 0 到多个新的 key-value 对并输出出去。</p><pre><code>map(k1,v1) -&gt; list(k2,v2)</code></pre><p>Reduce 函数，则是一个函数，它接受一个 Key，以及这个 Key 下的一组 Value，然后化简成一组新的值 Value 输出出去。</p><pre><code>reduce(k2,list(v2)) -&gt; list(v3)</code></pre><p><img src="https://static001.geekbang.org/resource/image/26/a8/26c9fe6a96ec705c81f171b4ab373aa8.jpg?wh=1920x1080" alt></p><p>​    </p><h4 id="MapReduce应用场景"><a href="#MapReduce应用场景" class="headerlink" title="MapReduce应用场景"></a>MapReduce应用场景</h4><p><strong>分布式grep</strong></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计大纲</title>
      <link href="/2022/02/22/%E8%AE%BE%E8%AE%A1%E5%A4%A7%E7%BA%B2/"/>
      <url>/2022/02/22/%E8%AE%BE%E8%AE%A1%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、ES篇"><a href="#一、ES篇" class="headerlink" title="一、ES篇"></a>一、ES篇</h1><blockquote><p>Elasticsearch可以实现<strong>秒级</strong>的搜索，cluster是一种分布式的部署，极<strong>易扩展(scale )</strong>这样很容易使它处理PB级的数据库容量。最重要的是Elasticsearch是它搜索的结果可以按照分数进行排序，它能提供我们最<strong>相关</strong>的搜索结果（<strong>relevance</strong>) 。</p></blockquote><h2 id="1、概述"><a href="#1、概述" class="headerlink" title="1、概述"></a>1、概述</h2><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li><p><strong>安装方便</strong>：没有其他依赖，下载后安装非常方便；只用修改几个参数就可以搭建起来一个集群</p></li><li><p><strong>JSON</strong>：输入/输出格式为 JSON，意味着不需要定义 Schema，快捷方便</p></li><li><p><strong>RESTful</strong>：基本所有操作 ( 索引、查询、甚至是配置 ) 都可以通过 HTTP 接口进行</p></li><li><p><strong>分布式</strong>：节点对外表现对等（每个节点都可以用来做入口） 加入节点自动负载均衡</p></li><li><p><strong>多租户</strong>：可根据不同的用途分索引，可以同时操作多个索引</p></li><li><p><strong>支持超大数据</strong>： 可以扩展到 PB 级的结构化和非结构化数据 海量数据的近实时处理</p></li></ol><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li><p><strong>分布式的搜索引擎</strong></p><p>分布式：Elasticsearch自动将海量数据分散到多台服务器上去存储和检索</p></li><li><p><strong>全文检索</strong></p><p>提供模糊搜索等自动度很高的查询方式，并进行相关性排名，高亮等功能</p></li><li><p><strong>数据分析引擎（分组聚合）</strong></p><p>社区网站，最近一周用户登录、最近一个月各功能使用情况</p></li><li><p><strong>对海量数据进行近实时（秒级）的处理</strong></p><p>海量数据的处理：因为是分布式架构，可以采用大量的服务器去存储和检索数据</p></li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li><p><strong>搜索类</strong>场景</p><p>比如说人员检索、设备检索、App内的搜索、订单搜索。</p></li><li><p><strong>日志分析</strong>类场景</p><p>经典的ELK组合（<strong>Elasticsearch</strong>/<strong>Logstash</strong>/<strong>Kibana</strong>），实现<strong>日志收集</strong>，<strong>日志存储</strong>，<strong>日志分析</strong></p></li><li><p><strong>数据预警平台</strong>及数据分析场景</p><p>例如社区团购提示，当优惠的价格低于某个值时，自动触发通知消息，通知用户购买。</p><p>分析竞争对手商品销量Top10，供运营分析等等。</p></li><li><p><strong>商业BI(Business Intelligence)</strong>系统</p><p>比如社区周边，需要分析某一地区用户消费金额及商品类别，输出相应的报表数据，并预测该地区的热卖商品，通过区域和人群特征划分进行定向推荐。Elasticsearch执行数据分析和挖掘，Kibana做数据可视化。</p></li></ul><h3 id="竞品分析"><a href="#竞品分析" class="headerlink" title="竞品分析"></a>竞品分析</h3><p><strong>Lucene</strong></p><p>Java编写的信息搜索工具包（Jar包），Lucene只是一个框架，熟练运用Lucene非常复杂。</p><p><strong>Solr</strong></p><p>基于<strong>Lucene</strong>的HTTP接口查询服务器，是一个封装了很多Lucene细节搜索引擎系统</p><p><strong>Elasticsearch</strong></p><p>基于<strong>Lucene</strong>分布式海量数据近实时搜索引擎。采用的策略是将每一个字段都编入索引，使其可以被搜索。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>1）Solr利用Zookeeper进行分布式管理，而Elasticsearch自身带有分布式协调管理功能</p><p>2）Solr比Elasticsearch实现更加全面，而Elasticsearch本身更注重于核心功能， 高级功能多由第三方插件提供</p><p>3）Solr在传统的搜索应用中表现好于Elasticsearch，而Elasticsearch在实时搜索应用方面比Solr表现好</p><p>目前主流依然是<strong>Elasticsearch</strong>7.x 最新的是7.8</p><p>​    优化：<strong>默认集成JDK</strong>、升级Lucene8大幅提升<strong>TopK性能</strong>、引入熔断机制<strong>避免OOM</strong>发生</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><h3 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h3><p>IKAnalyzer是一个开源的，基于java语言开发的轻量级的中文分词工具包。新版本的IKAnalyzer3.0则发展为 面向Java的公用分词组件，独立于Lucene项目，同时提供了对Lucene的默认优化实现。</p><p>IK分词器3.0的特性如下：</p><ol><li>采用了特有的“正向迭代<strong>最细粒度</strong>切分算法“，具有<strong>60万</strong>字/秒的高速处理能力。</li><li>采用了<strong>多子处理器</strong>分析模式，支持：英文字母（IP地址、Email、URL）、数字（日期，常用中文数量词，罗马数字，科学计数法），中文词汇（姓名、地名处理）等分词处理。</li><li>支持<strong>个人词条的优化</strong>的词典存储，更小的内存占用。</li><li>针对Lucene<strong>全文检索优化</strong>的查询分析器IKQueryParser；采用歧义分析算法优化查询关键字的搜索</li><li>排列组合，能极大的提高Lucene检索的命中率。</li></ol><ul><li><strong>扩展词典</strong>：ext_dict </li><li><strong>停用词典</strong>：stop_dict</li><li><strong>同义词典</strong>：same_dict</li></ul><h3 id="索引（类数据库）"><a href="#索引（类数据库）" class="headerlink" title="索引（类数据库）"></a>索引（类数据库）</h3><p>settings：设置索引库，定义索引库的分片数副本数等</p><h3 id="映射（类表设计）"><a href="#映射（类表设计）" class="headerlink" title="映射（类表设计）"></a>映射（类表设计）</h3><ul><li>字段的数据类型</li><li>分词器类型</li><li>是否要进行存储或者创造索引</li></ul><h3 id="文档（数据）"><a href="#文档（数据）" class="headerlink" title="文档（数据）"></a>文档（数据）</h3><ul><li>全量更新用Put</li><li>局部更新用Post</li></ul><h2 id="3、高级特性"><a href="#3、高级特性" class="headerlink" title="3、高级特性"></a>3、高级特性</h2><h3 id="映射高级"><a href="#映射高级" class="headerlink" title="映射高级"></a>映射高级</h3><h4 id="地理坐标点数据类型"><a href="#地理坐标点数据类型" class="headerlink" title="地理坐标点数据类型"></a><strong>地理坐标点数据类型</strong></h4><blockquote><p>地理坐标点是指地球表面可以用经纬度描述的一个点。 地理坐标点可以用来计算两个坐标间的距离，还可以判断一个坐标是否在一个区域中。地理坐标点需要显式声明对应字段类型为 geo_point</p></blockquote><h4 id="动态映射"><a href="#动态映射" class="headerlink" title="动态映射"></a>动态映射</h4><blockquote><p>使用dynamic mapping 来确定字段的数据类型并自动把新的字段添加到类型映射</p></blockquote><h3 id="DSL高级"><a href="#DSL高级" class="headerlink" title="DSL高级"></a>DSL高级</h3><ul><li><strong>查询所有(match_all query)</strong></li><li><p><strong>全文搜索(full-text query)</strong></p><ul><li>匹配搜索(match query)</li><li>短语搜索(match phrase query)</li><li>默认查询(query string)</li><li>多字段匹配搜索(multi match query)</li></ul></li><li><p><strong>词条级搜索(term-level query)</strong></p><ul><li>精确搜索term</li><li>集合搜索idx</li><li>范围搜索range</li><li>前缀搜索prefix</li><li>通配符搜索wildcard</li><li>正则搜索regexp</li><li>模糊搜索fuzzy</li></ul></li><li><p>复合搜索</p></li><li>排序<strong>sort</strong>&amp;分页<strong>size</strong>&amp;高亮<strong>highLight</strong>&amp;批量<strong>bluk</strong></li></ul><h3 id="聚合分析"><a href="#聚合分析" class="headerlink" title="聚合分析"></a><strong>聚合分析</strong></h3><blockquote><p>聚合分析是数据库中重要的功能特性，完成对一个查询的数据集中数据的聚合计算，如：找出某字段（或计算表达式的结果）的最大值、最小值，计算和、平均值等</p></blockquote><ul><li>对一个数据集求最大、最小、和、平均值等指标的聚合，在ES中称为<strong>指标聚合</strong> <strong>metric</strong></li><li>对查询出的数据进行<strong>分桶</strong>group by，再在<strong>桶</strong>上进行指标<strong>桶聚合</strong> <strong>bucketing</strong></li></ul><h3 id="智能搜索"><a href="#智能搜索" class="headerlink" title="智能搜索"></a><strong>智能搜索</strong></h3><ul><li>Term Suggester</li><li>Phrase Suggester</li><li>Completion Suggester</li><li>Context Suggester</li></ul><p>如果<strong>Completion Suggester</strong>已经到了零匹配，可以猜测用户有输入错误，这时候可以尝试一下<strong>Phrase Suggester</strong>。如果还是未匹配则尝试<strong>Term Suggester</strong>。</p><p>精准程度上(<strong>Precision</strong>)看： <strong>Completion &gt; Phrase &gt; Term</strong>， 而召回率上(Recall)则反之。</p><p>从性能上看，Completion Suggester是最快的，如果能满足业务需求，只用Completion Suggester做前缀匹配是最理想的。 Phrase和Term由于是做倒排索引的搜索，相比较而言性能应该要低不少，应尽量控制Suggester用到的索引的数据量，最理想的状况是经过一定时间预热后，索引可以全量map到内存。</p><h2 id="4、实战"><a href="#4、实战" class="headerlink" title="4、实战"></a>4、实战</h2><h3 id="写优化"><a href="#写优化" class="headerlink" title="写优化"></a>写优化</h3><ul><li><p><strong>副本数量</strong>0</p><p>首次 初始化数据时，将副本设置为0，写入完毕再改回，避免了副本建立索引的过程</p></li><li><p><strong>自动生成id</strong></p><p>可以避免写前判断是否存在的过程</p></li><li><p><strong>合理使用分词器</strong></p><p>binary类型不适用，title和text使用不同的分词器加快速度</p></li><li><p><strong>禁用评分，延长索引刷新间隔</strong></p></li><li><p><strong>将多个索引操作放入到batch进行处理</strong></p></li></ul><h3 id="读优化"><a href="#读优化" class="headerlink" title="读优化"></a>读优化</h3><ul><li><p>使用<strong>Filter</strong>代替Query，减少打分缓解，使用<strong>bool</strong>组合query和filter查询</p></li><li><p>对数据进行<strong>分组</strong>，按照日，月，年不同维度分组，查询可集中在局部index中</p></li></ul><h3 id="零停机索引重建方案"><a href="#零停机索引重建方案" class="headerlink" title="零停机索引重建方案"></a>零停机索引重建方案</h3><ul><li><p><strong>外部数据导入</strong></p><ul><li>通过MQ的web控制台或cli命令行，发送指定的MQ消息</li><li>MQ消息被微服务模块的消费者消费，触发ES数据重新导入功能</li><li>微服务模块从数据库里查询数据的总数及分页信息，并发送至MQ</li><li>微服务从MQ中根据分页信息从数据库获取到数据后，根据索引结构的定义，将数据组装成ES支持的JSON格式，并通过bulk命令将数据发送给Elasticsearch集群进行索引的重建工作。</li></ul></li><li><p><strong>基于Scroll+bulk+索引别名的方案</strong></p><ul><li><p>新建索引book_new，将mapping信息，settings信息等按新的要求全部定义好</p></li><li><p>使用scroll api将数据批量查询出来，指定scroll查询持续时间</p></li><li><p>采用bulk api将scoll查出来的一批数据，批量写入新索引</p></li><li><p>查询一批导入一批，注意每次都使用上次结束时的scoll_id</p></li><li><p>切换别名book_alias到新的索引book_new上面，此时Java客户端仍然使用别名访问，也不需要修</p><p>改任何代码，不需要停机。验证别名查询的是否为新索引的数据</p></li></ul></li><li><p><strong>Reindex API方案</strong></p><ul><li>Elasticsearch v6.3.1已经支持Reindex API，它对scroll、bulk做了一层封装，能够 对文档重建索引而不需要任何插件或外部工具。</li></ul></li></ul><p><strong>参与度</strong> &amp; <strong>灵活性</strong>：自研 &gt; scroll+bulk &gt; reindex</p><p><strong>稳定性</strong> &amp; <strong>可靠性</strong>：自研 &lt; scroll+bulk &lt; reindex</p><h3 id="DeepPaging性能解决方案"><a href="#DeepPaging性能解决方案" class="headerlink" title="DeepPaging性能解决方案"></a>DeepPaging性能解决方案</h3><blockquote><p>比如超级管理员，要给某个省份用户发送公告或者广告，最容易想到的就是利用 from + size 来实现，但这是不现实的</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gne4vx9hu4j30x60gw0w5.jpg" alt="image-20210206212712493" style="zoom:60%;"></p><h1 id="二：Docker-amp-K8S篇"><a href="#二：Docker-amp-K8S篇" class="headerlink" title="二：Docker&amp;K8S篇"></a>二：Docker&amp;K8S篇</h1><blockquote><p>chroot 是在 Unix 和 Linux 系统的一个操作，针对正在运作的软件行程和它的子进程，改变它外显的根目录。一个运行在这个环境下，经由 chroot 设置根目录的程序，它不能够对这个指定根目录之外的文件进行访问动作，不能读取，也不能更改它的内容。</p></blockquote><p><strong>虚拟化技术_VMware 、VirtualBox、KVM</strong></p><p>虚拟化技术就是在操作系统上多加了一个虚拟化层（Hypervisor），可以将物理机的CPU、内存、硬盘、网络等资源进行虚拟化，再通过虚拟化出来的空间上安装操作系统，构建虚拟的应用程序执行环境。这就是我们通常说的虚拟机。</p><p>虚拟机的优点：</p><ul><li>提升IT效率、降低运维成本</li><li>更快地部署工作负责</li><li>提高服务器可用性</li></ul><p>虚拟机的缺点：</p><ul><li>占用资源较多、性能较差</li><li>扩展、迁移能力较差</li></ul><h3 id="Why-Docker"><a href="#Why-Docker" class="headerlink" title="Why Docker"></a>Why Docker</h3><p><strong>场景</strong></p><ul><li>开发人员在本地编写代码，并使用Docker容器与其他同事共享劳动成果。</li><li>使用Docker将应用程序推送到测试环境中，并执行自动和手动测试。</li><li>开发人员可以在开发环境中对其进行修复，然后将其重新部署到测试环境中以进行测试和验证。</li><li>测试完成后，将修补程序推送给生产环境就像将更新的镜像推送到生产环境一样简单。</li></ul><p><strong>需求</strong></p><blockquote><p>快速，一致地交付应用程序、镜像打包环境，避免了环境不一致的问题，简化开发的生命周期，适合于快速迭代敏捷开发的场景</p></blockquote><p><img src="https://i.loli.net/2021/02/20/7hx2RcvUPKgXpma.png" alt="image-20210220140837929" style="zoom: 50%;"></p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><p><strong>Docker引擎-守护进程</strong></p><p>​    Docker使用C / S架构 ：用户通过<strong>Docker客户端</strong>与Docker守护进程（Docker引擎）通过Unix套接字或者RESTAPI进行通信，<strong>Docker引擎</strong>完成了构建，运行和分发Docker容器的繁重工作</p><p><strong>Docker镜像-Dockerfile</strong></p><p>​    Docker镜像类似于虚拟机镜像，是一个只读的模板，是创建Docker容器的基础</p><p>​    镜像是基于联合（Union）文件系统的一种层式的结构，由一系列指令一步一步构建出来。</p><p>​    比如：拷贝文件、执行命令</p><p><strong>Docker仓库-Hub</strong></p><p>Docker仓库可以分为<strong>公开仓库 （Public）</strong>和<strong>私有仓库（Private）</strong>两种形式。</p><p>最大的公开仓库是官方提供的<strong>Docker Hub</strong>，其中存放了数量庞大的镜像供用户下载。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p><strong>镜像</strong></p><pre class=" language-dockerfile"><code class="language-dockerfile">[root@localhost ~]# docker pull mysql:5.7.305.7.30: Pulling from library/mysql ……[root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql 5.7.30 9cfcce23593a 6 weeks ago 448MB[root@localhost ~]# docker tag mysql:5.7.30 mysql5 [root@localhost ~]# docker images REPOSITORY TAG IMAGE ID CREATED SIZE mysql5 latest 9cfcce23593a 6 weeks ago 448MB mysql 5.7.30 9cfcce23593a 6 weeks ago 448MB[root@localhost ~]# docker inspect mysql:5.7.30 [{显示docker 详细信息}][root@localhost ~]# docker search mysql[root@localhost ~]# docker rmi mysql:5.7.30[root@localhost ~]# docker push mysql[:TAG]</code></pre><p><strong>容器</strong></p><pre class=" language-dockerfile"><code class="language-dockerfile">[root@localhost ~]# docker create -it nginx[root@localhost ~]# docker start 9cfcce23593a#查看运行的容器 [root@localhost ~]# docker ps #查看所有容器 [root@localhost ~]# docker ps -a#新建并启动容器[root@localhost ~]# docker run -it --rm --network host tomcat:8.5.56-jdk8-openjdk</code></pre><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><ol><li><p>创建一个卷，待后边使用</p><pre class=" language-dockerfile"><code class="language-dockerfile">docker volume create test_volume</code></pre></li></ol><ol start="2"><li><p>分别启动2个容器挂在上卷,</p><pre class=" language-dockerfile"><code class="language-dockerfile">在2个终端窗口启动2个容器 docker run -it --rm -v test_volume:/test nginx:latest /bin/bashdocker run -it --rm -v test_volume:/test nginx:latest /bin/bash cd /test; touch a.txt ls /test # 在两个容器中我们均可以看到我们创建的文件，shixian在多个容器之间实现数据共享</code></pre></li></ol><p>挂载在容器 /test 目录内创建。 Docker <strong>不支持容器内安装点的相对路径</strong>。 多个容器可以在同一时间段内使用相同的卷。如果两个容器需要访问共享数据，例如，如果一个容器写入而另一个容器读取数据。 卷名 在驱动程序test必须唯一。这意味着不能将<strong>相同的卷名</strong>与两个不同的驱动程序一起使用。 如果我们指定了当前test_volume程序上已在使用的卷名，则Docker会假定我们要重用现有卷，并且不会返回错误。如果开始无 test_volume 则会创建这个卷当然除了使用卷，也可以使用将宿主机的文件映射到容器的卷，命令类似，只不过不用提前创建卷，而且数据会映射到宿主机上注意如果宿主机上的目录可以不存在，会在启动容器的时候创建</p><h1 id="三、Netty篇"><a href="#三、Netty篇" class="headerlink" title="三、Netty篇"></a>三、Netty篇</h1><h3 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a>核心组件</h3><h4 id="1、整体结构"><a href="#1、整体结构" class="headerlink" title="1、整体结构"></a>1、整体结构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijej9w7j30p00doaim.jpg" alt="image-20210504171606057" style="zoom:50%;"></p><p>​    </p><p>​    <strong>Core 核心层</strong><br>​    Core 核心层是 Netty 最精华的内容，它提供了底层网络通信的通用抽象和实现，包括事件模型、通用API、支持零拷贝的 ByteBuf 等。</p><p>​    <strong>Protocol Support 协议支持层</strong><br>​    协议支持层基本上覆盖了主流协议的编解码实现，如 HTTP、Protobuf、WebSocket、二进制等主流协议，此外 Netty 还支持自定义应用层协议。Netty 丰富的协议支持降低了用户的开发成本，基于 Netty 我们可以快速开发 HTTP、WebSocket 等服务。</p><p>​    <strong>Transport Service 传输服务层</strong><br>​    传输服务层提供了网络传输能力的定义和实现方法。它支持 Socket、HTTP 隧道、虚拟机管道等传输方式。Netty 对 TCP、UDP 等数据传输做了抽象和封装，用户可以更聚焦在业务逻辑实现上，而不必关系底层数据传输的细节。</p><h4 id="2、逻辑架构"><a href="#2、逻辑架构" class="headerlink" title="2、逻辑架构"></a>2、逻辑架构</h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iiju6h8j30ry0o6dj0.jpg" alt="image-20210504171514089" style="zoom:50%;"></p><p>​        </p><p>​    <strong>网络通信层</strong><br>​    网络通信层的职责是执行网络 I/O 的操作。它支持多种网络协议和 I/O 模型的连接操作。当网络数据读取到内核缓冲区后，会触发各种网络事件，这些网络事件会分发给事件调度层进行处理。</p><p>网络通信层的核心组件包含<strong>BootStrap、ServerBootStrap、Channel</strong>三个组件。</p><p>​    Bootstrap 是“引导”的意思，负责 Netty <strong>客户端程序</strong>的启动、初始化、服务器连接等过程，串联了 Netty 的其他核心组件。</p><p>​    ServerBootStrap 用于<strong>服务端启动</strong>绑定本地端口，会绑定Boss 和 Worker两个 EventLoopGroup。</p><p>​    Channel 的是“<strong>通道</strong>”，Netty Channel提供了基于NIO更高层次的抽象，如 register、bind、connect、read、write、flush 等。</p><p>​    </p><p>​    <strong>事件调度层</strong><br>​    事件调度层的职责是通过 Reactor 线程模型对各类事件进行聚合处理，通过 Selector 主循环线程集成多种事件（ I/O 事件、信号事件、定时事件等），实际的业务处理逻辑是交由服务编排层中相关的 Handler 完成。</p><p>事件调度层的核心组件包括 <strong>EventLoopGroup、EventLoop</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ijuqesxj30ke0ekgpj.jpg" alt="image-20210504171631793" style="zoom:50%;"></p><p>​                        </p><p>​    <strong>EventLoop</strong> 负责处理 Channel 生命周期内的所有 I/O 事件，如 accept、connect、read、write 等 I/O 事件</p><p>​        ①一个 EventLoopGroup 往往包含<strong>一个或者多个</strong> EventLoop。</p><p>​        ②EventLoop 同一时间会与一个Channel绑定，每个 EventLoop 负责<strong>处理一种类型 Channel</strong>。</p><p>​        ③Channel 在生命周期内可以对和多个 EventLoop 进行<strong>多次绑定和解绑</strong>。        </p><p>​    <strong>EventLoopGroup</strong> 是Netty 的<strong>核心处理引擎</strong>，本质是一个线程池，主要负责接收 I/O 请求，并分配线程执行处理请求。通过创建不同的 EventLoopGroup 参数配置，就可以支持 Reactor 的三种线程模型：</p><p>​        <strong>单线程模型</strong>：EventLoopGroup 只包含一个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 和 Worker 使用同一个EventLoopGroup；</p><p>​        <strong>主从多线程模型</strong>：EventLoopGroup 包含多个 EventLoop，Boss 是主 Reactor，Worker 是从 Reactor，它们分别使用不同的 EventLoopGroup，主 Reactor 负责新的网络连接 Channel 创建，然后把 Channel 注册到从 Reactor。</p><p>​    <strong>服务编排层</strong><br>​    服务编排层的职责是负责组装各类服务，它是 Netty 的核心处理链，用以实现网络事件的动态编排和有序传播。</p><p>服务编排层的核心组件包括 <strong>ChannelPipeline、ChannelHandler、ChannelHandlerContext</strong>。</p><p>​    <strong>ChannelPipeline</strong> 是 Netty 的核心编排组件，负责组装各种 ChannelHandler，ChannelPipeline 内部通过双向链表将不同的 ChannelHandler 链接在一起。当 I/O 读写事件触发时，Pipeline 会依次调用 Handler 列表对 Channel 的数据进行拦截和处理。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6il759apj313s068abj.jpg" alt="image-20210504171749533" style="zoom:50%;"></p><p>​    </p><p>​    客户端和服务端都有各自的 ChannelPipeline。客户端和服务端一次完整的请求：客户端出站（Encoder 请求数据）、服务端入站（Decoder接收数据并执行业务逻辑）、服务端出站（Encoder响应结果）。</p><p>​    <strong>ChannelHandler</strong> 完成数据的编解码以及处理工作。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ilvuhupj30ye08e0vd.jpg" alt="image-20210504171829071" style="zoom:50%;"></p><p>​    <strong>ChannelHandlerContext</strong> 用于保存Handler 上下文，通过 HandlerContext 我们可以知道 Pipeline 和 Handler 的关联关系。HandlerContext 可以实现 Handler 之间的交互，HandlerContext 包含了 Handler 生命周期的所有事件，如 connect、bind、read、flush、write、close 等。同时，HandlerContext 实现了Handler通用的逻辑的模型抽象。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6imu2khlj31080gu0xc.jpg" alt="image-20210504171924019" style="zoom:50%;"></p><h3 id="网络传输"><a href="#网络传输" class="headerlink" title="网络传输"></a>网络传输</h3><h4 id="1、五种IO模型的区别"><a href="#1、五种IO模型的区别" class="headerlink" title="1、五种IO模型的区别"></a><strong>1、五种IO模型的区别</strong></h4><p><strong>阻塞I/O：（BIO）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ingki0yj30kw0d6gmr.jpg" alt="image-20210504171959821" style="zoom:50%;"></p><p>​    </p><p>​        应用进程向内核发起 I/O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I/O 请求称为BIO（Blocking IO，阻塞 I/O），所以 BIO 在实现异步操作时，只能使用多线程模型，一个请求对应一个线程。但是，<strong>线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。</strong></p><p><strong>同步非阻塞I/O（NIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6inzsk9xj30lg0cign1.jpg" alt="image-20210504172029418" style="zoom:50%;"></p><p>​        </p><p>​        应用进程向内核发起 I/O 请求后不再会同步等待结果，而是会立即返回，通过轮询的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I/O 时效率并不高，而且<strong>随着并发量的提升，非阻塞 I/O 会存在严重的性能浪费。</strong></p><p><strong>多路复用I/O（select和poll）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iogl9x0j30ja0cqdh7.jpg" alt="image-20210504172057237" style="zoom:50%;"></p><p>​        </p><p>​        多路复用实现了<strong>一个线程处理多个 I/O 句柄的操作</strong>。多路指的是多个数据通道，复用指的是使用一个或多个固定线程来处理每一个 Socket。select、poll、epoll 都是 I/O 多路复用的具体实现，线程一次 select 调用可以获取内核态中多个数据通道的数据状态。其中，select只负责等，recvfrom只负责拷贝，阻塞IO中可以对多个文件描述符进行阻塞监听，是一种非常高效的 I/O 模型。</p><p><strong>信号驱动I/O（SIGIO）：</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ioxthajj30ii0cemyk.jpg" alt="image-20210504172124965" style="zoom:50%;"></p><p>​        </p><p>​        信号驱动IO模型，应用进程告诉内核：当数据报准备好的时候，给我发送一个信号，对SIGIO信号进行捕捉，并且调用我的信号处理函数来获取数据报。</p><p><strong>异步I/O（Posix.1的aio_系列函数）：</strong></p><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipcc12jj30lg0coabe.jpg" alt="image-20210504172148095" style="zoom:50%;"></p><p>​        当应用程序调用aio_read时，内核一方面去取数据报内容返回，另一方面将程序控制权还给应用进程，应用进程继续处理其他事情，是一种非阻塞的状态。当内核中有数据报就绪时，由内核将数据报拷贝到应用程序中，返回aio_read中定义好的函数处理程序。</p><h4 id="2、Reactor多线程模型"><a href="#2、Reactor多线程模型" class="headerlink" title="2、Reactor多线程模型"></a>2、Reactor多线程模型</h4><p>​        Netty 的 I/O 模型是基于<strong>非阻塞 I/O</strong> 实现的，底层依赖的是 NIO 框架的<strong>多路复用器 Selector</strong>。采用 <strong>epoll 模式</strong>后，只需要一个线程负责 Selector 的轮询。当有数据处于就绪状态后，需要一个<strong>事件分发器</strong>（Event Dispather），它负责将读写事件分发给对应的读写<strong>事件处理器</strong>（Event Handler）。事件分发器有两种设计模式：<strong>Reactor 和 Proactor</strong>，Reactor 采用同步 I/O， Proactor 采用异步 I/O。</p><p>​    </p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ipob6wjj30we0i4jz2.jpg" alt="image-20210504172207142" style="zoom:50%;"></p><p>​        Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I/O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，适合图片或视频流分析服务器，目前主流的事件驱动模型还是依赖 <strong>select 或 epoll</strong> 来实现。</p><h4 id="3、拆包粘包问题"><a href="#3、拆包粘包问题" class="headerlink" title="3、拆包粘包问题"></a>3、拆包粘包问题</h4><p><strong>拆包</strong>TCP 传输协议是面向流的，没有数据包界限。<br><strong>MTU（Maxitum Transmission Unit）</strong> 是链路层一次最大传输数据的大小。MTU 一般来说大小为 1500 byte。<strong>MSS（Maximum Segement Size）</strong> 是指 TCP 最大报文段长度，它是传输层一次发送最大数据的大小。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iq4xdjtj30q407egnk.jpg" alt="image-20210504172233844" style="zoom:50%;">    </p><p>如上图所示，如果 MSS + TCP 首部 + IP 首部 &gt; MTU，那么数据包将会被拆分为多个发送。这就是<strong>拆包现象</strong>。</p><p><strong>Nagle 算法</strong><br>Nagle 算法可以理解为批量发送，也是我们平时编程中经常用到的优化思路，它是在数据未得到确认之前先写入缓冲区，等待数据确认或者缓冲区积攒到一定大小再把数据包发送出去。Netty 中为了使数据<strong>传输延迟最小化</strong>，就默认<strong>禁用了 Nagle 算法</strong>。</p><p><strong>拆包/粘包的解决方案</strong></p><p>在客户端和服务端通信的过程中，服务端一次读到的数据大小是不确定的。需要确定边界：</p><p><strong>消息长度固定</strong><br><strong>特定分隔符</strong><br><strong>消息长度 + 消息内容</strong>(Netty)</p><h4 id="4、自定义协议"><a href="#4、自定义协议" class="headerlink" title="4、自定义协议"></a>4、自定义协议</h4><p>Netty 常用编码器类型：</p><pre class=" language-java"><code class="language-java">MessageToByteEncoder <span class="token comment" spellcheck="true">//对象编码成字节流；</span>MessageToMessageEncoder <span class="token comment" spellcheck="true">//一种消息类型编码成另外一种消息类型。</span></code></pre><p>Netty 常用解码器类型：</p><pre class=" language-java"><code class="language-java">ByteToMessageDecoder<span class="token operator">/</span>ReplayingDecoder <span class="token comment" spellcheck="true">//将字节流解码为消息对象；</span>MessageToMessageDecoder <span class="token comment" spellcheck="true">//将一种消息类型解码为另外一种消息类型。</span></code></pre><p>编解码器可以分为<strong>一次解码器</strong>和<strong>二次解码器</strong>，一次解码器用于解决 <strong>TCP 拆包/粘包问题</strong>，按协议解析后得到的字节数据。如果你需要对解析后的<strong>字节数据做对象模型</strong>的转换，这时候便需要用到二次解码器，同理编码器的过程是反过来的。</p><p><strong>Netty自定义协议内容：</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*+---------------------------------------------------------------+| 魔数 2byte | 协议版本号 1byte | 序列化算法 1byte | 报文类型 1byte  |+---------------------------------------------------------------+| 状态 1byte |        保留字段 4byte     |      数据长度 4byte     | +---------------------------------------------------------------+|                   数据内容 （长度不定）                          |+---------------------------------------------------------------+ */</span></code></pre><p>如何判断 ByteBuf 是否存在完整的报文？最常用的做法就是通过读取消息长度 dataLength 进行判断。如果 ByteBuf 的可读数据长度小于 dataLength，说明 ByteBuf 还不够获取一个完整的报文。</p><h4 id="5、WriteAndFlush"><a href="#5、WriteAndFlush" class="headerlink" title="5、WriteAndFlush"></a>5、WriteAndFlush</h4><p>​        <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6iqnas8fj31400lkaj2.jpg" alt="image-20210504172303465" style="zoom:50%;"></p><p>​    ①writeAndFlush 属于出站操作，它是从 Pipeline 的 Tail 节点开始进行事件传播，一直向前传播到 Head 节点。不管在 write 还是 flush 过程，Head 节点都中扮演着重要的角色。</p><p>​    ②write 方法并没有将数据写入 Socket 缓冲区，只是将数据写入到 ChannelOutboundBuffer 缓存中，ChannelOutboundBuffer 缓存内部是由单向链表实现的。</p><p>​    ③flush 方法才最终将数据写入到 Socket 缓冲区。</p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="1、堆外内存"><a href="#1、堆外内存" class="headerlink" title="1、堆外内存"></a>1、堆外内存</h4><p>​    在 Java 中对象都是在堆内分配的，通常我们说的<strong>JVM 内存</strong>也就指的<strong>堆内内存</strong>，<strong>堆内内存</strong>完全被<strong>JVM 虚拟机</strong>所管理，JVM 有自己的垃圾回收算法，对于使用者来说不必关心对象的内存如何回收。<strong>堆外内存</strong>与堆内内存相对应，对于整个机器内存而言，除<strong>堆内内存以外部分即为堆外内存</strong>。堆外内存不受 JVM 虚拟机管理，直接由操作系统管理。使用堆外内存有如下几个优点：</p><ol><li>堆内内存由 JVM GC 自动回收内存，降低了 Java 用户的使用心智，堆外内存由于不受 JVM 管理，所以在一定程度上可以降低 GC 对应用运行时带来的影响。</li><li>堆外内存需要手动释放，这一点跟 C/C++ 很像，稍有不慎就会造成应用程序内存泄漏，当出现内存泄漏问题时排查起来会相对困难。</li><li>当进行网络 I/O 操作、文件读写时，堆内内存都需要转换为堆外内存，然后再与底层设备进行交互，所以直接使用堆外内存可以减少一次内存拷贝。</li><li>堆外内存可以方便实现进程之间、JVM 多实例之间的数据共享。</li></ol><p>​    在堆内存放的 DirectByteBuffer 对象并不大，仅仅包含堆外内存的地址、大小等属性，同时还会创建对应的 Cleaner 对象，通过 ByteBuffer 分配的堆外内存不需要手动回收，它可以被 JVM 自动回收。当堆内的 DirectByteBuffer 对象被 GC 回收时，Cleaner 就会用于回收对应的堆外内存。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    从 DirectByteBuffer 的构造函数中可以看出，真正分配堆外内存的逻辑还是通过 unsafe.allocateMemory(size)，Unsafe 是一个非常不安全的类，它用于执行内存访问、分配、修改等<strong>敏感操作</strong>，可以越过 JVM 限制的枷锁。Unsafe 最初并不是为开发者设计的，使用它时虽然可以获取对底层资源的控制权，但也失去了安全性的保证，使用 Unsafe 一定要慎重（Java 中是不能直接使用 Unsafe 的，但是可以通过反射获取 Unsafe 实例）。Netty 中依赖了 Unsafe 工具类，是因为 Netty 需要与底层 Socket 进行交互，Unsafe 提升 Netty 的性能</p><p>​     因为DirectByteBuffer 对象的回收需要依赖 Old GC 或者 Full GC 才能触发清理，如果长时间没有 GC执行，那么堆外内存即使不再使用，也会一直在占用内存不释放，很容易将机器的物理内存耗尽。-XX:MaxDirectMemorySize 指定堆外内存的上限大小，超出时触发GC，仍无法释放抛出OOM异常。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ir0d0cmj30qw0hw41z.jpg" alt="image-20210504172324820" style="zoom:50%;"></p><p>​    当初始化堆外内存时，内存中的对象引用情况如下图所示，first 是 Cleaner 类中的静态变量，Cleaner 对象在初始化时会加入 Cleaner 链表中。DirectByteBuffer 对象包含堆外内存的地址、大小以及 Cleaner 对象的引用，ReferenceQueue 用于保存需要回收的 Cleaner 对象。</p><p>​    </p><h4 id="2、数据载体ByteBuf"><a href="#2、数据载体ByteBuf" class="headerlink" title="2、数据载体ByteBuf"></a>2、<strong>数据载体ByteBuf</strong></h4><p>JDK NIO 的 <strong>ByteBuffer</strong></p><ul><li>mark：为某个读取过的关键位置做标记，方便回退到该位置；</li><li>position：当前读取的位置；</li><li>limit：buffer 中有效的数据长度大小；</li><li>capacity：初始化时的空间容量。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6irlptv0j30z408wabn.jpg" alt="image-20210504172358702" style="zoom:50%;"></p><p>​    第一，ByteBuffer 分配的长度是固定的，无法动态扩缩容，每次在存放数据的时候对容量大小做校验，扩容需要将已有的数据迁移。</p><p>​    第二，ByteBuffer 只能通过 position 获取当前可操作的位置，因为读写共用的 position 指针，所以需要频繁调用 flip、rewind 方法切换读写状态。</p><p>Netty中的ByteBuf</p><ul><li><strong>废弃字节</strong>，表示已经丢弃的无效字节数据。</li><li><strong>可读字节</strong>，表示 ByteBuf 中可以被读取的字节内容，可以通过 writeIndex - readerIndex 计算得出。当读写位置重叠时时，表示 ByteBuf 已经不可读。</li><li><strong>可写字节</strong>，向 ByteBuf 中写入数据都会存储到可写字节区域。当 writeIndex 超过 capacity，表示 ByteBuf 容量不足，需要扩容。</li><li><strong>可扩容字节</strong>，表示 ByteBuf 最多还可以扩容多少字节，最多扩容到 maxCapacity 为止，超过 maxCapacity 再写入就会出错。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j1t85zuj31020ds42m.jpg" alt="image-20210504173347000" style="zoom:50%;"></p><p><strong>引用计数</strong></p><p>​    当byteBuf当引用计数为 0，该 ByteBuf 可以被放入到对象池中，避免每次使用 ByteBuf 都重复创建。</p><p>​    JVM 并不知道 Netty 的引用计数是如何实现的，当 ByteBuf 对象不可达时，一样会被 GC 回收掉，但是如果此时 ByteBuf 的引用计数不为 0，那么该对象就不会释放或者被放入对象池，从而发生了内存泄漏。Netty 会对分配的 ByteBuf 进行抽样分析，检测 ByteBuf 是否已经不可达且引用计数大于 0，判定内存泄漏的位置并输出到日志中，<strong>通过关注日志中 LEAK 关键字可以找到内存泄漏的具体对象</strong>。</p><h4 id="3、内存分配jemalloc"><a href="#3、内存分配jemalloc" class="headerlink" title="3、内存分配jemalloc"></a>3、<strong>内存分配jemalloc</strong></h4><p>​    为了减少分配时产生的内部碎片和外部碎片，常见的内存分配算法<strong>动态内存分配</strong>、<strong>伙伴算法</strong>和<strong>Slab 算法</strong></p><p><strong>动态内存分配（DMA）</strong></p><p>​    <strong>⾸次适应算法（first fit）</strong>，空闲分区链以地址递增的顺序将空闲分区以双向链表的形式连接在一起，从空闲分区链中找到第一个满足分配条件的空闲分区，然后从空闲分区中划分出一块可用内存给请求进程，剩余的空闲分区仍然保留在空闲分区链中。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j26fh88j30ni0ea41c.jpg" alt="image-20210504173407923" style="zoom:50%;"></p><p>​    <strong>循环首次适应算法（next fit）</strong>不再是每次从链表的开始进行查找，而是从上次找到的空闲分区的以后开始查找。查找效率提升，会产生更多的碎片。</p><p>​    <strong>最佳适应算法（best fit）</strong>，空闲分区链以空闲分区大小递增的顺序将空闲分区以双向链表的形式连接在一起，每次从空闲分区链的开头进行查找。</p><p><strong>伙伴算法</strong>（外部碎片少，内部碎片多）</p><p>​    是一种非常经典的内存分配算法，它采用了<strong>分离适配的设计思想</strong>，将物理内存按照 2 的次幂进行划分，内存分配时也是按照 2 的次幂大小进行按需分配</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j2m0rr1j30ly0iugnk.jpg" alt="image-20210504173433749" style="zoom:50%;"></p><ol><li>首先需要找到存储 2^4 连续 Page 所对应的链表，即数组下标为 4；</li><li>查找 2^4 链表中是否有空闲的内存块，如果有则分配成功；</li><li>如果 2^4 链表不存在空闲的内存块，则继续沿数组向上查找，即定位到数组下标为 5 的链表，链表中每个节点存储 2^5 的连续 Page；</li><li>如果 2^5 链表中存在空闲的内存块，则取出该内存块并将它分割为 2 个 2^4 大小的内存块，其中一块分配给进程使用，剩余的一块链接到 2^4 链表中。</li></ol><p><strong>Slab 算法（解决伙伴算法内部碎片问题）</strong></p><p>​    Slab 算法在伙伴算法的基础上，对小内存的场景专门做了优化，采用了内存池的方案，解决内部碎片问题。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p>在 Slab 算法中维护着大小不同的 Slab 集合，将这块内存划分为大小相同的 slot，不会对内存块再进行合并，同时使用位图 bitmap 记录每个 slot 的使用情况。</p><p>​    kmem_cache 中包含三个 Slab 链表：<strong>完全分配使用 slab_full</strong>、<strong>部分分配使用 slab_partial</strong>和<strong>完全空闲 slabs_empty</strong>，这三个链表负责内存的分配和释放。Slab 算法是基于对象进行内存管理的，它把相同类型的对象分为一类。当分配内存时，从 Slab 链表中划分相应的内存单元；单个 Slab 可以在不同的链表之间移动，例如当一个 Slab 被分配完，就会从 slab_partial 移动到 slabs_full，当一个 Slab 中有对象被释放后，就会从 slab_full 再次回到 slab_partial，所有对象都被释放完的话，就会从 slab_partial 移动到 slab_empty。当<strong>释放内存时，Slab 算法并不会丢弃已经分配的对象，而是将它保存在缓存中，当下次再为对象分配内存时，直接会使用最近释放的内存块</strong>。</p><h4 id="4、jemalloc-架构"><a href="#4、jemalloc-架构" class="headerlink" title="4、jemalloc 架构"></a>4、jemalloc 架构</h4><ul><li>内存是由一定数量的 arenas 负责管理，线程均匀分布在 arenas 当中；</li><li>每个 arena 都包含一个 bin 数组，每个 bin 管理不同档位的内存块；</li><li>每个 arena 被划分为若干个 chunks，每个 chunk 又包含若干个 runs，每个 run 由连续的 Page 组成，run 才是实际分配内存的操作对象；</li><li>每个 run 会被划分为一定数量的 regions，在小内存的分配场景，region 相当于用户内存；</li><li>每个 tcache 对应一个 arena，tcache 中包含多种类型的 bin。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j3160yuj30rw0eo77o.jpg" alt="image-20210504173454562" style="zoom:50%;"></p><p><strong>内存管理Arena</strong> ，内存由一定数量的 arenas 负责管理。每个用户线程采用 round-robin 轮询的方式选择可用的 arena 进行内存分配。</p><p><strong>分级管理Bin</strong>，每个 bin 管理的内存大小是按分类依次递增。<strong>jemalloc 中小内存的分配是基于 Slab 算法</strong>完成的，会产生不同类别的内存块。</p><p><strong>Page集合chunk</strong>，chunk 以 Page 为单位管理内存。每个 chunk 可被用于多次小内存的申请，但是在大内存分配的场景下只能分配一次。</p><p><strong>实际分配单位run</strong>，run 结构具体的大小由不同的 bin 决定，例如 8 字节的 bin 对应的 run 只有一个 Page，可以从中选取 8 字节的块进行分配。</p><p><strong>run 细分region</strong>，每个 run 会将划分为若干个等长的 region，每次内存分配也是按照 region 进行分发。</p><p><strong>tcache 是每个线程私有的缓存</strong>，tcache 每次从 arena 申请一批内存，在分配内存时首先在 tcache 查找，避免锁竞争，分配失败才会通过 run 执行内存分配。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u1jn9b3j31e80hqjt5.jpg" alt="image-20211205121406792"></p><p>Small 场景，如果请求分配内存的大小小于 arena 中的最小的 bin，那么优先从线程中对应的 tcache 中进行分配。首先确定查找对应的 tbin 中是否存在缓存的内存块，如果存在则分配成功，否则找到 tbin 对应的 arena，从 arena 中对应的 bin 中分配 region 保存在 tbin 的 avail 数组中，最终从 availl 数组中选取一个地址进行内存分配，当内存释放时也会将被回收的内存块进行缓存。</p><p>Large 场景的内存分配与 Smalll 类似，如果请求分配内存的大小大于 arena 中的最小的 bin，但是不大于 tcache 中能够缓存的最大块，依然会通过 tcache 进行分配，但是不同的是此时会分配 chunk 以及所对应的 run，从 chunk 中找到相应的内存空间进行分配。内存释放时也跟 samll 场景类似，会把释放的内存块缓存在 tacache 的 tbin 中。此外还有一种情况，当请求分配内存的大小大于tcache 中能够缓存的最大块，但是不大于 chunk 的大小，那么将不会采用 tcache 机制，直接在 chunk 中进行内存分配。</p><p>Huge 场景，如果请求分配内存的大小大于 chunk 的大小，那么直接通过 mmap 进行分配，调用 munmap 进行回收。</p><h4 id="5、内存池设计（待补充）"><a href="#5、内存池设计（待补充）" class="headerlink" title="5、内存池设计（待补充）"></a>5、内存池设计（待补充）</h4><h4 id="6、Recycle对象池（待补充）"><a href="#6、Recycle对象池（待补充）" class="headerlink" title="6、Recycle对象池（待补充）"></a>6、Recycle对象池（待补充）</h4><h4 id="7、零拷贝技术"><a href="#7、零拷贝技术" class="headerlink" title="7、零拷贝技术"></a>7、零拷贝技术</h4><ol><li>当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA 引擎从文件中读取数据，并存储到内核态缓冲区，这里是<strong>第一次数据拷贝</strong>。</li><li>请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。<strong>第二次数据拷贝</strong>的过程同时，会导致上下文从内核态再次切换到用户态。</li><li>用户进程调用 send() 方法期望将数据发送到网络中，用户态会再次切换到内核态，<strong>第三次数据拷贝</strong>请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区。</li><li>最终 send() 系统调用结束返回给用户进程，发生了第四次上下文切换。<strong>第四次拷贝会异步执行</strong>，从 Socket 缓冲区拷贝到协议引擎中。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jlghxe0j30t00fsjtw.jpg" alt="image-20210504175240348" style="zoom:50%;"></p><p>​    <strong>在 Linux 中</strong>系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术。</p><p>​    <strong>在 Java 中</strong>也使用了零拷贝技术，它就是 NIO FileChannel 类中的 transferTo() 方法，它可以将数据从 FileChannel 直接传输到另外一个 Channel。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jm8q3yej311c0h6q7v.jpg" alt="image-20210504175323875" style="zoom:50%;"></p><p><strong>Netty 中的零拷贝</strong>技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li>堆外内存，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li>CompositeByteBuf 类，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li>通过 Unpooled.wrappedBuffer 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li>ByteBuf.slice ，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 封装了transferTo() 方法 FileRegion，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝。</li></ul><h3 id="高性能数据结构"><a href="#高性能数据结构" class="headerlink" title="高性能数据结构"></a>高性能数据结构</h3><h4 id="1、FastThreadLocal"><a href="#1、FastThreadLocal" class="headerlink" title="1、FastThreadLocal"></a>1、FastThreadLocal</h4><p>​    ThreadLocal 可以理解为线程本地变量。ThreadLocal 为变量在每个线程中都创建了一个副本，该副本只能被当前线程访问，多线程之间是隔离的，变量不能在多线程之间共享。这样每个线程修改变量副本时，不会对其他线程产生影响。</p><p>​    既然多线程访问 ThreadLocal 变量时都会有自己独立的实例副本，那么很容易想到的方案就是在 ThreadLocal 中维护一个 Map，记录线程与实例之间的映射关系。当新增线程和销毁线程时都需要更新 Map 中的映射关系，因为会存在多线程并发修改，所以需要保证 Map 是线程安全的。但是在高并发的场景并发修改 Map 需要加锁，势必会降低性能。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmqtl1hj30q60dmtck.jpg" alt="image-20210504175349901" style="zoom:50%;"></p><p>​    JDK 为了避免加锁，采用了相反的设计思路。以 Thread 入手，在 Thread 中维护一个 Map，记录 ThreadLocal 与实例之间的映射关系，这样在同一个线程内，Map 就不需要加锁了。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jmyxnylj30ns06adgu.jpg" alt="image-20210504175406824" style="zoom:50%;"></p><p>​    ThreadLocalMap 是一种使用线性探测法实现的哈希表，底层采用数组存储数据，通过魔数0x61c88647来使散列更加平衡。ThreadLocalMap 初始化一个长度为 16 的 Entry 数组。与 HashMap 不同的是，Entry 的 key 就是 ThreadLocal对象本身，value 就是用户具体需要存储的值。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jncecy1j30yy0eejtq.jpg" alt="image-20210504175428964" style="zoom:50%;"></p><p>​    Entry 继承自弱引用类 WeakReference，Entry 的 key 是弱引用，value 是强引用。在 JVM 垃圾回收时，只要发现了弱引用的对象，不管内存是否充足，都会被回收。那么为什么 Entry 的 key 要设计成弱引用呢？如果 key 都是强引用，当线 ThreadLocal 不再使用时，然而 ThreadLocalMap 中还是存在对 ThreadLocal 的强引用，那么 GC 是无法回收的，从而造成内存泄漏。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4umi0759j30hi0a03zd.jpg" alt="img" style="zoom: 67%;"></p><p>​    虽然 Entry 的 key 设计成了弱引用，但是当 ThreadLocal不再使用(<strong>业务逻辑走完，但是由于线程复用导致线程并没有结束</strong>)被 GC 回收后，ThreadLocalMap 中可能出现 Entry 的 key 为 NULL，那么 Entry 的 value 一直会强引用数据而得不到释放，只能等待线程销毁。那么应该如何避免 ThreadLocalMap 内存泄漏呢？ThreadLocal 已经帮助我们做了一定的保护措施，在执行 ThreadLocal.set()/get() 方法时，ThreadLocal 会清除 ThreadLocalMap 中 key 为 NULL 的 Entry 对象，让它还能够被 GC 回收。除此之外，当线程中某个 ThreadLocal 对象不再使用时，立即调用 remove() 方法删除 Entry 对象。如果是在异常的场景中，应在 finally 代码块中进行清理，保持良好的编码意识。在Netty中，可以方便的使用FashThreadLocal来防止内存泄漏</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm4ux5gohpj30hs0ajjs1.jpg" alt="img" style="zoom:67%;"></p><p><strong>FastThreadLocal</strong></p><p>​    FastThreadLocal 使用 Object 数组替代了 Entry 数组，Object[0] 存储的是一个Set&lt;FastThreadLocal&lt;?&gt;&gt; 集合，从数组下标 1 开始都是直接存储的 value 数据，不再采用 ThreadLocal 的键值对形式进行存储。主要是针对set方法，增加了两个额外的行为。</p><ol><li>找到数组下标 index 位置，设置新的 value。</li><li>将 <strong>FastThreadLocal 对象保存到待清理的 Set 中</strong>。</li></ol><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jnu8l6aj315k060wfi.jpg" alt="image-20210504175457264" style="zoom:50%;"></p><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 remove() 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 FastThreadLocalRunnable，<strong>任务执行完毕后一定会执行 FastThreadLocal.removeAll() 将 Set 集合中所有 FastThreadLocal 对象都清理掉</strong></li></ul><h4 id="2、HashedTimerWheel"><a href="#2、HashedTimerWheel" class="headerlink" title="2、HashedTimerWheel"></a>2、<strong>HashedTimerWheel</strong></h4><p>​    生成月统计报表、每日得分结算、邮件定时推送</p><p>​    定时任务三种形式：</p><p>​        1、按固定周期定时执行</p><p>​        2、延迟一定时间后执行</p><p>​        3、指定某个时刻执行</p><p>​    定时任务的三个关键方法：</p><p>​        Schedule 新增任务至任务集合；</p><p>​        Cancel 取消某个任务；</p><p>​        Run 执行到期的任务</p><p>JDK自带的三种定时器：<strong>Timer</strong>、<strong>DelayedQueue</strong> 和 <strong>ScheduledThreadPoolExecutor</strong></p><pre><code>Timer小根堆队列，deadline 任务位于堆顶端，弹出的始终是最优先被执行的任务。Run 操作时间复杂度 O(1)，Schedule 和Cancel 操作的时间复杂度都是 O(logn)。</code></pre><p>不论有多少任务被加入数组，始终由 异步线程TimerThread 负责处理。TimerThread 会定时轮询 TaskQueue 中的任务，如果堆顶的任务的 deadline 已到，那么执行任务；如果是周期性任务，执行完成后重新计算下一次任务的 deadline，并再次放入小根堆；如果是单次执行的任务，执行结束后会从 TaskQueue 中删除。</p><p>​    </p><pre><code>DelayedQueue 采用优先级队列 PriorityQueue延迟获取对象的阻塞队列。DelayQueue中的每个对象都必须实现Delayed 接口，并重写 compareTo 和 getDelay 方法。</code></pre><p>DelayQueue 提供了 put() 和 take() 的阻塞方法，可以向队列中添加对象和取出对象。对象被添加到 DelayQueue 后，会根据 compareTo() 方法进行优先级排序。getDelay() 方法用于计算消息延迟的剩余时间，只有 getDelay &lt;=0 时，该对象才能从 DelayQueue 中取出。</p><p>DelayQueue 在日常开发中最常用的场景就是实现重试机制。例如，接口调用失败或者请求超时后，可以将当前请求对象放入 DelayQueue，通过一个异步线程 take() 取出对象然后继续进行重试。如果还是请求失败，继续放回 DelayQueue。可以设置重试的最大次数以及采用指数退避算法设置对象的 deadline，如 2s、4s、8s、16s ……以此类推。DelayQueue的时间复杂度和Timer基本一致。</p><pre class=" language-java"><code class="language-java">为了解决 Timer 的设计缺陷，JDK 提供了功能更加丰富的 ScheduledThreadPoolExecutor，多线程、相对时间、对异常</code></pre><p>​    Timer 是单线程模式。如果某个 TimerTask 执行时间很久，会影响其他任务的调度。</p><p>​    Timer 的任务调度是基于系统绝对时间的，如果系统时间不正确，可能会出现问题。</p><p>​    TimerTask 如果执行出现异常，Timer 并不会捕获，会导致线程终止，其他任务永远不会执行。</p><p><strong>时间轮原理分析</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jo7abpbj30wi0ciacs.jpg" alt="image-20210504175518335" style="zoom:50%;"></p><p>根据任务的到期时间进行取余和取模，然后根据取余结果将任务分布到不同的 slot 中，每个slot中根据round值决定是否操作，每次轮询到指定slot时，总时遍历最少round的对象进行执行，这样新增、执行两个操作的时间复杂度都近似O(1)。如果冲突较大可以增加数组长度，或者采用多级时间轮的方式处理。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">HashedWheelTimer</span><span class="token punctuation">(</span>        ThreadFactory threadFactory<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//线程池，但是只创建了一个线程</span>        <span class="token keyword">long</span> tickDuration<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">//时针每次 tick 的时间，相当于时针间隔多久走到下一个 slot</span>        TimeUnit unit<span class="token punctuation">,</span>             <span class="token comment" spellcheck="true">//表示 tickDuration 的时间单位，tickDuration * unit</span>        <span class="token keyword">int</span> ticksPerWheel<span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//时间轮上一共有多少个 slot，默认 512 个。</span>        <span class="token keyword">boolean</span> leakDetection<span class="token punctuation">,</span>        <span class="token keyword">long</span> maxPendingTimeouts<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//最大允许等待任务数</span>    <span class="token comment" spellcheck="true">// 省略其他代码</span>    wheel <span class="token operator">=</span> <span class="token function">createWheel</span><span class="token punctuation">(</span>ticksPerWheel<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建时间轮的环形数组结构</span>    mask <span class="token operator">=</span> wheel<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 用于快速取模的掩码</span>    <span class="token keyword">long</span> duration <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>tickDuration<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 转换成纳秒处理</span>    workerThread <span class="token operator">=</span> threadFactory<span class="token punctuation">.</span><span class="token function">newThread</span><span class="token punctuation">(</span>worker<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 创建工作线程</span>    leak <span class="token operator">=</span> leakDetection <span class="token operator">||</span> <span class="token operator">!</span>workerThread<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> leakDetector<span class="token punctuation">.</span><span class="token function">track</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token operator">:</span> null<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否开启内存泄漏检测</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>maxPendingTimeouts <span class="token operator">=</span> maxPendingTimeouts<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 最大允许等待任务数，HashedWheelTimer 中任务超出该阈值时会抛出异常</span><span class="token punctuation">}</span></code></pre><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jofq9r4j315i0fmq96.jpg" alt="image-20210504175531294" style="zoom:50%;"></p><p>​    <strong>时间轮空推进问题</strong></p><p>​    Netty 中的时间轮是通过固定的时间间隔 tickDuration 进行推动的，如果长时间没有到期任务，那么会存在时间轮空推进的现象，从而造成一定的性能损耗。此外，如果任务的到期时间跨度很大，例如 A 任务 1s 后执行，B 任务 6 小时之后执行，也会造成空推进的问题。</p><p><strong>Kafka解决方案</strong></p><p>​    <strong>为了解决空推进的问题</strong>，Kafka 借助 JDK 的 DelayQueue 来负责推进时间轮。DelayQueue 保存了时间轮中的每个 Bucket，并且根据 Bucket 的到期时间进行排序，最近的到期时间被放在 DelayQueue 的队头。Kafka 中会有一个线程来读取 DelayQueue 中的任务列表，<strong>如果时间没有到，那么 DelayQueue 会一直处于阻塞状态</strong>，从而解决空推进的问题。虽然DelayQueue 插入和删除的性能不是很好，但这其实就是一种权衡的策略，但是DelayQueue 只存放了 Bucket，Bucket 的数量并不多，相比空推进带来的影响是利大于弊的。</p><p>​    <strong>为了解决任务时间跨度很大的问题</strong>，Kafka 引入了层级时间轮，如下图所示。当任务的 deadline 超出当前所在层的时间轮表示范围时，就会尝试将任务添加到上一层时间轮中，跟钟表的时针、分针、秒针的转动规则是同一个道理。</p><h4 id="3、MpscQueue"><a href="#3、MpscQueue" class="headerlink" title="3、MpscQueue"></a>3、MpscQueue</h4><h4 id="4、select、poll、epoll的区别"><a href="#4、select、poll、epoll的区别" class="headerlink" title="4、select、poll、epoll的区别"></a>4、select、poll、epoll的区别</h4><p><strong>select</strong> （windows）<strong>poll </strong>(linux)本质上和select没有区别，查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。</p><p><strong>epoll </strong>支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。</p><p><strong>Epoll空轮询漏洞</strong></p><p>在 JDK 中， Epoll 的实现是存在漏洞的，即使 Selector 轮询的事件列表为空，NIO 线程一样可以被唤醒，导致 CPU 100% 占用。实际上 Netty 并没有从根源上解决该问题，而是巧妙地规避了这个问题。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">long</span> time <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*事件轮询的持续时间大于等于 timeoutMillis*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    selectCnt <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token comment" spellcheck="true">/*不正常的次数 selectCnt 达到阈值 512*/</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//重建Select并且SelectionKey重新注册到新Selector上</span>      selector <span class="token operator">=</span> <span class="token function">selectRebuildSelector</span><span class="token punctuation">(</span>selectCnt<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>NioEventLoop 线程的可靠性至关重要，一旦 NioEventLoop 发生阻塞或者陷入空轮询，就会导致整个系统不可用。</p><h1 id="四、LEETCODE"><a href="#四、LEETCODE" class="headerlink" title="四、LEETCODE"></a>四、LEETCODE</h1><h3 id="【Python语法】"><a href="#【Python语法】" class="headerlink" title="【Python语法】"></a>【Python语法】</h3><pre class=" language-python"><code class="language-python">reduce<span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">[</span><span class="token punctuation">,</span> initializer<span class="token punctuation">]</span><span class="token punctuation">)</span>    reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x <span class="token operator">*</span> y<span class="token punctuation">,</span>ns<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 数组之乘积 (ns[0] * ns[1]) * ns[2]</span>    reduce<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span>y<span class="token punctuation">:</span>x <span class="token operator">+</span> y<span class="token punctuation">,</span>ns<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 数组之和</span><span class="token comment" spellcheck="true"># 记忆化搜索</span>@functools<span class="token punctuation">.</span>lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span>res <span class="token operator">=</span> helper<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>N<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>helper<span class="token punctuation">.</span>cache_clear<span class="token punctuation">(</span><span class="token punctuation">)</span>tuple<span class="token punctuation">(</span>ns<span class="token punctuation">)</span> 可以hash做参数<span class="token comment" spellcheck="true"># 大根堆</span>q <span class="token operator">=</span> list<span class="token punctuation">(</span>map<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token operator">-</span>x<span class="token punctuation">,</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span>heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>q<span class="token punctuation">)</span>key <span class="token operator">=</span> <span class="token operator">-</span>heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 过滤函数</span>filter<span class="token punctuation">(</span>function<span class="token punctuation">,</span> iterable<span class="token punctuation">)</span>    filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token number">2</span> <span class="token operator">&lt;</span> x <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token operator">and</span> x <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    filter<span class="token punctuation">(</span>dfs<span class="token punctuation">,</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>graph<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 除数</span>div<span class="token punctuation">,</span> mod <span class="token operator">=</span> divmod<span class="token punctuation">(</span>sum<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>random<span class="token punctuation">.</span>randint<span class="token punctuation">(</span>i<span class="token punctuation">,</span>len<span class="token punctuation">(</span>self<span class="token punctuation">.</span>ns<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#第一个降序，第二个升序</span>sorted<span class="token punctuation">(</span>pss<span class="token punctuation">,</span>key <span class="token operator">=</span> <span class="token keyword">lambda</span> x<span class="token punctuation">:</span><span class="token punctuation">[</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token operator">-</span>x<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 不可变str 常见函数</span>split<span class="token punctuation">(</span>sep<span class="token operator">=</span>None<span class="token punctuation">,</span> maxsplit<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 以sep来分割字符串</span>strip<span class="token punctuation">(</span><span class="token punctuation">[</span>chars<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 去除首末两端的字符, 默认是 \r,\n," "</span>join<span class="token punctuation">(</span>iterable<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将iterable内的元素拼接成字符串,如','.join(['leet', 'code'])="leet,code"</span>replace<span class="token punctuation">(</span>old<span class="token punctuation">,</span> new<span class="token punctuation">[</span><span class="token punctuation">,</span> count<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 字符串替换, old to new</span>count<span class="token punctuation">(</span>sub<span class="token punctuation">[</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 统计子字符串sub的个数</span>startswith<span class="token punctuation">(</span>prefix<span class="token punctuation">[</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 以prefix开始的字符串</span>endswith<span class="token punctuation">(</span>suffix<span class="token punctuation">[</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token punctuation">,</span> end<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 以suffix结束的字符串</span>cs <span class="token keyword">in</span> chrs<span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># chrs 中包含 cs </span><span class="token comment" spellcheck="true"># deque 常见函数</span>queue <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>iterable<span class="token punctuation">[</span><span class="token punctuation">,</span> maxlen<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>queue<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 往右边添加一个元素</span>queue<span class="token punctuation">.</span>appendleft<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 往左边添加一个元素</span>queue<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 清空队列</span>queue<span class="token punctuation">.</span>count<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 返回指定元素的出现次数</span>queue<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>val<span class="token punctuation">[</span><span class="token punctuation">,</span> start<span class="token punctuation">[</span><span class="token punctuation">,</span> stop<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 在指定位置插入元素</span>queue<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取最右边一个元素，并在队列中删除</span>queue<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 获取最左边一个元素，并在队列中删除</span>queue<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 队列反转</span>queue<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 删除指定元素</span>queue<span class="token punctuation">.</span>rotate<span class="token punctuation">(</span>n<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 把右边元素放到左边</span><span class="token comment" spellcheck="true"># list 常见函数</span>lst<span class="token punctuation">.</span>sort<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>lst<span class="token punctuation">.</span>append<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 也可以 lst = lst + [val]</span>lst<span class="token punctuation">.</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 清空列表</span>lst<span class="token punctuation">.</span>count<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># val个数</span>lst<span class="token punctuation">.</span>pop<span class="token punctuation">(</span>val<span class="token operator">=</span>lst<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># (默认)从末端移除一个值</span>lst<span class="token punctuation">.</span>remove<span class="token punctuation">(</span>val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 移除 val</span>lst<span class="token punctuation">.</span>reverse<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 反转</span>lst<span class="token punctuation">.</span>insert<span class="token punctuation">(</span>i<span class="token punctuation">,</span> val<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 在 i 处插入 val</span><span class="token comment" spellcheck="true"># 字典dict 常见函数</span>d <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">:</span> value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 取到不存在的值时不会报错，用{}时、需要设置get的default值</span>pop<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token punctuation">,</span> default<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 通过键去删除键值对(若没有该键则返回default(没有设置default则报错))</span>setdefault<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token punctuation">,</span> default<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 设置默认值</span>update<span class="token punctuation">(</span><span class="token punctuation">[</span>other<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 批量添加</span>get<span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token punctuation">,</span> default<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 通过键获取值(若没有该键可设置默认值, 预防报错)</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 清空字典</span>keys<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将字典的键组成新的可迭代对象</span>values<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将字典中的值组成新的可迭代对象</span>items<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将字典的键值对凑成一个个元组, 组成新的可迭代对象</span>dict1 <span class="token operator">=</span> dict2 <span class="token comment" spellcheck="true">#两个字典完全相等，滑窗时可用</span><span class="token comment" spellcheck="true"># 集合set 常见函数</span>s <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token keyword">lambda</span> <span class="token punctuation">:</span> value<span class="token punctuation">)</span>add<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 向集合中添加数据</span>update<span class="token punctuation">(</span><span class="token operator">*</span>others<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 迭代着增加</span>clear<span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 清空集合</span>discard<span class="token punctuation">(</span>elem<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 删除集合中指定的值(不存在则不删除)</span><span class="token comment" spellcheck="true"># 堆heapq 常见函数</span>heap <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 建堆</span>heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span>item<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 往堆中插入新值</span>heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>heap<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 弹出最小的值</span>heap<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true"># 查看堆中最小的值, 不弹出</span>heapq<span class="token punctuation">.</span>heapify<span class="token punctuation">(</span>x<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 以线性时间将一个列表转为堆</span>heapq<span class="token punctuation">.</span>heappoppush<span class="token punctuation">(</span>heap<span class="token punctuation">,</span> item<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 弹出最小的值.并且将新的值插入其中.</span>heapq<span class="token punctuation">.</span>merge<span class="token punctuation">(</span><span class="token operator">*</span>iterables<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">,</span> reverse<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 将多个堆进行合并</span>heapq<span class="token punctuation">.</span>nlargest<span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 从堆中找出最大的 n 个数，key的作用和sorted( )方法里面的key类似, 用列表元素的某个属性和函数作为关键字</span>heapq<span class="token punctuation">.</span>nsmallest<span class="token punctuation">(</span>n<span class="token punctuation">,</span> iterable<span class="token punctuation">,</span> key<span class="token operator">=</span>None<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 从堆中找出最小的 n 个数, 与 nlargest 相反</span><span class="token comment" spellcheck="true"># 二分查找函数</span>bisect<span class="token punctuation">.</span>bisect_left<span class="token punctuation">(</span>ps<span class="token punctuation">,</span> T<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> R<span class="token operator">=</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#二分左边界</span>bisect<span class="token punctuation">.</span>bisect_right<span class="token punctuation">(</span>ps<span class="token punctuation">,</span> T<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> R<span class="token operator">=</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#二分右边界 </span>bisect<span class="token punctuation">.</span>insort_left<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">,</span> lo<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> hi<span class="token operator">=</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 二分插入到左侧</span>bisect<span class="token punctuation">.</span>insort_right<span class="token punctuation">(</span>a<span class="token punctuation">,</span> x<span class="token punctuation">,</span> lo<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> hi<span class="token operator">=</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 二分插入到右侧</span><span class="token comment" spellcheck="true"># bit操作</span><span class="token operator">&amp;</span> 符号，x <span class="token operator">&amp;</span> y ，会将两个十进制数在二进制下进行与运算<span class="token operator">|</span> 符号，x <span class="token operator">|</span> y ，会将两个十进制数在二进制下进行或运算<span class="token operator">^</span> 符号，x <span class="token operator">^</span> y ，会将两个十进制数在二进制下进行异或运算<span class="token operator">&lt;&lt;</span> 符号，x <span class="token operator">&lt;&lt;</span> y 左移操作，最右边用 <span class="token number">0</span> 填充<span class="token operator">>></span> 符号，x <span class="token operator">>></span> y 右移操作，最左边用 <span class="token number">0</span> 填充<span class="token operator">~</span> 符号，<span class="token operator">~</span>x ，按位取反操作，将 x 在二进制下的每一位取反<span class="token comment" spellcheck="true"># 整数集合set位运算</span><span class="token comment" spellcheck="true"># 整数集合做标志时，可以做参数加速运算</span>vstd 访问 i ：vstd <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span>vstd 离开 i ：vstd <span class="token operator">&amp;</span> <span class="token operator">~</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span>vstd 不包含 i <span class="token punctuation">:</span> <span class="token operator">not</span> vstd <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> i<span class="token punctuation">)</span>并集 ：A <span class="token operator">|</span> B交集 ：A <span class="token operator">&amp;</span> B全集 ：<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span>补集 ：<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> n<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">^</span> A子集 ：<span class="token punctuation">(</span>A <span class="token operator">&amp;</span> B<span class="token punctuation">)</span> <span class="token operator">==</span> B判断是否是 <span class="token number">2</span> 的幂 ：A <span class="token operator">&amp;</span> <span class="token punctuation">(</span>A <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span>最低位的 <span class="token number">1</span> 变为 <span class="token number">0</span> ：n <span class="token operator">&amp;</span><span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">while</span> n<span class="token punctuation">:</span>            n <span class="token operator">&amp;</span><span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span>            ret <span class="token operator">+=</span> <span class="token number">1</span>最低位的 <span class="token number">1</span>：A <span class="token operator">&amp;</span> <span class="token punctuation">(</span><span class="token operator">-</span>A<span class="token punctuation">)</span>，最低位的 <span class="token number">1</span> 一般记为 lowbit<span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># ^     ：匹配字符串开头</span><span class="token comment" spellcheck="true"># [\+\-]：代表一个+字符或-字符</span><span class="token comment" spellcheck="true"># ?     ：前面一个字符可有可无</span><span class="token comment" spellcheck="true"># \d    ：一个数字</span><span class="token comment" spellcheck="true"># +     ：前面一个字符的一个或多个</span><span class="token comment" spellcheck="true"># \D    ：一个非数字字符</span><span class="token comment" spellcheck="true"># *     ：前面一个字符的0个或多个</span>matches <span class="token operator">=</span> re<span class="token punctuation">.</span>match<span class="token punctuation">(</span><span class="token string">'[ ]*([+-]?\d+)'</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span></code></pre><h3 id="【背包模板】"><a href="#【背包模板】" class="headerlink" title="【背包模板】"></a>【背包模板】</h3><p><strong>「力扣」上的 0-1 背包问题：</strong></p><ul><li><p>组合问题模板</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#0-1背包，不可重复</span><span class="token keyword">for</span> n <span class="token keyword">in</span> ns<span class="token punctuation">:</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>T<span class="token punctuation">,</span> n<span class="token number">-1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> n<span class="token punctuation">]</span> <span class="token operator">+</span> ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#完全背包，可重复，无序，算重量</span><span class="token keyword">for</span> n <span class="token keyword">in</span> ns<span class="token punctuation">:</span>     <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">,</span> T<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> n<span class="token punctuation">]</span> <span class="token operator">+</span> ws<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#完全背包，可重复，有序，算次数     </span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> T<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> n <span class="token keyword">in</span> ns<span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>n<span class="token punctuation">]</span></code></pre><p><strong>✅377</strong> 组合总和 Ⅳ<br>✅<strong>494</strong> 目标和<br>✅<strong>518</strong> 零钱兑换 II</p></li><li><p>True、False问题</p><pre class=" language-python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">|</span><span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span></code></pre><p><strong>✅139</strong> 单词拆分<br><strong>✅416</strong> 分割等和子集</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#特殊的可以使用bit数组</span></code></pre></li><li><p>最大最小问题：</p><pre class=" language-python"><code class="language-python">dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>num<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>✅<strong>474</strong> 一和零<br>✅<strong>322</strong> 零钱兑换</p></li></ul><p>「力扣」第 <strong>879</strong> 题：盈利计划（困难）；<br>「力扣」第 <strong>1449</strong> 题：数位成本和为目标值的最大数字（困难）。</p><h3 id="【回溯模板】"><a href="#【回溯模板】" class="headerlink" title="【回溯模板】"></a>【回溯模板】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 回溯算法，复杂度较高2^n或者N！，因为回溯算法就是暴力穷举，可用lru剪枝</span>@functools<span class="token punctuation">.</span>lru_cache<span class="token punctuation">(</span>None<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>路径<span class="token punctuation">,</span> 选择列表<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> 满足结束条件<span class="token punctuation">:</span>        结果<span class="token punctuation">.</span>append<span class="token punctuation">(</span>路径<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> 选择 <span class="token keyword">in</span> 选择列表<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 核心代码段</span>          <span class="token keyword">if</span> vst<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true"># 辅助数组，减枝</span>          <span class="token keyword">continue</span>        做出选择        递归执行backtrack        撤销选择</code></pre><p>「<strong>剪枝</strong>」第 <strong>46</strong> 题 全排列 第 <strong>47</strong> 题 全排列②</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 剪枝</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>temp_list<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> length <span class="token operator">==</span> n<span class="token punctuation">:</span>      res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">if</span> <span class="token operator">not</span> visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span>          visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>          backtrack<span class="token punctuation">(</span>temp_list <span class="token operator">+</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>          visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span></code></pre><p>「<strong>索引遍历</strong>」第 <strong>78</strong> 题 子集 | 第 <strong>47</strong> 题 子集② | 第 <strong>131</strong> 题 分割字符串</p><pre><code>  第 **39 **题 组合 | 第 **40** 题 组合②  | 第 **216** 题 组合③</code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 索引遍历</span><span class="token keyword">def</span> <span class="token function">helper1</span><span class="token punctuation">(</span>idx<span class="token punctuation">,</span> n<span class="token punctuation">,</span> temp_list<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> temp_list <span class="token operator">not</span> <span class="token keyword">in</span> res<span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>temp_list<span class="token punctuation">)</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>idx<span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">:</span>    helper1<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> n<span class="token punctuation">,</span> temp_list <span class="token operator">+</span> <span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>「 <strong>资源消耗</strong>」第 <strong>22</strong> 题 夸号生成</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 资源消耗</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>S<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> <span class="token operator">not</span> L <span class="token operator">and</span> <span class="token operator">not</span> R<span class="token punctuation">:</span>    ans<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span>join<span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">return</span>  <span class="token keyword">if</span> L <span class="token punctuation">:</span>     backtrack<span class="token punctuation">(</span>S <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">'('</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token number">-1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span>  <span class="token keyword">if</span> R <span class="token operator">></span> L <span class="token punctuation">:</span> backtrack<span class="token punctuation">(</span>S <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token string">')'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token number">-1</span><span class="token punctuation">)</span></code></pre><p>「<strong>资源消耗</strong>」第 <strong>93</strong> 题 复原IP</p><pre class=" language-python"><code class="language-python">资源消耗<span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> tmp<span class="token punctuation">,</span> flag<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> i <span class="token operator">==</span> n <span class="token operator">and</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>tmp<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">elif</span> i<span class="token operator">&lt;</span>n <span class="token operator">and</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">'0'</span><span class="token punctuation">:</span>    backtrack<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">,</span> flag <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>  <span class="token keyword">elif</span> flag <span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> min<span class="token punctuation">(</span>n<span class="token punctuation">,</span>i <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">if</span> <span class="token number">0</span> <span class="token operator">&lt;</span> int<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">255</span><span class="token punctuation">:</span>        backtrack<span class="token punctuation">(</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> tmp <span class="token operator">+</span> s<span class="token punctuation">[</span>i<span class="token punctuation">:</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">"."</span><span class="token punctuation">,</span> flag <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>「<strong>资源消耗</strong>」第 <strong>17</strong> 题 电话号码</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 资源消耗</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> remains<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> <span class="token operator">not</span> remains<span class="token punctuation">:</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>path<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span>    <span class="token keyword">return</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>remains<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    dfs<span class="token punctuation">(</span>path <span class="token operator">+</span> <span class="token punctuation">[</span>remains<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">,</span> remains<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> remains<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 套模板</span><span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>pth<span class="token punctuation">,</span>idx<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> idx <span class="token operator">==</span> len<span class="token punctuation">(</span>ds<span class="token punctuation">)</span><span class="token punctuation">:</span>        res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>pth<span class="token punctuation">)</span>        <span class="token keyword">return</span>    <span class="token keyword">for</span> c <span class="token keyword">in</span> dic<span class="token punctuation">[</span>ds<span class="token punctuation">[</span>idx<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        dfs<span class="token punctuation">(</span>pth <span class="token operator">+</span> c<span class="token punctuation">,</span> idx <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>「<strong>多重限制</strong>」第 <strong>37</strong> 题 解数独  | 第 <strong>51</strong> 题 N皇后</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 多重限制</span><span class="token keyword">def</span> <span class="token function">backtrack</span><span class="token punctuation">(</span>pos<span class="token punctuation">)</span><span class="token punctuation">:</span>  <span class="token keyword">if</span> pos <span class="token operator">==</span> n<span class="token punctuation">:</span>    <span class="token keyword">return</span> <span class="token boolean">True</span>  i<span class="token punctuation">,</span> j <span class="token operator">=</span> empty<span class="token punctuation">[</span>pos<span class="token punctuation">]</span>  <span class="token keyword">for</span> num <span class="token keyword">in</span> row<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&amp;</span> col<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;</span> block<span class="token punctuation">[</span>bidx<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>    row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    block<span class="token punctuation">[</span>bidx<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>remove<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    board<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> str<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    <span class="token keyword">if</span> backtrack<span class="token punctuation">(</span>pos <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token boolean">True</span>    row<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    col<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span>    block<span class="token punctuation">[</span>bidx<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>add<span class="token punctuation">(</span>num<span class="token punctuation">)</span></code></pre><p>「<strong>递归</strong>」第 <strong>10</strong> 题 正则匹配</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 递归</span><span class="token keyword">def</span> <span class="token function">isMatch</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> s<span class="token punctuation">:</span> str<span class="token punctuation">,</span> p<span class="token punctuation">:</span> str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> bool<span class="token punctuation">:</span>  <span class="token keyword">if</span> <span class="token operator">not</span> p<span class="token punctuation">:</span>     <span class="token keyword">return</span> <span class="token operator">not</span> s  f <span class="token operator">=</span> bool<span class="token punctuation">(</span>s <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">in</span> <span class="token punctuation">{</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token string">'.'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> len<span class="token punctuation">(</span>p<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">2</span> <span class="token operator">and</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"*"</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">or</span> f <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">)</span>  <span class="token keyword">else</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> f <span class="token operator">and</span> self<span class="token punctuation">.</span>isMatch<span class="token punctuation">(</span>s<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">,</span> p<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h3 id="【并查集模板】"><a href="#【并查集模板】" class="headerlink" title="【并查集模板】"></a>【并查集模板】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#虚拟节点用以连接某一特征的全部节点，类似于链表的preHead</span>dummy parent <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>size <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span><span class="token keyword">lambda</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">)</span>cnt <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">def</span> <span class="token function">find</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    parent<span class="token punctuation">.</span>setdefault<span class="token punctuation">(</span>x<span class="token punctuation">,</span>x<span class="token punctuation">)</span>    <span class="token keyword">while</span> x <span class="token operator">!=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">:</span>        x <span class="token operator">=</span> parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true">#路径压缩 parent[x] = parent[parent[x]];</span>    <span class="token keyword">return</span> x<span class="token keyword">def</span> <span class="token function">union</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span>    nonlocal cnt    <span class="token keyword">if</span> connected<span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token keyword">return</span>    <span class="token comment" spellcheck="true"># 小的树挂到大的树上， 使树尽量平衡</span>    xP <span class="token operator">=</span> find<span class="token punctuation">(</span>x<span class="token punctuation">)</span>    yP <span class="token operator">=</span> find<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token keyword">if</span> size<span class="token punctuation">[</span>hP<span class="token punctuation">]</span> <span class="token operator">&lt;</span> size<span class="token punctuation">[</span>yP<span class="token punctuation">]</span><span class="token punctuation">:</span>        parent<span class="token punctuation">[</span>xP<span class="token punctuation">]</span> <span class="token operator">=</span> yP    <span class="token keyword">else</span><span class="token punctuation">:</span>        parent<span class="token punctuation">[</span>yP<span class="token punctuation">]</span> <span class="token operator">=</span> xP    size<span class="token punctuation">[</span>xP<span class="token punctuation">]</span> <span class="token operator">+=</span> size<span class="token punctuation">[</span>yP<span class="token punctuation">]</span>    <span class="token comment" spellcheck="true"># 优化结束</span>    parent<span class="token punctuation">[</span>find<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> find<span class="token punctuation">(</span>y<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 不优化</span>    cnt <span class="token operator">-=</span> <span class="token number">1</span>    <span class="token keyword">return</span> size<span class="token punctuation">[</span>xP<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">connected</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> find<span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">==</span> find<span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">add</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> x <span class="token operator">not</span> <span class="token keyword">in</span> parent<span class="token punctuation">:</span>        parent<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> None        cnt <span class="token operator">+=</span> <span class="token number">1</span><span class="token comment" spellcheck="true"># 检查是否有环</span><span class="token keyword">for</span> a<span class="token punctuation">,</span> b <span class="token keyword">in</span> edges<span class="token punctuation">:</span>    <span class="token keyword">if</span> connected<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token boolean">True</span>    union<span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"># 将每个集合组成以头为key的字典</span>res <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> e <span class="token keyword">in</span> e2n<span class="token punctuation">:</span>    res<span class="token punctuation">[</span>uf<span class="token punctuation">.</span>find<span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>e<span class="token punctuation">)</span></code></pre><h3 id="【拓扑排序模板】"><a href="#【拓扑排序模板】" class="headerlink" title="【拓扑排序模板】"></a>【拓扑排序模板】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 【拓扑排序模板】</span>ins <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> nous <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> cur<span class="token punctuation">,</span> pre <span class="token keyword">in</span> ps<span class="token punctuation">:</span>    ins<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>              <span class="token comment" spellcheck="true">#入度</span>    ous<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">#出度</span>res <span class="token operator">=</span> list<span class="token punctuation">(</span>filter<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span>ins<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">,</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token keyword">while</span> q<span class="token punctuation">:</span>    pre <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> cur <span class="token keyword">in</span> ous<span class="token punctuation">[</span>pre<span class="token punctuation">]</span><span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#释放出度队列</span>        ins<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token keyword">if</span> <span class="token operator">not</span> ins<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">:</span>             q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">#入度为0解锁</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span></code></pre><h3 id="【单调栈模板】"><a href="#【单调栈模板】" class="headerlink" title="【单调栈模板】"></a><strong>【单调栈模板】</strong></h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># s中一般存索引</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> stack <span class="token operator">and</span> ns<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> ns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 单调递减栈</span>        stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 业务逻辑</span>    stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><p>「<strong>单调递增</strong>」第 <strong>84</strong> 题 求最大矩形</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第 **84** 题 求最大矩形</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>hs<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> s <span class="token operator">and</span> hs<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> hs<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        base <span class="token operator">=</span> s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> s<span class="token punctuation">:</span>            H <span class="token operator">=</span> hs<span class="token punctuation">[</span>base<span class="token punctuation">]</span>            W <span class="token operator">=</span> i <span class="token operator">-</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 当前弹出的做高，当前与次小做宽</span>            res <span class="token operator">=</span> max<span class="token punctuation">(</span>res<span class="token punctuation">,</span> H <span class="token operator">*</span> W<span class="token punctuation">)</span>    s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><p>「<strong>单调递增,考虑剩余</strong>」第 <strong>316</strong> 题 去除重复字符</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第 **316** 题 去除重复字符</span><span class="token keyword">for</span> i<span class="token punctuation">,</span>c <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>ss<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">if</span> c <span class="token operator">not</span> <span class="token keyword">in</span> s<span class="token punctuation">:</span>        <span class="token keyword">while</span> s <span class="token operator">and</span> c <span class="token operator">&lt;</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">and</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">in</span> ss<span class="token punctuation">[</span>i<span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>c<span class="token punctuation">)</span></code></pre><p>「<strong>单调递减</strong>」第 <strong>42</strong> 题 接雨水</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第 **42** 题 接雨水</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>hgt<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> stack <span class="token operator">and</span> hgt<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> hgt<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#递减栈</span>        base <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> stack<span class="token punctuation">:</span>            LH <span class="token operator">=</span> hgt<span class="token punctuation">[</span>stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>            W <span class="token operator">=</span> i <span class="token operator">-</span> stack<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span>            H <span class="token operator">=</span> min<span class="token punctuation">(</span>LH<span class="token punctuation">,</span>hgt<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span> hgt<span class="token punctuation">[</span>base<span class="token punctuation">]</span>            res <span class="token operator">+=</span> W <span class="token operator">*</span> H     stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><p>「<strong>单调递减</strong>」第 <strong>739</strong> 题 每日温度</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 第 **739** 题 每日温度</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>T<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">while</span> s <span class="token operator">and</span> T<span class="token punctuation">[</span>s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> T<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token punctuation">:</span>   <span class="token comment" spellcheck="true">#递减栈</span>        s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>    res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> i <span class="token keyword">if</span> s <span class="token keyword">else</span> <span class="token number">0</span>    s<span class="token punctuation">.</span>append<span class="token punctuation">(</span>i<span class="token punctuation">)</span></code></pre><h3 id="【二分模板】"><a href="#【二分模板】" class="headerlink" title="【二分模板】"></a>【二分模板】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 1355579 T=5 => 13(5)55579 返回2</span><span class="token comment" spellcheck="true"># ps[i-1] &lt; ps[i] &lt;= ps[i+1]</span>bisect<span class="token punctuation">.</span>bisect_left<span class="token punctuation">(</span>ps<span class="token punctuation">,</span> T<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> R<span class="token operator">=</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 1355579 T=5 => 13555(5)79 返回5</span><span class="token comment" spellcheck="true"># ps[i-1] &lt;= ps[i] &lt; ps[i+1]</span>bisect<span class="token punctuation">.</span>bisect_right<span class="token punctuation">(</span>ps<span class="token punctuation">,</span> T<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> R<span class="token operator">=</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span>  bisect<span class="token punctuation">.</span>bisect<span class="token punctuation">(</span>ps<span class="token punctuation">,</span> T<span class="token punctuation">,</span> L<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> R<span class="token operator">=</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span>   </code></pre><p>「<strong>中位返回</strong>」第 <strong>33</strong> 题 搜索旋转排序数组 | 第<strong>374</strong>题 猜数字大小 | 第<strong>69</strong>题  x平方根</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 中位返回</span><span class="token keyword">while</span> L <span class="token operator">&lt;=</span> R<span class="token punctuation">:</span>    M <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> R<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">if</span> nums<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">==</span> T<span class="token punctuation">:</span>        <span class="token keyword">return</span> M    <span class="token keyword">elif</span> nums<span class="token punctuation">[</span>M<span class="token punctuation">]</span> <span class="token operator">&lt;</span> T<span class="token punctuation">:</span>        L <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        R <span class="token operator">=</span> M <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>「<strong>区域压缩</strong>」第<strong>278</strong>题 第一个错误版本| 第<strong>162</strong>题 寻找峰值 | 第<strong>153</strong>题 寻找数组最小值</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 区域压缩</span><span class="token keyword">while</span> L <span class="token operator">&lt;</span> R<span class="token punctuation">:</span>    M <span class="token operator">=</span> <span class="token punctuation">(</span>L <span class="token operator">+</span> R<span class="token punctuation">)</span> <span class="token operator">//</span> <span class="token number">2</span>    <span class="token keyword">if</span> need <span class="token keyword">in</span> s<span class="token punctuation">[</span>L<span class="token punctuation">:</span>M<span class="token punctuation">]</span><span class="token punctuation">:</span>        R <span class="token operator">=</span> M    <span class="token keyword">else</span><span class="token punctuation">:</span>        L <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">1</span></code></pre><h3 id="【动态规划模板】"><a href="#【动态规划模板】" class="headerlink" title="【动态规划模板】"></a>【动态规划模板】</h3><h4 id="「单串问题」"><a href="#「单串问题」" class="headerlink" title="「单串问题」"></a>「<strong>单串问题</strong>」</h4><ul><li>70 爬楼梯问题</li><li>801 使序列递增的最小交换次数</li><li>746 使用最小花费爬楼梯</li><li>300 最长上升子序列</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 依赖前单个元素</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span> ns<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 依赖前部区域元素</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> f<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="「单串加状态问题」"><a href="#「单串加状态问题」" class="headerlink" title="「单串加状态问题」"></a>「<strong>单串加状态问题</strong>」</h4><ul><li><p>887 鸡蛋掉落</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 鸡蛋掉落</span><span class="token keyword">while</span> cur<span class="token punctuation">[</span>K<span class="token punctuation">]</span> <span class="token operator">&lt;</span> N<span class="token punctuation">:</span>             <span class="token comment" spellcheck="true"># 还剩 j 个蛋 测 ans 次 覆盖多少层</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> K <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 覆盖总层数 碎了 -1 次层数 + 1 + 没碎 -1 次层数</span>        cur<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> prev<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">+</span> prev<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    ans <span class="token operator">+=</span> <span class="token number">1</span>    prev <span class="token operator">=</span> copy<span class="token punctuation">.</span>deepcopy<span class="token punctuation">(</span>cur<span class="token punctuation">)</span></code></pre></li><li><p>813 最大平均值分组</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 813 最大平均值分组</span><span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>K<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true">#循环k次</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>          <span class="token comment" spellcheck="true">#每次均依赖上次的结果</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> N<span class="token punctuation">)</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> avrg<span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token operator">+</span> dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>410 分割数组最大值</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 410 分割数组最大值</span><span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>K<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>         <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token comment" spellcheck="true"># 0~i中分 k 段最大 即为</span>            <span class="token comment" spellcheck="true"># 0~j中分k-1段最大 和 j到i的前缀和的最大</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> min<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> ps<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> ps<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre></li></ul><h4 id="「经典双串LCS问题」"><a href="#「经典双串LCS问题」" class="headerlink" title="「经典双串LCS问题」"></a>「<strong>经典双串LCS问题</strong>」</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 经典双串LCS问题</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>M<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>M<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> t1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> t2<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">:</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span>         <span class="token keyword">else</span> <span class="token punctuation">:</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="「区间动态规划」"><a href="#「区间动态规划」" class="headerlink" title="「区间动态规划」"></a>「区间动态规划」</h4><ul><li>5 最长回文子串</li><li>647 最多回文子串</li><li>516 最长回文子序列</li><li>1312 最长回文插入次数</li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># dp[i][j] 代表从 i 到 j 的最长子串满足条件的数量</span><span class="token comment" spellcheck="true"># i-- &lt; j++  ==> i 在 0~j 范围内 --</span>dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>N<span class="token punctuation">)</span> <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span>    dp<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>j<span class="token number">-1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> ss<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> ss<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token number">2</span>        <span class="token keyword">else</span> <span class="token punctuation">:</span>            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> max<span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><h4 id="「区间分治动态规划」"><a href="#「区间分治动态规划」" class="headerlink" title="「区间分治动态规划」"></a><strong>「区间分治动态规划」</strong></h4><p><a href="https://leetcode-cn.com/problems/predict-the-winner/" target="_blank" rel="noopener">486 预测赢家</a></p><p><a href="***https://leetcode-cn.com/problems/burst-balloons/***">312 戳气球</a></p><p><a href="***https://leetcode-cn.com/problems/strange-printer/***">664 奇怪的打印机</a></p><p><a href="***https://leetcode-cn.com/problems/remove-boxes/***">546 移除盒子</a></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 区间分治动态规划</span><span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ns<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>    N <span class="token operator">=</span> len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span>    dp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> N <span class="token keyword">for</span> _ <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> l <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 长度从小到大</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>N<span class="token operator">-</span>l<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 以 i 为 开头</span>            j <span class="token operator">=</span> i <span class="token operator">+</span> l           <span class="token comment" spellcheck="true"># 以 j 为 终点</span>            <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 以 k 为分割点，进行分治         </span>                <span class="token operator">//</span> Todo 业务逻辑 </code></pre><p>「<strong>卡特兰数</strong>」</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 卡特兰数</span>g<span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token operator">=</span> g<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">*</span>g<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span> <span class="token operator">+</span> g<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">*</span>g<span class="token punctuation">(</span>n<span class="token number">-2</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>g<span class="token punctuation">(</span>n<span class="token number">-1</span><span class="token punctuation">)</span><span class="token operator">*</span>g<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>dp<span class="token operator">=</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n<span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>n<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> dp<span class="token punctuation">[</span>j<span class="token number">-1</span><span class="token punctuation">]</span> <span class="token operator">*</span> dp<span class="token punctuation">[</span>i<span class="token operator">-</span>j<span class="token punctuation">]</span></code></pre><h3 id="【滑动窗口】"><a href="#【滑动窗口】" class="headerlink" title="【滑动窗口】"></a>【滑动窗口】</h3><pre class=" language-PYTHON"><code class="language-PYTHON">"""给定待查串s和目标串t"""nd, wd = {}, {}nd = collections.Counter(s1)L, R = 0, 0cnt = 0 # 满足条件个数while R < len(s):        # 窗口右边界不断扩大，本质是搜索问题的可能解    c = s[R]      # 即将加入到窗口中的字符    R += 1    更新窗口中的数据    while 满足窗口收缩条件：  # 窗口的左边界收缩，本质是优化可行解        记录或返回结果        d = s[L]   # 即将从窗口中删除的字符        L += 1        更新窗口中的数据return 结果# 固定窗口 ,比滑动窗口更快一些i = j = cnt = 0      for j in range(len(A)):    if A[j] == 0:         cnt += 1    if cnt > K: #不满足时 平移        if A[i] == 0:            cnt -= 1        i += 1return j - i + 1        for j in range(len(A)):    if A[j] == 0:        cnt += 1    while cnt > K:        if A[i] == 0:            cnt -= 1        i += 1    res = max(res, j - i + 1)return res</code></pre><h3 id="【前缀和】"><a href="#【前缀和】" class="headerlink" title="【前缀和】"></a>【前缀和】</h3><p>「<strong>累加和存位置</strong>」</p><p>1371 最长偶数元音子数组</p><p>525 最长相等01子数组</p><p>325 最长和为k 子数组</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 前缀和初始化</span>psd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>  <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    t <span class="token operator">^</span><span class="token operator">=</span> cd<span class="token punctuation">.</span>get<span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true"># 业务逻辑</span>    <span class="token keyword">if</span> t <span class="token operator">not</span> <span class="token keyword">in</span> psd<span class="token punctuation">:</span>        psd<span class="token punctuation">[</span>t<span class="token punctuation">]</span> <span class="token operator">=</span> i       <span class="token comment" spellcheck="true"># 第一次存入数组</span>    <span class="token keyword">else</span><span class="token punctuation">:</span>        ans <span class="token operator">=</span> max<span class="token punctuation">(</span>ans<span class="token punctuation">,</span> i <span class="token operator">-</span> psd<span class="token punctuation">[</span>t<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#已存入则开始计算</span></code></pre><p>「<strong>累加和存数量</strong>」</p><p>560 和为K的子数组数量</p><p> 统计优美子数组</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 累加和存数量</span>psd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">+=</span> ns<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">if</span> s <span class="token operator">-</span> T <span class="token keyword">in</span> psd<span class="token punctuation">:</span>        ans <span class="token operator">+=</span> psd<span class="token punctuation">[</span>s <span class="token operator">-</span> T<span class="token punctuation">]</span> <span class="token comment" spellcheck="true"># 存数量</span>    psd<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> psd<span class="token punctuation">.</span>get<span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>「<strong>模K状态前缀和</strong>」</p><p>523 连续和为 k 倍 的子数组（存索引）</p><p>974 和被k 整除 子数组数量（存数量）</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 模K状态前缀和</span>psd <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span>ans <span class="token operator">=</span> s <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    s <span class="token operator">+=</span> ns<span class="token punctuation">[</span>i<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># 业务逻辑</span>    <span class="token keyword">if</span> T <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">:</span> s <span class="token operator">%=</span> abs<span class="token punctuation">(</span>T<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 模k状态做key，索引做值</span>    <span class="token keyword">if</span> s <span class="token operator">not</span> <span class="token keyword">in</span> psd<span class="token punctuation">:</span>        psd<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">=</span> i    <span class="token keyword">elif</span> i <span class="token operator">-</span> psd<span class="token punctuation">[</span>s<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token boolean">True</span></code></pre><p><strong>「矩阵前缀和」</strong></p><ul><li>363 不超过K的最大数值和</li><li>1074 和为目标值的子矩阵数量 </li></ul><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 矩阵前缀和</span><span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>m<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true">#固定左边界</span>    ps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span> n    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i<span class="token punctuation">,</span> m<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#固定右边界</span>        psS <span class="token operator">=</span> <span class="token number">0</span>            dct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">#初始只有一种可能</span>        <span class="token keyword">for</span> k <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true"># 以高做前缀和</span>            ps<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">+=</span> mtx<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span>          <span class="token comment" spellcheck="true"># 每行前缀和</span>            psS <span class="token operator">+=</span> ps<span class="token punctuation">[</span>k<span class="token punctuation">]</span>                <span class="token comment" spellcheck="true"># n行前缀和</span>            cnt <span class="token operator">+=</span> dct<span class="token punctuation">.</span>get<span class="token punctuation">(</span>psS <span class="token operator">-</span> T<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true"># 满足条件cnt</span>            dct<span class="token punctuation">[</span>psS<span class="token punctuation">]</span> <span class="token operator">=</span> dct<span class="token punctuation">.</span>get<span class="token punctuation">(</span>psS<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token comment" spellcheck="true"># 保存当前状态</span><span class="token keyword">return</span> cnt</code></pre><h3 id="【双指针】"><a href="#【双指针】" class="headerlink" title="【双指针】"></a>【双指针】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 双指针</span><span class="token keyword">def</span> <span class="token function">removeElement</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> ns<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> val<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> int<span class="token punctuation">:</span>    slow <span class="token operator">=</span> <span class="token number">0</span>    n <span class="token operator">=</span> len<span class="token punctuation">(</span>ns<span class="token punctuation">)</span>    <span class="token keyword">for</span> fast <span class="token keyword">in</span> range<span class="token punctuation">(</span>n<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> ns<span class="token punctuation">[</span>fast<span class="token punctuation">]</span> <span class="token operator">!=</span> val<span class="token punctuation">:</span>            ns<span class="token punctuation">[</span>slow<span class="token punctuation">]</span> <span class="token operator">=</span> ns<span class="token punctuation">[</span>fast<span class="token punctuation">]</span>            slow <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token keyword">return</span> slow</code></pre><h3 id="【深度优先】"><a href="#【深度优先】" class="headerlink" title="【深度优先】"></a>【深度优先】</h3><p>「<strong>二叉树遍历模板</strong>」</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 递归</span><span class="token comment" spellcheck="true"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span><span class="token comment" spellcheck="true"># 空间复杂度：空间复杂度：O(h)，h为树的高度。最坏情况下需要空间O(n)，平均情况为O(logn)</span><span class="token comment" spellcheck="true"># 递归1：二叉树遍历最易理解和实现版本</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># 前序递归</span>        <span class="token keyword">return</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>preOrd<span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">+</span> self<span class="token punctuation">.</span>preOrd<span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true"># # 中序递归 </span>        <span class="token comment" spellcheck="true"># return self.inOrd(root.left) + [root.val] + self.inOrd(root.right)</span>        <span class="token comment" spellcheck="true"># # 后序递归</span>        <span class="token comment" spellcheck="true"># return self.postOrd(root.left) + self.postOrd(root.right) + [root.val]</span><span class="token comment" spellcheck="true"># 递归2：通用模板，可以适应不同的题目，添加参数、增加返回条件、修改进入递归条件、自定义返回值</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">def</span> <span class="token function">dfs</span><span class="token punctuation">(</span>cur<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> cur<span class="token punctuation">:</span>                <span class="token keyword">return</span>                  <span class="token comment" spellcheck="true"># 前序递归</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>            dfs<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>             <span class="token comment" spellcheck="true"># # 中序递归</span>            <span class="token comment" spellcheck="true"># dfs(cur.left)</span>            <span class="token comment" spellcheck="true"># res.append(cur.val)</span>            <span class="token comment" spellcheck="true"># dfs(cur.right)</span>            <span class="token comment" spellcheck="true"># # 后序递归</span>            <span class="token comment" spellcheck="true"># dfs(cur.left)</span>            <span class="token comment" spellcheck="true"># dfs(cur.right)</span>            <span class="token comment" spellcheck="true"># res.append(cur.val)      </span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        dfs<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># 迭代</span><span class="token comment" spellcheck="true"># 时间复杂度：O(n)，n为节点数，访问每个节点恰好一次。</span><span class="token comment" spellcheck="true"># 空间复杂度：O(h)，h为树的高度。取决于树的结构，最坏情况存储整棵树，即O(n)</span><span class="token comment" spellcheck="true"># 迭代1：前序遍历最常用模板（后序同样可以用）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>                res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># # 前序迭代模板：最常用的二叉树DFS迭代遍历模板</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            cur <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            <span class="token keyword">if</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># # 后序迭代，相同模板：将前序迭代进栈顺序稍作修改，最后得到的结果反转</span>        <span class="token comment" spellcheck="true"># while stack:</span>        <span class="token comment" spellcheck="true">#     cur = stack.pop()</span>        <span class="token comment" spellcheck="true">#     if cur.left:</span>        <span class="token comment" spellcheck="true">#         stack.append(cur.left)</span>        <span class="token comment" spellcheck="true">#     if cur.right:</span>        <span class="token comment" spellcheck="true">#         stack.append(cur.right)</span>        <span class="token comment" spellcheck="true">#     res.append(cur.val)</span>        <span class="token comment" spellcheck="true"># return res[::-1]</span><span class="token comment" spellcheck="true"># 迭代1：层序遍历最常用模板</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">levelOrder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> q <span class="token punctuation">:</span>            l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>            <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>                t <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>                l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token keyword">if</span> t<span class="token punctuation">.</span>left <span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span>                <span class="token keyword">if</span> t<span class="token punctuation">.</span>right <span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># 迭代2：前、中、后序遍历通用模板（只需一个栈的空间）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>         res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        cur <span class="token operator">=</span> root        <span class="token comment" spellcheck="true"># 中序，模板：先用指针找到每颗子树的最左下角，然后进行进出栈操作</span>        <span class="token keyword">while</span> stack <span class="token operator">or</span> cur<span class="token punctuation">:</span>            <span class="token keyword">while</span> cur<span class="token punctuation">:</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">)</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left            cur <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right        <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># # 前序，相同模板</span>        <span class="token comment" spellcheck="true"># while stack or cur:</span>        <span class="token comment" spellcheck="true">#     while cur:</span>        <span class="token comment" spellcheck="true">#         res.append(cur.val)</span>        <span class="token comment" spellcheck="true">#         stack.append(cur)</span>        <span class="token comment" spellcheck="true">#         cur = cur.left</span>        <span class="token comment" spellcheck="true">#     cur = stack.pop()</span>        <span class="token comment" spellcheck="true">#     cur = cur.right</span>        <span class="token comment" spellcheck="true"># return res</span>        <span class="token comment" spellcheck="true"># # 后序，相同模板</span>        <span class="token comment" spellcheck="true"># while stack or cur:</span>        <span class="token comment" spellcheck="true">#     while cur:</span>        <span class="token comment" spellcheck="true">#         res.append(cur.val)</span>        <span class="token comment" spellcheck="true">#         stack.append(cur)</span>        <span class="token comment" spellcheck="true">#         cur = cur.right</span>        <span class="token comment" spellcheck="true">#     cur = stack.pop()</span>        <span class="token comment" spellcheck="true">#     cur = cur.left</span>        <span class="token comment" spellcheck="true"># return res[::-1]</span><span class="token comment" spellcheck="true"># 迭代3：标记法迭代（需要双倍的空间来存储访问状态）：</span><span class="token comment" spellcheck="true"># 前、中、后、层序通用模板，只需改变进栈顺序或即可实现前后中序遍历，</span><span class="token comment" spellcheck="true"># 而层序遍历则使用队列先进先出。0表示当前未访问，1表示已访问。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> root<span class="token punctuation">)</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> stack<span class="token punctuation">:</span>            flag<span class="token punctuation">,</span> cur <span class="token operator">=</span> stack<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token operator">not</span> cur<span class="token punctuation">:</span> <span class="token keyword">continue</span>            <span class="token keyword">if</span> flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>                <span class="token comment" spellcheck="true"># 前序，标记法</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span>                stack<span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> cur<span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># # 后序，标记法</span>                <span class="token comment" spellcheck="true"># stack.append((1, cur))</span>                <span class="token comment" spellcheck="true"># stack.append((0, cur.right))</span>                <span class="token comment" spellcheck="true"># stack.append((0, cur.left))</span>                <span class="token comment" spellcheck="true"># # 中序，标记法</span>                <span class="token comment" spellcheck="true"># stack.append((0, cur.right))</span>                <span class="token comment" spellcheck="true"># stack.append((1, cur))</span>                <span class="token comment" spellcheck="true"># stack.append((0, cur.left))  </span>            <span class="token keyword">else</span><span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>          <span class="token keyword">return</span> res        <span class="token comment" spellcheck="true"># # 层序，标记法</span>        <span class="token comment" spellcheck="true"># res = []</span>        <span class="token comment" spellcheck="true"># queue = [(0, root)]</span>        <span class="token comment" spellcheck="true"># while queue:</span>        <span class="token comment" spellcheck="true">#     flag, cur = queue.pop(0)  # 注意是队列，先进先出</span>        <span class="token comment" spellcheck="true">#     if not cur: continue</span>        <span class="token comment" spellcheck="true">#     if flag == 0:</span>                  <span class="token comment" spellcheck="true"># 层序遍历这三个的顺序无所谓，因为是队列，只弹出队首元素</span>        <span class="token comment" spellcheck="true">#         queue.append((1, cur))</span>        <span class="token comment" spellcheck="true">#         queue.append((0, cur.left))</span>        <span class="token comment" spellcheck="true">#         queue.append((0, cur.right))</span>        <span class="token comment" spellcheck="true">#     else:</span>        <span class="token comment" spellcheck="true">#         res.append(cur.val)</span>        <span class="token comment" spellcheck="true"># return res</span><span class="token comment" spellcheck="true"># 莫里斯遍历</span><span class="token comment" spellcheck="true"># 时间复杂度：O(n)，n为节点数，看似超过O(n)，有的节点可能要访问两次，实际分析还是O(n)</span><span class="token comment" spellcheck="true"># 空间复杂度：O(1)，如果在遍历过程中就输出节点值，则只需常数空间就能得到中序遍历结果，空间只需两个指针。</span><span class="token comment" spellcheck="true"># 如果将结果储存最后输出，则空间复杂度还是O(n)。</span><span class="token comment" spellcheck="true"># PS：莫里斯遍历实际上是在原有二叉树的结构基础上，构造了线索二叉树，</span><span class="token comment" spellcheck="true"># 线索二叉树定义为：原本为空的右子节点指向了中序遍历顺序之后的那个节点，把所有原本为空的左子节点都指向了中序遍历之前的那个节点</span><span class="token comment" spellcheck="true"># 此处只给出中序遍历，前序遍历只需修改输出顺序即可</span><span class="token comment" spellcheck="true"># 而后序遍历，由于遍历是从根开始的，而线索二叉树是将为空的左右子节点连接到相应的顺序上，使其能够按照相应准则输出</span><span class="token comment" spellcheck="true"># 但是后序遍历的根节点却已经没有额外的空间来标记自己下一个应该访问的节点，</span><span class="token comment" spellcheck="true"># 所以这里需要建立一个临时节点dump，令其左孩子是root。并且还需要一个子过程，就是倒序输出某两个节点之间路径上的各个节点。</span><span class="token comment" spellcheck="true"># 莫里斯遍历，借助线索二叉树中序遍历（附前序遍历）</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">inOrd</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> TreeNode<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># cur = pre = TreeNode(None)</span>        cur <span class="token operator">=</span> root        <span class="token keyword">while</span> cur<span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> cur<span class="token punctuation">.</span>left<span class="token punctuation">:</span>                res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true"># print(cur.val)</span>                cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right            <span class="token keyword">else</span><span class="token punctuation">:</span>                pre <span class="token operator">=</span> cur<span class="token punctuation">.</span>left                <span class="token keyword">while</span> pre<span class="token punctuation">.</span>right <span class="token operator">and</span> pre<span class="token punctuation">.</span>right <span class="token operator">!=</span> cur<span class="token punctuation">:</span>                    pre <span class="token operator">=</span> pre<span class="token punctuation">.</span>right                <span class="token keyword">if</span> <span class="token operator">not</span> pre<span class="token punctuation">.</span>right<span class="token punctuation">:</span>                    <span class="token comment" spellcheck="true"># print(cur.val) 这里是前序遍历的代码，前序与中序的唯一差别</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> cur                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>left                <span class="token keyword">else</span><span class="token punctuation">:</span>                    pre<span class="token punctuation">.</span>right <span class="token operator">=</span> None                    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>cur<span class="token punctuation">.</span>val<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true"># print(cur.val)</span>                    cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>right        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># N叉树遍历</span><span class="token comment" spellcheck="true"># 时间复杂度：时间复杂度：O(M)，其中 M 是 N 叉树中的节点个数。每个节点只会入栈和出栈各一次。</span><span class="token comment" spellcheck="true"># 空间复杂度：O(M)。在最坏的情况下，这棵 N 叉树只有 2 层，所有第 2 层的节点都是根节点的孩子。</span><span class="token comment" spellcheck="true"># 将根节点推出栈后，需要将这些节点都放入栈，共有 M−1个节点，因此栈的大小为 O(M)。</span><span class="token comment" spellcheck="true"># N叉树简洁递归</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">.</span>val<span class="token punctuation">]</span>        <span class="token keyword">for</span> node <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>            res<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>self<span class="token punctuation">.</span>preorder<span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># N叉树通用递归模板</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">def</span> <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>                <span class="token keyword">return</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>root<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token keyword">for</span> child <span class="token keyword">in</span> root<span class="token punctuation">.</span>children<span class="token punctuation">:</span>                helper<span class="token punctuation">(</span>child<span class="token punctuation">)</span>        helper<span class="token punctuation">(</span>root<span class="token punctuation">)</span>        <span class="token keyword">return</span> res<span class="token comment" spellcheck="true"># N叉树迭代方法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">preorder</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> root<span class="token punctuation">:</span> <span class="token string">'Node'</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> root<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        s <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span>        <span class="token comment" spellcheck="true"># s.append(root)</span>        res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>        <span class="token keyword">while</span> s<span class="token punctuation">:</span>            node <span class="token operator">=</span> s<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token punctuation">)</span>            res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true"># for child in node.children[::-1]:</span>            <span class="token comment" spellcheck="true">#     s.append(child)</span>            s<span class="token punctuation">.</span>extend<span class="token punctuation">(</span>node<span class="token punctuation">.</span>children<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> res</code></pre><h3 id="【广度优先】"><a href="#【广度优先】" class="headerlink" title="【广度优先】"></a>【广度优先】</h3><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 「**无向图的遍历**」</span>q <span class="token operator">=</span> collections<span class="token punctuation">.</span>deque<span class="token punctuation">(</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">while</span> q<span class="token punctuation">:</span>    cur <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token keyword">for</span> nxt <span class="token keyword">in</span> dt<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> vst<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span><span class="token punctuation">:</span>            vstd<span class="token punctuation">[</span>nxt<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token boolean">True</span>            q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>nxt<span class="token punctuation">)</span></code></pre><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># 「**二叉树层序遍历**」</span>q <span class="token operator">=</span> deque<span class="token punctuation">(</span><span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">)</span>res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">while</span> q <span class="token punctuation">:</span>    l <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>q<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>        t <span class="token operator">=</span> q<span class="token punctuation">.</span>popleft<span class="token punctuation">(</span><span class="token punctuation">)</span>        l<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span>        <span class="token keyword">if</span> t<span class="token punctuation">.</span>left <span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>left<span class="token punctuation">)</span>        <span class="token keyword">if</span> t<span class="token punctuation">.</span>right <span class="token punctuation">:</span> q<span class="token punctuation">.</span>append<span class="token punctuation">(</span>t<span class="token punctuation">.</span>right<span class="token punctuation">)</span>    res<span class="token punctuation">.</span>append<span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token keyword">return</span> res</code></pre><h3 id="【图论】"><a href="#【图论】" class="headerlink" title="【图论】"></a>【图论】</h3><hr><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#「Dijkstra最短路径」</span>dic <span class="token operator">=</span> collections<span class="token punctuation">.</span>defaultdict<span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token keyword">for</span> u<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w <span class="token keyword">in</span> edges<span class="token punctuation">:</span>    dic<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>v<span class="token punctuation">,</span> w<span class="token punctuation">]</span><span class="token punctuation">)</span>    dic<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token punctuation">.</span>append<span class="token punctuation">(</span><span class="token punctuation">[</span>u<span class="token punctuation">,</span> w<span class="token punctuation">]</span><span class="token punctuation">)</span>q <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">]</span>dist <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token keyword">while</span> q<span class="token punctuation">:</span>    dis<span class="token punctuation">,</span> cur <span class="token operator">=</span> heapq<span class="token punctuation">.</span>heappop<span class="token punctuation">(</span>q<span class="token punctuation">)</span>    <span class="token keyword">if</span> dist<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>        dist<span class="token punctuation">[</span>cur<span class="token punctuation">]</span> <span class="token operator">=</span> dis        <span class="token keyword">for</span> nxt<span class="token punctuation">,</span> wi <span class="token keyword">in</span> dic<span class="token punctuation">[</span>cur<span class="token punctuation">]</span><span class="token punctuation">:</span>            heapq<span class="token punctuation">.</span>heappush<span class="token punctuation">(</span>q<span class="token punctuation">,</span> <span class="token punctuation">[</span>dis <span class="token operator">+</span> wi<span class="token punctuation">,</span> nxt<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p><strong>「Floyd 求图中路径」</strong></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Floyd算法 求图中任意2点距离</span>ds <span class="token operator">=</span> defaultdict<span class="token punctuation">(</span>int<span class="token punctuation">)</span>st <span class="token operator">=</span> set<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> i<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>ess<span class="token punctuation">)</span><span class="token punctuation">:</span>    ds<span class="token punctuation">[</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> vs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    ds<span class="token punctuation">[</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">/</span> vs<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    st<span class="token punctuation">.</span>update<span class="token punctuation">(</span><span class="token punctuation">{</span>x<span class="token punctuation">,</span>y<span class="token punctuation">}</span><span class="token punctuation">)</span>arr <span class="token operator">=</span> list<span class="token punctuation">(</span>st<span class="token punctuation">)</span><span class="token keyword">for</span> k <span class="token keyword">in</span> arr<span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> arr<span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> arr<span class="token punctuation">:</span>            <span class="token keyword">if</span> ds<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">and</span> ds<span class="token punctuation">[</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                ds<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> ds<span class="token punctuation">[</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">*</span> ds<span class="token punctuation">[</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><h1 id="五、实战算法篇"><a href="#五、实战算法篇" class="headerlink" title="五、实战算法篇"></a>五、实战算法篇</h1><h3 id="1、URL黑名单（布隆过滤器）"><a href="#1、URL黑名单（布隆过滤器）" class="headerlink" title="1、URL黑名单（布隆过滤器）"></a><strong>1、</strong>URL黑名单（布隆过滤器）</h3><p><strong>100亿黑名单URL，每个64B，问这个黑名单要怎么存？判断一个URL是否在黑名单中</strong></p><p>​    <strong>散列表：</strong></p><p>​        如果把黑名单看成一个集合，将其存在 hashmap 中，貌似太大了，需要 640G，明显不科学。</p><p>​    <strong>布隆过滤器：</strong></p><p>​        它实际上是一个很长的二进制矢量和一系列随机映射函数。</p><p>​        它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>​        在数组中的每一位都是二进制位。布隆过滤器除了一个位数组，还有 K 个哈希函数。当一个元素加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li></ul><h3 id="2、词频统计（分文件）"><a href="#2、词频统计（分文件）" class="headerlink" title="2、词频统计（分文件）"></a>2、词频统计（分文件）</h3><p><strong>2GB内存在20亿整数中找到出现次数最多的数</strong> </p><p>​        通常做法是使用哈希表对出现的每一个数做词频统计，哈希表的key是某个整数，value记录整数出现的次数。本题的数据量是20亿，有可能一个数出现20亿次，则为了避免溢出，哈希表的key是32位（4B）,value也是 32位（4B），那么一条哈希表的记录就需要占用8B。</p><p>​        当哈希表记录数为2亿个时，需要16亿个字节数（8*2亿），需要至少1.6GB内存(16亿/2^30,1GB== 2 ^30个字节 == 10亿)。则20亿个记录，至少需要16GB的内存，不符合题目要求。</p><p>​        解决办法是将20亿个数的大文件利用哈希函数分成16个小文件，根据哈希函数可以把20亿条数据均匀分布到16个文件上，同一种数不可能被哈希函数分到不同的小文件上，假设哈希函数够好。然后对每一个小文件用哈希函数来统计其中每种数出现的次数，这样我们就得到16个文件中出现次数最多的数，接着从16个数中选出次数最大的那个key即可。</p><h3 id="3、未出现的数（bit数组）"><a href="#3、未出现的数（bit数组）" class="headerlink" title="3、未出现的数（bit数组）"></a><strong>3、未出现的数</strong>（bit数组）</h3><p><strong>40亿个非负整数中找到没有出现的数</strong> </p><p>​        对于原问题，如果使用哈希表来保存出现过的数，那么最坏情况下是40亿个数都不相同，那么哈希表则需要保存40亿条数据，一个32位整数需要4B，那么40亿*4B = 160亿个字节，一般大概10亿个字节的数据需要1G的空间，那么大概需要16G的空间，这不符合要求。</p><p>　　我们换一种方式，申请一个bit数组，数组大小为4294967295，大概为40亿bit，40亿/8 = 5亿字节，那么需要0.5G空间， bit数组的每个位置有两种状态0和1，那么怎么使用这个bit数组呢？呵呵，数组的长度刚好满足我们整数的个数范围，那么数组的每个下标值对应4294967295中的一个数，逐个遍历40亿个无符号数，例如，遇到20，则bitArray[20] = 1；遇到666，则bitArray[666] = 1,遍历完所有的数，将数组相应位置变为1。</p><p><strong>40亿个非负整数中找到一个没有出现的数，内存限制10MB</strong> </p><p>​        10亿个字节的数据大概需要1GB空间处理，那么10MB内存换算过来就是可以处理1千万字节的数据，也就是8千万bit，对于40亿非负整数如果申请bit数组的话，40亿bit / 0.8亿bit = 50，那么这样最少也得分50块来处理，下面就以64块来进行分析解答吧。</p><p><strong>总结一下进阶的解法：</strong></p><p>1．根据10MB的内存限制，确定统计区间的大小，就是第二次遍历时的bitArr大小。</p><p>2．利用区间计数的方式，找到那个计数不足的区间，这个区间上肯定有没出现的数。</p><p>3．对这个区间上的数做bit map映射，再遍历bit map，找到一个没出现的数即可。</p><p><strong>自己的想法</strong></p><p>如果只是找一个数，可以高位模运算，写到64个不同的文件，然后在最小的文件中通过bitArray一次处理掉。</p><p><strong>40亿个无符号整数，1GB内存，找到所有出现两次的数</strong> </p><p>​        对于原问题，可以用bit map的方式来表示数出现的情况。具体地说，是申请一个长度为4294967295×2的bit类型的数组bitArr，用2个位置表示一个数出现的词频，1B占用8个bit，所以长度为4294967295×2的bit类型的数组占用1GB空间。怎么使用这个bitArr数组呢？遍历这40亿个无符号数，如果初次遇到num，就把bitArr[num<em>2 + 1]和bitArr[num</em>2]设置为01，如果第二次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为10，如果第三次遇到num，就把bitArr[num<em>2+1]和bitArr[num</em>2]设置为11。以后再遇到num，发现此时bitArr[num<em>2+1]和bitArr[num</em>2]已经被设置为11，就不再做任何设置。遍历完成后，再依次遍历bitArr，如果发现bitArr[i<em>2+1]和bitArr[i</em>2]设置为10，那么i 就是出现了两次的数。</p><h3 id="4、重复URL（分机器）"><a href="#4、重复URL（分机器）" class="headerlink" title="4、重复URL（分机器）"></a><strong>4、重复URL</strong>（分机器）</h3><p><strong>找到100亿个URL中重复的URL</strong></p><p>​        原问题的解法使用解决大数据问题的一种常规方法：把大文件通过哈希函数分配到机器，或者通过哈希函数把大文件拆成小文件。一直进行这种划分，直到划分的结果满足资源限制的要求。首先，你要向面试官询问在资源上的限制有哪些，包括内存、计算时间等要求。在明确了限制要求之后，可以将每条URL通过哈希函数分配到若干机器或者拆分成若干小文件，这里的“若干”由具体的资源限制来计算出精确的数量。 </p><p>​        例如，将100亿字节的大文件通过哈希函数分配到100台机器上，然后每一台机器分别统计分给自己的URL中是否有重复的URL，<strong>同时哈希函数的性质决定了同一条URL不可能分给不同的机器；</strong>或者在单机上将大文件通过哈希函数拆成1000个小文件，对每一个小文件再利用哈希表遍历，找出重复的URL；或者在分给机器或拆完文件之后，进行排序，排序过后再看是否有重复的URL出现。总之，牢记一点，很多大数据问题都离不开分流，要么是哈希函数把大文件的内容分配给不同的机器，要么是哈希函数把大文件拆成小文件，然后处理每一个小数量的集合。</p><h3 id="5、TOPK搜索（小根堆）"><a href="#5、TOPK搜索（小根堆）" class="headerlink" title="5、TOPK搜索（小根堆）"></a><strong>5、TOPK搜索（小根堆）</strong></h3><p><strong>海量搜索词汇，找到最热TOP100词汇的方法</strong> </p><p>​        最开始还是用哈希分流的思路来处理，把包含百亿数据量的词汇文件分流到不同的机器上，具体多少台机器由面试官规定或者由更多的限制来决定。对每一台机器来说，如果分到的数据量依然很大，比如，内存不够或其他问题，可以再用哈希函数把每台机器的分流文件拆成更小的文件处理。</p><p>​        处理每一个小文件的时候，哈希表统计每种词及其词频，哈希表记录建立完成后，再遍历哈希表，遍历哈希表的过程中使用大小为100的小根堆来选出每一个小文件的top 100（整体未排序的top 100）。每一个小文件都有自己词频的小根堆（整体未排序的top 100），将小根堆里的词按照词频排序，就得到了每个小文件的排序后top 100。然后把各个小文件排序后的top 100进行外排序或者继续利用小根堆，就可以选出每台机器上的top 100。不同机器之间的top100再进行外排序或者继续利用小根堆，最终求出整个百亿数据量中的top 100。对于top K 的问题，除哈希函数分流和用哈希表做词频统计之外，还经常用堆结构和外排序的手段进行处理。</p><h3 id="6、中位数（单向二分查找）"><a href="#6、中位数（单向二分查找）" class="headerlink" title="6、中位数（单向二分查找）"></a><strong>6、中位数（单向二分查找）</strong></h3><p><strong>10MB内存，找到100亿整数的中位数</strong> </p><p>①内存够：内存够还慌什么啊，直接把100亿个全部排序了，你用冒泡都可以…然后找到中间那个就可以了。但是你以为面试官会给你内存？？ </p><p>②内存不够：题目说是整数，我们认为是带符号的int,所以4字节，占32位。 </p><p>  假设100亿个数字保存在一个大文件中，依次读一部分文件到内存(不超过内存的限制)，将每个数字用二进制表示，比较二进制的最高位(第32位，符号位，0是正，1是负)，如果数字的最高位为0，则将这个数字写入 file_0文件中；如果最高位为 1，则将该数字写入file_1文件中。 </p><p>  从而将100亿个数字分成了两个文件，假设 file_0文件中有 60亿 个数字，file_1文件中有 40亿 个数字。那么中位数就在 file_0 文件中，并且是 file_0 文件中所有数字排序之后的第 10亿 个数字。（file_1中的数都是负数，file_0中的数都是正数，也即这里一共只有40亿个负数，那么排序之后的第50亿个数一定位于file_0中） </p><p>  现在，我们只需要处理 file_0 文件了（不需要再考虑file_1文件）。对于 file_0 文件，同样采取上面的措施处理：将file_0文件依次读一部分到内存(不超内存限制)，将每个数字用二进制表示，比较二进制的 次高位（第31位），如果数字的次高位为0，写入file_0_0文件中；如果次高位为1，写入file_0_1文件 中。 </p><p>  现假设 file_0_0文件中有30亿个数字，file_0_1中也有30亿个数字，则中位数就是：file_0_0文件中的数字从小到大排序之后的第10亿个数字。 </p><p>  抛弃file_0_1文件，继续对 file_0_0文件 根据 次次高位(第30位) 划分，假设此次划分的两个文件为：file_0_0_0中有5亿个数字，file_0_0_1中有25亿个数字，那么中位数就是 file_0_0_1文件中的所有数字排序之后的 第 5亿 个数。 </p><p>  按照上述思路，直到划分的文件可直接加载进内存时，就可以直接对数字进行快速排序，找出中位数了。</p><h3 id="7、短域名系统（缓存）"><a href="#7、短域名系统（缓存）" class="headerlink" title="7、短域名系统（缓存）"></a><strong>7、短域名系统（缓存）</strong></h3><p><strong>设计短域名系统，将长URL转化成短的URL.</strong></p><p>（1）利用放号器，初始值为0，对于每一个短链接生成请求，都递增放号器的值，再将此值转换为62进制（a-zA-Z0-9），比如第一次请求时放号器的值为0，对应62进制为a，第二次请求时放号器的值为1，对应62进制为b，第10001次请求时放号器的值为10000，对应62进制为sBc。</p><p>（2）将短链接服务器域名与放号器的62进制值进行字符串连接，即为短链接的URL，比如：<a href="http://t.cn/sBc。" target="_blank" rel="noopener">t.cn/sBc。</a></p><p>（3）重定向过程：生成短链接之后，需要存储短链接到长链接的映射关系，即sBc -&gt; URL，浏览器访问短链接服务器时，根据URL Path取到原始的链接，然后进行302重定向。映射关系可使用K-V存储，比如Redis或Memcache。</p><h3 id="8、海量评论入库（消息队列）"><a href="#8、海量评论入库（消息队列）" class="headerlink" title="8、海量评论入库（消息队列）"></a><strong>8、海量评论入库（消息队列）</strong></h3><p><strong>假设有这么一个场景，有一条新闻，新闻的评论量可能很大，如何设计评论的读和写</strong></p><p>前端页面直接给用户展示、通过消息队列异步方式入库</p><p>读可以进行读写分离、同时热点评论定时加载到缓存</p><h3 id="9、在线-并发用户数（Redis）"><a href="#9、在线-并发用户数（Redis）" class="headerlink" title="9、在线/并发用户数（Redis）"></a><strong>9、在线/并发用户数（Redis）</strong></h3><p>​    <strong>显示网站的用户在线数的解决思路</strong></p><p>​        维护在线用户表</p><p>​        使用Redis统计</p><p><strong>显示网站并发用户数</strong></p><ol><li>每当用户访问服务时，把该用户的 ID 写入ZSORT队列，权重为当前时间</li><li>根据权重(即时间)计算一分钟内该机构的用户数Zrange</li><li>删掉一分钟以上过期的用户Zrem</li></ol><h3 id="10、热门字符串（前缀树）"><a href="#10、热门字符串（前缀树）" class="headerlink" title="10、热门字符串（前缀树）"></a>10、热门字符串（前缀树）</h3><p>假设目前有 1000w 个记录（这些查询串的重复度比较高，虽然总数是 1000w，但如果除去重复后，则不超过 300w 个）。请统计最热门的 10 个查询串，要求使用的内存不能超过 1G。（一个查询串的重复度越高，说明查询它的用户越多，也就越热门。）</p><p><strong>HashMap 法</strong></p><p>虽然字符串总数比较多，但去重后不超过 300w，因此，可以考虑把所有字符串及出现次数保存在一个 HashMap 中，所占用的空间为 300w*(255+4)≈777M（其中，4 表示整数占用的 4 个字节）。由此可见，1G 的内存空间完全够用。</p><p><strong>思路如下</strong>：</p><p>首先，遍历字符串，若不在 map 中，直接存入 map，value 记为 1；若在 map 中，则把对应的 value 加 1，这一步时间复杂度 <code>O(N)</code> 。</p><p>接着遍历 map，构建一个 10 个元素的小顶堆，若遍历到的字符串的出现次数大于堆顶字符串的出现次数，则进行替换，并将堆调整为小顶堆。</p><p>遍历结束后，堆中 10 个字符串就是出现次数最多的字符串。这一步时间复杂度 <code>O(Nlog10)</code> 。</p><p><strong>前缀树法</strong></p><p>当这些字符串有大量相同前缀时，可以考虑使用前缀树来统计字符串出现的次数，树的结点保存字符串出现次数，0 表示没有出现。</p><p><strong>思路如下</strong>：</p><p>在遍历字符串时，在前缀树中查找，如果找到，则把结点中保存的字符串次数加 1，否则为这个字符串构建新结点，构建完成后把叶子结点中字符串的出现次数置为 1。</p><p>最后依然使用<strong>小顶堆</strong>来对字符串的出现次数进行排序。</p><h3 id="11、红包算法"><a href="#11、红包算法" class="headerlink" title="11、红包算法"></a>11、红包算法</h3><p>线性切割法，一个区间切N-1刀。越早越多</p><p>二倍均值法，【0 ~ 剩余金额 / 剩余人数 * 2】中随机，相对均匀</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpbvl5pvj30qu0gcgm0.jpg" alt="img"></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goqpc3hz9dj31450ggq8k.jpg" alt="img"></p><h3 id="11、手写快排"><a href="#11、手写快排" class="headerlink" title="11、手写快排"></a>11、手写快排</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 常规快排 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L <span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">></span> R<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> M <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> M <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort1</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> M <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">></span> R<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> R<span class="token punctuation">)</span> <span class="token keyword">return</span> L<span class="token punctuation">;</span>        <span class="token keyword">int</span> lessEqual <span class="token operator">=</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> L<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token operator">++</span>lessEqual<span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token operator">++</span>lessEqual<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> lessEqual<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* 荷兰国旗 */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">></span> R<span class="token punctuation">)</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> equalArea <span class="token operator">=</span> <span class="token function">netherlandsFlag</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> equalArea<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> equalArea<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">netherlandsFlag</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">></span> R<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> R<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> L<span class="token punctuation">,</span> R <span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> less <span class="token operator">=</span> L <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> more <span class="token operator">=</span> R<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> L<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> more<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> arr<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>R<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token operator">++</span>less<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token operator">--</span>more<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> more<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> less <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> more <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// for test</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> testTime <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">10000000</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> succeed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> T1<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>T2<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> testTime<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token function">generateRandomArray</span><span class="token punctuation">(</span>maxSize<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2 <span class="token operator">=</span> <span class="token function">copyArray</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr3 <span class="token operator">=</span> <span class="token function">copyArray</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//            int[] arr1 = {9,8,7,6,5,4,3,2,1};</span>            <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort1</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr1<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> t2 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>arr2<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">long</span> t3 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            T1 <span class="token operator">+=</span> <span class="token punctuation">(</span>t2<span class="token operator">-</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>            T2 <span class="token operator">+=</span> <span class="token punctuation">(</span>t3<span class="token operator">-</span>t2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>arr1<span class="token punctuation">,</span> arr2<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">isEqual</span><span class="token punctuation">(</span>arr2<span class="token punctuation">,</span> arr3<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                succeed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>T1<span class="token operator">+</span><span class="token string">" "</span><span class="token operator">+</span>T2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//        System.out.println(succeed ? "Nice!" : "Oops!");</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">generateRandomArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> maxSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxSize <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                         <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>maxValue <span class="token operator">*</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null<span class="token punctuation">)</span>  <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">isEqual</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>arr1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>arr1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> arr2 <span class="token operator">==</span> null<span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">.</span>length <span class="token operator">!=</span> arr2<span class="token punctuation">.</span>length<span class="token punctuation">)</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> arr2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">printArray</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null<span class="token punctuation">)</span>             <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>             System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="12、手写归并"><a href="#12、手写归并" class="headerlink" title="12、手写归并"></a>12、手写归并</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> M<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> help <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>R <span class="token operator">-</span> L <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> p1 <span class="token operator">=</span> L<span class="token punctuation">;</span>    <span class="token keyword">int</span> p2 <span class="token operator">=</span> M <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> M <span class="token operator">&amp;&amp;</span> p2 <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>p2<span class="token punctuation">]</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p1 <span class="token operator">&lt;=</span> M<span class="token punctuation">)</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p1<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>p2 <span class="token operator">&lt;=</span> R<span class="token punctuation">)</span>        help<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>p2<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> help<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        arr<span class="token punctuation">[</span>L <span class="token operator">+</span> i<span class="token punctuation">]</span> <span class="token operator">=</span> help<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> L<span class="token punctuation">,</span> <span class="token keyword">int</span> R<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>L <span class="token operator">==</span> R<span class="token punctuation">)</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mid <span class="token operator">=</span> L <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>R <span class="token operator">-</span> L<span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">process</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> L<span class="token punctuation">,</span> mid<span class="token punctuation">,</span> R<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="13、手写堆排"><a href="#13、手写堆排" class="headerlink" title="13、手写堆排"></a>13、手写堆排</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 堆排序额外空间复杂度O(1)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr <span class="token operator">==</span> null <span class="token operator">||</span> arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>         <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> heapSize <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// O(N*logN)</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>heapSize <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// O(N)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// O(logN)</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">--</span>heapSize<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// O(1)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// arr[index]刚来的数，往上</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapInsert</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span><span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> index<span class="token punctuation">,</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> <span class="token punctuation">(</span>index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// arr[index]位置的数，能否往下移动</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token keyword">int</span> heapSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 左孩子的下标</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapSize<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 下方还有孩子的时候</span>        <span class="token comment" spellcheck="true">// 两个孩子中，谁的值大，把下标给largest</span>        <span class="token comment" spellcheck="true">// 1）只有左孩子，left -> largest</span>        <span class="token comment" spellcheck="true">// 2) 同时有左孩子和右孩子，右孩子的值&lt;= 左孩子的值，left -> largest</span>        <span class="token comment" spellcheck="true">// 3) 同时有左孩子和右孩子并且右孩子的值> 左孩子的值， right -> largest</span>        <span class="token keyword">int</span> largest <span class="token operator">=</span> left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">&lt;</span> heapSize <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">?</span> left<span class="token operator">+</span><span class="token number">1</span> <span class="token operator">:</span> left<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 父和较大的孩子之间，谁的值大，把下标给largest</span>        largest <span class="token operator">=</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">?</span> largest <span class="token operator">:</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">==</span> index<span class="token punctuation">)</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        index <span class="token operator">=</span> largest<span class="token punctuation">;</span>        left <span class="token operator">=</span> index <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">heapSort</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printArray</span><span class="token punctuation">(</span>arr1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="14、手写单例"><a href="#14、手写单例" class="headerlink" title="14、手写单例"></a>14、手写单例</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton singleton<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="15、手写LRUcache"><a href="#15、手写LRUcache" class="headerlink" title="15、手写LRUcache"></a>15、手写LRUcache</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 基于linkedHashMap</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> LinkedHashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> cache<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//容量大小</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//缓存中不存在此key，直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//先从链表中删除</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再把该节点放到链表末尾处</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已经存在，在当前链表移除</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>capacity <span class="token operator">==</span> cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//cache已满，删除链表头位置</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> keySet <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterator <span class="token operator">=</span> keySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//插入到链表末尾</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//手写双向链表</span><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">DNode</span> <span class="token punctuation">{</span>        DNode prev<span class="token punctuation">;</span>        DNode next<span class="token punctuation">;</span>        <span class="token keyword">int</span> val<span class="token punctuation">;</span>        <span class="token keyword">int</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> DNode<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    DNode head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>    <span class="token keyword">int</span> cap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        cap <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            DNode node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> node<span class="token punctuation">.</span>val<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            DNode node <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            node<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            DNode newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            newNode<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>            newNode<span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> cap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">removeNode</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>DNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DNode prevNode <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        DNode nextNode <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        prevNode<span class="token punctuation">.</span>next <span class="token operator">=</span> nextNode<span class="token punctuation">;</span>        nextNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> prevNode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span>DNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DNode firstNode <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> firstNode<span class="token punctuation">;</span>        firstNode<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="16、手写线程池"><a href="#16、手写线程池" class="headerlink" title="16、手写线程池"></a><strong>16、手写线程池</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>pool<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Set<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>BlockingQueue<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MySelfThreadPool</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//默认线程池中的线程的数量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> WORK_NUM <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//默认处理任务的数量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TASK_NUM <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> workNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//线程数量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务数量</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>WorkThread<span class="token operator">></span> workThreads<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//保存线程的集合</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> taskQueue<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//阻塞有序队列存放任务</span>    <span class="token keyword">public</span> <span class="token function">MySelfThreadPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>WORK_NUM<span class="token punctuation">,</span> TASK_NUM<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">MySelfThreadPool</span><span class="token punctuation">(</span><span class="token keyword">int</span> workNum<span class="token punctuation">,</span> <span class="token keyword">int</span> taskNum<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workNum <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> workNum <span class="token operator">=</span> WORK_NUM<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>taskNum <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> taskNum <span class="token operator">=</span> TASK_NUM<span class="token punctuation">;</span>        taskQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>taskNum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workNum <span class="token operator">=</span> workNum<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>taskNum <span class="token operator">=</span> taskNum<span class="token punctuation">;</span>        workThreads <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//启动一定数量的线程数，从队列中获取任务处理</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>workNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            WorkThread workThread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WorkThread</span><span class="token punctuation">(</span><span class="token string">"thead_"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            workThread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workThreads<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>workThread<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            taskQueue<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ready close thread pool..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workThreads <span class="token operator">==</span> null <span class="token operator">||</span> workThreads<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>WorkThread workThread <span class="token operator">:</span> workThreads<span class="token punctuation">)</span> <span class="token punctuation">{</span>            workThread<span class="token punctuation">.</span><span class="token function">stopWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            workThread <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//help gc</span>        <span class="token punctuation">}</span>        workThreads<span class="token punctuation">.</span><span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">WorkThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span><span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token function">WorkThread</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">setName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">interrupted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Runnable runnable <span class="token operator">=</span> taskQueue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取任务</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>runnable <span class="token operator">!=</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">" readyexecute:"</span><span class="token operator">+</span>runnable<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        runnable<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//执行任务</span>                    <span class="token punctuation">}</span>                    runnable <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//help gc</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">stopWork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">interrupt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">package</span> com<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>pool<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestMySelfThreadPool</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TASK_NUM <span class="token operator">=</span> <span class="token number">50</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//任务的个数</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        MySelfThreadPool myPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MySelfThreadPool</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>TASK_NUM<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            myPool<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">MyTask</span><span class="token punctuation">(</span><span class="token string">"task_"</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyTask</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> String name<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">MyTask</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// TODO Auto-generated catch block</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"task :"</span><span class="token operator">+</span>name<span class="token operator">+</span><span class="token string">" end..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// TODO Auto-generated method stub</span>            <span class="token keyword">return</span> <span class="token string">"name = "</span><span class="token operator">+</span>name<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="17、手写消费者生产者模式"><a href="#17、手写消费者生产者模式" class="headerlink" title="17、手写消费者生产者模式"></a><strong>17、手写消费者生产者模式</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Storage</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> MAX_VALUE <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Object<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> num <span class="token operator">></span> MAX_VALUE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"暂时不能执行生产任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已生产产品数"</span><span class="token operator">+</span>num<span class="token operator">+</span><span class="token string">" 仓库容量"</span><span class="token operator">+</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>list<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"暂时不能执行消费任务"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    list<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已消费产品数"</span><span class="token operator">+</span>num<span class="token operator">+</span><span class="token string">" 仓库容量"</span> <span class="token operator">+</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            list<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Producer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> Storage storage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Producer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        storage<span class="token punctuation">.</span><span class="token function">produce</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">private</span> Storage storage<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Customer</span><span class="token punctuation">(</span>Storage storage<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> storage<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNum</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">=</span> num<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        storage<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Storage storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer p3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Producer p4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Producer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Customer c1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Customer c2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        Customer c3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Customer</span><span class="token punctuation">(</span>storage<span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p3<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">80</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c3<span class="token punctuation">.</span><span class="token function">setNum</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        c3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        p3<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="18、手写阻塞队列"><a href="#18、手写阻塞队列" class="headerlink" title="18、手写阻塞队列"></a><strong>18、手写阻塞队列</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">blockQueue</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> container <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition isNull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition isFull <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">blockQueue</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">>=</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"阻塞队列满了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    isFull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                isFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token operator">++</span>size<span class="token punctuation">;</span>            container<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>            isNull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"阻塞队列空了"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    isNull<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                isNull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token keyword">int</span> res <span class="token operator">=</span> container<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            container<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            isFull<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    AxinBlockQueue queue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AxinBlockQueue</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            queue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"塞入"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread t2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"消费"</span><span class="token operator">+</span>queue<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">800</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    t2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="19、手写多线程交替打印ABC"><a href="#19、手写多线程交替打印ABC" class="headerlink" title="19、手写多线程交替打印ABC"></a><strong>19、手写多线程交替打印ABC</strong></h3><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>demo<span class="token punctuation">.</span>test<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>Condition<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span>ReentrantLock<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">syncPrinter</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 打印次数</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> PRINT_COUNT <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> ReentrantLock reentrantLock<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition thisCondtion<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition nextCondtion<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">char</span> printChar<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">syncPrinter</span><span class="token punctuation">(</span>ReentrantLock reentrantLock<span class="token punctuation">,</span> Condition thisCondtion<span class="token punctuation">,</span> Condition nextCondition<span class="token punctuation">,</span> <span class="token keyword">char</span> printChar<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>reentrantLock <span class="token operator">=</span> reentrantLock<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextCondtion <span class="token operator">=</span> nextCondition<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>thisCondtion <span class="token operator">=</span> thisCondtion<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>printChar <span class="token operator">=</span> printChar<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取打印锁 进入临界区</span>        reentrantLock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 连续打印PRINT_COUNT次</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> PRINT_COUNT<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//打印字符</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>printChar<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 使用nextCondition唤醒下一个线程</span>                <span class="token comment" spellcheck="true">// 因为只有一个线程在等待，所以signal或者signalAll都可以</span>                nextCondtion<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 不是最后一次则通过thisCondtion等待被唤醒</span>                <span class="token comment" spellcheck="true">// 必须要加判断，不然虽然能够打印10次，但10次后就会直接死锁</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> PRINT_COUNT <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 本线程让出锁并等待唤醒</span>                        thisCondtion<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            reentrantLock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        ReentrantLock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Condition conditionA <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Condition conditionB <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Condition conditionC <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread printA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">syncPrinter</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> conditionA<span class="token punctuation">,</span> conditionB<span class="token punctuation">,</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread printB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">syncPrinter</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> conditionB<span class="token punctuation">,</span> conditionC<span class="token punctuation">,</span><span class="token string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread printC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">syncPrinter</span><span class="token punctuation">(</span>lock<span class="token punctuation">,</span> conditionC<span class="token punctuation">,</span> conditionA<span class="token punctuation">,</span><span class="token string">'C'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printA<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printB<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        printC<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="20、交替打印FooBar"><a href="#20、交替打印FooBar" class="headerlink" title="20、交替打印FooBar"></a>20、交替打印FooBar</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//手太阴肺经 BLOCKING Queue</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FooBar</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> BlockingQueue<span class="token operator">&lt;</span>Integer<span class="token operator">></span> foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            foo<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bar<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bar<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            foo<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//手阳明大肠经CyclicBarrier 控制先后</span><span class="token keyword">class</span> <span class="token class-name">FooBar6</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar6</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    CyclicBarrier cb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CyclicBarrier</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>fin<span class="token punctuation">)</span><span class="token punctuation">;</span>            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fin <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                cb<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BrokenBarrierException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            fin <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//手少阴心经 自旋 + 让出CPU</span><span class="token keyword">class</span> <span class="token class-name">FooBar5</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar5</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>             <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                permitFoo <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>               <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>permitFoo<span class="token punctuation">)</span> <span class="token punctuation">{</span>            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>            permitFoo <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                Thread<span class="token punctuation">.</span><span class="token function">yield</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//手少阳三焦经 可重入锁 + Condition</span><span class="token keyword">class</span> <span class="token class-name">FooBar4</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar4</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Lock lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReentrantLock</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Condition foo <span class="token operator">=</span> lock<span class="token punctuation">.</span><span class="token function">newCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    foo<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                foo<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    foo<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                foo<span class="token punctuation">.</span><span class="token function">signal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">finally</span> <span class="token punctuation">{</span>                lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//手厥阴心包经 synchronized + 标志位 + 唤醒</span><span class="token keyword">class</span> <span class="token class-name">FooBar3</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 标志位，控制执行顺序，true执行printFoo，false执行printBar</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">boolean</span> type <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> Object foo<span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 锁标志</span>    <span class="token keyword">public</span> <span class="token function">FooBar3</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>                    foo<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                type <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                foo<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>type<span class="token punctuation">)</span><span class="token punctuation">{</span>                    foo<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                type <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                foo<span class="token punctuation">.</span><span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//手太阳小肠经 信号量 适合控制顺序</span><span class="token keyword">class</span> <span class="token class-name">FooBar2</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span>    <span class="token keyword">private</span> Semaphore foo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Semaphore bar <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Semaphore</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">FooBar2</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>n <span class="token operator">=</span> n<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">foo</span><span class="token punctuation">(</span>Runnable printFoo<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            foo<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printFoo<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            bar<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">bar</span><span class="token punctuation">(</span>Runnable printBar<span class="token punctuation">)</span> <span class="token keyword">throws</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bar<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            printBar<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            foo<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h1 id="六、个人项目"><a href="#六、个人项目" class="headerlink" title="六、个人项目"></a><strong>六、个人项目</strong></h1><h2 id="一、一站到底"><a href="#一、一站到底" class="headerlink" title="一、一站到底"></a><strong>一、一站到底</strong></h2><p>​    采用SpringBoot构建项目，主要通过分布式缓存、队列、限流保证系统高可用，Netty、缓存、反向代理保证高并发。</p><blockquote><p>双人对战答题、公司对战抢答</p></blockquote><h3 id="1、如何设计排行榜"><a href="#1、如何设计排行榜" class="headerlink" title="1、如何设计排行榜"></a>1、如何设计排行榜</h3><ul><li>个人总得分和总排名实时更新</li><li>个人排行榜按分数、时间、次数、正确率展示</li><li>日榜、过去N日榜滚动更新</li></ul><h4 id="性能优化过程"><a href="#性能优化过程" class="headerlink" title="性能优化过程"></a>性能优化过程</h4><p>​    第一条需求很简单，使用了Redis的<strong>Zset</strong>实现不过这里总得分采用了基于<strong>分数、时间、次数和正确率</strong>的混合加权。考虑到数据的<strong>持久化</strong>，以及<strong>关系数据库和缓存的一致性</strong>导致的设计的复杂性，使用了<strong>谷歌</strong>开源的<strong>JamsRanking</strong></p><p>​    优点<strong>是可以直接使用现成的setScores和getRanking接口封装了Redis和Mysql和消息队列的完成</strong>事务和一致性<strong>的使用细节。缺点是</strong>并发比较低<strong>使用Jmeter进行压测，单机只有</strong>20<strong>左右的</strong>TPS**</p><p>​    后来看了下源码，主要是它针对每一次设置都进行了分布式事务处理，并且会返回事务提交或回滚的结果。了解了底层实现以后就去谷歌的<strong>开源社区</strong>去查阅了相关的解决方案，当时官方对这个问题并没有通过<strong>配置能直接解决问题</strong>的快捷方式，不过推荐了使用者自身如果对响应时间不高的场景下可以采用<strong>批量合并事务</strong>的方式进行优化。基于这个思路，我们把写操作进行了封装并放入了<strong>队列</strong>，然后在消费者端批量取得数据后进行事务的批量处理，压测环境下整体性能达到了<strong>500TPS</strong>。已经基本满足了线上更新的需求，但是当时压测的过程中，队列偶尔的吞吐量会<strong>大范围波动</strong>，经常会持续数十秒，然后业务一次性处理完再响应，导致<strong>局部响应时间大幅度增长</strong></p><p>​    后来也是在官网上查询，了解到谷歌开源组件使用的<strong>队列服务</strong>底层是使用<strong>BigTable</strong>作为持久层，但是当BigTable分片过大时，会触发<strong>再分片</strong>的过程，再分片的过程中，是<strong>不会进行任务分发</strong>的，所以就会导致先前的问题。针对这个问题，谷歌官方的建议是提前<strong>配置队列的数量、负载策略和最大容量</strong>等信息，保证所有队列<strong>不同时触发</strong>再分片</p><p>​    进行两次优化后，压测环境已经基本可以满足预期了，在实际生产环境的部署中，发现对于事务更新失败时，JamsRanking会对失败的事务进行<strong>切分和重试</strong>，整个过程对于研发人员是<strong>透明</strong>的，不利于线上问题排查，所以我们当时特地写了一个watchdog的工具，监控事务回滚达到十次以上的事务，查明原因后通过后台管理系统进行相应补偿，保证<strong>最终一致性</strong></p><p><strong>最终结果：</strong></p><ul><li>高效快速：能在数百毫秒内找到玩家排名以及进行更新</li><li>强一致性以及持久化、排名准确</li><li><p>可以扩展到任意数量的玩家</p></li><li><p>吞吐量有限制，只能支持约每秒 500次更新。</p></li></ul><p>针对这个缺点谷歌官方也是给出了使用分片树和近似排名的解决方案，当然复杂的方案有更高的运维成本，所以我们优化工作也就到此为止</p><h4 id="方案优化过程"><a href="#方案优化过程" class="headerlink" title="方案优化过程"></a>方案优化过程</h4><h4 id="方案1：每日一个滚动榜，当日汇聚（费时间）"><a href="#方案1：每日一个滚动榜，当日汇聚（费时间）" class="headerlink" title="方案1：每日一个滚动榜，当日汇聚（费时间）"></a>方案1：每日一个滚动榜，当日汇聚（费时间）</h4><p>​    首先记录每天的排行榜和一个滚动榜，加分时同时写入这两个榜单，每日零点后跑工具将前几天数据累加写入当日滚动榜，该方案缺点是时间复杂度高，7天榜还好，只需要读过去6天数据，如果是100天榜，该方案需要读过去99天榜，显然不可接受</p><h4 id="方案2：全局N个滚动榜同时写（费空间）"><a href="#方案2：全局N个滚动榜同时写（费空间）" class="headerlink" title="方案2：全局N个滚动榜同时写（费空间）"></a>方案2：全局N个滚动榜同时写（费空间）</h4><p>​    要做到每日零点后榜单实时生效，而不需要等待离线作业的完成，一种方案是预写未来的榜单。可以写当天的滚动榜的同时，写往后N-1天的滚动榜一起写入该方案不仅能脱离离线作业做到实时更新，且可以省略每天的日榜。但缺点也不难看出，对于7天滚动榜，每次写操作需要更新7个榜单，但是对于百日榜，空间消耗无法接受，1000万榜单大约消耗1G内存</p><h4 id="方案3：实时更新，常数次写操作"><a href="#方案3：实时更新，常数次写操作" class="headerlink" title="方案3：实时更新，常数次写操作"></a>方案3：实时更新，常数次写操作</h4><p>有不有办法做到既能实时更新，写榜数量也不随N的增加而增加呢？</p><p>​    仍然是记录每天的排行榜和一个滚动榜，加分操作也还是同时操作当日榜和全局榜，但每日零点的离线作业改为从全局榜中减去之前过期的数据，从而实现先滚动更新。  此方案每次只需读取一个日榜做减法，时间复杂度为O(1)；但是无法做到实时更新。 这个方案的优点是在十二点前提前准备好差分榜，到了十二点直接加上当天数据就是滚动榜内容 ，这样就在常数次写操作的前提下，实现了滚动榜的实时更新</p><h3 id="2、如何解决重复答题"><a href="#2、如何解决重复答题" class="headerlink" title="2、如何解决重复答题"></a>2、<strong>如何解决重复答题</strong></h3><p>​    <strong>利用setnx防止重复答题</strong><br>​    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取锁推荐使用set的方式</span>String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token string">"NX"</span><span class="token punctuation">,</span> <span class="token string">"EX"</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 推荐使用redis+lua脚本</span>String lua <span class="token operator">=</span> <span class="token string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>Object result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>lua<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span></code></pre><h3 id="3、一个题目被多个人抢答"><a href="#3、一个题目被多个人抢答" class="headerlink" title="3、一个题目被多个人抢答"></a><strong>3、一个题目被多个人抢答</strong></h3><p>​    <strong>利用redis来实现乐观锁（抢答）</strong>，好处是答错的人不影响状态，第一个秒杀答对的人才能得分。</p><p>1、利用redis的watch功能，监控这个 Corp:Activ:Qust: 的状态值<br>2、获取Corp:Activ:Qust: 的值，创建redis事务，给这个key的值-1<br>3、执行这个事务，如果key的值被修改过则回滚，key不变</p><h3 id="4、如何管理昵称重复"><a href="#4、如何管理昵称重复" class="headerlink" title="4、如何管理昵称重复"></a><strong>4、如何管理昵称重复</strong></h3><p>​    <strong>使用布隆过滤器：</strong></p><p>​    它实际上是一个很长的二进制矢量数组和 K 个哈希函数。当一个昵称加入布隆过滤器中的时候，会进行如下操作：</p><ul><li>使用 K 个哈希函数对元素值进行 K 次计算，得到 K 个哈希值。</li><li>根据得到的哈希值，在位数组中把对应下标的值置为 1。 Na</li></ul><p>​    用户新增昵称时需要首先计算K个哈希值，如果K个哈希值有一个不为0则通过，否则不通过，不通过时通过加随机字符串再次检验，检测通过后返回给前端，帮助用户自动填写。</p><p>​    布隆过滤器的好处是它<strong>可以用来判断一个元素是否在一个集合中</strong>。它的优势是只需要占用很小的内存空间以及有着高效的查询效率。对于布隆过滤器而言，它的本质是一个<strong>位数组</strong>：位数组就是数组的每个元素都只占用 1 bit ，并且每个元素只能是 0 或者 1。</p><p>BloomFilter 的优势是，全内存操作，性能很高。另外空间效率非常高，<strong>要达到 1% 的误判率，平均单条记录占用 1.2 字节即可。而且，平均单条记录每增加 0.6 字节，还可让误判率继续变为之前的 1/10，即平均单条记录占用 1.8 字节，误判率可以达到 1/1000；平均单条记录占用 2.4 字节，误判率可以到 1/10000，以此类推</strong>。这里的误判率是指，BloomFilter 判断某个 key 存在，但它实际不存在的概率，因为它存的是 key 的 Hash 值，而非 key 的值，所以有概率存在这样的 key，它们内容不同，但多次 Hash 后的 Hash 值都相同。对于 BloomFilter 判断不存在的 key ，则是 100% 不存在的，反证法，如果这个 key 存在，那它每次 Hash 后对应的 Hash 值位置肯定是 1，而不会是 0</p><p>​        </p><h3 id="5、如何管理出题定时任务"><a href="#5、如何管理出题定时任务" class="headerlink" title="5、如何管理出题定时任务"></a><strong>5、如何管理出题定时任务</strong></h3><p>​    压测环境中服务器通过Netty的主从Reactor多路复用NIO事件模型，单机可以<strong>轻松应对十万长连接</strong>，但是每个业务中，由于每个用户登录系统后需要按照指定顺序答题，例如一共要答十道，那么服务器针对这一个用户就会产生十个定时任务，所以对于系统来说，定时器的<strong>数量就是百万级别的</strong>。</p><p>​    通过压测结果发现：JDK自带的Timer，在大概三万并发时性能就急剧下降了。也是此时根据业务场景的需要，将定时任务改成了Netty自带的HashedWheelTimer时间轮方案，通过压测单机在50万级别下依然能够平滑的执行。</p><p>​    也是这个强烈的反差，使我在强烈的好奇心促使下，阅读源码了解到常规的JDK 的Timer 和 DelayedQueue 等工具类，可实现简单的定时任务，单底层用的是<strong>堆数据结构</strong>，存取复杂度都是 <strong>O(NlogN)</strong>，无法支撑海量定时任务。<strong>Netty经典的时间轮方案</strong>，正是通过将任务存取及取消操作时间复杂度降为 O(1)，而广泛应用在定时<strong>任务量大、性能要求高</strong>的场景中。</p><p>​    <img src="https://tva1.sinaimg.cn/large/0081Kckwly1glvl9c3hp2j30py0d7q4i.jpg" alt="img" style="zoom:50%;"></p><p>​    基于Netty的Websocket底层，服务器端维护一个高效批量管理定时任务的调度模型。时间轮一般会实现成一个<strong>环形数组结构</strong>，类似一个时钟，分为很多槽，一个槽代表一个时间间隔，每个槽使用<strong>双向链表</strong>存储定时任务。指针<strong>周期性地跳动</strong>，跳动到一个槽位，就执行该槽位的定时任务。</p><p>​    单层时间轮的容量和精度都是有限的，对于精度要求特别高、时间跨度特别大或是海量定时任务需要调度的场景，可以考虑使用多级时间轮以及持久化存储与时间轮结合的方案。时间轮的<strong>定时任务处理逻辑</strong>如下：</p><ol><li>将缓存在 timeouts 队列中的定时任务转移到时间轮中对应的槽中</li><li>根据当前指针定位对应槽，处理该槽位的双向链表中的定时任务，从链表头部开始迭代：<ul><li>属于当前时钟周期则取出运行</li><li>不属于则将其剩余的时钟周期数减一</li></ul></li><li>检测时间轮的状态。如果时间轮处于运行状态，则循环执行上述步骤，不断执行定时任务。</li></ol><h3 id="6：如何解决客户端断连"><a href="#6：如何解决客户端断连" class="headerlink" title="6：如何解决客户端断连"></a><strong>6：如何解决客户端断连</strong></h3><p>​    使用Netty的<strong>重连检测狗</strong>ConnectionWatchdog</p><p>​    服务端定义refreshTime，当我们从channel中read到了服务端发来的心跳响应消息的话，就刷新refreshTime为当前时间</p><p>​    客户端在state是WRITER_IDLE的时候每隔一秒就发送一个心跳包到sever端，告诉server端我还活着。</p><p>当重连成功时，会触发channelActive方法，在这里我们开启了一个定时任务去判断refreshTime和当前时间的时间差，超过5秒说明断线了，要进行重连，最后计算重连次数，尝试连接2次以上连不上就会修改header信息强制重连去连另一个服务器。</p><h2 id="二、秒杀项目"><a href="#二、秒杀项目" class="headerlink" title="二、秒杀项目"></a>二、秒杀项目</h2><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a><strong>技术选型</strong></h3><p>秒杀用到的基础组件，主要有<strong>框架、KV 存储、关系型数据库、MQ</strong>。</p><p>框架主要有 Web 框架和 RPC 框架。</p><p>其中，Web 框架主要用于提供 HTTP 接口给浏览器访问，所以 Web 框架的选型在秒杀服务中非常重要。在这里，我<strong>推荐Gin</strong>，它的性能和易用性都不错，在 <strong>GitHub 上的 Star 达到了 44k</strong>。对比性能最好的 fasthttp，虽然 fasthttp 在请求延迟低于 10ms 时性能优势明显，但其底层使用的对象池容易让人踩坑，导致其易用性较差，所以没必要过于追求性能而忽略了稳定性</p><p>至于 RPC 框架，我推荐选用 <strong>gRPC</strong>，因为它的扩展性和性能都非常不错。在秒杀系统中，Redis 中的数据主要是给秒杀接口服务使用，以便将配置从管理后台同步到 Redis 缓存中。</p><p>KV 存储方面，秒杀系统中主要是用 <strong>Redis 缓存活动配置</strong>，用 <strong>etcd 存储集群信息</strong>。</p><p>关系型数据库中，<strong>MySQL</strong> 技术成熟且稳定可靠，秒杀系统用它存储活动配置数据很合适。主要 原因还是秒杀活动信息和库存数据都缓存在 Redis 中，活动过程中秒杀服务不操作数据库， 使用 MySQL 完全能够满足需求。</p><p>MQ 有很多种，其中 <strong>Kafka</strong> 在业界认可度最高，技术也非常成熟，性能很不错，非常适合用在秒杀系统中。Kafka 支持自动创建队列，秒杀服务各个节点可以用它自动创建属于自己的队列</p><h3 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h3><p><strong>背景</strong></p><ul><li>秒杀业务简单，每个秒杀活动的商品是事先定义好的，商品有明确的类型和数量，卖完即止</li><li><p>秒杀活动定时上架，消费者可以在活动开始后，通过秒杀入口进行抢购秒杀活动</p></li><li><p>秒杀活动由于商品物美价廉，开始售卖后，会被快速抢购一空。</p></li></ul><p><strong>现象</strong></p><ul><li><p>秒杀活动持续时间短，访问冲击量大，秒杀系统需要应对这种爆发性的访问模型</p></li><li><p>业务的请求量远远大于售卖量，大部分是陪跑的请求，秒杀系统需要提前规划好处理策略</p></li><li><p>前端访问量巨大，系统对后端数据的访问量也会短时间爆增，对数据存储资源进行良好设计</p></li><li><p>活动期间会给整个业务系统带来超大负荷，需要制定各种策略，避免系统过载而宕机</p></li><li><p>售卖活动商品价格低廉，存在套利空间，各种非法作弊手段层出，需要提前规划预防策略</p></li></ul><p><strong>秒杀系统设计</strong></p><p>​    首先，要<strong>尽力将请求拦截在系统上游</strong>，层层设阻拦截，过滤掉无效或超量的请求。因为访问量远远大于商品数量，所有的请求打到后端服务的最后一步，其实并没有必要，反而会严重拖慢真正能成交的请求，降低用户体验。</p><p>​    秒杀系统专为秒杀活动服务，售卖商品确定，因此可以在设计秒杀商品页面时，将商品信息提前设计为静态信息，将静态的商品信息以及常规的 CSS、JS、宣传图片等静态资源，一起<strong>独立存放到 CDN 节点</strong>，加速访问，且降低系统访问压力，在访问前端也可以<strong>制定种种限制策略，</strong>比如活动没开始时，抢购按钮置灰，避免抢先访问，用户抢购一次后，也将按钮置灰，让用户排队等待，避免反复刷新。</p><p>​    其次，要<strong>充分利用缓存</strong>，提升系统的性能和可用性。</p><p>​    用户所有的请求进入秒杀系统前，通过<strong>负载均衡策略</strong>均匀分发到不同 Web 服务器，避免节点过载。在 Web 服务器中，首先检查用户的访问权限，识别并发刷订单的行为。如果发现售出数量已经达到秒杀数量，则直接返回结束，要将秒杀业务系统和其他业务系统进行功能分拆，尽量将秒杀系统及依赖服务<strong>独立分拆部署</strong>，避免影响其他核心业务系统。</p><p>​    秒杀系统需要构建访问记录缓存，记录访问 IP、用户的访问行为，发现异常访问，提前进行阻断及返回。同时还需要<strong>构建用户缓存</strong>，并针对历史数据分析，提前缓存僵尸强刷专业户，方便在秒杀期间对其进行策略限制。这些访问记录、用户数据，通过缓存进行存储，可以加速访问，另外，对用户数据还进行缓存预热，避免活动期间大量穿透。</p><h3 id="1、如何解决超卖？"><a href="#1、如何解决超卖？" class="headerlink" title="1、如何解决超卖？"></a><strong>1、如何解决超卖？</strong></h3><p>mysql乐观锁+redis预减库存+redis缓存卖完标记 </p><p>第一是基于<strong>数据库乐观锁</strong>的方式保证数据并发扣减的强一致性；</p><p>第二是基于<strong>数据库的事务</strong>实现批量扣减部分失败时的数据回滚。</p><p>​    在扣减指定数量前应先做一次前置数量校验的读请求（参考<strong>读写分离</strong> + <strong>全缓存方案</strong>）</p><blockquote><p>纯数据库乐观锁+事务的方式性能比较差，但是如果不计成本和考虑场景的话也完全够用，因为任何没有机器配置的指标，都是耍流氓。如果我采用 Oracle 的数据库、100 多核的刀锋服务器、SSD 的硬盘，即使是纯数据库的扣减方案，也是可以达到单机上万的 TPS 的。</p></blockquote><p><strong>单线程Redis 的 lua 脚本实现批量扣减</strong></p><p>当用户调用扣减接口时，将扣减的 对应数量 + 脚本标示传递至 Redis 即可，所有的扣减判断逻辑均在 Redis 中的 lua 脚本中执行，lua 脚本执行完成之后返还是否成功给客户端。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6j9dkq6vj30w20kowku.jpg" alt="image-20210504174103769" style="zoom:50%;"></p><p>Redis 中的 lua 脚本执行时，首先会使用 get 命令查询 uuid 进行查重。当防重通过后，会<strong>批量获取对应的剩余库存状态并进行判断</strong>，如果一个扣减的数量大于剩余数量，则返回错误并提示数量不足。</p><p>Redis 的单线程模型，确保<strong>不会出现当所有扣减数量在判断均满足后，在实际扣减时却数量不够</strong>。同时，单线程保证判断数量的步骤和后续扣减步骤之间，没有其他任何线程出现并发的执行。</p><p>当 Redis 扣减成功后，扣减接口会<strong>异步的将此次扣减内容保存至数据库</strong>。异步保存数据库的目的是防止出现极端情况—— Redis 宕机后数据未持久化到磁盘，此时我们可以使用数据库恢复或者校准数据</p><p>最后，运营后台直连数据库，是运营和商家修改库存的入口。商家在运营后台进货物进行补充。同时，运营后台的实现需要将此数量<strong>同步的增加至 Redis</strong>，因为当前方案的所有实际扣减都在 Redis 中</p><blockquote><p>纯缓存方案虽<strong>不会导致超卖</strong>，但因<strong>缓存不具备事务特性</strong>，极端情况下会存在缓存里的数据<strong>无法回滚</strong>，导致出现<strong>少卖</strong>的情况。且架构中的异步写库，也可能发生失败，导致多扣的数据丢失</p></blockquote><p>可以借助<strong>顺序写</strong>的特性，将扣减任务同步<strong>插入</strong>任务表，发现异常时，将任务表作为<strong>undolog</strong>进行回滚</p><p>可以解决由于<strong>网络不通</strong>、调用缓存<strong>扣减超时</strong>、在扣减到一半时缓存<strong>突然宕机</strong>（故障 failover）了。针对上述请求，都有相应的异常抛出，根据异常进行<strong>数据库回滚</strong>即可，最终任务库里的数据都是准的</p><p>更进一步：由于任务库是无状态的，可以进行水平分库，提升整体性能</p><h3 id="2、如何解决重复下单？"><a href="#2、如何解决重复下单？" class="headerlink" title="2、如何解决重复下单？"></a><strong>2、如何解决重复下单？</strong></h3><p>mysql唯一索引+分布式锁 </p><h3 id="3、如何防刷？"><a href="#3、如何防刷？" class="headerlink" title="3、如何防刷？"></a><strong>3、如何防刷？</strong></h3><p>IP限流 | 验证码 | 单用户 | 单设备 | IMEI | 源IP |均设置规则</p><h3 id="4、热key问题如何解决？"><a href="#4、热key问题如何解决？" class="headerlink" title="4、热key问题如何解决？"></a><strong>4、热key问题如何解决？</strong></h3><p>redis集群+本地缓存+限流+key加随机值分布在多个实例中 </p><p>1、<strong>缓存集群</strong>可以单节点进行<strong>主从复制和垂直扩容</strong></p><p>2、利用应用内的<strong>前置缓存</strong>，但是需注意需要设置上限</p><p>3、延迟不敏感，<strong>定时刷新</strong>，实时感知用主动刷新</p><p>4、和缓存穿透一样，限制逃逸流量，单请求进行数据<strong>回源并刷新前置</strong></p><p>5、无论如何设计，最后都要写一个<strong>兜底逻辑</strong>，千万级流量说来就来</p><h3 id="5、应对高并发的读请求"><a href="#5、应对高并发的读请求" class="headerlink" title="5、应对高并发的读请求"></a><strong>5、应对高并发的读请求</strong></h3><p>使用缓存策略将请求挡在上层中的缓存中</p><p>使用CDN，能静态化的数据尽量做到静态化，</p><p>加入限流（比如对短时间之内来自某一个用户，某一个IP、某个设备的重复请求做丢弃处理）</p><p><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。</p><ul><li><p>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</p></li><li><p>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</p></li><li><p>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</p></li><li><p>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</p><p>流量控制效果从好到差依次是：<strong>漏桶限流 &gt; 令牌桶限流 &gt; 滑动窗口限流 &gt; 计数器限流</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6ja736ekj316o06640u.jpg" alt="image-20210504174148831" style="zoom:50%;"></p><p>其中，只有漏桶算法<strong>真正实现了恒定速度处理请求</strong>，能够绝对<strong>防止突发流量超过下游系统承载能力</strong>。<br>不过，漏桶限流也有个不足，就是需要分<strong>配内存资源缓存请求</strong>，这会增加内存的使用率。而<strong>令牌桶限流</strong>算法中的“桶”可以用一个整数表示，<strong>资源占用相对较小</strong>，这也让它成为最常用的限流算法。正是因为这些特点，<strong>漏桶限流和令牌桶限流</strong>经常在一些大流量系统中结合使用。</p></li></ul><h3 id="6、应对高并发的写请求"><a href="#6、应对高并发的写请求" class="headerlink" title="6、应对高并发的写请求"></a><strong>6、应对高并发的写请求</strong></h3><ul><li><p><strong>削峰</strong>：恶意用户拦截</p><p>对于单用户多次点击、单设备、IMEI、源IP均设置规则</p></li><li><p>采用比较成熟的<strong>漏桶算法、令牌桶</strong>算法，也可以使用<strong>guava</strong>开箱即用的限流算法</p><p>可以集群限流，但单机限流更加简洁和稳定</p></li><li><p>当前层<strong>直接过滤</strong>一定比例的请求，最大承载值前需要加上<strong>兜底逻辑</strong></p></li><li><p>对于已经无货的产品，<strong>本地缓存</strong>直接返回</p></li><li><p><strong>单独部署，减少对系统正常服务的影响，方便扩缩容</strong></p></li></ul><p>对于<strong>一段时间内的秒杀活动，需要保证写成功</strong>，我们可以使用 <strong>消息队列</strong>。</p><ul><li>削去秒杀场景下的峰值写流量——<strong>流量削峰</strong></li><li>通过异步处理简化秒杀请求中的业务流程——<strong>异步处理</strong></li><li>解耦，实现秒杀系统模块之间松耦合——<strong>解耦</strong></li></ul><p><strong>削去秒杀场景下的峰值写流量</strong></p><ul><li><strong>将秒杀请求暂存于消息队列</strong>，业务服务器响应用户“秒杀结果正在处理中。。。”，释放系统资源去处理其它用户的请求。</li><li><strong>削峰填谷</strong>，削平短暂的流量高峰，消息堆积会造成请求延迟处理，但秒杀用户对于短暂延迟有一定容忍度。秒杀商品有 1000 件，处理一次购买请求的时间是 500ms，那么总共就需要 500s 的时间。这时你部署 10 个队列处理程序，那么秒杀请求的处理时间就是 50s，也就是说用户需要等待 50s 才可以看到秒杀的结果，这是可以接受的。这时会<strong>并发 10 个</strong>请求到达数据库，并不会对数据库造成很大的压力。</li></ul><p><strong>通过异步处理简化秒杀请求中的业务流程</strong></p><p>​    先处理主要的业务，异步处理次要的业务。</p><ul><li>如主要流程是<strong>生成订单</strong>、<strong>扣减库存</strong>；</li><li>次要流程比如购买成功之后会给用户<strong>发优惠券</strong>，<strong>增加用户的积**</strong>分**。</li><li>此时秒杀只要处理生成订单，扣减库存的耗时，发放优惠券、增加用户积分异步去处理了。</li></ul><p><strong>解耦</strong></p><p>​    实现秒杀系统模块之间松耦合将秒杀数据同步给数据团队，有两种思路：</p><ul><li>使用 HTTP 或者 RPC 同步调用，即提供一个接口，实时将数据推送给数据服务。<strong>系统的耦合度高</strong>，如果其中一个服务有问题，可能会导致另一个服务不可用。</li><li>使用消息队列<strong>将数据全部发送给消息队列</strong>，然后<strong>数据服务订阅这个消息队列</strong>，接收数据进行处理。</li></ul><h3 id="7、如何保证数据一致性"><a href="#7、如何保证数据一致性" class="headerlink" title="7、如何保证数据一致性"></a><strong>7、如何保证数据一致性</strong></h3><p><strong>CacheAside旁路缓存</strong>读请求不命中查询数据库，查询完成写入缓存，写请求更新数据库后删除缓存数据。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span>Object data<span class="token punctuation">)</span><span class="token punctuation">{</span>    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>为防缓存失效这一信息丢失，可用消息队列确保。</p><ul><li>更新数据库数据；</li><li>数据库会将操作信息写入binlog日志当中；</li><li>另起一段非业务代码，程序订阅提取出所需要的数据以及key；</li><li>尝试删除缓存操作，若删除失败，将这些信息发送至消息队列；</li><li>重新从消息队列中获得该数据，重试操作；</li></ul><p>订阅<strong>binlog程序在mysql中有现成的中间</strong>件叫canal，重试机制，主要采用的是消息队列的方式。</p><p><strong>终极方案：请求串行化</strong></p><p>真正靠谱非秒杀的方案：将访问操作串行化</p><ol><li>先删缓存，将更新数据库的<strong>写操作放进有序队列中</strong></li><li>从缓存查不到的<strong>读操作也进入有序队列</strong></li></ol><p>需要解决的问题：</p><ol><li>读请求积压，大量超时，导致数据库的压力：限流、熔断</li><li>如何避免大量请求积压：将队列水平拆分，提高并行度。</li></ol><h3 id="8、可靠性如何保障"><a href="#8、可靠性如何保障" class="headerlink" title="8、可靠性如何保障**"></a>8、可靠性如何保障**</h3><p>​    由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;"></p><p>​    当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。 </p><h3 id="9、秒杀系统瓶颈-日志"><a href="#9、秒杀系统瓶颈-日志" class="headerlink" title="9、秒杀系统瓶颈-日志"></a>9、秒杀系统瓶颈-日志</h3><blockquote><p>秒杀服务单节点需要处理的请求 QPS 可能达到 10 万以上。一个请求从进入秒杀服务到处理失败或者成功，至少会产生两条日志。也就是说，高峰期间，一个秒杀节点每秒产生的日志可能达到 <strong>30 万条</strong>以上</p></blockquote><p>​    一块性能比较好的固态硬盘，每秒写的IOPS 大概在 3 万左右。也就是说，一个秒杀节点的每秒日志条数是固态硬盘 IOPS 的 10 倍，磁盘都扛不住，更别说通过网络写入到监控系统中。</p><ul><li><strong>每秒日志量远高于磁盘 IOPS</strong>，直接写磁盘会影响服务性能和稳定性</li><li>大量日志导致服务频繁分配，<strong>频繁释放内存，影响服务性能</strong>。</li><li>服务异常退出<strong>丢失大量日志</strong>的问题</li></ul><p><strong>解决方案</strong></p><ul><li><strong>Tmpfs</strong>，即临时文件系统，它是一种基于内存的文件系统。我们可以将秒杀服务写日志的文件放在临时文件系统中。相比直接写磁盘，在临时文件系统中写日志的性能至少<strong>能提升 100 倍</strong>，每当日志文件达到 20MB 的时候，就将<strong>日志文件转移到磁盘上</strong>，并将临时文件系统中的日志文件清空。</li><li>可以参考内存池设计，将给logger分配缓冲区，每一次的新写可以复用Logger对象</li><li>参考kafka的缓冲池设计，当缓冲区达到大小和间隔时长临界值时，调用Flush函数，减少丢失的风险</li></ul><p><strong>10、池化技术</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6japwof2j31520na4mh.jpg" alt="image-20210504174220668"></p><p>​    通常可以采用<strong>循环队列</strong>来保存空闲连接。使用的时候，可以从队列头部取出连接，用完后将空闲连接放到队列尾部。Netty中利用带缓冲区的 channel 来充当队列。</p><h2 id="三、即时通信"><a href="#三、即时通信" class="headerlink" title="三、即时通信"></a>三、即时通信</h2><h3 id="1、单聊消息可靠传输"><a href="#1、单聊消息可靠传输" class="headerlink" title="1、单聊消息可靠传输"></a>1、<strong>单聊消息可靠传输</strong></h3><p>TCP保证消息可靠传输三板斧：超时、重传、确认。服务端和客户端通信MSG和ACK的共计6个报文</p><ul><li>请求报文（request，后简称为为R），客户端主动发送给服务端。</li><li>应答报文（acknowledge，后简称为A），服务器被动应答客户端的报文。</li><li>通知报文（notify，后简称为N），服务器主动发送给客户端的报文</li></ul><p><strong>在线消息流程：</strong></p><p>​        A 消息请求  <strong>MSG:R</strong>  =&gt; S 消息应答  <strong>MSG:A</strong>  =&gt; S 消息通知B  <strong>MSG:N</strong> </p><p>​        S 确认通知  <strong>ACK:N</strong>  &lt;=  S 确认应答  <strong>ACK:A</strong>  &lt;=  B确认请求S  <strong>ACK:R</strong> </p><p><strong>超时与重传、确认和去重：</strong></p><p>​    A发出了 <strong>MSG:R</strong> ，收到了<strong>MSG:A</strong>之后，在一个期待的时间内，如果没有收到<strong>ACK:N</strong>，A会尝试将 <strong>MSG:R</strong>  重发。可能A同时发出了很多消息，所以A需要在本地维护一个等待ack队列，并配合timer超时机制，来记录哪些消息没有收到<strong>ACK:N</strong>，定时重发。确认ACK<strong>保证必达</strong>，去重保证<strong>唯一</strong></p><p><strong>离线消息流程</strong></p><p>​    原方案：根据离线好友的标识，交互拉取指定的消息</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8kxci29zj30b305974z.jpg" alt="IM消息送达保证机制实现(二)：保证离线消息的可靠投递_2.png"></p><p>优化的方案：</p><ul><li>如用户<strong>勾选全量</strong>则返回计数，在用户点击时拉取。</li><li>如用户未勾选全量则返回<strong>最近全部离线消息</strong>，客户端针对<strong>用户id进行计算</strong>。</li><li>全量离线信息可以通过客户端异步线程分页拉取，减少卡顿</li><li>将ACK和分页第二次拉取的报文重合，可以较少离线消息拉取交互的次数</li></ul><h3 id="2、群聊消息如何保证不丢不重"><a href="#2、群聊消息如何保证不丢不重" class="headerlink" title="2、群聊消息如何保证不丢不重"></a><strong>2、群聊消息如何保证不丢不重</strong></h3><blockquote><p>在线的群友能第一时间收到消息；<br>离线的群友能在登陆后收到消息。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8jswr3poj30hh078dg2.jpg" alt="IM群聊消息如此复杂，如何保证不丢不重？_1.jpg"></p><ul><li>群消息发送者x向server发出群消息；</li><li>server去db中查询群中有多少用户(x,A,B,C,D)；</li><li>server去cache中查询这些用户的在线状态；</li><li>对于群中在线的用户A与B，群消息server进行实时推送；</li><li>对于群中离线的用户C与D，群消息server进行离线存储。</li></ul><p>​    对于同一份群消息的内容，多个离线用户存储了很多份。假设群中有200个用户离线，离线消息则冗余了200份，这极大的增加了数据库的存储压力</p><ul><li>离线消息表只存储用户的群离线消息msg_id，降低数据库的冗余存储量</li><li>加入应用层的ACK，才能保证群消息一定到达，服务端幂等性校验及客户端去重，保证不重复</li><li><p>每条群消息都ACK，会给服务器造成巨大的冲击，通过批量ACK减少消息风暴扩散系数的影响</p></li><li><p>群离线消息过多：拉取过慢，可以通过分页懒拉取改善。</p></li></ul><h3 id="3、如何保证消息的时序性"><a href="#3、如何保证消息的时序性" class="headerlink" title="3、如何保证消息的时序性"></a>3、<strong>如何保证消息的时序性</strong></h3><p>方案：</p><ul><li>Id通过借鉴微信号段+跳跃的方式保证趋势递增</li><li>单聊借鉴数据库设计，单点序列化同步到其他节点保证多机时序</li><li>群聊消息使用单点序列化保证各个发送者的消息相对时序</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gm8m1ge2ksj30j707gt96.jpg" alt="如何保证IM实时消息的“时序性”与“一致性”？_10.jpg"></p><p>优化：</p><ul><li>利用服务器单点序列化时序，可能出现服务端收到消息的时序，与发出序列不一致</li><li>在A往B发出的消息中，加上发送方A本地的一个绝对时序，来表示接收方B的展现时序。</li><li>群聊消息保证一个群聊落在一个service上然后通过本地递增解决全局递增的瓶颈问题</li></ul><h3 id="4：推拉结合"><a href="#4：推拉结合" class="headerlink" title="4：推拉结合"></a><strong>4：推拉结合</strong></h3><p>历史方案：</p><ul><li>服务器在缓存集群里存储所有用户的在线状态 -&gt; 保证状态可查</li><li>用户状态实时变更，任何用户登录/登出时，需要推送所有好友更新状态</li><li>A登录时，先去数据库拉取自己的好友列表，再去缓存获取所有好友的在线状态</li></ul><p><strong>“消息风暴扩散系数”</strong>是指一个消息发出时，变成N个消息的扩散系数，这个系数与业务及数据相关，一定程度上它的大小决定了技术采用推送还是拉取。</p><p>优化方案：</p><ul><li><strong>好友状态推拉结合</strong>，首页置顶亲密、当前群聊，采用推送，否则可以采用轮询拉取的方式同步；</li><li><strong>群友的状态</strong>，由于消息风暴扩散系数过大，可以采用按需拉取，延时拉取的方式同步；</li><li><strong>系统消息/开屏广告等</strong>这种实时产生的消息，可以采用推送的方式获取消息；</li></ul><h3 id="5、好友推荐"><a href="#5、好友推荐" class="headerlink" title="5、好友推荐"></a>5、好友推荐</h3><p>Neo4j 图谱数据库</p><h2 id="四、智慧社区"><a href="#四、智慧社区" class="headerlink" title="四、智慧社区"></a>四、智慧社区</h2><p>​    18年初，针对我们Dubbo框架的智慧楼宇项目的单体服务显得十分笨重，需要采用微服务的形式进行架构的重新设计，当时，我阅读了<em>Eric Evans</em> 写的《领域驱动设计：软件核心复杂性应对之道》和<em>Martin</em> <em>fowler</em>的《微服务架构：<em>Microservice</em>》两本重量级书籍，书中了解到转型微服务的重要原因之一就是利用<strong>分治的思想</strong>减少系统的复杂性，是一种针对<strong>复杂问题的宏观设计</strong>，来应对系统后来规模越来越大，维护越来越困难的问题。然而，拆分成微服务以后，并<strong>不意味着每个微服务都是各自独立地运行</strong>，而是彼此协作地组织在一起。这就好像一个团队，<strong>规模越大越需要一些方法来组织</strong>，这正是我们需要DDD模型为我们的架构设计提供理论并实践的方法。</p><p>​    当时每次版本更新迭代动辄十几个微服务同时修改，有时一个简单的数据库字段变更，也需要同时变更多个微服务，引起了团队的反思：微服务化看上去并没有减少我们的工作量。《企业架构设计》中对于微服务的定义是<strong>小而专</strong>，但在起初的设计时，我们只片面的<strong>理解了小却忽视了专</strong>，此时我们才意识到拆分的关键是要保证微服务内高内聚，微服务间低耦合。</p><h3 id="物联网架构"><a href="#物联网架构" class="headerlink" title="物联网架构"></a><strong>物联网架构</strong></h3><blockquote><p>物联网是互联网的<strong>外延</strong>。将用户端<strong>延伸</strong>和扩展到物与人的连接。物联网模式中，所有<strong>物品与网络连接</strong>，并进行通信和场景联动。互联网通过<strong>电脑、移动终端</strong>等设备将参与者联系起来，形成的一种全新的<strong>信息互换方式</strong></p></blockquote><h4 id="DCM系统架构"><a href="#DCM系统架构" class="headerlink" title="DCM系统架构"></a>DCM系统架构</h4><ul><li><strong>设备感知层</strong>（Device）：利用射频识别、二维码、传感器等技术进行数据采集</li><li><strong>网络传输层</strong>（Connect）：依托通信网络和协议，实现可信的信息交互和共享</li><li><strong>应用控制层</strong>（Manage）：分析和处理海量数据和信息，实现智能化的决策和控制</li></ul><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jc1stt3j31380lswso.jpg" alt="image-20210504174337327" style="zoom:50%;"></p><h4 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a><strong>三要素</strong></h4><ul><li><strong>设备联网</strong>：通过不同的网络协议和通信标准，实现设备与控制端的连接</li><li><strong>云端分析</strong>：提供监控、存储、分析等数据服务，以及保障客户的业务数据安全</li><li><strong>云边协同</strong>：云端接受设备上报数据，下发设备管控指令</li></ul><h4 id="云-边-端协同"><a href="#云-边-端协同" class="headerlink" title="云 / 边 / 端协同"></a>云 / 边 / 端协同</h4><p><strong>云端计算</strong>、<strong>终端计算</strong>和<strong>边缘计算</strong>是一个协同的系统，根据用户场景、资源约束程度、业务实时性等进行动态调 配，形成可靠、低成本的应用方案。从过去几年的发展积累来看，AI 已在物联网多个层面进行融合，比我们合作的海康威视、旷视宇视、商汤科技等纷纷发布了物联网AI相关平台和产品，和移动和小区进行了紧密的融合。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gn9kwux9vjj312w0li138.jpg" alt="image-20210202225351673" style="zoom:50%;"></p><h4 id="物联网平台接入"><a href="#物联网平台接入" class="headerlink" title="物联网平台接入"></a>物联网平台接入</h4><p><img src="https://static-aliyun-doc.oss-accelerate.aliyuncs.com/assets/img/zh-CN/3199158061/p132750.png" alt="企业基于物联网平台的业务链路" style="zoom:50%;"></p><p>向下连接海量设备，支撑设备<strong>数据采集上云</strong>；</p><p>向上通过调用<strong>云端API</strong>将指令下发至设备端，实现<strong>远程控制</strong>。</p><p><strong>上行数据链路</strong></p><ul><li>设备建立<strong>MQTT</strong>长连接，上报数据（发布Topic和Payload）到物联网平台</li><li>物联网平台通过<strong>配置</strong>规则，通过<strong>RocketMQ</strong>、<strong>AMQP</strong>等队列转发到业务平台</li></ul><p><strong>下行指令链路</strong></p><ul><li>业务服务器基于<strong>HTTPS</strong>协议调用的API接口，发布Topic指令到物联网平台。</li><li>物联网平台通过<strong>MQTT</strong>协议，使用发布（指定Topic和Payload）到<strong>设备端</strong>。</li></ul><h4 id="门锁接入"><a href="#门锁接入" class="headerlink" title="门锁接入"></a>门锁接入</h4><p><strong>WIFI门锁</strong>：<strong>非保活</strong> 平常处于断电休眠状态，需要<strong>MCU</strong> <strong>唤醒</strong>才能传输和发送数据</p><p><strong>蓝牙门锁</strong>：<strong>MCU串口对接</strong>和<strong>SDK对接</strong>，近距离<strong>单点登录</strong>和远距离<strong>网关登录</strong></p><p><strong>Zigbee门锁</strong>：<strong>非保活</strong> 但是保持心跳，<strong>MCU</strong>对接，<strong>Zigbee协议</strong>控制。</p><p><strong>NB-Iot门锁</strong>：可以通过<strong>公网</strong>连接，把门禁变成<strong>SAAS</strong>服务，<strong>MCU</strong></p><table><thead><tr><th>名词</th><th>解释</th></tr></thead><tbody><tr><td><strong>SaaS</strong></td><td><strong>Software-as-a-Service</strong> ，提供给客户的服务是运营商运行在云计算基础设施上的应用程序。<strong>用户可以在各种设备上通过客户端界面访问应用</strong>，例如计算机浏览器。用户不需要管理或控制任何云计算基础设施，包括网络、服务器、操作系统、存储等资源，一切由 SaaS 提供商管理和运维。</td></tr><tr><td><strong>PaaS</strong></td><td><strong>Platform-as-a-Service</strong>，表示平台即服务理念，客户不需要管理或控制底层的云基础设施，包括网络、服务器、操作系统、存储等，但<strong>客户能控制部署的应用程序</strong>，也可能控制运行应用程序的托管环境配置。</td></tr><tr><td><strong>IaaS</strong></td><td>I<strong>nfrastructure-as-a-Service</strong> ，表示基础设施即服务理念，提供的服务是对所有计算基础设施的利用，包括 CPU、内存、存储、网络等其它计算资源。<strong>用户能够部署和运行任意软件，包括操作系统和应用程序。</strong></td></tr></tbody></table><h4 id="各种协议"><a href="#各种协议" class="headerlink" title="各种协议"></a>各种协议</h4><p><strong>HTTP协议（CS用户上网）</strong></p><p>HTTP协议是典型的CS通讯模式，由<strong>客户端主动</strong>发起连接，向服务器请求<strong>XML或JSON数据</strong>。该协议最早是为了适用web浏览器的<strong>上网浏览场景</strong>和设计的，目前在<strong>PC、手机、pad</strong>等终端上都应用广泛，但并<strong>不适用于物联网场景</strong></p><ul><li>由于必须由设备主动向服务器发送数据，难以主动向设备推送数据。</li><li>物联网场景中的<strong>设备多样</strong>，运算<strong>受限的设备</strong>，难以实现JSON数据格式的解析</li></ul><p><strong>RESTAPI（松耦合调用）</strong></p><p>REST/HTTP主要为了<strong>简化</strong>互联网中的系统架构，<strong>快速实现</strong>客户端和服务器之间交互的<strong>松耦合</strong>，降低了客户端和服务器之间的<strong>交互延迟</strong>。因此适合在物联网的应用层面，通过REST<strong>开放</strong>物联网中资源，实现服务被其他应用所调用。</p><p><strong>CoAP协议（无线传感）</strong></p><blockquote><p>简化了HTTP协议的<strong>RESTful API</strong>，它适用于在<strong>资源受限</strong>的通信的IP网络。</p></blockquote><p><strong>MQTT协议（低带宽）</strong></p><blockquote><p>MQTT协议采用<strong>发布/订阅</strong>模式，物联网终端都通过TCP连接到云端，云端通过主题的方式管理各个设备关注的通讯内容，<strong>负责</strong>将设备与设备之间<strong>消息的转发</strong></p></blockquote><p>适用范围：在低带宽、不可靠的集中<strong>星型网络架构</strong>（hub-and-spoke），不适用设备与设备之间通信，设备<strong>控制能力弱</strong>，另外<strong>实时性较差</strong>，一般都在<strong>秒级</strong>。协议要<strong>足够轻量</strong>，方便嵌入式设备去快速地解析和响应。具备<strong>足够的灵活性</strong>，使其足以为 IoT 设备和服务的多样化提供支持。应该设计为<strong>异步消息协议</strong>，这么做是因为大多数 IoT 设备的网络延迟很可能非常不稳定，若使用同步消息协议，IoT 设备需要等待服务器的响应，必须是<strong>双向通信</strong>，服务器和客户端应该可以互相发送消息。</p><p><strong>AMQP协议（互操作性）</strong></p><blockquote><p>用于业务系统例如PLM，ERP，MES等进行数据交换。</p></blockquote><p>　　适用范围：最早应用于金融系统之间的交易消息传递，在物联网应用中，主要适用于移动手持设备与后台数据中心的通信和分析。</p><p><strong>XMPP协议（即时通信）</strong></p><blockquote><p>开源形式组织产生的网络即时通信协议。被IETF国际标准组织完成了标准化工作</p></blockquote><p>　　适用范围：<strong>即时通信</strong>的应用程序，还能用在<strong>协同工具</strong>、游戏等。</p><p>​    XMPP在通讯的业务流程上是更适合物联网系统的，开发者不用花太多心思去解决设备通讯时的业务通讯流程，相对开发成本会更低。但是HTTP协议中的安全性以及计算资源消耗的硬伤并没有得到本质的解决。</p><p><strong>JMS （Java消息服务）</strong></p><p>​    Java消息服务（Java Message Service）应用程序接口，是一个Java平台中关于面向消息中间件（MOM）的API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</p><p><strong>Zigbee协议</strong></p><p>​    低功耗，它保持IEEE 802.15.4（2003）标准</p><h3 id="IOT流量洪峰"><a href="#IOT流量洪峰" class="headerlink" title="IOT流量洪峰"></a>IOT流量洪峰</h3><p>智慧社区IOT领域，不管是嵌入式芯片还是应用服务器都需要传递消息，常见上行的消息有：<strong>人脸识别开门、烟感雾感告警</strong>、共享充电桩充电，下行的<strong>广告下发、NB门禁开门指令、</strong>超级门板显示等，由于物联网设备时不时会<strong>故障和断网导致大量的流量洪峰</strong>，传统消息队列需要针对性优化。</p><ul><li><p><strong>上下行拆分</strong></p><p>上行消息特征：并发量<strong>高</strong>、可靠性和<strong>时延性要求低</strong></p><p>下行消息特征：并发量<strong>低</strong>、控制指令的<strong>成功率要求高</strong></p></li><li><p><strong>海量Topic下性能</strong></p><p><strong>Kafka</strong>海量Topic性能会<strong>急剧下降</strong>，Zookeeper协调也有瓶颈</p><p><strong>多泳道消息队列</strong>可以实现IoT消息队列的故障<strong>隔离</strong></p></li><li><p><strong>实时消息优先处理</strong></p><p>NB门禁实时产生的开门指令必须<strong>第一优先级处理</strong>，堆积的消息降级</p><p>设计成<strong>无序、不持久化</strong>的，并与传统的FIFO队列隔离</p></li><li><p><strong>连接、计算、存储分离</strong></p><p>Broker只做<strong>流转分发</strong>，实现<strong>无状态</strong>和<strong>水平扩展</strong></p><p>计算交给<strong>Flink</strong>，存储交给nosqlDB，实现<strong>高吞吐写</strong></p></li><li><p><strong>消息策略-推拉结合</strong></p><p>MQTT针对电池类物联网设备，AMQP针对安全性较高的门禁设备</p><p>消费端离线时存到queue，在线时将<strong>实时消息和从queue中拉取的消息</strong>一起推送</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goboitd4h2j30u00ciq3i.jpg" alt="img"></p><p><strong>如果解决海量Topic</strong></p><p>​    首先要做的就是分区、分组等水平拆分的方式，接下来考虑单实例如何处理更多Topic，传统消息队列在海量Topic下顺序写会退化成随机写，性能大幅下降</p><ul><li><p><strong>人工Sharding</strong>：部署多个Kafka集群，通过不同mq连接来隔离</p></li><li><p><strong>合并Topic</strong>，客户端封装subTopic。比如一个服务的N个统计项，会消费到无关消息</p><p>​    基于这个思路，使用<strong>Kafka Streams</strong>或者<strong>Hbase列</strong>存储来聚合</p></li></ul><p>针对单个Topic海量订阅的问题，<strong>可以在上层封装广播组件来协调批量发送</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobohzda8fj30u00cgaax.jpg" alt="img"></p><h3 id="社区直播带货"><a href="#社区直播带货" class="headerlink" title="社区直播带货"></a>社区直播带货</h3><blockquote><p>使用<strong>端 / 边 / 云</strong>三级架构，客户端加密传输，边缘节点转发、云侧转码并持久化</p></blockquote><h4 id="产品的背景"><a href="#产品的背景" class="headerlink" title="产品的背景"></a><strong>产品的背景</strong></h4><blockquote><p>上线时间，从调研到正式上线用了 3个月时间，上线后一个月内就要经历双十二挑战。在这么紧的上线时间要求下，需要用到公司提供的所有优势，包括<strong>cdn网络，直播牌照</strong>等</p></blockquote><h4 id="面临的挑战"><a href="#面临的挑战" class="headerlink" title="面临的挑战"></a>面临的挑战</h4><ul><li>直播数据是<strong>实时</strong>生成的，所有不能够进行<strong>预缓存</strong></li><li>直播随时会发生，举办热点活动，相关服务器资源需要<strong>动态分配</strong></li><li><p>直播的延迟对于用户体验影响很大，需要控制在<strong>秒级</strong></p></li><li><p>直播sdk是内嵌在社区应用里的，整体要求不能超过5M</p></li></ul><h4 id="协议的比较"><a href="#协议的比较" class="headerlink" title="协议的比较"></a>协议的比较</h4><table><thead><tr><th>协议</th><th>上线时间</th><th>网络兼容</th><th>端对端延迟</th><th>应用大小</th><th>问题</th></tr></thead><tbody><tr><td>WebRTC</td><td></td><td>✗</td><td></td><td></td><td>Webrtc 基于 UDP，和社区应用的网络架构不兼容</td></tr><tr><td>HTTP Upload</td><td></td><td></td><td>✗</td><td></td><td>会导致网络高延迟</td></tr><tr><td>Custom Protocol</td><td>✗</td><td></td><td></td><td></td><td>工程师需要实现自己的客户端与服务端的库，无法按时上线</td></tr><tr><td>Proprietary</td><td></td><td></td><td></td><td>✗</td><td>协议就需要几兆的空间，超出额度</td></tr><tr><td>RTMPS</td><td>✔</td><td>✔</td><td>✔</td><td>✔</td><td>TCP实时传输消息协议，更安全更可靠</td></tr></tbody></table><h4 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h4><p><strong>RTMPS</strong>：基于TCP实时传输消息协议，更安全更可靠</p><p><strong>MPEG-DASH</strong>：是一种基于HTTP协议自适应比特率流媒体技术，应对复杂的环境</p><p><img src="https://i.loli.net/2021/01/25/zjwC7B8fdcpDytA.png" alt="image-20210125145103417"></p><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播数据到<strong>边缘节点</strong>（POP）</p></li><li><p>POP 使用<strong>RTMP</strong>发送数据到数据中心（DC）</p></li><li><p>DC 将数据编码成<strong>不同的清晰度</strong>并进行持久化存储</p><p><strong>云端转码</strong>主要有<strong>两种分辨率</strong>400x400 和 720x720. </p></li><li><p>播放端通过 <strong>MPEG-DASH</strong> / RTMPS 协议接收直播数据</p><p>如果用户网络不好<strong><a href="https://www.cloudflare.com/zh-cn/learning/video/what-is-mpeg-dash/" target="_blank" rel="noopener">MPEG-DASH</a></strong>会自动转换成低分辨率</p></li></ol><h4 id="直播流程"><a href="#直播流程" class="headerlink" title="直播流程"></a><strong>直播流程</strong></h4><p><img src="https://i.loli.net/2021/01/25/GITnbhDqPdtZY2k.png" alt="image-20210125153606264" style="zoom:50%;"></p><ol><li><p>直播端使用 <strong>RTMPS</strong> 协议发送直播流数据到 POP 内的就近的代理服务器</p></li><li><p>代理服务器<strong>转发</strong>直播流数据到数据中心的网关服务器（<strong>443转80</strong>）</p></li><li><p>网关服务器使用<strong>直播 id 的一致性哈希算法</strong>发送直播数据到指定的编码服务器</p></li><li><p>编码服务器有几项职责：</p><ul><li><p>4.1 <strong>验证直播数据</strong>的格式是否正确。</p></li><li><p>4.2 <strong>关联</strong>直播 id 以及编码服务器第一映射，保证客户端即使连接中断或者服务器扩容时，在<strong>重新连接</strong>的时候依然能够连接到相同的编码服务器</p></li><li><p>4.3 使用直播数据<strong>编码成不同解析度</strong>的输出数据</p></li><li><p>4.4 使用 <strong>DASH</strong> 协议输出数据并<strong>持久化</strong>存储</p></li></ul></li></ol><h4 id="播放流程"><a href="#播放流程" class="headerlink" title="播放流程"></a>播放流程</h4><p><img src="https://i.loli.net/2021/01/25/Lo5N8QYlI2DPjyO.png" alt="image-20210125154758184" style="zoom:50%;"></p><ol><li>播放端使用 HTTP <strong>DASH</strong> 协议向 POP 拉取直播数据</li><li>POP 里面的代理服务器会检查数据是否已经在 POP 的<strong>缓存</strong>内。如果是的话，缓存会返回数据给播放端，否则，代理服务器会向 DC 拉取直播数据</li><li>DC 内的代理服务器会检查数据是否在 DC 的缓存内，如果是的话，缓存会返回数据给 POP，并更新 POP 的缓存，再返回给播放端。不是的话，代理服务器会使用一致性哈希算法向对应的编码服务器请求数据，并更新 DC 的缓存，返回到 POP，再返回到播放端。</li></ol><p><strong>收获</strong></p><ol><li>项目的成功不，代码只是内功，考虑适配不同的网络、利用可利用的资源</li><li>惊群效应在热点服务器以及许多组件中都可能发生</li><li>开发大型项目需要对<strong>吞吐量和时延</strong>、<strong>安全和性能</strong>做出妥协</li><li>保证架构的灵活度和可扩展性，为内存、服务器、带宽耗尽做好规划</li></ol><h3 id="直播高可用方案"><a href="#直播高可用方案" class="headerlink" title="直播高可用方案"></a><strong>直播高可用方案</strong></h3><p><strong>网络可靠性</strong>：</p><ul><li>根据<strong>网络连接速度</strong>来自动调整视频质量</li><li>使用<strong>短时间的数据缓存</strong>来解决直播端不稳定，瞬间断线的问题</li><li>根据<strong>网络质量自动降级</strong>为音频直播以及播放</li></ul><p><strong>惊群效应：</strong></p><ul><li>当多个播放端向同一个 POP 请求直播数据的时候，如果数据不在缓存中</li><li>这时候只有一个请求 A 会到 DC 中请求数据，其他请求会等待结果</li><li>但是如果请求 A 超时没有返回数据的话，所有请求会一起向 DC 访问数据</li><li>这时候就会加大 DC 的压力，触发惊群效应</li><li>解决这个问题的方法就是通过<strong>实际的情况</strong>来调整请求超时的时间。这个时间如果太长的话会带来直播的延迟，太短的话会经常触发惊群效应（<strong>每个时间窗口只允许触发一次</strong>，设置允许最大回源数量）</li></ul><h3 id="性能优化方案"><a href="#性能优化方案" class="headerlink" title="性能优化方案"></a><strong>性能优化方案</strong></h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobogaxxjkj304v0e7t93.jpg" alt="img"></p><p><strong>数据库优化：</strong> 数据库是最容易成为瓶颈的组件，考虑从 SQL 优化或者数据库本身去提高它的性能。如果瓶颈依然存在，则会考虑分库分表将数据打散，如果这样也没能解决问题，则可能会选择缓存组件进行优化</p><p><strong>集群最优：</strong>存储节点的问题解决后，计算节点也有可能发生问题。一个集群系统如果获得了水平扩容的能力，就会给下层的优化提供非常大的时间空间，由最初的 3 个节点，扩容到最后的 200 多个节点，但由于人力问题，服务又没有什么新的需求，下层的优化就一直被搁置着。</p><p><strong>硬件升级：</strong>水平扩容不总是有效的，原因在于单节点的计算量比较集中，或者 JVM 对内存的使用超出了宿主机的承载范围。在动手进行代码优化之前，我们会对节点的硬件配置进行升级。</p><p><strong>代码优化</strong>：代码优化是提高性能最有效的方式，但需要收集一些数据，这个过程可能是服务治理，也有可能是代码流程优化。比如JavaAgent 技术，会无侵入的收集一些 profile 信息，供我们进行决策。</p><p><strong>并行优化：</strong>并行优化是针对速度慢的接口进行并行调用。所以我们通常使用 ContDownLatch 对需要获取的数据进行并行处理，效果非常不错，比如在 200ms 内返回对 50 个耗时 100ms 的下层接口的调用。</p><p><strong>JVM 优化</strong>： JVM 发生问题时，优化会获得巨大的性能提升。但在 JVM 不发生问题时，它的优化效果有限。但在代码优化、并行优化、JVM 优化的过程中，JVM 的知识却起到了关键性的作用</p><p><strong>操作系统优化：</strong>操作系统优化是解决问题的杀手锏，比如像 HugePage、SWAP、“CPU 亲和性”这种比较底层的优化。但就计算节点来说，对操作系统进行优化并不是很常见。运维在背后会做一些诸如文件句柄的调整、网络参数的修改，这对于我们来说就已经够用了</p><h3 id="流量回放自动化测试"><a href="#流量回放自动化测试" class="headerlink" title="流量回放自动化测试"></a>流量回放自动化测试</h3><blockquote><p>系统级的重构，测试回归的工作量至少都是以月为单位，对于人力的消耗巨大。一种应对方案是，先不改造，到系统实在扛不住了再想办法。另一种应对方案是，先暂停需求，全力进行改造。但在实际工作场景中，上述应对策略往往很难实现。</p></blockquote><p>场景：</p><p>1、读服务均是查询，它是无状态的。</p><p>2、不管是架构升级还是日常需求，读服务对外接口的出入参格式是没有变化的</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jd95rpij315g0hqn5q.jpg" alt="image-20210504174447049" style="zoom:50%;"></p><ul><li><p><strong>日志收集</strong>，主要作用是收集被测系统的真实用户请求，基于一定规则处理后作为系统用例；</p><p>Spring 里的 Interceptor 、Servlet 里的 Filter 过滤器，对所有请求的入参和出参进行记录，并通过 MQ 发送出去。（注意错峰、过滤写、去重等）</p></li><li><p>数据回放是基于收集的用例，对被测系统进行数据回放，发起自动化测试回归；</p><p><strong>离线回放：</strong>只调用新服务，将返回的数据和日志里的出参进行比较，<strong>日志比较大</strong></p><p><strong>实时回放：</strong>去实时调用线上系统和被测系统，并存储实时返回回放的结果信息，<strong>线上有负担</strong></p><p><strong>并行回放：</strong>新版本不即时上线，每次调用老版本接口时概率实时回放新版本接口，<strong>耗时间周期</strong></p></li><li><p><strong>差异对比</strong>，通过差异对比自动发现与预期不一致的用例，进而确定 Bug。</p><p>采用文本对比，可以直观地看到哪个字段数据有差异，从而更快定位到问题。正常情况下，只要存在差异的数据，均可认为是 Bug，是需要进行修复的。</p></li></ul><p><strong>方法论</strong></p><p><strong>Discovery</strong></p><p>​                考虑企业战略，分析客户需求，制定产品目标</p><p>​                    由外到内：竞争对手的方案，为什么做，以后怎么发展，如何去优化。</p><p>​                    自上而下：基于公司的战略，考虑自身能力和所处环境。</p><p>​                    自下而上：从资源、历史问题、优先级出发，形成一套可行性实施方法。</p><p><strong>Define</strong></p><p>​                基于收集的信息，综合跨业务线的抽象能力和服务，先做什么后做什么，怎么做</p><p>​                    设计新的架构，重点设计解决痛点问题。</p><p>​                    拆分业务领域，重点划分工作临界上下文。</p><p><strong>Design</strong></p><p>​                详细的业务设计，功能设计，交付计划，考核计划</p><p>​                    产品愿景，产品形态，相关竞品方案对比，价值、优势、收益</p><p>​                    梳理业务范围，要知道电商领域四大流（信息流、商流、资金流、物流）</p><p>​                    MVP最小可用比，让客户和老大看到结果，最后通编写story把故事编圆</p><p><strong>Delivery</strong></p><p>​                交付阶段，根据反馈及时调整中台战略，减少损失和增大收益</p><p>​                    合理制定每个阶段的绩效考核目标：</p><p>​                40%稳定+25%业务创新+20%服务接入+15%用户满意度</p><h1 id="七、架构设计"><a href="#七、架构设计" class="headerlink" title="七、架构设计"></a><strong>七、架构设计</strong></h1><h2 id="1、社区系统的架构"><a href="#1、社区系统的架构" class="headerlink" title="1、社区系统的架构"></a>1、社区系统的架构</h2><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmqv8zyhkqj311s0u0q7s.jpg" alt="image-20210117182546782" style="zoom:40%;"></p><p><strong>系统拆分</strong></p><p>​        通过DDD领域模型，对服务进行拆分，将一个系统拆分为多个子系统，做成SpringCloud的微服务。微服务设计时要尽可能做到少扇出，多扇入，根据服务器的承载，进行客户端负载均衡，通过对核心服务的上游服务进行限流和降级改造。</p><p>​    一个服务的代码不要太多，1 万行左右，两三万撑死了吧。</p><p>​    大部分的系统，是要进行<strong>多轮拆分</strong>的，第一次拆分，可能就是将以前的多个模块该拆分开来了，比如说将电商系统拆分成<strong>订单系统、商品系统、采购系统、仓储系统、用户系统</strong>等等吧。</p><p>​    但是后面可能每个系统又变得越来越复杂了，比如说采购系统里面又分成了<strong>供应商管理系统、采购单管理系统</strong>，订单系统又拆分成了<strong>购物车系统、价格系统、订单管理</strong>系统。</p><p><strong>CDN、Nginx静态缓存、JVM缓存</strong></p><p>​    利用Java的模板thymeleaf可以将页面和数据动态渲染好，然后通过Nginx直接返回。动态数据可以从redis中获取。其中redis里的数据由一个缓存服务来进行消费指定的变更服务。</p><p>​    商品数据，每条数据是 10kb。100 条数据是 1mb，10 万条数据是 1g。常驻内存的是 200 万条商品数据，占用内存是 20g，仅仅不到总内存的 50%。目前高峰期每秒就是 3500 左右的请求量。</p><p><strong>缓存</strong></p><p>Redis cluster，10 台机器，5主5从，5 个节点对外提供读写服务，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，<strong>5 台机器最多是 25 万读写</strong>请求每秒。</p><p>​    <strong>32G 内存+ 8 核 CPU + 1T</strong> 磁盘，但是分配给 <strong>Redis 进程的是 10g 内存</strong>，一般线上生产环境，Redis 的内存尽量不要超过 10g，超过 10g 可能会有问题。</p><p>​    因为每个主实例都挂了一个从实例，所以是<strong>高可用</strong>的，任何一个主实例宕机，都会自动故障迁移，Redis 从实例<strong>会自动变成主实例</strong>继续提供读写服务。</p><p><strong>MQ</strong></p><p>​    可以通过消息队列对微服务系统进行<a href="#1、拆分微服务">解耦</a>，异步调用的更适合微服务的扩展</p><p>​    同时可以应对秒杀活动中<a href="# 6、应对高并发的写请求">应对高并发写请求</a>，比如kafka在毫秒延迟基础上可以实现10w级吞吐量</p><p>​    针对<a href="#IOT流量洪峰">IOT流量洪峰</a>做了一些特殊的优化，保证消息的及时性</p><p>​    同时可以使用消息队列保证分布式系统<a href="#7、如何保证数据一致性">最终一致性</a></p><p><strong>分库分表</strong></p><p>​        分库分表，可能到了最后数据库层面还是免不了抗高并发的要求，好吧，那么就 将一个数据库拆分为多个库，多个库来扛更高的并发；然后将一个表拆分为多个 表，每个表的数据量保持少一点，提高 sql 跑的性能。<strong>在通讯录、订单和商城商品模块超过千万级别都应及时考虑分表分库</strong></p><p><strong>读写分离</strong></p><p>​        读写分离，这个就是说大部分时候数据库可能也是读多写少，没必要所有请求都 集中在一个库上吧，可以搞个主从架构，主库写入，从库读取，搞一个读写分离。 读流量太多的时候，还可以加更多的从库。比如<strong>统计监控类的微服务</strong>通过读写分离，只需访问从库就可以完成统计，例如ES</p><p><strong>ElasticSearch</strong></p><p>​        Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的<strong>查询、统计类</strong>的操作，比如<strong>运营平台上</strong>的各地市的汇聚统计，还有一些<strong>全文搜索类</strong>的操作，比如<strong>通讯录和订单</strong>的查询。</p><h2 id="2、商城系统-亿级商品如何存储"><a href="#2、商城系统-亿级商品如何存储" class="headerlink" title="2、商城系统-亿级商品如何存储"></a>2、商城系统-亿级商品如何存储</h2><p>基于 Hash 取模、一致性 Hash 实现分库分表</p><p>高并发读可以通过<a href="5、应对高并发的读请求">多级缓存</a>应对</p><p>大促销热key读的问题通过<a href="**4、热key问题如何解决？**">redis集群+本地缓存+限流+key加随机值</a>分布在多个实例中</p><p>高并发写的问题通过<strong>基于 Hash 取模、一致性 Hash 实现分库分表</strong>均匀落盘</p><p>业务分配不均导致的<strong>热key</strong>读写问题，可以根据业务场景进行range分片，将热点范围下的子key打散</p><p>具体实现：预先设定主键的生成规则，根据规则进行数据的分片路由，但这种方式会侵入商品各条线主数据的业务规则，更好的方式是基于<strong>分片元数据服务器</strong>（即每次访问分片前先询问分片元服务器在路由到实际分片）不过会带来复杂性，比如保证元数据服务器的<strong>一致性</strong>和可用性。</p><h2 id="3、对账系统-分布式事务一致性"><a href="#3、对账系统-分布式事务一致性" class="headerlink" title="3、对账系统-分布式事务一致性"></a>3、对账系统-分布式事务一致性</h2><blockquote><p>尽量避免分布式事务，单进程用数据库事务，跨进程用消息队列</p></blockquote><p>主流实现分布式系统事务一致性的方案：</p><ol><li><strong>最终一致性</strong>：也就是基于 MQ 的可靠消息投递的机制，</li><li>基于重试加确认的的<strong>最大努力通知方案</strong>。</li></ol><p>理论上也可以使用（2PC两阶段提交、3PC三阶段提交、TCC短事务、SAGA长事务方案），但是这些方案工业上落地代价很大，不适合互联网的业界场景。针对金融支付等需要强一致性的场景可以通过前两种方案实现。（<strong>展开说的话参考分布式事务</strong>）</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruh4oifej30xq0auq7p.jpg" alt="image-20210321212516364"></p><p>本地数据库事务原理：<strong>undo log</strong>（原子性） + <strong>redo log</strong>（持久性） + <strong>数据库锁</strong>（原子性&amp;隔离性） + <strong>MVCC</strong>（隔离性）</p><p>分布式事务原理：<strong>全局事务协调器（原子性）</strong> + 全局锁（隔离性） + <strong>DB本地事务（原子性、持久性）</strong></p><p>一、我们公司账单系统和第三方支付系统对账时，就采用“<strong>自研补偿/MQ方案 + 人工介入</strong>”方式</p><p>落地的话：方案最“轻”，性能损失最少。可掌控性好，简单易懂，易维护。<br>考虑到分布式事务问题是小概率事件，留有补救余地就行，性能的损失可是实打实的反应在线上每一个请求上</p><p>二、也了解到业界比如阿里成熟<strong>Seata AT</strong>模式，平均性能会降低35%以上</p><p>我觉得不是特殊的场景不推荐</p><p>三、RocketMQ事务消息</p><p>听起来挺好挺简单的方案，但它比较挑业务场景，同步性强的处理链路不适合。<br>【重要】要求下游MQ消费方一定能成功消费消息。否则转人工介入处理。<br>【重要】千万记得实现幂等性。</p><h2 id="4、用户系统-多线程数据割接"><a href="#4、用户系统-多线程数据割接" class="headerlink" title="4、用户系统-多线程数据割接"></a>4、用户系统-多线程数据割接</h2><p>由于项目需要进行数据割接，保证用户多平台使用用户感知的一致，将广东项目的几百万用户及业务数据按照一定的逻辑灌到社区云平台上，由于依赖了第三方统一认证和省侧crm系统，按照之前系统内割接的方法，通过数据库将用户的唯一标识查出来然后使用多线程向省侧crm系统获取结果。</p><p>但是测试的过程中，发现每个线程请求的数据发生了错乱，导致每个请求处理的数据有重复，于是立即停止了脚本，当时怀疑是多线程对资源并发访问导致的，于是把ArrayList 改成了CopyOnWriteArrayList，但是折腾了一晚上，不管怎么修改，线程之间一直有重复数据，叫了一起加班的同事也没看出问题来，和同事估算了一下不使用多线程，大概30-40个小时能跑完，想了下也能接受，本来已经准备放弃了。</p><p>不过回到家，我还是用多线程仔细单步模拟了下，整个处理的过程，发现在起线程的时候，有些子线程并没有把分配给他的全部id的list处理完，导致最终状态没更新，新线程又去执行了一遍，然后我尝试通过修改在线程外深拷贝一个List再作为参数传入到子线程里，（后续clear的时候也是clear老的List）果然，整个测试过程中再也没出现过重复处理的情况。</p><p>事后，我也深究了下原因：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span><span class="token punctuation">(</span>arrayBuffer<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">99</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> val asList <span class="token operator">=</span> arrayBuffer<span class="token punctuation">.</span>toList exec<span class="token punctuation">.</span><span class="token function">execute</span> <span class="token punctuation">(</span> <span class="token function">openIdInsertMethod</span><span class="token punctuation">(</span>asList<span class="token punctuation">)</span> <span class="token punctuation">)</span> arrayBuffer<span class="token punctuation">.</span>clear<span class="token punctuation">}</span></code></pre><p>在一个线程中开启另外一个新线程，则新开线程称为该线程的子线程，子线程初始优先级与父线程相同。不过主线程先启动占用了cpu资源，因此主线程总是优于子线程。然而，即使设置了优先级，也无法保障线程的执行次序。只不过，优先级高的线程获取CPU资源的概率较大，优先级低的并非没机会执行。</p><p>所以主线程上的clear操作有可能先执行，那么子线程中未处理完的数据就变成一个空的数组，所以就出现了多个线程出现了重复数据的原因，所以我们要保证的是子线程每次执行完后再进行clear即可。而不是一开始定位的保证ArrayList的安全性。所以将赋值(buffer-&gt;list)操作放在外面去执行后，多线程数据就正常了。</p><h2 id="5、秒杀系统场景设计"><a href="#5、秒杀系统场景设计" class="headerlink" title="5、秒杀系统场景设计"></a>5、秒杀系统场景设计</h2><p><a href="# 二、秒杀项目">见秒杀项目方案设计</a></p><h2 id="6、统计系统-海量计数"><a href="#6、统计系统-海量计数" class="headerlink" title="6、统计系统-海量计数"></a><strong>6、统计系统-海量计数</strong></h2><p><strong>中小规模的计数服务</strong>（万级）</p><p>最常见的计数方案是采用缓存 + DB 的存储方案。当计数变更时，先变更计数 DB，计数加 1，然后再变更计数缓存，修改计数存储的 Memcached 或 Redis。这种方案比较通用且成熟，但在高并发访问场景，支持不够友好。在互联网社交系统中，有些业务的计数变更特别频繁，比如微博 feed 的阅读数，计数的变更次数和访问次数相当，每秒十万到百万级以上的更新量，如果用 DB 存储，会给 DB 带来巨大的压力，DB 就会成为整个计数服务的瓶颈所在。即便采用聚合延迟更新 DB 的方案，由于总量特别大，同时请求均衡分散在大量不同的业务端，巨大的写压力仍然是 DB 的不可承受之重。</p><p><strong>大型互联网场景</strong>（百万级）</p><p>直接把计数全部存储在 Redis 中，通过 hash 分拆的方式，可以大幅提升计数服务在 Redis 集群的写性能，通过主从复制，在 master 后挂载多个从库，利用读写分离，可以大幅提升计数服务在 Redis 集群的读性能。而且 Redis 有持久化机制，不会丢数据</p><p>一方面 Redis 作为通用型存储来存储计数，内存存储效率低。以存储一个 key 为 long 型 id、value 为 4 字节的计数为例，Redis 至少需要 65 个字节左右，不同版本略有差异。但这个计数理论只需要占用 12 个字节即可。内存有效负荷只有 12/65=18.5%。如果再考虑一个 long 型 id 需要存 4 个不同类型的 4 字节计数，内存有效负荷只有 (8+16)/(65*4)= 9.2%。</p><p>另一方面，Redis 所有数据均存在内存，单存储历史千亿级记录，单份数据拷贝需要 10T 以上，要考虑核心业务上 1 主 3 从，需要 40T 以上的内存，再考虑多 IDC 部署，轻松占用上百 T 内存。就按单机 100G 内存来算，计数服务就要占用上千台大内存服务器。存储成本太高。</p><p><strong>微博、微信、抖音</strong>（亿级）</p><p>定制数据结构，共享key 紧凑存储，提升计数有效负荷率</p><p>超过阈值后数据保存到SSD硬盘，内存里存索引</p><p>冷key从SSD硬盘中读取后，放入到LRU队列中</p><p>自定义主从复制的方式，海量冷数据异步多线程并发复制</p><h2 id="7、系统设计-微软"><a href="#7、系统设计-微软" class="headerlink" title="7、系统设计 - 微软"></a>7、系统设计 - 微软</h2><h3 id="1、需求收集"><a href="#1、需求收集" class="headerlink" title="1、需求收集"></a><strong>1、需求收集</strong></h3><p>确认<strong>使用的对象</strong>（ToC：高并发，ToB：高可用）</p><p><strong>系统的服务场景</strong>（<strong>即时通信</strong>：低延迟，<strong>游戏</strong>：高性能，<strong>购物</strong>：秒杀-一致性）</p><p><strong>用户量级</strong>（<strong>万级</strong>：双机、<strong>百万</strong>：集群、<strong>亿级</strong>：弹性分布式、容器化编排架构）</p><p><strong>百万读</strong>：3主6从，<strong>每个节点的读写高峰 QPS</strong> 可能可以达到每秒 5 万，可以实现15万，30万读性能</p><p><strong>亿级读</strong>，通过CDN、静态缓存、JVM缓存等多级缓存来提高读并发</p><p><strong>百万写</strong>，通过消息队列削峰填谷，通过hash分拆，水平扩展分布式缓存</p><p><strong>亿级写</strong>，redis可以定制数据结构、SSD+内存LRU、冷数据异步多线程复制</p><p>持久化，（Mysql）承受量约为 1K的QPS，读写分离提升<strong>读并发</strong>，分库分表提升<strong>写并发</strong></p><h3 id="2、顶层设计"><a href="#2、顶层设计" class="headerlink" title="2、顶层设计"></a><strong>2、顶层设计</strong></h3><p>核心功能包括什么：</p><p>写功能：发送微博</p><p>读功能：热点资讯</p><p>交互：点赞、关注</p><h3 id="3、系统核心指标"><a href="#3、系统核心指标" class="headerlink" title="3、系统核心指标"></a><strong>3、系统核心指标</strong></h3><ul><li>系统<strong>性能</strong>和<strong>延迟</strong><ul><li>边缘计算 | 动静分离 | 缓存 |  多线程 | </li></ul></li><li><strong>可扩展性</strong>和<strong>吞吐量</strong><ul><li>负载均衡 | 水平扩展 | 垂直扩展 | 异步 | 批处理 | 读写分离</li></ul></li><li><strong>可用性</strong>和<strong>一致性</strong><ul><li>主从复制 | 哨兵模式 | 集群 | 分布式事务 </li></ul></li></ul><h3 id="4、数据存储"><a href="#4、数据存储" class="headerlink" title="4、数据存储"></a>4、数据存储</h3><p>键值存储 : Redis ( 热点资讯 )</p><p>文档存储 : MongoDB ( 微博文档分类)</p><p>分词倒排：Elasticsearch（搜索）</p><p>列型存储：Hbase、BigTable（大数据）</p><p>图形存储：Neo4j （社交及推荐）</p><p>多媒体：FastDfs（图文视频微博）</p><h2 id="7、如何设计一个微博"><a href="#7、如何设计一个微博" class="headerlink" title="7、如何设计一个微博"></a>7、如何设计一个微博</h2><p><strong>实现哪些功能：</strong></p><p>筛选出核心功能（Post a Tweet，Timeline，News Feed，Follow/Unfollow a user，Register/Login）</p><p><strong>承担多大QPS：</strong></p><p>QPS = 100，那么用我的笔记本作Web服务器就好了</p><p>QPS = 1K，一台好点的Web 服务器也能应付，需要考虑单点故障；</p><p>QPS = 1m，则需要建设一个1000台Web服务器的集群，考虑动态扩容、负载分担、故障转移</p><p>一台 SQL Database （Mysql）承受量约为 1K的QPS；</p><p>一台 NoSQL Database (Redis) 约承受量是 20k 的 QPS；</p><p>一台 NoSQL Database (Memcache) 约承受量是 200k 的 QPS；</p><p><strong>微服务战略拆分</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruqql81gj30p20c5q45.jpg" alt="img" style="zoom:67%;"></p><p><strong>针对不同服务选择不同存储</strong></p><p><img src="https://pic1.zhimg.com/80/v2-13cab4d5f56e3ecb682c351c0eb4a24b_1440w.jpg?source=1940ef5c" alt="img"></p><p><strong>设计数据表的结构</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goruu4homyj31400ht405.jpg" alt="img"></p><p>基本差不多就形成了一个解决方案，但是并不是完美的，仍然需要小步快跑的不断的针对<strong>消息队列、缓存、分布式事务、分表分库、大数据、监控、可伸缩</strong>方面进行优化</p><h1 id="八、领域模型落地"><a href="#八、领域模型落地" class="headerlink" title="八、领域模型落地"></a>八、领域模型落地</h1><h3 id="1、拆分微服务"><a href="#1、拆分微服务" class="headerlink" title="1、拆分微服务"></a>1、拆分微服务</h3><blockquote><p>​    微服务内高内聚，微服务间低耦合</p></blockquote><p><strong>微服务内高内聚</strong>即单一职责原则</p><p>​    每个微服务中的代码变化都是同一类原因。因这类原因而需要变更的代码都在这个微服务中，与其他微服务无关，那么就可以将代码修改的范围缩小到这个微服务内。把这个微服务修改好了，独立修改、独立发布，该需求就实现了。这样，微服务的优势才能发挥出来。</p><p><strong>微服务间低耦合</strong>开放封闭原则</p><p>​    就是说在微服务实现自身业务的过程中，如果需要执行的某些过程不是自己的职责，就应当将这些过程交给其他微服务去实现，你只需要对它的接口进行调用。这样，微服务之间的调用就实现了解耦。</p><p>​    <strong>领域建模</strong>就是将一个系统划分成了多个子域，每个子域都是一个独立的业务场景，每个子域的边界就是“<strong>限界上下文</strong>”。该业务场景会涉及许多领域对象，但<strong>分析建模</strong>始终需要围绕着业务场景的上下文进行。</p><p>​    <strong>领域事件通知机制</strong>最有效的方式就是通过消息队列，实现领域事件在微服务间的通知。</p><blockquote><p>“核心通讯录”微服务只负责发送变更消息到消息队列，不管谁会接收并处理这些消息；</p><p>“门禁管理”微服务只负责接收照片变更消息，不管谁发送的这个消息。</p></blockquote><h3 id="2、关联微服务"><a href="#2、关联微服务" class="headerlink" title="2、关联微服务"></a>2、关联微服务</h3><ol><li><p>按照<strong>限界上下文</strong>进行微服务的拆分，将领域模型<strong>划分到多个问题子域</strong></p></li><li><p>基于<strong>充血模型</strong>与<strong>贫血模型</strong>设计各个微服务的业务领域层（Service、Entity、Value）</p></li><li><p>通过<strong>领域事件通知机制</strong>和<strong>微服务调用</strong>的推拉结合，将各个子域进行解耦关联</p><ul><li><strong>核心</strong>：</li></ul></li></ol><ul><li><p>通讯录 | 短信 | 推送通知 | 支付 | 文件服务</p></li><li><p><strong>智慧通行</strong></p><blockquote><p>解决物业多品牌、多系统应用造成的<strong>信息孤岛</strong>，<strong>数据混乱</strong>的问题</p></blockquote><ul><li>人脸门禁 | 可视对讲 | 电梯梯控 | 停车系统 | 访客预约</li></ul></li><li><p><strong>安全社区</strong></p><blockquote><p>通过<strong>图像视频识别</strong>、<strong>传感数据采集</strong>，实现<strong>报警联动</strong>和<strong>风险预警</strong></p></blockquote><ul><li>视频监控 | 周界报警 | 高空抛物 | 跨域追踪</li></ul></li><li><p><strong>全屋智能</strong></p><blockquote><p>围绕业主需求，逐步引入社区医疗、社区养老、<strong>社区团购</strong>、<strong>社区家政</strong>等服务</p></blockquote><ul><li>超级面板 | 无线门锁 | 烟感雾感</li></ul></li><li><p><strong>增值服务</strong></p><blockquote><p>实现跨品牌的产品体验，支持基于<strong>matrix引擎</strong>的智能生活场景裂变能力</p></blockquote><ul><li>智能充电 | 云广播 | 出入提醒 | 定向投放</li></ul></li></ul><h3 id="3、微服务的落地"><a href="#3、微服务的落地" class="headerlink" title="3、微服务的落地"></a><strong>3、微服务的落地</strong></h3><blockquote><p>​    通过合理的微服务设计，尽量让每次的需求变更都交给某个小团队独立完成，让需求变更落到某个微服务上进行变更。唯有这样，每次变更只需独立地修改这个微服务，独立打包、独立升级，新需求独立实现，才能发挥微服务的优势。</p></blockquote><ul><li><strong>数据隔离：</strong>数据库中用户信息表的读写只有<strong>通讯录</strong>微服务。当其他微服务需要读写用户信息时，就不能直接读取用户信息表，而是通过 API 接口去调用<strong>通讯录</strong>微服务。</li><li><strong>接口复用：</strong>因此，当多个团队向你提需求时，必须要对这些接口进行规划，通过复用<strong>尽可能少的接口满足他们的需求；</strong>当有新的接口提出时，要尽量通过现有接口解决问题。</li><li><strong>向前兼容：</strong>当调用方需要接口变更时怎么办？变更现有接口应当尽可能向前兼容，即接口的名称与参数都不变，只是在内部增加新的功能。<strong>宁愿增加一个新的接口也最好不要去变更原有的接口。</strong></li><li><strong>本地调用：</strong>在<strong>访客申请</strong>微服务的本地，增加一个<strong>查询用户Service</strong>的 feign 接口。这样，<strong>访客申请Service</strong>就像本地调用一样调用<strong>查询用户Service</strong>，再通过 feign 接口实现远程调用。这种<strong>防腐层</strong>的设计，可以隔离当前微服务以外的其他微服务拆分变更导致的接口的失效的影响。</li><li><p><strong>数据库去中心化：</strong></p><ul><li>微服务中<strong>通讯录服务</strong>与<strong>健康码服务</strong>分别对应的<strong>用户库与权限库</strong>，它们的共同特点是数据量小但频繁读取，可以选用小型的 MySQL 数据库并在前面架设 Redis 来提高查询性能；</li><li>微服务中<strong>访客通行</strong>与<strong>生活缴费</strong>分别对应的<strong>通行记录库、订单库</strong>，其特点是数据量大并且高并发写，选用一个数据库显然扛不住这样的压力，因此可以选用了 TiDB 这样的 NewSQL 数据库进行分布式存储，将数据压力分散到多个数据节点中，从而解决 I/O 瓶颈；</li><li>微服务中<strong>数据分析</strong>与<strong>通讯录查询</strong>这样的查询分析业务，则选用 <strong>NoSQL 数据库</strong>或<strong>大数据平台</strong>，通过读写分离将生产库上的数据同步过来进行分布式存储，然后宽表一系列的预处理，应对海量历史数据的决策分析与秒级查询。（ NoSQL 为空的字段是不占用空间的，因此字段再多都不影响查询性能）</li></ul></li></ul><h3 id="4、领域模型的意义"><a href="#4、领域模型的意义" class="headerlink" title="4、领域模型的意义"></a>4、领域模型的意义</h3><p>​    <strong>贫血模型、充血模型、策略模式、装饰者模式</strong>只是DDD实现的方式，而DDD的真谛是<strong>领域建模</strong>。</p><p>​    做事不能仅凭一腔热血，一定要符合自然规律。其实软件的设计开发过程也是这样。对业务理解不深刻全局架构设计往往是过度设计，这时候<strong>应该抓主要流程</strong>，开始领域建模。</p><ul><li>接着，每次添加新功能的时候，一方面要满足当前的需求，另一方面业务相关的<strong>领域建模设计</strong>刚刚满足需求，从而使设计最简化、代码最少。</li><li>这样的设计过程叫<strong>小步快跑</strong>。采用小步快跑的设计方法，一开始不用思考那么多问题，从简单问题开始逐步深入。<strong>领域模型</strong>就像小树一样一点儿一点儿成长，最后完成所有的功能。</li></ul><blockquote><p>保持软件设计不退化的关键在于每次需求变更的设计，只有保证每次需求变更时做出正确的设计，才能保证软件以一种良性循环的方式不断维护下去。</p></blockquote><p>​    有没有一种方法，让我们在第十次变更、第二十次变更、第三十次变更时，依然能够找到正确的设计呢？有，那就是<strong>领域驱动设计</strong></p><p>​    那么在每次需求变更时，将变更还原到真实世界中，看看真实世界是什么样子的，根据真实世界进行变更。</p><h3 id="5、战略建模"><a href="#5、战略建模" class="headerlink" title="5、战略建模"></a>5、战略建模</h3><p>​    <img src="https://tva1.sinaimg.cn/large/008i3skNly1gq6jet6kizj310c0ngtp4.jpg" alt="image-20210504174616848" style="zoom:50%;"></p><h3 id="6、相关名词"><a href="#6、相关名词" class="headerlink" title="6、相关名词"></a><strong>6、相关名词</strong></h3><p><strong>领域和子域（Domain/Subdomain）</strong></p><p>​    在<strong>上下文地图</strong>构建的领域中，对应模块，使用<strong>限界上下文</strong>划分领域，对应微服务</p><p><strong>限界上下文（Bounded Context）</strong></p><p>​    在一个领域/子域中，有概念上的领域边界，任何<strong>领域对象</strong>在该边界内部的有不依赖外部的确切含义。</p><p><strong>领域对象</strong></p><p>​    服务、实体与值对象是领域驱动设计的领域对象，可以通过<strong>贫血模型</strong>和<strong>充血模型</strong>转换为程序设计</p><p><strong>实体和值对象</strong></p><p>​    通过一个<strong>唯一标识字段来区分</strong>真实世界中的每一个个体的领域对象，称为实体。真实世界中那些<strong>一成不变的</strong>、本质性的事物的领域对象，称为值对象。    <strong>可变性</strong>是实体的特点，而<strong>不变性</strong>则是值对象的本质。</p><p><strong>贫血模型与充血模型</strong></p><p>​    POJO对象中只保存get/set方法，没有任何业务逻辑，这样的设计被称为<strong>贫血模型</strong></p><p>​    <strong>充血模型</strong>是封装和继承思想的体现，门禁设备实体中，包含特征值下发、广告下发、通行记录回调等方法，不同厂商的实体针对多态进行<strong>聚合</strong>，并通过<strong>工厂或仓库</strong>对外提供服务。在充血模型中， Service 只干一件非常简单的事，就是直接去调用对象中的<strong>工厂方法</strong>生成不同产品，其他的什么都不干。</p><p><strong>聚合</strong></p><p>​    聚合体现的是一种<strong>整体与部分</strong>的关系。正是因为有这样的关系，在操作整体的时候，整体就封装了对部分的操作。如何正确理解是否存在聚合的关系：就是当<strong>整体不存在</strong>时，部分就变得<strong>没有了意义</strong>。部分是整体的一个部分，与<strong>整体有相同的生命周期</strong>。</p><p><strong>工厂</strong></p><p><strong>通过装配，创建领域对象，是领域对象生命周期的起点。</strong>譬如，系统要通过 ID 装载一个访客申请：</p><ol><li><p>表单工厂分别调用表单信息DAO、表单明细 DAO 和用户DAO 去进行查询；</p></li><li><p>将得到的表单明细对象、用户对象进行装配，分别 set 到<strong>表单信息对象</strong>的<strong>表单明细</strong>与<strong>用户属性</strong>中；</p></li><li>最后，表单工厂将装配好的表单对象返回给表单仓库。</li></ol><p><strong>仓库</strong></p><p>​    如果服务器是一个非常强大的服务器，那么我们不需要任何数据库。系统创建的所有领域对象都放在仓库中，当需要这些对象时，通过 ID 到仓库中去获取。</p><ul><li><p>当客户程序通过 ID 去获取某个领域对象时，仓库会通过这个 ID 先到<strong>缓存中进行查找</strong>：</p></li><li><p>查找到了，则<strong>直接返回</strong>，不需要查询数据库；</p></li><li><p>没有找到，则通知工厂，工厂调用 DAO 去数据库中查询，然后<strong>装配成领域对象返回给仓库</strong>。</p></li><li><p>仓库在收到这个领域对象以后，在返回给客户程序的同时，将该<strong>对象放到缓存中</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计划大纲</title>
      <link href="/2022/01/22/%E8%AE%A1%E5%88%92%E5%A4%A7%E7%BA%B2/"/>
      <url>/2022/01/22/%E8%AE%A1%E5%88%92%E5%A4%A7%E7%BA%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="一、基础篇"><a href="#一、基础篇" class="headerlink" title="一、基础篇"></a>一、基础篇</h1><h2 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础"></a>网络基础</h2><h3 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a><strong>TCP三次握手</strong></h3><p>​    <strong>三次握手过程：</strong></p><p>​        客户端——发送带有SYN标志的数据包——服务端       <strong>一次握手</strong>  Client进入syn_sent状态</p><p>​        服务端——发送带有SYN/ACK标志的数据包——客户端   <strong>二次握手</strong>  服务端进入syn_rcvd</p><p>​        客户端——发送带有ACK标志的数据包——服务端               <strong>三次握手</strong>   连接就进入Established状态</p><p>​    <strong>为什么三次：</strong></p><p>​        主要是为了建立可靠的通信信道，保证客户端与服务端同时具备发送、接收数据的能力</p><p>​    <strong>为什么两次不行？</strong></p><p>​        1、防止已失效的请求报文又传送到了服务端，建立了多余的链接，浪费资源</p><p>​        2、 两次握手只能保证单向连接是畅通的。（为了实现可靠数据传输， TCP 协议的通信双方， 都必须维    护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方    相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤；如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认）</p><p><strong>TCP四次挥手过程 </strong></p><p><strong>四次挥手过程：</strong></p><p>​    客户端——发送带有FIN标志的数据包——服务端，关闭与服务端的连接 ，客户端进入FIN-WAIT-1状态</p><p>​    服务端收到这个 FIN，它发回⼀ 个 ACK，确认序号为收到的序号加1，服务端就进入了CLOSE-WAIT状态</p><p>​    服务端——发送⼀个FIN数据包——客户端，关闭与客户端的连接，客户端就进入FIN-WAIT-2状态</p><p>​    客户端收到这个 FIN，发回 ACK 报⽂确认，并将确认序号设置为收到序号加1，TIME-WAIT状态</p><p><strong>为什么四次：</strong></p><p>​    因为需要确保客户端与服务端的数据能够完成传输。</p><p><strong>CLOSE-WAIT：</strong></p><p>​    这种状态的含义其实是表示在等待关闭</p><p><strong>TIME-WAIT：</strong></p><p>​    为了解决网络的丢包和网络不稳定所带来的其他问题，确保连接方能在时间范围内，关闭自己的连接</p><p><strong>如何查看TIME-WAIT状态的链接数量？</strong>        </p><p>​    netstat -an |grep TIME_WAIT|wc -l  查看连接数等待time_wait状态连接数</p><p><strong>为什么会TIME-WAIT过多？解决方法是怎样的？</strong></p><p>​    <strong>可能原因：</strong> 高并发短连接的TCP服务器上，当服务器处理完请求后立刻按照主动正常关闭连接</p><p>​    <strong>解决：</strong>负载均衡服务器；Web服务器首先关闭来自负载均衡服务器的连接</p><h4 id="1、OSI与TCP-IP-模型"><a href="#1、OSI与TCP-IP-模型" class="headerlink" title="1、OSI与TCP/IP 模型"></a><strong>1、OSI与TCP/IP 模型</strong></h4><p>​        OSI七层：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层</p><p>​        TCP/IP五层：物理层、数据链路层、网络层、传输层、应用层</p><h4 id="2、常见网络服务分层"><a href="#2、常见网络服务分层" class="headerlink" title="2、常见网络服务分层"></a><strong>2、常见网络服务分层</strong></h4><p>​        应用层：HTTP、SMTP、DNS、FTP</p><p>​        传输层：TCP 、UDP</p><p>​        网络层：ICMP 、IP、路由器、防火墙</p><p>​        数据链路层：网卡、网桥、交换机</p><p>​        物理层：中继器、集线器</p><h4 id="3、TCP与UDP区别及场景"><a href="#3、TCP与UDP区别及场景" class="headerlink" title="3、TCP与UDP区别及场景"></a><strong>3、TCP与UDP区别及场景</strong></h4><table><thead><tr><th>类型</th><th style="text-align:center">特点</th><th style="text-align:center">性能</th><th style="text-align:center">应用过场景</th><th style="text-align:center">首部字节</th><th></th></tr></thead><tbody><tr><td>TCP</td><td style="text-align:center">面向连接、可靠、字节流</td><td style="text-align:center">传输效率慢、所需资源多</td><td style="text-align:center">文件、邮件传输</td><td style="text-align:center">20-60</td><td></td></tr><tr><td>UDP</td><td style="text-align:center">无连接、不可靠、数据报文段</td><td style="text-align:center">传输效率快、所需资源少</td><td style="text-align:center">语音、视频、直播</td><td style="text-align:center">8个字节</td></tr></tbody></table><p>​    <strong>基于TCP的协议：</strong>HTTP、FTP、SMTP</p><p>​    <strong>基于UDP的协议：</strong>RIP、DNS、SNMP</p><h4 id="4、TCP滑动窗口，拥塞控制"><a href="#4、TCP滑动窗口，拥塞控制" class="headerlink" title="4、TCP滑动窗口，拥塞控制"></a><strong>4、TCP滑动窗口，拥塞控制</strong></h4><p>​        <strong>TCP通过：</strong>应用数据分割、对数据包进行编号、校验和、流量控制、拥塞控制、超时重传等措施保证数据的可靠传输；</p><p>​        <strong>拥塞控制目的：</strong>为了防止过多的数据注入到网络中，避免网络中的路由器、链路过载</p><p>​        <strong>拥塞控制过程：</strong>TCP维护一个拥塞窗口，该窗口随着网络拥塞程度动态变化，通过慢开始、拥塞避免等算法减少网络拥塞的发生。</p><h4 id="5、TCP粘包原因和解决方法"><a href="#5、TCP粘包原因和解决方法" class="headerlink" title="5、TCP粘包原因和解决方法"></a><strong>5、TCP粘包原因和解决方法</strong></h4><p>​    <strong>TCP粘包是指</strong>：发送方发送的若干包数据到接收方接收时粘成一包</p><p>​    <strong>发送方原因：</strong></p><p>​        TCP默认使用Nagle算法（主要作用：减少网络中报文段的数量）：</p><p>​            收集多个小分组，在一个确认到来时一起发送、导致发送方可能会出现粘包问题</p><p>​    <strong>接收方原因：</strong></p><p>​            TCP将接收到的数据包保存在接收缓存里，如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</p><p>​    <strong>解决粘包问题：</strong></p><p>​        最本质原因在与接收对等方无法分辨消息与消息之间的边界在哪，通过使用某种方案给出边界，例如：</p><ul><li><p>发送定长包。每个消息的大小都是一样的，接收方只要累计接收数据，直到数据等于一个定长的数值就将它作为一个消息。</p></li><li><p>包尾加上\r\n标记。FTP协议正是这么做的。但问题在于如果数据正文中也含有\r\n，则会误判为消息的边界。</p></li><li><p>包头加上包体长度。包头是定长的4个字节，说明了包体的长度。接收对等方先接收包体长度，依据包体长度来接收包体。</p></li></ul><h4 id="6、TCP、UDP报文格式"><a href="#6、TCP、UDP报文格式" class="headerlink" title="6、TCP、UDP报文格式"></a><strong>6、TCP、UDP报文格式</strong></h4><p>​    <strong>TCP报文格式：</strong></p><p>​        <img src="https://farm1.staticflickr.com/792/27194088468_4cb0141fc8_b.jpg" style="zoom: 67%;"></p><p>​    <strong>源端口号和目的端口号</strong>：</p><p>​        用于寻找发端和收端应用进程。这两个值加上ip首部源端ip地址和目的端ip地址唯一确定一个tcp连接。</p><p>​    <strong>序号字段：</strong></p><p>​        序号用来标识从T C P发端向T C P收端发送的数据字节流，它表示在这个报文段中的的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则 T C P用序号对每个字节进行计数。序号是32 bit的无符号数，序号到达 2^32-1后又从0开始。</p><p>　　当建立一个新的连接时，SYN标志变1。序号字段包含由这个主机选择的该连接的初始序号ISN（Initial Sequence Number）。该主机要发送数据的第一个字节序号为这个ISN加1，因为SYN标志消耗了一个序号</p><p>​    <strong>确认序号</strong>：</p><p>​        既然每个传输的字节都被计数，确认序号包含发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加 1。只有ACK标志为 1时确认序号字段才有效。发送ACK无需任何代价，因为 32 bit的确认序号字段和A C K标志一样，总是T C P首部的一部分。因此，我们看到一旦一个连接建立起来，这个字段总是被设置， ACK标志也总是被设置为1。TCP为应用层提供全双工服务。这意味数据能在两个方向上独立地进行传输。因此，连接的每一端必须保持每个方向上的传输数据序号。</p><p>​    <strong>首都长度</strong>：</p><p>​        首部长度给出首部中 32 bit字的数目。需要这个值是因为任选字段的长度是可变的。这个字段占4 bit，因此T C P最多有6 0字节的首部。然而，没有任选字段，正常的长度是 2 0字节。</p><p>​    <strong>标志字段</strong>：在T C P首部中有 6个标志比特。它们中的多个可同时被设置为1.<br>　　URG紧急指针（u rgent pointer）有效<br>　　ACK确认序号有效。<br>　　PSH接收方应该尽快将这个报文段交给应用层。<br>　　RST重建连接。<br>　　SYN同步序号用来发起一个连接。这个标志和下一个标志将在第 1 8章介绍。<br>　　FIN发端完成发送任务。</p><p>​    <strong>窗口大小</strong>：</p><p>​        T C P的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数，起始于确认序号字段指明的值，这个值是接收端期望接收的字节。窗口大小是一个 16 bit字段，因而窗口大小最大为 65535字节。</p><p>​    <strong>检验和：</strong></p><p>​        检验和覆盖了整个的 T C P报文段：T C P首部和T C P数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</p><p>​    <strong>紧急指针</strong>：</p><p>​        只有当URG标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。 T C P的紧急方式是发送端向另一端发送紧急数据的一种方式。</p><p>​    <strong>选项</strong>：</p><p>​        最常见的可选字段是最长报文大小，又称为 MSS (Maximum Segment Size)。每个连接方通常都在通信的第一个报文段（为建立连接而设置 S Y N标志的那个段）中指明这个选项。它指明本端所能接收的最大长度的报文段。</p><p>​    <strong>UDP报文格式：</strong></p><p>​    <img src="https://appwk.baidu.com/naapi/doc/view?ih=482&o=png_6_0_0_176_917_504_247_892.979_1262.879&iw=986&ix=0&iy=0&aimw=986&rn=1&doc_id=182d935c3186bceb18e8bb77&pn=1&sign=b88bda03b9954e506622f97b8b2ae438&type=1&app_ver=2.9.8.2&ua=bd_800_800_IncredibleS_2.9.8.2_2.3.7&bid=1&app_ua=IncredibleS&uid=&cuid=&fr=3&Bdi_bear=WIFI&from=3_10000&bduss=&pid=1&screen=800_800&sys_ver=2.3.7" style="zoom:50%;"></p><p>​    <strong>端口号</strong>：</p><p>​        用来表示发送和接受进程。由于 I P层已经把I P数据报分配给T C P或U D P（根据I P首部中协议字段值），因此T C P端口号由T C P来查看，而 U D P端口号由UDP来查看。T C P端口号与UDP端口号是相互独立的。</p><p>​    <strong>长度</strong>：</p><p>​        UDP长度字段指的是UDP首部和UDP数据的字节长度。该字段的最小值为 8字节（发送一份0字节的UDP数据报是 O K）。</p><p>​    <strong>检验和</strong>：</p><p>​        UDP检验和是一个端到端的检验和。它由发送端计算，然后由接收端验证。其目的是为了发现UDP首部和数据在发送端到接收端之间发生的任何改动。</p><p>​    <strong>IP报文格式：</strong>普通的IP首部长为20个字节，除非含有可选项字段。</p><p>​                <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1614312792,1954581760&fm=26&gp=0.jpg" style="zoom:67%;"></p><p>​    <strong>4位版本</strong>：</p><p>​        目前协议版本号是4，因此IP有时也称作IPV4.</p><p>​    <strong>4位首部长度</strong>：</p><p>​        首部长度指的是首部占32bit字的数目，包括任何选项。由于它是一个4比特字段，因此首部长度最长为60个字节。</p><p>​    <strong>服务类型（TOS）</strong>：</p><p>​        服务类型字段包括一个3bit的优先权字段（现在已经被忽略），4bit的TOS子字段和1bit未用位必须置0。4bit的TOS分别代表：最小时延，最大吞吐量，最高可靠性和最小费用。4bit中只能置其中1比特。如果所有4bit均为0，那么就意味着是一般服务。</p><p>​    <strong>总长度</strong>：</p><p>​        总长度字段是指整个IP数据报的长度，以字节为单位。利用首部长度和总长度字段，就可以知道IP数据报中数据内容的起始位置和长度。由于该字段长16bit，所以IP数据报最长可达65535字节。当数据报被分片时，该字段的值也随着变化。</p><p>​    <strong>标识字段</strong>：</p><p>​        标识字段唯一地标识主机发送的每一份数据报。通常每发送一份报文它的值就会加1。</p><p>​    <strong>生存时间</strong>：</p><p>​        TTL（time-to-live）生存时间字段设置了数据报可以经过的最多路由器数。它指定了数据报的生存时间。TTL的初始值由源主机设置（通常为 3 2或6 4），一旦经过一个处理它的路由器，它的值就减去 1。当该字段的值为 0时，数据报就被丢弃，并发送 ICMP 报文通知源主机。</p><p>​    <strong>首部检验和</strong>：</p><p>​        首部检验和字段是根据 I P首部计算的检验和码。它不对首部后面的数据进行计算。 ICMP、IGMP、UDP和TCP在它们各自的首部中均含有同时覆盖首部和数据检验和码。</p><p>​    <strong>以太网报文格式：</strong></p><p><img src="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=2733576797,55677727&amp;fm=26&amp;gp=0.jpg" alt></p><p>​    <strong>目的地址和源地址：</strong></p><p>​        是指网卡的硬件地址（也叫MAC 地址），长度是48 位，是在网卡出厂时固化的。</p><p>​    <strong>数据：</strong></p><p>​        以太网帧中的数据长度规定最小46 字节，最大1500 字节，ARP 和RARP 数据包的长度不够46 字节，要在后面补填充位。最大值1500 称为以太网的最大传输单元（MTU），不同的网络类型有不同的MTU，如果一个数据包从以太网路由到拨号链路上，数据包度大于拨号链路的MTU了，则需要对数据包进行分片fragmentation）。ifconfig 命令的输出中也有“MTU:1500”。注意，MTU 个概念指数据帧中有效载荷的最大长度，不包括帧首部的长度。</p><h3 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a><strong>HTTP协议</strong></h3><h4 id="1、HTTP协议1-0-1-1-2-0"><a href="#1、HTTP协议1-0-1-1-2-0" class="headerlink" title="1、HTTP协议1.0_1.1_2.0"></a>1、HTTP协议1.0_1.1_2.0</h4><p>​    <strong>HTTP1.0：</strong>服务器处理完成后立即断开TCP连接（<strong>无连接</strong>），服务器不跟踪每个客户端也不记录过去的请求（<strong>无状态</strong>）</p><p>​    <strong>HTTP1.1：</strong>KeepAlived<strong>长连接</strong>避免了连接建立和释放的开销；通过Content-Length来判断当前请求数据是否已经全部接受（<strong>有状态</strong>）</p><p>​    <strong>HTTP2.0：</strong>引入二进制数据帧和流的概念，其中帧对数据进行顺序标识；因为有了序列，服务器可以<strong>并行</strong>的传输数据。</p><p>​    <strong>http1.0和http1.1的主要区别如下：</strong><br>​        1、缓存处理：1.1添加更多的缓存控制策略（如：Entity tag，If-Match）<br>​        2、网络连接的优化：1.1支持断点续传<br>​        3、错误状态码的增多：1.1新增了24个错误状态响应码，丰富的错误码更加明确各个状态<br>​        4、Host头处理：支持Host头域，不在以IP为请求方标志<br>​        5、长连接：减少了建立和关闭连接的消耗和延迟。</p><p>​    <strong>http1.1和http2.0的主要区别：</strong><br>​        1、新的传输格式：2.0使用二进制格式，1.0依然使用基于文本格式<br>​        2、多路复用：连接共享，不同的request可以使用同一个连接传输（最后根据每个request上的id号组合成正常的请求）<br>​        3、header压缩：由于1.X中header带有大量的信息，并且得重复传输，2.0使用encoder来减少需要传输的hearder大小<br>​        4、服务端推送：同google的SPDUY（1.0的一种升级）一样</p><h4 id="2、HTTP与HTTPS之间的区别"><a href="#2、HTTP与HTTPS之间的区别" class="headerlink" title="2、HTTP与HTTPS之间的区别"></a>2、HTTP与HTTPS之间的区别</h4><p>​        <strong>HTTP与HTTPS之间的区别：</strong></p><table><thead><tr><th style="text-align:center">HTTP</th><th style="text-align:center">HTTPS</th></tr></thead><tbody><tr><td style="text-align:center">默认端口80</td><td style="text-align:center">HTTPS默认使用端口443</td></tr><tr><td style="text-align:center">明文传输、数据未加密、安全性差</td><td style="text-align:center">传输过程ssl加密、安全性较好</td></tr><tr><td style="text-align:center">响应速度快、消耗资源少</td><td style="text-align:center">响应速度较慢、消耗资源多、需要用到CA证书</td></tr></tbody></table><p>​        <strong>HTTPS链接建立的过程：</strong></p><p>​            1.首先客户端先给服务器发送一个请求</p><p>​            2.服务器发送一个SSL证书给客户端，内容包括：证书的发布机构、有效期、所有者、签名以及公钥</p><p>​            3.客户端对发来的公钥进行真伪校验，校验为真则使用公钥对对称加密算法以及对称密钥进行加密</p><p>​            4.服务器端使用私钥进行解密并使用对称密钥加密确认信息发送给客户端</p><p>​            5.随后客户端和服务端就使用对称密钥进行信息传输</p><p>​        <strong>对称加密算法：</strong></p><p>​            双方持有相同的密钥，且加密速度快，典型对称加密算法：DES、AES</p><p>​        <strong>非对称加密算法：</strong></p><p>​            密钥成对出现（私钥、公钥），私钥只有自己知道，不在网络中传输；而公钥可以公开。相比对称加密速度较慢，典型的非对称加密算法有：RSA、DSA</p><h4 id="3、Get和Post请求区别"><a href="#3、Get和Post请求区别" class="headerlink" title="3、Get和Post请求区别"></a><strong>3、Get和Post请求区别</strong></h4><p><strong>HTTP请求：</strong></p><table><thead><tr><th style="text-align:left">方法</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">GET</td><td>向特定资源发送请求，查询数据，并返回实体</td></tr><tr><td style="text-align:left">POST</td><td>向指定资源提交数据进行处理请求，可能会导致新的资源建立、已有资源修改</td></tr><tr><td style="text-align:left">PUT</td><td>向服务器上传新的内容</td></tr><tr><td style="text-align:left">HEAD</td><td>类似GET请求，返回的响应中没有具体的内容，用于获取报头</td></tr><tr><td style="text-align:left">DELETE</td><td>请求服务器删除指定标识的资源</td></tr><tr><td style="text-align:left">OPTIONS</td><td>可以用来向服务器发送请求来测试服务器的功能性</td></tr><tr><td style="text-align:left">TRACE</td><td>回显服务器收到的请求，用于测试或诊断</td></tr><tr><td style="text-align:left">CONNECT</td><td>HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器</td></tr></tbody></table><p><strong>get和Post区别：</strong></p><table><thead><tr><th></th><th>GET</th><th>POST</th></tr></thead><tbody><tr><td>可见性</td><td>数据在URL中对所有人可见</td><td>数据不会显示在URL中</td></tr><tr><td>安全性</td><td>与post相比，get的安全性较差，因为所<br>发送的数据是URL的一部分</td><td>安全，因为参数不会被保存在浏览器<br>历史或web服务器日志中</td></tr><tr><td>数据长度</td><td>受限制，最长2kb</td><td>无限制</td></tr><tr><td>编码类型</td><td>application/x-www-form-urlencoded</td><td>multipart/form-data</td></tr><tr><td>缓存</td><td>能被缓存</td><td>不能被缓存</td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="4、HTTP常见响应状态码"><a href="#4、HTTP常见响应状态码" class="headerlink" title="4、HTTP常见响应状态码"></a><strong>4、HTTP常见响应状态码</strong></h4><p>​        100：Continue — 继续。客户端应继续其请求。</p><p>​        200：OK — 请求成功。一般用于GET与POST请求。</p><p>​        301：Moved Permanently — 永久重定向。</p><p>​        302：Found — 暂时重定向。</p><p>​        400：Bad Request — 客户端请求的语法错误，服务器无法理解。</p><p>​        403：Forbideen — 服务器理解请求客户端的请求，但是拒绝执行此请求。</p><p>​        404：Not Found — 服务器无法根据客户端的请求找到资源（网页）。</p><p>​        500：Internal Server Error — 服务器内部错误，无法完成请求。</p><p>​        502：Bad Gateway — 作为网关或者代理服务器尝试执行请求时，从远程服务器接收到了无效的响应。</p><h4 id="5、重定向和转发区别"><a href="#5、重定向和转发区别" class="headerlink" title="5、重定向和转发区别"></a><strong>5、重定向和转发区别</strong></h4><p>​    <strong>重定向：redirect：</strong></p><p>​            地址栏发生变化    </p><p>​            重定向可以访问其他站点（服务器）的资源</p><p>​            重定向是两次请求。不能使用request对象来共享数据</p><p>​    <strong>转发：forward：</strong></p><p>​            转发地址栏路径不变</p><p>​            转发只能访问当前服务器下的资源</p><p>​            转发是一次请求，可以使用request对象共享数据</p><h4 id="6、Cookie和Session区别。"><a href="#6、Cookie和Session区别。" class="headerlink" title="6、Cookie和Session区别。"></a><strong>6、Cookie和Session区别。</strong></h4><p>​    Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但两者有所区别：</p><p>​            Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>​            cookie不是很安全，别人可以分析存放在本地的COOKIE并进行欺骗,考虑到安全应当使用session。</p><p>​            Cookie ⼀般⽤来保存⽤户信息，Session 的主要作⽤就是通过服务端记录⽤户的状态</p><h3 id="浏览器输入URL过程"><a href="#浏览器输入URL过程" class="headerlink" title="浏览器输入URL过程"></a><strong>浏览器输入URL过程</strong></h3><p>​    <strong>过程：</strong>DNS解析、TCP连接、发送HTTP请求、服务器处理请求并返回HTTP报文、浏览器渲染、结束</p><table><thead><tr><th>过程</th><th>使用的协议</th></tr></thead><tbody><tr><td>1、浏览器查找域名DNS的IP地址<br>DNS查找过程（浏览器缓存、路由器缓存、DNS缓存）</td><td>DNS：获取域名对应的ip</td></tr><tr><td>2、根据ip建立TCP连接</td><td>TCP：与服务器建立连接</td></tr><tr><td>3、浏览器向服务器发送HTTP请求</td><td>HTTP：发送请求</td></tr><tr><td>4、服务器响应HTTP响应</td><td>HTTP</td></tr><tr><td>5、浏览器进行渲染</td></tr></tbody></table><h2 id="操作系统基础"><a href="#操作系统基础" class="headerlink" title="操作系统基础"></a><strong>操作系统基础</strong></h2><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a><strong>进程和线程的区别</strong></h3><p>​        <strong>进程：</strong>是资源分配的最小单位，一个进程可以有多个线程，多个线程共享进程的堆和方法区资源，不共享栈、程序计数器</p><p>​        <strong>线程：</strong>是任务调度和执行的最小单位，线程并行执行存在资源竞争和上下文切换的问题</p><p>​        <strong>协程：</strong>是一种比线程更加轻量级的存在，正如一个进程可以拥有多个线程一样，一个线程可以拥有多个协程。</p><h4 id="1、进程间通信方式IPC"><a href="#1、进程间通信方式IPC" class="headerlink" title="1、进程间通信方式IPC"></a><strong>1、进程间通信方式IPC</strong></h4><p><strong>管道pipe：</strong></p><p>​        亲缘关系使用匿名管道，非亲缘关系使用命名管道，管道遵循FIFO，半双工，数据只能单向通信；</p><p><strong>信号：</strong></p><p>​        信号是一种比较复杂的通信方式，用户调用kill命令将信号发送给其他进程。</p><p><strong>消息队列：</strong></p><p>​        消息队列克服了信号传递信息少，管道只能承载无格式字节流以及缓冲区大小受限等特点。</p><p><strong>共享内存(share memory)：</strong></p><ul><li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li><li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li></ul><p><strong>信号量(Semaphores) ：</strong></p><p>​        信号量是⼀个计数器，⽤于多进程对共享数据的访问，这种通信⽅式主要⽤于解决与同步相关的问题并避免竞争条件。</p><p><strong>套接字(Sockets) :</strong> </p><p>​        简单的说就是通信的两⽅的⼀种约定，⽤套接字中的相关函数来完成通信过程。</p><h4 id="2、用户态和核心态"><a href="#2、用户态和核心态" class="headerlink" title="2、用户态和核心态"></a><strong>2、用户态和核心态</strong></h4><p><strong>用户态：</strong>只能受限的访问内存，运行所有的应用程序</p><p><strong>核心态：</strong>运行操作系统程序，cpu可以访问内存的所有数据，包括外围设备</p><p><strong>为什么要有用户态和内核态：</strong></p><p>​        由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络</p><p><strong>用户态切换到内核态的3种方式：</strong></p><p>​    <strong>a. 系统调用</strong></p><p>​        主动调用，系统调用的机制其核心还是使用了操作系统为用户特别开放的一个中断来实现，例如Linux的int 80h中断。</p><p>​    <strong>b. 异常</strong></p><p>​        当CPU在执行运行在用户态下的程序时，发生了某些事先不可知的异常，比如缺页异常，这时会触发切换内核态处理异常。</p><p>​    <strong>c. 外围设备的中断</strong></p><p>​        当外围设备完成用户请求的操作后，会向CPU发出相应的中断信号，这时CPU会由用户态到内核态的切换。</p><h4 id="3、操作系统的进程空间"><a href="#3、操作系统的进程空间" class="headerlink" title="3、操作系统的进程空间"></a><strong>3、操作系统的进程空间</strong></h4><p>​    栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。</p><p>​    堆区（heap）— 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。</p><p>​    静态区（static）—存放全局变量和静态变量的存储</p><p>​    代码区(text)—存放函数体的二进制代码。</p><p>​    <strong>线程共享堆区、静态区</strong></p><h3 id="操作系统内存管理"><a href="#操作系统内存管理" class="headerlink" title="操作系统内存管理"></a>操作系统内存管理</h3><p><strong>存管理方式：</strong>页式管理、段式管理、段页式管理</p><p><strong>分段管理：</strong></p><p>​        将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）</p><p><strong>分页管理：</strong></p><p>​        在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的页框，程序加载时，可以将任意一页放入内存中任意一个页框，这些页框不必连续，从而实现了离散分离。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）</p><p><strong>段页式管理：</strong></p><p>​        段⻚式管理机制结合了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的</p><h4 id="1、页面置换算法FIFO、LRU"><a href="#1、页面置换算法FIFO、LRU" class="headerlink" title="1、页面置换算法FIFO、LRU"></a><strong>1、页面置换算法FIFO、LRU</strong></h4><p><strong>置换算法：</strong>先进先出FIFO、最近最久未使用LRU、最佳置换算法OPT</p><p><strong>先进先出FIFO:</strong></p><p>​        缺点：没有考虑到实际的页面使用频率，性能差、与通常页面使用的规则不符合，实际应用较少</p><p><strong>最近最久未使用LRU:</strong></p><p>​        原理：选择最近且最久未使用的页面进行淘汰</p><p>​        优点：考虑到了程序访问的时间局部性，有较好的性能，实际应用也比较多</p><p>​        缺点：没有合适的算法，只有适合的算法，lFU、random都可以</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @program: Java * @description: LRU最近最久未使用置换算法，通过LinkedHashMap实现 * @author: Mr.Li * @create: 2020-07-17 10:29 **/</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> LinkedHashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> cache<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//容量大小</span>    <span class="token comment" spellcheck="true">/**     *初始化构造函数     * @param capacity     */</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//缓存中不存在此key，直接返回</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//先从链表中删除</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//再把该节点放到链表末尾处</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>cache<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已经存在，在当前链表移除</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>capacity <span class="token operator">==</span> cache<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//cache已满，删除链表头位置</span>            Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> keySet <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> iterator <span class="token operator">=</span> keySet<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//插入到链表末尾</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * @program: Java * @description: LRU最近最久未使用置换算法，通过LinkedHashMap内部removeEldestEntry方法实现 * @author: Mr.Li * @create: 2020-07-17 10:59 **/</span><span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *初始化构造函数     * @param capacity     */</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75f</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> capacity<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 容量大于capacity 时就删除</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//返回key对应的value值，若不存在，返回-1</span>        <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>最佳置换算法OPT:</strong></p><p>​        原理：每次选择当前物理块中的页面在未来长时间不被访问的或未来不再使用的页面进行淘汰</p><p>​        优点：具有较好的性能，可以保证获得最低的缺页率</p><p>​        缺点：过于理想化，但是实际上无法实现（没办法预知未来的页面）</p><h4 id="2、死锁条件、解决方式。"><a href="#2、死锁条件、解决方式。" class="headerlink" title="2、死锁条件、解决方式。"></a><strong>2、死锁条件、解决方式。</strong></h4><p>​    死锁是指两个或两个以上进程在执行过程中，因争夺资源而造成的下相互等待的现象；</p><p>​    <strong>死锁的条件：</strong></p><p>​        互斥条件：进程对所分配到的资源不允许其他进程访问，若其他进程访问该资源，只能等待至占有该资源的进程释放该资源；</p><p>​        请求与保持条件：进程获得一定的资源后，又对其他资源发出请求，阻塞过程中不会释放自己已经占有的资源</p><p>​        非剥夺条件：进程已获得的资源，在未完成使用之前，不可被剥夺，只能在使用后自己释放</p><p>​        循环等待条件：系统中若干进程组成环路，环路中每个进程都在等待相邻进程占用的资源</p><p>​    <strong>解决方法：</strong>破坏死锁的任意一条件</p><p>​        乐观锁，破坏资源互斥条件，<strong>CAS</strong></p><p>​        资源一次性分配，从而剥夺请求和保持条件、<strong>tryLock</strong></p><p>​        可剥夺资源：即当进程新的资源未得到满足时，释放已占有的资源，从而破坏不可剥夺的条件，<strong>数据库deadlock超时</strong></p><p>​        资源有序分配法：系统给每类资源赋予一个序号，每个进程按编号递增的请求资源，从而破坏环路等待的条件，<strong>转账场景</strong></p><h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a><strong>Java基础</strong></h2><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><p><strong>特性：</strong>封装、继承、多态</p><p>​    <strong>封装：</strong>对抽象的事物抽象化成一个对象，并对其对象的属性私有化，同时提供一些能被外界访问属性的方法；</p><p>​    <strong>继承</strong>：子类扩展新的数据域或功能，并复用父类的属性与功能，单继承，多实现；</p><p>​    <strong>多态：</strong>通过继承（多个⼦类对同⼀⽅法的重写）、也可以通过接⼝（实现接⼝并覆盖接⼝）</p><h4 id="1、Java与C-区别"><a href="#1、Java与C-区别" class="headerlink" title="1、Java与C++区别"></a><strong>1、Java与C++区别</strong></h4><p>​    不同点：c++支持多继承，并且有指针的概念，由程序员自己管理内存；Java是单继承，可以用接口实现多继承，Java 不提供指针来直接访问内存，程序内存更加安全，并且Java有JVM⾃动内存管理机制，不需要程序员⼿动释放⽆⽤内存</p><h4 id="2、多态实现原理"><a href="#2、多态实现原理" class="headerlink" title="2、多态实现原理"></a><strong>2、多态实现原理</strong></h4><p>多态的底层实现是动态绑定，即在运行时才把方法调用与方法实现关联起来。</p><p><strong>静态绑定与动态绑定：</strong></p><p>​    一种是在编译期确定，被称为静态分派，比如方法的重载；</p><p>​    一种是在运行时确定，被称为动态分派，比如方法的覆盖（重写）和接口的实现。</p><p><strong>多态的实现</strong></p><p>​        虚拟机栈中会存放当前方法调用的栈帧（局部变量表、操作栈、动态连接 、返回地址）。多态的实现过程，就是方法调用动态分派的过程，如果子类覆盖了父类的方法，则在多态调用中，动态绑定过程会首先确定实际类型是子类，从而先搜索到子类中的方法。这个过程便是方法覆盖的本质。</p><h4 id="3、static和final关键字"><a href="#3、static和final关键字" class="headerlink" title="3、static和final关键字"></a>3、static和final关键字</h4><p><strong>static：</strong>可以修饰属性、方法</p><p>​    <strong>static修饰属性：</strong></p><p>​        类级别属性，所有对象共享一份，随着类的加载而加载（只加载一次），先于对象的创建；可以使用类名直接调用。</p><p>​    <strong>static修饰方法：</strong></p><p>​        随着类的加载而加载；可以使用类名直接调用；静态方法中，只能调用静态的成员，不可用this；</p><p><strong>final：</strong>关键字主要⽤在三个地⽅：变量、⽅法、类。</p><p>​    <strong>final修饰变量：</strong></p><p>​        如果是基本数据类型的变量，则其数值⼀旦在初始化之后便不能更改；</p><p>​        如果是引⽤类型的变量，则在对其初始化之后便不能再让其指向另⼀个对象。</p><p>​    <strong>final修饰方法：</strong></p><p>​        把⽅法锁定，以防任何继承类修改它的含义（重写）；类中所有的 private ⽅法都隐式地指定为 final。</p><p>​    <strong>final修饰类：</strong></p><p>​         final 修饰类时，表明这个类不能被继承。final 类中的所有成员⽅法都会被隐式地指定为 final ⽅法。</p><p>一个类不能被继承，除了final关键字之外，还有可以私有化构造器。（内部类无效）</p><h4 id="4、抽象类和接口"><a href="#4、抽象类和接口" class="headerlink" title="4、抽象类和接口"></a>4、抽象类和接口</h4><p><strong>抽象类：</strong>包含抽象方法的类，即使用abstract修饰的类；抽象类只能被继承，所以不能使用final修饰，抽象类不能被实例化，</p><p><strong>接口：</strong>接口是一个抽象类型，是抽象方法的集合，接口支持多继承，接口中定义的方法，默认是public abstract修饰的抽象方法</p><p><strong>相同点：</strong></p><p>​    ① 抽象类和接口都不能被实例化</p><p>​    ② 抽象类和接口都可以定义抽象方法，子类/实现类必须覆写这些抽象方法</p><p><strong>不同点：</strong></p><p>​    ① 抽象类有构造方法，接口没有构造方法</p><p>​    ③抽象类可以包含普通方法，接口中只能是public abstract修饰抽象方法（Java8之后可以）</p><p>​    ③ 抽象类只能单继承，接口可以多继承</p><p>​    ④ 抽象类可以定义各种类型的成员变量，接口中只能是public static final修饰的静态常量</p><p><strong>抽象类的使用场景：</strong></p><p>​    既想约束子类具有共同的行为（但不再乎其如何实现），又想拥有缺省的方法，又能拥有实例变量</p><p><strong>接口的应用场景：</strong></p><p>​    约束多个实现类具有统一的行为，但是不在乎每个实现类如何具体实现；实现类中各个功能之间可能没有任何联系</p><h4 id="5、泛型以及泛型擦除"><a href="#5、泛型以及泛型擦除" class="headerlink" title="5、泛型以及泛型擦除"></a>5、泛型以及泛型擦除</h4><p>参考：<a href="https://blog.csdn.net/baoyinwang/article/details/107341997" target="_blank" rel="noopener">https://blog.csdn.net/baoyinwang/article/details/107341997</a></p><p><strong>泛型：</strong></p><p>​        泛型的本质是参数化类型。这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p><p><strong>泛型擦除：</strong></p><p>​        Java的泛型是伪泛型，使用泛型的时候加上类型参数，在编译器编译生成的字节码的时候会去掉，这个过程成为类型擦除。</p><p>​        如List<string>等类型，在编译之后都会变成 List。JVM 看到的只是 List，而由泛型附加的类型信息对 JVM 来说是不可见的。</string></p><p>可以通过反射添加其它类型元素</p><h4 id="6、反射原理以及使用场景"><a href="#6、反射原理以及使用场景" class="headerlink" title="6、反射原理以及使用场景"></a><strong>6、反射原理以及使用场景</strong></h4><p><strong>Java反射：</strong></p><p>​        是指在运行状态中，对于任意一个类都能够知道这个类所有的属性和方法；并且都能够调用它的任意一个方法；</p><p><strong>反射原理：</strong></p><p>​        反射首先是能够获取到Java中的反射类的字节码，然后将字节码中的方法，变量，构造函数等映射成 相应的 Method、Filed、Constructor 等类</p><p>​    <strong>如何得到Class的实例:</strong></p><pre><code>     1.类名.class(就是一份字节码)     2.Class.forName(String className);根据一个类的全限定名来构建Class对象     3.每一个对象多有getClass()方法:obj.getClass();返回对象的真实类型</code></pre><p><strong>使用场景：</strong></p><ul><li><p><strong>开发通用框架 -</strong> 反射最重要的用途就是开发各种通用框架。很多框架（比如 Spring）都是配置化的（比如通过 XML 文件配置 JavaBean、Filter 等），为了保证框架的通用性，需要根据配置文件运行时动态加载不同的对象或类，调用不同的方法。</p></li><li><p><strong>动态代理</strong> - 在切面编程（AOP）中，需要拦截特定的方法，通常，会选择动态代理方式。这时，就需要反射技术来实现了。</p><p>JDK：spring默认动态代理，需要实现接口</p><p>CGLIB：通过asm框架序列化字节流，可配置，性能差</p></li><li><p><strong>自定义注解</strong> - 注解本身仅仅是起到标记作用，它需要利用反射机制，根据注解标记去调用注解解释器，执行行为。</p></li></ul><h4 id="7、Java异常体系"><a href="#7、Java异常体系" class="headerlink" title="7、Java异常体系"></a><strong>7、Java异常体系</strong></h4><p>​                <img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=3137389296,1222888772&fm=26&gp=0.jpg" style="zoom:67%;"></p><p>Throwable 是 Java 语言中所有错误或异常的超类。下一层分为 Error 和 Exception</p><p><strong>Error ：</strong></p><p>​        是指 java 运行时系统的内部错误和资源耗尽错误。应用程序不会抛出该类对象。如果出现了这样的错误，除了告知用户，剩下的就是尽力使程序安全的终止。</p><p><strong>Exception 包含：RuntimeException 、CheckedException</strong></p><p>编程错误可以分成三类：语法错误、逻辑错误和运行错误。</p><p><strong>语法错误</strong>（也称编译错误）是在编译过程中出现的错误，由编译器检查发现语法错误</p><p><strong>逻辑错误</strong>指程序的执行结果与预期不符，可以通过调试定位并发现错误的原因</p><p><strong>运行错误</strong>是引起程序非正常终端的错误，需要通过异常处理的方式处理运行错误</p><p><strong>RuntimeException：</strong> 运行时异常，程序应该从逻辑角度尽可能避免这类异常的发生。</p><p>​     如 NullPointerException 、 ClassCastException ； </p><p><strong>CheckedException：</strong>受检异常，程序使用trycatch进行捕捉处理</p><p>​        如IOException、SQLException、NotFoundException；</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe17hajvzj316d0lhju3.jpg" alt="JavaCollection"></p><h4 id="1、ArrayList和LinkedList"><a href="#1、ArrayList和LinkedList" class="headerlink" title="1、ArrayList和LinkedList"></a><strong>1、ArrayList和LinkedList</strong></h4><p><strong>ArrayList：</strong></p><p>​        底层基于数组实现，支持对元素进行快速随机访问，适合随机查找和遍历，不适合插入和删除。（提一句实际上）<br>​        默认初始大小为10，当数组容量不够时，会触发扩容机制（扩大到当前的1.5倍），需要将原来数组的数据复制到新的数组中；当从 ArrayList 的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。</p><p><strong>LinkedList：</strong></p><p>​        底层基于双向链表实现，适合数据的动态插入和删除；<br>​        内部提供了 List 接口中没有定义的方法，用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用。（比如jdk官方推荐使用基于linkedList的Deque进行堆栈操作）</p><p><strong>ArrayList与LinkedList区别：</strong></p><p>​        都是线程不安全的，ArrayList 适用于查找的场景，LinkedList 适用于增加、删除多的场景</p><p><strong>实现线程安全：</strong></p><p>​        可以使用原生的Vector，或者是Collections.synchronizedList(List list)函数返回一个线程安全的ArrayList集合。<br>​        建议使用concurrent并发包下的<strong>CopyOnWriteArrayList</strong>的。</p><p>​            ①<strong>Vector:</strong> 底层通过synchronize修饰保证线程安全，效率较差</p><p>​            ②<strong>CopyOnWriteArrayList：</strong>写时加锁，使用了一种叫<strong>写时复制</strong>的方法；读操作是可以不用加锁的</p><p>​            </p><h4 id="2、List遍历快速和安全失败"><a href="#2、List遍历快速和安全失败" class="headerlink" title="2、List遍历快速和安全失败"></a><strong>2、List遍历快速和安全失败</strong></h4><p><strong>①普通for循环遍历List删除指定元素</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">5</span><span class="token punctuation">)</span>        list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><strong>② 迭代遍历,用list.remove(i)方法删除元素</strong></p><pre class=" language-JAVA"><code class="language-JAVA">Iterator<Integer> it = list.iterator();while(it.hasNext()){    Integer value = it.next();    if(value == 5){        list.remove(value);    }}</code></pre><p><strong>③foreach遍历List删除元素</strong></p><pre class=" language-JAVA"><code class="language-JAVA">for(Integer i:list){    if(i==3) list.remove(i);}</code></pre><p><strong>fail—fast：</strong>快速失败</p><p>​        当异常产生时，直接抛出异常，程序终止;</p><p>​        fail-fast主要是体现在当我们在遍历集合元素的时候，经常会使用迭代器，但在迭代器遍历元素的过程中，如果集合的结构（modCount）被改变的话，就会抛出异常ConcurrentModificationException，防止继续遍历。这就是所谓的快速失败机制。</p><p><strong>fail—safe：</strong>安全失败</p><p>    采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。由于在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发ConcurrentModificationException。</p><p>    缺点：基于拷贝内容的优点是避免了ConcurrentModificationException，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>    场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><h4 id="3、详细介绍HashMap"><a href="#3、详细介绍HashMap" class="headerlink" title="3、详细介绍HashMap"></a><strong>3、详细介绍HashMap</strong></h4><p>角度：数据结构+扩容情况+put查找的详细过程+哈希函数+容量为什么始终都是2^N，JDK1.7与1.8的区别。</p><p>参考：<a href="https://www.jianshu.com/p/9fe4cb316c05" target="_blank" rel="noopener">https://www.jianshu.com/p/9fe4cb316c05</a></p><p><strong>数据结构：</strong></p><p>​        HashMap在底层数据结构上采用了数组＋链表＋红黑树，通过散列映射来存储键值对数据</p><p><strong>扩容情况：</strong></p><p>​        默认的负载因子是0.75，如果数组中已经存储的元素个数大于数组长度的75%，将会引发扩容操作。</p><p>​        【1】创建一个长度为原来数组长度<strong>两倍的新数组</strong>。</p><p>​        【2】1.7采用Entry的重新hash运算，1.8采用高于与运算。</p><p><strong>put操作步骤：</strong></p><p>​                <img src="https://s0.lgstatic.com/i/image3/M01/73/D9/CgpOIF5rDYmATP43AAB3coc0R64799.png" alt="img" style="zoom:67%;"></p><p>​    1、判断数组是否为空，为空进行初始化;</p><p>​    2、不为空，则计算 key 的 hash 值，通过(n - 1) &amp; hash计算应当存放在数组中的下标 index;</p><p>​    3、查看 table[index] 是否存在数据，没有数据就构造一个Node节点存放在 table[index] 中；</p><p>​    4、存在数据，说明发生了hash冲突(存在二个节点key的hash值一样), 继续判断key是否相等，相等，用新的value替换原数据；</p><p>​    5、若不相等，判断当前节点类型是不是树型节点，如果是树型节点，创造树型节点插入红黑树中；</p><p>​    6、若不是红黑树，创建普通Node加入链表中；判断链表长度是否大于 8，大于则将链表转换为红黑树；</p><p>​    7、插入完成之后判断当前节点数是否大于阈值，若大于，则扩容为原数组的二倍</p><p><strong>哈希函数：</strong></p><p>​     通过hash函数（优质因子31循环累加）先拿到 key 的hashcode，是一个32位的值，然后让hashcode的高16位和低16位进行<strong>异或</strong>操作。该函数也称为扰动函数，做到尽可能降低hash碰撞，通过尾插法进行插入。</p><p><strong>容量为什么始终都是2^N：</strong></p><p>​        先做对数组的⻓度取模运算，得到的余数才能⽤来要存放的位置也就是对应的数组下标。这个数组下标的计算⽅法是“  (n - 1) &amp; hash ”。（n代表数组⻓度）。方便数组的扩容和增删改时的取模。</p><p><strong>JDK1.7与1.8的区别：</strong></p><p><strong>JDK1.7 HashMap：</strong></p><p>​        底层是 <strong>数组和链表</strong> 结合在⼀起使⽤也就是链表散列。如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。扩容翻转时顺序不一致使用头插法会产生死循环，导致cpu100%</p><p><strong>JDK1.8 HashMap：</strong>    </p><p>​        底层数据结构上采用了<strong>数组＋链表＋红黑树</strong>；当链表⻓度⼤于阈值（默认为 8-泊松分布），数组的⻓度大于 64时，链表将转化为红⿊树，以减少搜索时间。（解决了tomcat臭名昭著的url参数dos攻击问题）</p><h4 id="4、ConcurrentHashMap"><a href="#4、ConcurrentHashMap" class="headerlink" title="4、ConcurrentHashMap "></a><strong>4、ConcurrentHashMap </strong></h4><p>​        可以通过<strong>ConcurrentHashMap</strong> 和 <strong>Hashtable</strong>来实现线程安全；Hashtable 是原始API类，通过synchronize同步修饰，效率低下；ConcurrentHashMap 通过分段锁实现，效率较比Hashtable要好；</p><p><strong>ConcurrentHashMap的底层实现：</strong></p><p>​        <strong>JDK1.7的 ConcurrentHashMap</strong> 底层采⽤ 分段的数组+链表 实现；采用 <strong>分段锁</strong>（Sagment） 对整个桶数组进⾏了分割分段(Segment默认16个)，每⼀把锁只锁容器其中⼀部分数据，多线程访问容器⾥不同数据段的数据，就不会存在锁竞争，提⾼并发访问率。</p><p><img src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=1035283471,1167301443&amp;fm=26&amp;gp=0.jpg" alt></p><p>​        <strong>JDK1.8的 ConcurrentHashMap</strong> 采⽤的数据结构跟HashMap1.8的结构⼀样，数组+链表/红⿊树；摒弃了Segment的概念，⽽是直接⽤ Node 数组+链表+红⿊树的数据结构来实现，通过并发控制 <strong>synchronized 和CAS</strong>来操作保证线程的安全。</p><h4 id="5、序列化和反序列化"><a href="#5、序列化和反序列化" class="headerlink" title="5、序列化和反序列化"></a><strong>5、序列化和反序列化</strong></h4><p>​        序列化的意思就是将对象的状态转化成字节流，以后可以通过这些值再生成相同状态的对象。对象序列化是对象持久化的一种实现方法，它是将对象的属性和方法转化为一种序列化的形式用于存储和传输。反序列化就是根据这些保存的信息重建对象的过程。</p><p><strong>序列化：</strong>将java对象转化为字节序列的过程。</p><p><strong>反序列化：</strong>将字节序列转化为java对象的过程。 </p><p><strong>优点：</strong></p><p>​    a、实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘上（通常存放在文件里）Redis的RDB</p><p>​    b、利用序列化实现远程通信，即在网络上传送对象的字节序列。 Google的protoBuf</p><p><strong>反序列化失败的场景：</strong></p><p>​        序列化ID：serialVersionUID不一致的时候，导致反序列化失败</p><h4 id="6、String"><a href="#6、String" class="headerlink" title="6、String"></a><strong>6、String</strong></h4><p>String 使用<strong>数组</strong>存储内容，数组使用 <strong>final</strong> 修饰，因此 String 定义的字符串的值也是<strong>不可变的</strong></p><p>StringBuffer 对方法加了同步锁，线程安全，效率略低于 StringBuilder</p><h3 id="设计模式与原则"><a href="#设计模式与原则" class="headerlink" title="设计模式与原则"></a>设计模式与原则</h3><h4 id="1、单例模式"><a href="#1、单例模式" class="headerlink" title="1、单例模式"></a>1、单例模式</h4><p>​    某个类只能生成一个实例，该实例全局访问，例如Spring容器里一级缓存里的单例池。</p><p><strong>优点</strong>：</p><p>​    <strong>唯一访问</strong>：如生成唯一序列化的场景、或者spring默认的bean类型。</p><p>​    <strong>提高性能</strong>：频繁实例化创建销毁或者耗时耗资源的场景，如连接池、线程池。</p><p><strong>缺点</strong>：</p><p>​    不适合有状态且需变更的</p><p><strong>实现方式</strong>：</p><p>​    <strong>饿汉式</strong>：线程安全速度快</p><p>​    <strong>懒汉式</strong>：双重检测锁，第一次减少锁的开销、第二次防止重复、volatile防止重排序导致实例化未完成</p><p>​    <strong>静态内部类</strong>：线程安全利用率高</p><p>​    <strong>枚举</strong>：effictiveJAVA推荐，反射也无法破坏</p><h4 id="2、工厂模式"><a href="#2、工厂模式" class="headerlink" title="2、工厂模式"></a>2、工厂模式</h4><p>​    定义一个用于创建产品的接口，由子类决定生产何种产品。</p><p><strong>优点：</strong>解耦：提供参数即可获取产品，通过配置文件可以不修改代码增加具体产品。</p><p><strong>缺点：</strong>每增加一个产品就得新增一个产品类</p><h4 id="3、抽象工厂模式"><a href="#3、抽象工厂模式" class="headerlink" title="3、抽象工厂模式"></a>3、抽象工厂模式</h4><p>​    提供一个接口，用于创建相关或者依赖对象的家族，并由此进行约束。</p><p><strong>优点：</strong>可以在类的内部对产品族进行约束</p><p><strong>缺点</strong>：假如产品族中需要增加一个新的产品，则几乎所有的工厂类都需要进行修改。</p><h2 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>构造方法可以被重载，只有当类中没有显性声明任何构造方法时，才会有默认构造方法。</p><p>构造方法没有返回值，构造方法的作用是创建新对象。</p><h3 id="初始化块"><a href="#初始化块" class="headerlink" title="初始化块"></a>初始化块</h3><p>静态初始化块的优先级最高，会最先执行，在非静态初始化块之前执行。</p><p>静态初始化块会在类第一次被加载时最先执行，因此在 main 方法之前。</p><h3 id="This"><a href="#This" class="headerlink" title="This"></a>This</h3><p>关键字 <code>this</code> 代表当前对象的引用。当前对象指的是调用类中的属性或方法的对象</p><p>关键字 <code>this</code> 不可以在静态方法中使用。静态方法不依赖于类的具体对象的引用</p><h3 id="重写和重载的区别"><a href="#重写和重载的区别" class="headerlink" title="重写和重载的区别"></a><strong>重写和重载的区别</strong></h3><p>重载指在同一个类中定义多个方法，这些方法名称相同，签名不同。</p><p>重写指在子类中的方法的名称和签名都和父类相同，使用override注解</p><h3 id="Object类方法"><a href="#Object类方法" class="headerlink" title="Object类方法"></a>Object类方法</h3><p><strong>toString</strong>     默认是个指针，一般需要重写</p><p><strong>equals</strong>        比较对象是否相同，默认和==功能一致</p><p><strong>hashCode</strong>  散列码，equals则hashCode相同，所以重写equals必须重写hashCode</p><p><strong>finalize   </strong>    用于垃圾回收之前做的遗嘱，默认空，子类需重写</p><p><strong>clone</strong>           深拷贝，类需实现cloneable的接口</p><p><strong>getClass</strong>     反射获取对象元数据，包括类名、方法、</p><p><strong>notify、wait</strong>   用于线程通知和唤醒</p><h3 id="基本数据类型和包装类"><a href="#基本数据类型和包装类" class="headerlink" title="基本数据类型和包装类"></a>基本数据类型和包装类</h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goe1gq2yipj318s0ruwj4.jpg" alt="image-20210309224910999"></p><table><thead><tr><th>类型</th><th>缓存范围</th></tr></thead><tbody><tr><td>Byte,Short,Integer,Long</td><td>[-128, 127]</td></tr><tr><td>Character</td><td>[0, 127]</td></tr><tr><td>Boolean</td><td>[false, true]</td></tr></tbody></table><h1 id="二、JVM篇"><a href="#二、JVM篇" class="headerlink" title="二、JVM篇"></a>二、JVM篇</h1><h3 id="JVM内存划分"><a href="#JVM内存划分" class="headerlink" title="JVM内存划分"></a><strong>JVM内存划分</strong></h3><h4 id="1、JVM运行时数据区域"><a href="#1、JVM运行时数据区域" class="headerlink" title="1、JVM运行时数据区域"></a><strong>1、JVM运行时数据区域</strong></h4><p>​        堆、方法区（元空间）、虚拟机栈、本地方法栈、程序计数器</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobgnw8m8uj30l10bejs4.jpg" alt="xxx"></p><p><strong>Heap(堆)：</strong></p><p>​        对象的实例以及数组的内存都是要在堆上进行分配的，堆是线程共享的一块区域，用来存放对象实例，也是垃圾回收（GC）的主要区域；开启逃逸分析后，某些未逃逸的对象可以通过标量替换的方式在栈中分配</p><p>​        堆细分：新生代、老年代，对于新生代又分为：<strong>Eden区</strong>和<strong>Surviver1</strong>和<strong>Surviver2</strong>区；</p><p><strong>方法区：</strong></p><p>​        对于JVM的方法区也可以称之为永久区，它储存的是已经被java虚拟机加载的类信息、常量、静态变量；Jdk1.8以后取消了方法区这个概念，称之为元空间（MetaSpace）；</p><p>​        当应用中的 Java 类过多时，比如 <strong>Spring 等一些使用动态代理的框架生成了很多类</strong>，如果占用空间超出了我们的设定值，就会发生<strong>元空间溢出</strong></p><p><strong>虚拟机栈：</strong></p><p>​        虚拟机栈<strong>是线程私有的</strong>，他的生命周期和线程的生命周期是一致的。里面装的是一个一个的<strong>栈帧</strong>，每一个方法在执行的时候都会创建一个栈帧，栈帧中用来存放（<strong>局部变量表</strong>、<strong>操作数栈</strong> 、<strong>动态链接</strong> 、<strong>返回地址</strong>）；在Java虚拟机规范中，对此区域规定了两种异常状况：如果线程请求的栈深度大于虚拟机所允许的深度，将会抛出<strong>StackOverflowError</strong>异常；如果虚拟机栈动态扩展时无法申请到足够的内存，就会抛出<strong>OutOfMemoryError</strong>异常。</p><ul><li><p><strong>局部变量表：</strong>局部变量表是一组变量值存储空间，用来存放<strong>方法参数</strong>、方法内部定义的<strong>局部变量</strong>。底层是变量槽（variable slot）</p></li><li><p><strong>操作数栈：</strong>是用来记录一个方法在执行的过程中，<strong>字节码指令向操作数栈中进行入栈和出栈的过程</strong>。大小在编译的时候已经确定了，当一个方法刚开始执行的时候，操作数栈中是空发的，在方法执行的过程中会有各种<strong>字节码指令</strong>往操作数栈中<strong>入栈和出栈</strong>。</p></li><li><p><strong>动态链接：</strong>因为字节码文件中有很多符号的引用，这些符号引用一部分会在<strong>类加载的解析阶段</strong>或<strong>第一次使用</strong>的时候转化成<strong>直接引用</strong>，这种称为<strong>静态解析</strong>；另一部分会<strong>在运行期间</strong>转化为直接引用，称为<strong>动态链接</strong>。</p></li><li><p><strong>返回地址（returnAddress）：</strong>类型（指向了一条字节码指令的地址）</p><p><strong>JIT即时编译器（Just In Time Compiler），简称 JIT 编译器</strong>: </p><p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，比如锁粗化等</p></li></ul><p><strong>本地方法栈：</strong></p><p>​        本地方法栈和虚拟机栈类似，不同的是虚拟机栈服务的是Java方法，而<strong>本地方法栈服务的是Native方法</strong>。在HotSpot虚拟机实现中是把本地方法栈和虚拟机栈合二为一的，同理它也会抛出<strong>StackOverflowError</strong>和<strong>OOM</strong>异常。</p><p><strong>PC程序计数器：</strong></p><p>​        PC，指的是存放下一条指令的位置的一个指针。它是一块较小的内存空间，且是<strong>线程私有</strong>的。由于线程的切换，CPU在执行的过程中，需要记住原线程的下一条指令的位置，所以每一个线程都需要有自己的PC。</p><h4 id="2、堆内存分配策略"><a href="#2、堆内存分配策略" class="headerlink" title="2、堆内存分配策略"></a><strong>2、堆内存分配策略</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjl5glvj30l10h9jrt.jpg" alt="img"></p><ul><li><p>对象优先分配在Eden区，如果Eden区没有足够的空间进行分配时，虚拟机执行一次MinorGC。而那些无需回收的存活对象，将会进到 Survivor 的 From 区（From 区内存不足时，直接进入 Old 区）。</p></li><li><p>大对象直接进入老年代（需要大量连续内存空间的对象）。这样做的目的是避免在Eden区和两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。</p></li><li><p>长期存活的对象进入老年代。虚拟机为每个对象定义了一个年龄（Age Count）计数器，如果对象经过了1次Minor GC那么对象会进入Survivor区，之后每经过一次Minor GC那么对象的年龄加1，直到达到阀值（默认15次），对象进入老年区。</p><p>（<strong>动态对象年龄判定</strong>：程序从年龄最小的对象开始累加，如果累加的对象大小，大于幸存区的一半，则将当前的对象 age 作为新的阈值，年龄大于此阈值的对象则直接进入老年代）</p></li><li><p>每次进行Minor GC或者大对象直接进入老年区时，JVM会计算所需空间大小如小于老年区的剩余值大小，则进行一次<strong>Full GC</strong>。</p></li></ul><h4 id="3、创建一个对象的步骤"><a href="#3、创建一个对象的步骤" class="headerlink" title="3、创建一个对象的步骤"></a><strong>3、创建一个对象的步骤</strong></h4><p><strong>步骤：类加载检查、分配内存、初始化零值、设置对象头、执行init方法</strong></p><p><strong>①类加载检查：</strong> </p><p>​        虚拟机遇到 new 指令时，⾸先去检查是否能在常量池中定位到这个类的符号引⽤，并且检查这个符号引⽤代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执⾏相应的类加载过程。</p><p><strong>②分配内存：</strong></p><p>​         在类加载检查通过后，接下来虚拟机将为新⽣对象分配内存，分配⽅式有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，选择那种分配⽅式由 Java 堆是否规整决定，⽽Java堆是否规整⼜由所采⽤的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>③初始化零值：</strong></p><p>​         内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，这⼀步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使⽤，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> </p><p>​        初始化零值完成之后，虚拟机要对对象进⾏必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运⾏状态的不同，如是否启⽤偏向锁等，对象头会有不同的设置⽅式。</p><p><strong>⑤执⾏ init ⽅法：</strong> </p><p>​        从虚拟机的视⻆来看，⼀个新的对象已经产⽣了，但从Java 程序的视⻆来看， <init> ⽅法还没有执⾏，所有的字段都还为零。所以⼀般来说（除循环依赖），执⾏ new 指令之后会接着执⾏  <init> ⽅法，这样⼀个真正可⽤的对象才算产⽣出来。</init></init></p><h4 id="4、对象引用"><a href="#4、对象引用" class="headerlink" title="4、对象引用"></a>4、<strong>对象引用</strong></h4><p>普通的对象引用关系就是<strong>强引用</strong>。</p><p><strong>软引用</strong>用于维护一些可有可无的对象。只有在<strong>内存不足时，系统则会回收软引用对象</strong>，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。</p><p><strong>弱引用</strong>对象相比软引用来说，要更加无用一些，它拥有更短的生命周期，当 JVM 进行垃圾回收时，<strong>无论内存是否充足</strong>，都会回收被弱引用关联的对象。</p><p><strong>虚引用</strong>是一种形同虚设的引用，在现实场景中用的不是很多，它主要用来<strong>跟踪对象被垃圾回收</strong>的活动。</p><h3 id="JVM类加载过程"><a href="#JVM类加载过程" class="headerlink" title="JVM类加载过程"></a><strong>JVM类加载过程</strong></h3><p><strong>过程：加载、验证、准备、解析、初始化</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnnbem87j30eq0cogmj.jpg" alt="img" style="zoom:50%;"></p><p><strong>加载阶段：</strong></p><p>​        1.通过一个类的全限定名来获取定义此类的二进制字节流。</p><p>​        2.将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</p><p>​        3.在Java堆中生成一个代表这个类的java.lang.class对象，作为方法区这些数据的访问入口。</p><p><strong>验证阶段：</strong></p><p>​        1.文件格式验证（是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理）</p><p>​        2.元数据验证（对字节码描述的信息进行语意分析，以保证其描述的信息符合Java语言规范要求）</p><p>​        3.字节码验证（保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）</p><p>​        4.符号引用验证（虚拟机将符号引用转化为直接引用时，解析阶段中发生）</p><p><strong>准备阶段：</strong></p><p>​        准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。将对象初始化为“零”值</p><p><strong>解析阶段：</strong></p><p>​        解析阶段时虚拟机将常量池内的符号引用替换为直接引用的过程。</p><p>​        <strong>字符串常量池</strong>：堆上，默认class文件的静态常量池</p><p>​        <strong>运行时常量池</strong>：在方法区，属于元空间</p><p><strong>初始化阶段：</strong></p><p>​        初始化阶段时加载过程的最后一步，而这一阶段也是真正意义上开始执行类中定义的Java程序代码。</p><h4 id="1、双亲委派机制"><a href="#1、双亲委派机制" class="headerlink" title="1、双亲委派机制"></a><strong>1、双亲委派机制</strong></h4><p>​        每⼀个类都有⼀个对应它的类加载器。系统中的 ClassLoder 在协同⼯作的时候会默认使⽤ 双亲委派模型 。即在类加载的时候，系统会⾸先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，⾸先会把该请求委派该⽗类加载器的  loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器  BootstrapClassLoader 中。当⽗类加载器⽆法处理时，才由⾃⼰来处理。当⽗类加载器为null时，会使⽤启动类加载器  BootstrapClassLoader 作为⽗类加载器。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobn5lh4f6j30hk08rjso.jpg" alt="img"></p><p><strong>使用好处：</strong></p><p>​        此机制保证JDK核心类的优先加载；使得Java程序的稳定运⾏，可以避免类的重复加载，也保证了 Java 的核⼼ API 不被篡改。如果不⽤没有使⽤双亲委派模型，⽽是每个类加载器加载⾃⼰的话就会出现⼀些问题，⽐如我们编写⼀个称为  java.lang.Object 类的话，那么程序运⾏的时候，系统就会出现多个不同的Object 类。</p><p><strong>破坏双亲委派机制：</strong></p><ul><li>可以⾃⼰定义⼀个类加载器，重写loadClass方法；</li><li><p>Tomcat 可以加载自己目录下的 class 文件，并不会传递给父类的加载器；</p></li><li><p>Java 的 SPI，发起者 BootstrapClassLoader 已经是最上层了，它直接获取了 AppClassLoader 进行驱动加载，和双亲委派是相反的。</p></li></ul><h4 id="2、tomcat的类加载机制"><a href="#2、tomcat的类加载机制" class="headerlink" title="2、tomcat的类加载机制"></a><strong>2、tomcat的类加载机制</strong></h4><p><strong>步骤：</strong></p><ol><li>先在本地cache查找该类是否已经加载过，看看 Tomcat 有没有加载过这个类。</li><li>如果Tomcat 没有加载过这个类，则从系统类加载器的cache中查找是否加载过。</li><li>如果没有加载过这个类，尝试用ExtClassLoader类加载器类加载，重点来了，这里并没有首先使用 AppClassLoader 来加载类。这个Tomcat 的 WebAPPClassLoader 违背了双亲委派机制，直接使用了 ExtClassLoader来加载类。这里注意 ExtClassLoader 双亲委派依然有效，ExtClassLoader 就会使用 Bootstrap ClassLoader 来对类进行加载，保证了 Jre 里面的核心类不会被重复加载。 比如在 Web 中加载一个 Object 类。WebAppClassLoader → ExtClassLoader → Bootstrap ClassLoader，这个加载链，就保证了 Object 不会被重复加载。</li><li>如果 BoostrapClassLoader，没有加载成功，就会调用自己的 findClass 方法由自己来对类进行加载，findClass 加载类的地址是自己本 web 应用下的 class。</li><li>加载依然失败，才使用 AppClassLoader 继续加载。</li><li>都没有加载成功的话，抛出异常。</li></ol><p>总结一下以上步骤，WebAppClassLoader 加载类的时候，故意打破了JVM 双亲委派机制，绕开了 AppClassLoader，直接先使用 ExtClassLoader 来加载类。</p><h3 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h3><h4 id="1、存活算法和两次标记过程"><a href="#1、存活算法和两次标记过程" class="headerlink" title="1、存活算法和两次标记过程"></a><strong>1、存活算法和两次标记过程</strong></h4><p><strong>引用计数法：</strong></p><p>​        给对象添加一个引用计数器，每当由一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p><p>​    优点：实现简单，判定效率也很高</p><p>​    缺点：他很难解决对象之间相互循环引用的问题，基本上被抛弃</p><p><strong>可达性分析法：</strong></p><p>​        通过一系列的成为“GC Roots”(活动线程相关的各种引用，虚拟机<strong>栈帧引用</strong>，<strong>静态变量引用</strong>，<strong>JNI引用</strong>)的对象作为起始点，从这些节点ReferenceChains开始向下搜索，搜索所走过的路径成为引用链，当一个对象到GC ROOTS没有任何引用链相连时，则证明此对象时不可用的；</p><p><strong>两次标记过程：</strong></p><p>​        对象被回收之前，该对象的finalize()方法会被调用；两次标记，即第一次标记不在“关系网”中的对象。第二次的话就要先判断该对象有没有实现finalize()方法了，如果没有实现就直接判断该对象可回收；如果实现了就会先放在一个队列中，并由虚拟机建立的一个低优先级的线程去执行它，随后就会进行第二次的小规模标记，在这次被标记的对象就会真正的被回收了。</p><h4 id="2、垃圾回收算法"><a href="#2、垃圾回收算法" class="headerlink" title="2、垃圾回收算法"></a><strong>2、垃圾回收算法</strong></h4><p><strong>垃圾回收算法</strong>：复制算法、标记清除、标记整理、分代收集</p><p><strong>复制算法：(young)</strong></p><p>​        将内存分为⼤⼩相同的两块，每次使⽤其中的⼀块。当这⼀块的内存使⽤完后，就将还存活的对象复制到另⼀块去，然后再把使⽤的空间⼀次清理掉。这样就使每次的内存回收都是对内存区间的⼀半进⾏回收；</p><p>​        优点：实现简单，内存效率高，不易产生碎片</p><p>​        缺点：内存压缩了一半，倘若存活对象多，Copying 算法的效率会大大降低</p><p><strong>标记清除：(cms)</strong></p><p>​        标记出所有需要回收的对象，在标记完成后统⼀回收所有被标记的对象</p><p>​        缺点：效率低，标记清除后会产⽣⼤量不连续的碎⽚，需要预留空间给分配阶段的浮动垃圾</p><p><strong>标记整理：(old)</strong></p><p>​        标记过程仍然与“标记-清除”算法⼀样，再让所有存活的对象向⼀端移动，然后直接清理掉端边界以外的内存；解决了产生大量不连续碎片问题</p><p><strong>分代收集：</strong></p><p>​        根据各个年代的特点选择合适的垃圾收集算法。</p><p>​        新生代采用复制算法，新生代每次垃圾回收都要回收大部分对象，存活对象较少，即要复制的操作比较少，一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space, To Space)，每次使用Eden 空间和其中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。</p><p>​        老年代的对象存活⼏率是⽐较⾼的，⽽且没有额外的空间对它进⾏分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进⾏垃圾收集。</p><p><strong>Safepoint</strong> 当发生 GC 时，用户线程必须全部停下来，才可以进行垃圾回收，这个状态我们可以认为 JVM 是安全的（safe），整个堆的状态是稳定的。如果在 GC 前，有线程迟迟进入不了 safepoint，那么整个 JVM 都在等待这个阻塞的线程，造成了整体 GC 的时间变长</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnmip32vj30l109q0t3.jpg" alt="img"></p><h5 id="MinorGC、MajorGC、FullGC"><a href="#MinorGC、MajorGC、FullGC" class="headerlink" title="MinorGC、MajorGC、FullGC"></a><strong>MinorGC、MajorGC、FullGC</strong></h5><p><strong>MinorGC</strong> 在年轻代空间不足的时候发生，</p><p><strong>MajorGC</strong> 指的是老年代的 GC，出现 MajorGC 一般经常伴有 MinorGC。</p><p><strong>FullGC</strong> 1、当老年代无法再分配内存的时候；2、元空间不足的时候；3、显示调用 System.gc 的时候。另外，像 CMS 一类的垃圾回收器，在 MinorGC 出现 promotion failure 的时候也会发生 FullGC。</p><p><strong>对象优先在 Eden 区分配</strong><br>    大多数情况下，对象在新生代 Eden 区分配，当 Eden 区空间不够时，发起 Minor GC。</p><p><strong>大对象直接进入老年代</strong><br>    大对象是指需要连续内存空间的对象，比如很长的字符串以及数组。老年代直接分配的<strong>目的是</strong>避免在 Eden 区和 Survivor 区之间出现大量内存复制。</p><p><strong>长期存活的对象进入老年代</strong><br>    虚拟机给每个对象定义了年龄计数器，对象在 Eden 区出生之后，如果经过一次 Minor GC 之后，将进入 Survivor 区，同时对象年龄变为 1，增加到一定阈值时则进入老年代（阈值默认为 15）</p><p><strong>动态对象年龄判定</strong><br>    为了能更好地适应不同程序的内存状况，虚拟机并不总是要求对象的年龄必须达到阈值才能进入老年代。如果在 Survivor 区中相同年龄的所有对象的空间总和大于 Survivor 区空间的一半，则年龄大于或等于该年龄的对象直接进入老年代。</p><p><strong>空间分配担保</strong><br>    在发生 Minor GC 之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象的空间总和，如果这个条件成立，那么 Minor GC 可以确保是安全的。如果不成立则进行 Full GC。</p><h4 id="3、垃圾收集器"><a href="#3、垃圾收集器" class="headerlink" title="3、垃圾收集器"></a><strong>3、垃圾收集器</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnjx3zcej30l10ctaat.jpg" alt="img"></p><p>​    <strong>JDK3：Serial Parnew 关注效率</strong></p><p><strong>Serial：</strong></p><p>​        Serial 是一个单线程的收集器，它不但只会使用一个 CPU 或一条线程去完成垃圾收集工作，并且在进行垃圾收集的同时，必须暂停其他所有的工作线程，直到垃圾收集结束。适合用于客户端垃圾收集器。</p><p><strong>Parnew：</strong></p><p>​        ParNew 垃圾收集器其实是 Serial 收集器的多线程版本，也使用复制算法，除了使用多线程进行垃圾收集之外，其余的行为和 Serial 收集器完全一样，ParNew 垃圾收集器在垃圾收集过程中同样也要暂停所有其他的工作线程。</p><p>​    <strong>JDK5：parallel Scavenge+（Serial old/parallel old）关注吞吐量</strong></p><p><strong>parallel Scavenge：</strong>(关注吞吐量)</p><p>​        Parallel Scavenge收集器关注点是吞吐量（⾼效率的利⽤CPU）。CMS等垃圾收集器的关注点更多的是⽤户线程的停顿时间（提⾼⽤户体验）；高吞吐量可以最高效率地利用 CPU 时间，尽快地完成程序的运算任务，主要适用于在后台运算而不需要太多交互的任务。</p><p><strong>Serial old：</strong></p><p>Serial收集器的⽼年代版本，它同样是⼀个单线程收集器，使用标记-整理算法。主要有两个用途：</p><ul><li><p>在 JDK1.5 之前版本中与新生代的 Parallel Scavenge 收集器搭配使用。</p></li><li><p>作为年老代中使用 CMS 收集器的后备垃圾收集方案。</p></li></ul><p><strong>parallel old：</strong></p><p>​        Parallel Scavenge收集器的⽼年代版本。使⽤多线程和“标记-整理”算法。</p><p><strong>JDK8-CMS：（关注最短垃圾回收停顿时间）</strong></p><p>​        CMS收集器是一种年老代垃圾收集器，其最主要目标是获取<strong>最短垃圾回收停顿时间</strong>，和其他年老代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p><p>​        <strong>初始标记：</strong>只是标记一下 GC Roots 能直接关联的对象，速度很快，STW。</p><p>​        <strong>并发标记：</strong>进行 ReferenceChains跟踪的过程，和用户线程一起工作，不需要暂停工作线程。</p><p>​        <strong>重新标记：</strong>为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，STW。</p><p>​        <strong>并发清除：</strong>清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</p><p>​        由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p><p>​        <strong>优点：</strong>并发收集、低停顿</p><p>​        <strong>缺点：</strong>对CPU资源敏感；⽆法处理浮动垃圾；使⽤“标记清除”算法，会导致⼤量空间碎⽚产⽣。</p><p><strong>JDK9-G1：（精准控制停顿时间，避免垃圾碎片）</strong></p><p>​        是⼀款⾯向服务器的垃圾收集器,主要针对配备多颗处理器及⼤容量内存的机器.以极⾼概率满⾜GC停顿时间要求的同时,还具备⾼吞吐量性能特征；相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p><p>​        【1】基于标记-整理算法，不产生内存碎片。</p><p>​        【2】可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</p><p>​        G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，优先回收垃圾最多的区域。<strong>区域划分</strong>和<strong>优先级区域</strong>回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。</p><ul><li><p><strong>初始标记</strong>：<strong>Stop The World，</strong>仅使用一条初始标记线程对GC Roots关联的对象进行标记</p></li><li><p><strong>并发标记</strong>：使用一条标记线程与用户线程并发执行。此过程进行<strong>可达性分析，速度很慢</strong></p></li><li><p><strong>最终标记</strong>：<strong>Stop The World</strong>，使用多条标记线程并发执行</p></li><li><p><strong>筛选回收</strong>：回收废弃对象，此时也要 <strong>Stop The World</strong>，并使用多条筛选回收线程并发执行</p></li></ul><p><strong>JDK11-ZGC:</strong>（在不关注容量的情况获取最小停顿时间5TB/10ms）</p><p>​    着色笔技术：加快标记过程</p><p>​    读屏障：解决GC和应用之间并发导致的STW问题</p><ul><li><p>支持 TB 级堆内存（最大 4T， JDK13 最大16TB）</p></li><li><p>最大 GC 停顿 10ms</p></li><li><p>对吞吐量影响最大，不超过 15%</p></li></ul><h4 id="4、配置垃圾收集器"><a href="#4、配置垃圾收集器" class="headerlink" title="4、配置垃圾收集器"></a><strong>4、配置垃圾收集器</strong></h4><ul><li>首先是内存大小问题，基本上每一个内存区域我都会设置一个上限，来避免溢出问题，比如元空间。</li><li>通常，堆空间我会设置成操作系统的 2/3，超过 8GB 的堆，优先选用 G1</li><li>然后我会对 JVM 进行初步优化，比如根据老年代的对象提升速度，来调整年轻代和老年代之间的比例</li><li>依据系统容量、访问延迟、吞吐量等进行专项优化，我们的服务是高并发的，对 STW 的时间敏感</li><li>我会通过记录详细的 GC 日志，来找到这个瓶颈点，借用 GCeasy 这样的日志分析工具，定位问题</li></ul><h4 id="4、JVM性能调优"><a href="#4、JVM性能调优" class="headerlink" title="4、JVM性能调优"></a><strong>4、JVM性能调优</strong></h4><p>对应进程的JVM状态以定位问题和解决问题并作出相应的优化</p><p><strong>常用命令：</strong>jps、jinfo、jstat、jstack、jmap</p><p><strong>jps：查看java进程及相关信息</strong></p><pre class=" language-java"><code class="language-java">jps <span class="token operator">-</span>l 输出jar包路径，类全名jps <span class="token operator">-</span>m 输出main参数jps <span class="token operator">-</span>v 输出JVM参数</code></pre><p><strong>jinfo：查看JVM参数</strong></p><pre class=" language-java"><code class="language-java">jinfo <span class="token number">11666</span>jinfo <span class="token operator">-</span>flags <span class="token number">11666</span>Xmx、Xms、Xmn、MetaspaceSize</code></pre><p><strong>jstat：查看JVM运行时的状态信息，包括内存状态、垃圾回收</strong></p><pre class=" language-java"><code class="language-java">jstat <span class="token punctuation">[</span>option<span class="token punctuation">]</span> LVMID <span class="token punctuation">[</span>interval<span class="token punctuation">]</span> <span class="token punctuation">[</span>count<span class="token punctuation">]</span>其中LVMID是进程id，interval是打印间隔时间（毫秒），count是打印次数（默认一直打印）option参数解释：<span class="token operator">-</span>gc 垃圾回收堆的行为统计<span class="token operator">-</span>gccapacity 各个垃圾回收代容量<span class="token punctuation">(</span>young<span class="token punctuation">,</span>old<span class="token punctuation">,</span>perm<span class="token punctuation">)</span>和他们相应的空间统计<span class="token operator">-</span>gcutil 垃圾回收统计概述<span class="token operator">-</span>gcnew 新生代行为统计<span class="token operator">-</span>gcold 年老代和永生代行为统计</code></pre><p><strong>jstack：查看JVM线程快照，jstack命令可以定位线程出现长时间卡顿的原因，例如死锁，死循环</strong></p><pre class=" language-java"><code class="language-java">jstack <span class="token punctuation">[</span><span class="token operator">-</span>l<span class="token punctuation">]</span> <span class="token operator">&lt;</span>pid<span class="token operator">></span> <span class="token punctuation">(</span>连接运行中的进程<span class="token punctuation">)</span>option参数解释：<span class="token operator">-</span>F 当使用jstack <span class="token operator">&lt;</span>pid<span class="token operator">></span>无响应时，强制输出线程堆栈。<span class="token operator">-</span>m 同时输出java和本地堆栈<span class="token punctuation">(</span>混合模式<span class="token punctuation">)</span><span class="token operator">-</span>l 额外显示锁信息</code></pre><p><strong>jmap：可以用来查看内存信息</strong>(配合jhat使用)</p><pre class=" language-java"><code class="language-java">jmap <span class="token punctuation">[</span>option<span class="token punctuation">]</span> <span class="token operator">&lt;</span>pid<span class="token operator">></span> <span class="token punctuation">(</span>连接正在执行的进程<span class="token punctuation">)</span>option参数解释：<span class="token operator">-</span>heap 打印java heap摘要<span class="token operator">-</span>dump<span class="token operator">:</span><span class="token operator">&lt;</span>dump<span class="token operator">-</span>options<span class="token operator">></span> 生成java堆的dump文件</code></pre><h4 id="5、JDK新特性"><a href="#5、JDK新特性" class="headerlink" title="5、JDK新特性"></a>5、JDK新特性</h4><p>JDK8</p><p>支持 Lamda 表达式、集合的 stream 操作、提升HashMap性能</p><p><strong>JDK9</strong></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//Stream API中iterate方法的新重载方法，可以指定什么时候结束迭代</span>IntStream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">,</span> i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>默认G1垃圾回收器</p><p><strong>JDK10</strong> </p><p>其重点在于通过完全GC并行来改善G1最坏情况的等待时间。</p><p><strong>JDK11</strong></p><p>ZGC (并发回收的策略) 4TB</p><p>用于 Lambda 参数的局部变量语法</p><p><strong>JDK12</strong></p><p>Shenandoah GC (GC 算法)停顿时间和堆的大小没有任何关系，并行关注停顿响应时间。</p><p><strong>JDK13</strong></p><p>增加ZGC以将未使用的堆内存返回给操作系统，16TB</p><p><strong>JDK14</strong></p><p>删除cms垃圾回收器、弃用ParallelScavenge+SerialOldGC垃圾回收算法组合</p><p>将ZGC垃圾回收器应用到macOS和windows平台</p><h3 id="线上故障排查"><a href="#线上故障排查" class="headerlink" title="线上故障排查"></a>线上故障排查</h3><h4 id="1、硬件故障排查"><a href="#1、硬件故障排查" class="headerlink" title="1、硬件故障排查"></a>1、硬件故障排查</h4><p>如果一个实例发生了问题，根据情况选择，要不要着急去重启。如果出现的CPU、内存飙高或者日志里出现了OOM异常</p><p><strong>第一步是隔离</strong>，第二步是<strong>保留现场</strong>，第三步才是<strong>问题排查</strong>。</p><p><strong>隔离</strong></p><p>就是把你的这台机器从请求列表里摘除，比如把 nginx 相关的权重设成零。</p><p><strong>现场保留</strong></p><p><strong>瞬时态和历史态</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobnwy22d2j30l10cpt9d.jpg" alt="img"></p><p>查看比如 CPU、系统内存等，通过历史状态可以体现一个趋势性问题，而这些信息的获取一般依靠监控系统的协作。           </p><p><strong>保留信息</strong></p><p>（1）<strong>系统当前网络连接</strong></p><pre><code>ss -antp &gt; $DUMP_DIR/ss.dump 2&gt;&amp;1</code></pre><p>使用 ss 命令而不是 netstat 的原因，是因为 netstat 在网络连接非常多的情况下，执行非常缓慢。</p><p>后续的处理，可通过查看各种网络连接状态的梳理，来排查 TIME_WAIT 或者 CLOSE_WAIT，或者其他连接过高的问题，非常有用。</p><p>（2）<strong>网络状态统计</strong></p><pre class=" language-java"><code class="language-java">netstat <span class="token operator">-</span>s <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>netstat<span class="token operator">-</span>s<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>它能够按照各个协议进行统计输出，对把握当时整个网络状态，有非常大的作用。</p><pre class=" language-java"><code class="language-java">sar <span class="token operator">-</span>n DEV <span class="token number">1</span> <span class="token number">2</span> <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>sar<span class="token operator">-</span>traffic<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>在一些速度非常高的模块上，比如 Redis、Kafka，就经常发生跑满网卡的情况。表现形式就是网络通信非常缓慢。</p><p>（3）<strong>进程资源</strong></p><pre class=" language-java"><code class="language-java">lsof <span class="token operator">-</span>p $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>lsof<span class="token operator">-</span>$PID<span class="token punctuation">.</span>dump</code></pre><p>通过查看进程，能看到打开了哪些文件，可以以进程的维度来查看整个资源的使用情况，包括每条网络连接、每个打开的文件句柄。同时，也可以很容易的看到连接到了哪些服务器、使用了哪些资源。这个命令在资源非常多的情况下，输出稍慢，请耐心等待。</p><p>（4）<strong>CPU 资源</strong></p><pre><code>mpstat &gt; $DUMP_DIR/mpstat.dump 2&gt;&amp;1vmstat 1 3 &gt; $DUMP_DIR/vmstat.dump 2&gt;&amp;1sar -p ALL  &gt; $DUMP_DIR/sar-cpu.dump  2&gt;&amp;1uptime &gt; $DUMP_DIR/uptime.dump 2&gt;&amp;1</code></pre><p>主要用于输出当前系统的 CPU 和负载，便于事后排查。</p><p>（5）<strong>I/O 资源</strong></p><pre class=" language-java"><code class="language-java">iostat <span class="token operator">-</span>x <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>iostat<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>一般，以计算为主的服务节点，I/O 资源会比较正常，但有时也会发生问题，比如<strong>日志输出过多，或者磁盘问题</strong>等。此命令可以输出每块磁盘的基本性能信息，用来排查 I/O 问题。在第 8 课时介绍的 GC 日志分磁盘问题，就可以使用这个命令去发现。</p><p>（6）<strong>内存问题</strong></p><pre class=" language-java"><code class="language-java">free <span class="token operator">-</span>h <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>free<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>free 命令能够大体展现操作系统的内存概况，这是故障排查中一个非常重要的点，比如 SWAP 影响了 GC，SLAB 区挤占了 JVM 的内存。</p><p>（7）<strong>其他全局</strong></p><pre class=" language-java"><code class="language-java">ps <span class="token operator">-</span>ef <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>ps<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>dmesg <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>dmesg<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>sysctl <span class="token operator">-</span>a <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>sysctl<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>dmesg 是许多静悄悄死掉的服务留下的最后一点线索。当然，ps 作为执行频率最高的一个命令，由于内核的配置参数，会对系统和 JVM 产生影响，所以我们也输出了一份。</p><p>（8）<strong>进程快照</strong>，最后的遗言（jinfo）</p><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jinfo $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jinfo<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>此命令将输出 Java 的基本进程信息，包括<strong>环境变量和参数配置</strong>，可以查看是否因为一些错误的配置造成了 JVM 问题。</p><p><strong>（9）dump 堆信息</strong></p><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstat <span class="token operator">-</span>gcutil $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jstat<span class="token operator">-</span>gcutil<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstat <span class="token operator">-</span>gccapacity $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jstat<span class="token operator">-</span>gccapacity<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>jstat 将输出当前的 gc 信息。一般，基本能大体看出一个端倪，如果不能，可将借助 jmap 来进行分析。</p><p><strong>（10）堆信息</strong></p><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>heap $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token operator">-</span>heap<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>histo $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jmap<span class="token operator">-</span>histo<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span>$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jmap <span class="token operator">-</span>dump<span class="token operator">:</span>format<span class="token operator">=</span>b<span class="token punctuation">,</span>file<span class="token operator">=</span>$DUMP_DIR<span class="token operator">/</span>heap<span class="token punctuation">.</span>bin $PID <span class="token operator">></span> <span class="token operator">/</span>dev<span class="token operator">/</span>null  <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>jmap 将会得到当前 Java 进程的 dump 信息。如上所示，其实最有用的就是第 4 个命令，但是前面三个能够让你初步对系统概况进行大体判断。因为，第 4 个命令产生的文件，一般都非常的大。而且，需要下载下来，导入 MAT 这样的工具进行深入分析，才能获取结果。这是分析内存泄漏一个必经的过程。</p><p><strong>（11）JVM 执行栈</strong></p><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jstack $PID <span class="token operator">></span> $DUMP_DIR<span class="token operator">/</span>jstack<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>jstack 将会获取当时的执行栈。一般会多次取值，我们这里取一次即可。这些信息非常有用，能够还原 Java 进程中的线程情况。</p><pre class=" language-java"><code class="language-java">top <span class="token operator">-</span>Hp $PID <span class="token operator">-</span>b <span class="token operator">-</span>n <span class="token number">1</span> <span class="token operator">-</span>c <span class="token operator">></span>  $DUMP_DIR<span class="token operator">/</span>top<span class="token operator">-</span>$PID<span class="token punctuation">.</span>dump <span class="token number">2</span><span class="token operator">></span><span class="token operator">&amp;</span><span class="token number">1</span></code></pre><p>为了能够得到更加精细的信息，我们使用 top 命令，来获取进程中所有线程的 CPU 信息，这样，就可以看到资源到底耗费在什么地方了。</p><p><strong>（12）高级替补</strong></p><pre class=" language-java"><code class="language-java">kill <span class="token operator">-</span><span class="token number">3</span> $PID</code></pre><p>有时候，jstack 并不能够运行，有很多原因，比如 Java 进程几乎不响应了等之类的情况。我们会尝试向进程发送 kill -3 信号，这个信号将会打印 jstack 的 trace 信息到日志文件中，是 jstack 的一个替补方案。</p><pre class=" language-java"><code class="language-java">gcore <span class="token operator">-</span>o $DUMP_DIR<span class="token operator">/</span>core $PID</code></pre><p>对于 jmap 无法执行的问题，也有替补，那就是 GDB 组件中的 gcore，将会生成一个 core 文件。我们可以使用如下的命令去生成 dump：</p><pre class=" language-java"><code class="language-java">$<span class="token punctuation">{</span>JDK_BIN<span class="token punctuation">}</span>jhsdb jmap <span class="token operator">--</span>exe $<span class="token punctuation">{</span>JDK<span class="token punctuation">}</span>java  <span class="token operator">--</span>core $DUMP_DIR<span class="token operator">/</span>core <span class="token operator">--</span>binaryheap</code></pre><ol start="3"><li><strong>内存泄漏的现象</strong></li></ol><p>稍微提一下 jmap 命令，它在 9 版本里被干掉了，取而代之的是 jhsdb，你可以像下面的命令一样使用。</p><pre class=" language-java"><code class="language-java">jhsdb jmap  <span class="token operator">--</span>heap <span class="token operator">--</span>pid  <span class="token number">37340</span>jhsdb jmap  <span class="token operator">--</span>pid  <span class="token number">37288</span>jhsdb jmap  <span class="token operator">--</span>histo <span class="token operator">--</span>pid  <span class="token number">37340</span>jhsdb jmap  <span class="token operator">--</span>binaryheap <span class="token operator">--</span>pid  <span class="token number">37340</span></code></pre><p>一般内存溢出，表现形式就是 Old 区的占用持续上升，即使经过了多轮 GC 也没有明显改善。比如ThreadLocal里面的GC Roots，内存泄漏的根本就是，这些对象并没有切断和 GC Roots 的关系，可通过一些工具，能够看到它们的联系。</p><h4 id="2、报表异常-JVM调优"><a href="#2、报表异常-JVM调优" class="headerlink" title="2、报表异常 | JVM调优"></a>2、报表异常 | JVM调优</h4><p>有一个报表系统，频繁发生内存溢出，在高峰期间使用时，还会频繁的发生拒绝服务，由于大多数使用者是管理员角色，所以很快就反馈到研发这里。</p><p>业务场景是由于有些结果集的字段不是太全，因此需要对结果集合进行循环，并通过 HttpClient 调用其他服务的接口进行数据填充。使用 Guava 做了 JVM 内缓存，但是响应时间依然很长。</p><p>初步排查，JVM 的资源太少。接口 A 每次进行报表计算时，都要涉及几百兆的内存，而且在内存里驻留很长时间，有些计算又非常耗 CPU，特别的“吃”资源。而我们分配给 JVM 的内存只有 3 GB，在多人访问这些接口的时候，内存就不够用了，进而发生了 OOM。在这种情况下，没办法，只有升级机器。把机器配置升级到 4C8G，给 JVM 分配 6GB 的内存，这样 OOM 问题就消失了。但随之而来的是频繁的 GC 问题和超长的 GC 时间，平均 GC 时间竟然有 5 秒多。</p><p>进一步，由于报表系统和高并发系统不太一样，它的对象，存活时长大得多，并不能仅仅通过增加年轻代来解决；而且，如果增加了年轻代，那么必然减少了老年代的大小，由于 CMS 的碎片和浮动垃圾问题，我们可用的空间就更少了。虽然服务能够满足目前的需求，但还有一些不太确定的风险。</p><p>第一，了解到程序中有很多缓存数据和静态统计数据，为了减少 MinorGC 的次数，通过分析 GC 日志打印的对象年龄分布，把 MaxTenuringThreshold 参数调整到了 3（特殊场景特殊的配置）。这个参数是让年轻代的这些对象，赶紧回到老年代去，不要老呆在年轻代里。</p><p>第二，我们的 GC 时间比较长，就一块开了参数 CMSScavengeBeforeRemark，使得在 CMS remark 前，先执行一次 Minor GC 将新生代清掉。同时配合上个参数，其效果还是比较好的，一方面，对象很快晋升到了老年代，另一方面，年轻代的对象在这种情况下是有限的，在整个 MajorGC 中占的时间也有限。</p><p>第三，由于缓存的使用，有大量的弱引用，拿一次长达 10 秒的 GC 来说。我们发现在 GC 日志里，处理 weak refs 的时间较长，达到了 4.5 秒。这里可以加入参数 ParallelRefProcEnabled 来并行处理Reference，以加快处理速度，缩短耗时。</p><p>优化之后，效果不错，但并不是特别明显。经过评估，针对高峰时期的情况进行调研，我们决定再次提升机器性能，改用 8core16g 的机器。但是，这带来另外一个问题。</p><p><strong>高性能的机器带来了非常大的服务吞吐量</strong>，通过 jstat 进行监控，能够看到年轻代的分配速率明显提高，但随之而来的 MinorGC 时长却变的不可控，有时候会超过 1 秒。累积的请求造成了更加严重的后果。</p><p>这是由于堆空间明显加大造成的回收时间加长。为了获取较小的停顿时间，我们在堆上<strong>改用了 G1 垃圾回收器</strong>，把它的目标设定在 200ms。G1 是一款非常优秀的垃圾收集器，不仅适合堆内存大的应用，同时也简化了调优的工作。通过主要的参数初始和最大堆空间、以及最大容忍的 GC 暂停目标，就能得到不错的性能。修改之后，虽然 GC 更加频繁了一些，但是停顿时间都比较小，应用的运行较为平滑。</p><p>到目前为止，也只是勉强顶住了已有的业务，但是，这时候领导层面又发力，<strong>要求报表系统可以支持未来两年业务10到100倍的增长</strong>，并保持其可用性，但是这个“千疮百孔”的报表系统，稍微一压测，就宕机，那如何应对十倍百倍的压力呢 ? 硬件即使可以做到动态扩容，但是毕竟也有极限。</p><p>使用 MAT 分析堆快照，发现很多地方可以通过代码优化，那些占用内存特别多的对象：</p><p>1、select * 全量排查，只允许获取必须的数据</p><p>2、报表系统中cache实际的命中率并不高，将Guava 的 Cache 引用级别改成弱引用（WeakKeys）</p><p>3、限制报表导入文件大小，同时拆分用户超大范围查询导出请求。</p><p>每一步操作都使得JVM使用变得更加可用，一系列优化以后，机器相同压测数据性能提升了数倍。</p><h4 id="3、大屏异常-JUC调优"><a href="#3、大屏异常-JUC调优" class="headerlink" title="3、大屏异常 | JUC调优"></a>3、大屏异常 | JUC调优</h4><p>有些数据需要使用 HttpClient 来获取进行补全。提供数据的服务提供商有的响应时间可能会很长，也有可能会造成服务整体的阻塞。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobr4whjzwj30l1058dfx.jpg" alt="img"></p><p>接口 A 通过 HttpClient 访问服务 2，响应 100ms 后返回；接口 B 访问服务 3，耗时 2 秒。HttpClient 本身是有一个最大连接数限制的，如果服务 3 迟迟不返回，就会造成 HttpClient 的连接数达到上限，<strong>概括来讲，就是同一服务，由于一个耗时非常长的接口，进而引起了整体的服务不可用</strong></p><p>这个时候，通过 jstack 打印栈信息，会发现大多数竟然阻塞在了接口 A 上，而不是耗时更长的接口 B，这个现象起初十分具有迷惑性，不过经过分析后，我们猜想其实是因为接口 A 的速度比较快，在问题发生点进入了更多的请求，它们全部都阻塞住的同时被打印出来了。</p><p>为了验证这个问题，我搭建了一个demo 工程，模拟了两个使用同一个 HttpClient 的接口。fast 接口用来访问百度，很快就能返回；slow 接口访问谷歌，由于众所周知的原因，会阻塞直到超时，大约 10 s。 利用ab对两个接口进行压测，同时使用 jstack 工具 dump 堆栈。首先使用 jps 命令找到进程号，然后把结果重定向到文件（可以参考 10271.jstack 文件）。</p><p>过滤一下 nio 关键字，可以查看 tomcat 相关的线程，足足有 200 个，这和 Spring Boot 默认的 maxThreads 个数不谋而合。更要命的是，有大多数线程，都处于 BLOCKED 状态，说明线程等待资源超时。通过grep fast | wc -l 分析，确实200个中有150个都是blocked的fast的进程。</p><p>问题找到了，解决方式就顺利成章了。</p><p>1、fast和slow争抢连接资源，通过线程池限流或者熔断处理</p><p>2、有时候slow的线程也不是一直slow，所以就得加入监控</p><p>3、使用带countdownLaunch对线程的执行顺序逻辑进行控制</p><h4 id="4、接口延迟-SWAP调优"><a href="#4、接口延迟-SWAP调优" class="headerlink" title="4、接口延迟 | SWAP调优"></a><strong>4、接口延迟 | SWAP调优</strong></h4><p>有一个关于服务的某个实例，经常发生服务卡顿。由于服务的并发量是比较高的，每多停顿 1 秒钟，几万用户的请求就会感到延迟。</p><p>我们统计、类比了此服务其他实例的 CPU、内存、网络、I/O 资源，区别并不是很大，所以一度怀疑是机器硬件的问题。</p><p>接下来我们对比了节点的 GC 日志，发现无论是 Minor GC，还是 Major GC，这个节点所花费的时间，都比其他实例长得多。</p><p>通过仔细观察，我们发现在 GC 发生的时候，vmstat 的 si、so 飙升的非常严重，这和其他实例有着明显的不同。</p><p>使用 free 命令再次确认，发现 SWAP 分区，使用的比例非常高，引起的具体原因是什么呢？</p><p>更详细的操作系统内存分布，从 /proc/meminfo 文件中可以看到具体的逻辑内存块大小，有多达 40 项的内存信息，这些信息都可以通过遍历 /proc 目录的一些文件获取。我们注意到 slabtop 命令显示的有一些异常，dentry（目录高速缓冲）占用非常高。</p><p>问题最终定位到是由于某个运维工程师删除日志时，定时执行了一句命令：</p><p>find / | grep “xxx.log”</p><p>他是想找一个叫做 要被删除 的日志文件，看看在哪台服务器上，结果，这些老服务器由于文件太多，扫描后这些文件信息都缓存到了 slab 区上。而服务器开了 swap，操作系统发现物理内存占满后，并没有立即释放 cache，导致每次 GC 都要和硬盘打一次交道。</p><p><strong>解决方式就是关闭 SWAP 分区。</strong></p><p>swap 是很多性能场景的万恶之源，建议禁用。在高并发 SWAP 绝对能让你体验到它魔鬼性的一面：进程倒是死不了了，但 GC 时间长的却让人无法忍受。</p><h4 id="5、内存溢出-Cache调优"><a href="#5、内存溢出-Cache调优" class="headerlink" title="5、内存溢出 | Cache调优"></a>5、<strong>内存溢出 | Cache调优</strong></h4><blockquote><p>有一次线上遇到故障，重新启动后，使用 jstat 命令，发现 Old 区一直在增长。我使用 jmap 命令，导出了一份线上堆栈，然后使用 MAT 进行分析，通过对 GC Roots 的分析，发现了一个非常大的 HashMap 对象，这个原本是其他同事做缓存用的，但是做了一个无界缓存，没有设置超时时间或者 LRU 策略，在使用上又没有重写key类对象的hashcode和equals方法，对象无法取出也直接造成了堆内存占用一直上升，后来，将这个缓存改成 guava 的 Cache，并设置了弱引用，故障就消失了。</p><p>关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p></blockquote><p>内存溢出是一个结果，而<strong>内存泄漏</strong>是一个原因。内存溢出的原因有<strong>内存空间不足、配置错误</strong>等因素。一些错误的编程方式，不再被使用的对象、没有被回收、没有及时切断与 GC Roots 的联系，这就是内存泄漏。</p><p>举个例子，有团队使用了 HashMap 做缓存，但是并没有设置超时时间或者 LRU 策略，造成了放入 Map 对象的数据越来越多，而产生了内存泄漏。</p><p>再来看一个经常发生的内存泄漏的例子，也是由于 HashMap 产生的。代码如下，由于没有重写 Key 类的 hashCode 和 equals 方法，造成了放入 HashMap 的所有对象都无法被取出来，它们和外界失联了。所以下面的代码结果是 null。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//leak example</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMapLeakDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Key</span> <span class="token punctuation">{</span>        String title<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Key</span><span class="token punctuation">(</span>String title<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>title <span class="token operator">=</span> title<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>Key<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">"3"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Integer integer <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Key</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>即使提供了 equals 方法和 hashCode 方法，也要非常小心，尽量避免使用自定义的对象作为 Key。</p><p>再看一个例子，关于文件处理器的应用，在读取或者写入一些文件之后，由于发生了一些异常，<strong>close 方法又没有放在 finally</strong> 块里面，造成了文件句柄的泄漏。由于文件处理十分频繁，产生了严重的内存泄漏问题。</p><h4 id="6：CPU飙高-死循环"><a href="#6：CPU飙高-死循环" class="headerlink" title="6：CPU飙高 | 死循环"></a>6：CPU飙高 | 死循环</h4><p>我们有个线上应用，单节点在运行一段时间后，CPU 的使用会飙升，一旦飙升，一般怀疑某个业务逻辑的计算量太大，或者是触发了死循环（比如著名的 HashMap 高并发引起的死循环），但排查到最后其实是 GC 的问题。        </p><p>（1）使用 top 命令，查找到使用 CPU 最多的某个进程，记录它的 pid。使用 Shift + P 快捷键可以按 CPU 的使用率进行排序。</p><pre class=" language-java"><code class="language-java">top</code></pre><p>（2）再次使用 top 命令，加 -H 参数，查看某个进程中使用 CPU 最多的某个线程，记录线程的 ID。</p><pre class=" language-java"><code class="language-java">top <span class="token operator">-</span>Hp $pid</code></pre><p>（3）使用 printf 函数，将十进制的 tid 转化成十六进制。</p><pre class=" language-java"><code class="language-java">printf <span class="token operator">%</span>x $tid</code></pre><p>（4）使用 jstack 命令，查看 Java 进程的线程栈。</p><pre class=" language-java"><code class="language-java">jstack $pid <span class="token operator">></span>$pid<span class="token punctuation">.</span>log</code></pre><p>（5）使用 less 命令查看生成的文件，并查找刚才转化的十六进制 tid，找到发生问题的线程上下文。</p><pre class=" language-java"><code class="language-java">less $pid<span class="token punctuation">.</span>log</code></pre><p>我们在 jstack 日志搜关键字DEAD，以及中找到了 CPU 使用最多的几个线程id。</p><p>可以看到问题发生的根源，是我们的堆已经满了，但是又没有发生 OOM，于是 GC 进程就一直在那里回收，回收的效果又非常一般，造成 CPU 升高应用假死。接下来的具体问题排查，就需要把内存 dump 一份下来，使用 MAT 等工具分析具体原因了。</p><h1 id="三、多线程篇"><a href="#三、多线程篇" class="headerlink" title="三、多线程篇"></a>三、多线程篇</h1><h3 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h3><h4 id="1、线程状态"><a href="#1、线程状态" class="headerlink" title="1、线程状态"></a><strong>1、线程状态</strong></h4><p>​        线程是cpu任务调度的最小执行单位，每个线程拥有自己独立的程序计数器、虚拟机栈、本地方法栈</p><p><strong>线程状态：创建、就绪、运行、阻塞、死亡</strong></p><p><img src="https://s0.lgstatic.com/i/image3/M01/77/29/Cgq2xl5xxGKAKBpeAAEw9Ifr07Y662.png" alt="img" style="zoom: 40%;"></p><h4 id="2、线程状态切换"><a href="#2、线程状态切换" class="headerlink" title="2、线程状态切换"></a><strong>2、线程状态切换</strong></h4><table><thead><tr><th>方法</th><th>作用</th><th>区别</th></tr></thead><tbody><tr><td>start</td><td>启动线程，由虚拟机自动调度执行run()方法</td><td>线程处于就绪状态</td></tr><tr><td>run</td><td>线程逻辑代码块处理，JVM调度执行</td><td>线程处于运行状态</td></tr><tr><td>sleep</td><td>让当前正在执行的线程休眠（暂停执行）</td><td>不释放锁</td></tr><tr><td>wait</td><td>使得当前线程等待</td><td>释放同步锁</td></tr><tr><td>notify</td><td>唤醒在此对象监视器上等待的单个线程</td><td>唤醒单个线程</td></tr><tr><td>notifyAll</td><td>唤醒在此对象监视器上等待的所有线程</td><td>唤醒多个线程</td></tr><tr><td>yiled</td><td>停止当前线程，让同等优先权的线程运行</td><td>用Thread类调用</td></tr><tr><td>join</td><td>使当前线程停下来等待，直至另一个调用join方法的线程终止</td><td>用线程对象调用</td></tr></tbody></table><p><img src="https://s0.lgstatic.com/i/image/M00/80/24/Ciqc1F_Qfy2ACkrLAAD2DLkc2qw212.png" alt="img" style="zoom:67%;"></p><h4 id="3、阻塞唤醒过程"><a href="#3、阻塞唤醒过程" class="headerlink" title="3、阻塞唤醒过程"></a><strong>3、阻塞唤醒过程</strong></h4><p><strong>阻塞：</strong></p><p>​        这三个方法的调用都会使当前线程阻塞。该线程将会被放置到对该Object的请求等待队列中，然后让出当前对Object所拥有的所有的同步请求。线程会一直暂停所有线程调度，直到下面其中一种情况发生：</p><p>　　　　① 其他线程调用了该Object的notify方法，而该线程刚好是那个被唤醒的线程；</p><p>　　　　② 其他线程调用了该Object的notifyAll方法；</p><p><strong>唤醒：</strong></p><p>​        线程将会从等待队列中移除，重新成为可调度线程。它会与其他线程以常规的方式竞争对象同步请求。<strong>一旦它重新获得对象的同步请求，所有之前的请求状态都会恢复，也就是线程调用wait的地方的状态。线程将会在之前调用wait的地方继续运行下去。</strong></p><p><strong>为什么要出现在同步代码块中：</strong></p><p>​        由于<code>wait()属于Object方法，调用之后会强制释放当前对象锁，所以在wait()</code> 调用时必须拿到当前对象的监视器monitor对象。因此，wait()方法在同步方法/代码块中调用。</p><h4 id="4、wait和sleep区别"><a href="#4、wait和sleep区别" class="headerlink" title="4、wait和sleep区别"></a><strong>4、wait和sleep区别</strong></h4><ul><li><p>wait 方法必须在 synchronized 保护的代码中使用，而 sleep 方法并没有这个要求。</p></li><li><p>wait 方法会主动释放 monitor 锁，在同步代码中执行 sleep 方法时，并不会释放 monitor 锁。</p></li><li><p>wait 方法意味着永久等待，直到被中断或被唤醒才能恢复，不会主动恢复，sleep 方法中会定义一个时间，时间到期后会主动恢复。</p></li><li><p>wait/notify 是 Object 类的方法，而 sleep 是 Thread 类的方法。</p></li></ul><h4 id="5、创建线程方式"><a href="#5、创建线程方式" class="headerlink" title="5、创建线程方式"></a>5、创建线程方式</h4><p><strong>实现 Runnable 接口</strong>（优先使用）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RunnableThread</span> <span class="token keyword">implements</span> <span class="token class-name">Runnable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'用实现Runnable接口实现线程'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>实现Callable接口</strong>（有返回值可抛出异常）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">CallableTask</span> <span class="token keyword">implements</span> <span class="token class-name">Callable</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>继承Thread类</strong>（java不支持多继承）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExtendsThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">'用Thread类实现线程'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>使用线程池</strong>（底层都是实现run方法）</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultThreadFactory</span> <span class="token keyword">implements</span> <span class="token class-name">ThreadFactory</span> <span class="token punctuation">{</span>    <span class="token function">DefaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SecurityManager s <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getSecurityManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        group <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> s<span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getThreadGroup</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        namePrefix <span class="token operator">=</span> <span class="token string">"pool-"</span> <span class="token operator">+</span> poolNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span><span class="token string">"-thread-"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Thread <span class="token function">newThread</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span>group<span class="token punctuation">,</span> r<span class="token punctuation">,</span>namePrefix <span class="token operator">+</span> threadNumber<span class="token punctuation">.</span><span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">isDaemon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> t<span class="token punctuation">.</span><span class="token function">setDaemon</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//是否守护线程</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getPriority</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span> t<span class="token punctuation">.</span><span class="token function">setPriority</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span>NORM_PRIORITY<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//线程优先级</span>        <span class="token keyword">return</span> t<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p>优点：通过复用已创建的线程，<strong>降低资源损耗</strong>、线程可以直接处理队列中的任务<strong>加快响应速度</strong>、同时便于<strong>统一监控和管理</strong>。</p><h4 id="1、线程池构造函数"><a href="#1、线程池构造函数" class="headerlink" title="1、线程池构造函数"></a><strong>1、线程池构造函数</strong></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 线程池构造函数7大参数*/</span><span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>    TimeUnit unit<span class="token punctuation">,</span>BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>ThreadFactory threadFactory<span class="token punctuation">,</span>    RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p><strong>参数介绍：</strong></p><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池大小</td></tr><tr><td>maximumPoolSize</td><td>最大线程池大小</td></tr><tr><td>keepAliveTime</td><td>线程池中超过 corePoolSize 数目的空闲线程最大存活时间；</td></tr><tr><td>TimeUnit</td><td>keepAliveTime 时间单位</td></tr><tr><td>workQueue</td><td>阻塞任务队列</td></tr><tr><td>threadFactory</td><td>新建线程工厂</td></tr><tr><td>RejectedExecutionHandler</td><td>拒绝策略。当提交任务数超过 maxmumPoolSize+workQueue 之和时，任务会交给RejectedExecutionHandler 来处理</td></tr></tbody></table><h4 id="2、线程处理任务过程："><a href="#2、线程处理任务过程：" class="headerlink" title="2、线程处理任务过程："></a><strong>2、线程处理任务过程：</strong></h4><p><img src="https://s0.lgstatic.com/i/image3/M01/78/50/Cgq2xl5zjxGAXOA-AABF0Dv8GMI518.png" alt="img" style="zoom: 67%;"></p><ol><li>当线程池小于corePoolSize，新提交任务将创建一个新线程执行任务，即使此时线程池中存在空闲线程。</li><li>当线程池达到corePoolSize时，新提交任务将被放入 workQueue 中，等待线程池中任务调度执行。</li><li>当workQueue已满，且 maximumPoolSize 大于 corePoolSize 时，新提交任务会创建新线程执行任务。</li><li>当提交任务数超过 maximumPoolSize 时，新提交任务由 RejectedExecutionHandler 处理。</li><li>当线程池中超过corePoolSize 线程，空闲时间达到 keepAliveTime 时，关闭空闲线程 。</li></ol><h4 id="3、线程拒绝策略"><a href="#3、线程拒绝策略" class="headerlink" title="3、线程拒绝策略"></a><strong>3、线程拒绝策略</strong></h4><p>​        线程池中的线程已经用完了，无法继续为新任务服务，同时，等待队列也已经排满了，再也塞不下新任务了。这时候我们就需要拒绝策略机制合理的处理这个问题。</p><p>JDK 内置的拒绝策略如下：</p><p>​        <strong>AbortPolicy：</strong>直接抛出异常，阻止系统正常运行。可以根据业务逻辑选择重试或者放弃提交等策略。</p><p>​        <strong>CallerRunsPolicy ：</strong>只要线程池未关闭，该策略直接在调用者线程中，运行当前被丢弃的任务。</p><p>​                不会造成任务丢失，同时减缓提交任务的速度，给执行任务缓冲时间。</p><p>​        <strong>DiscardOldestPolicy ：</strong>丢弃最老的一个请求，也就是即将被执行的任务，并尝试再次提交当前任务。</p><p>​        <strong>DiscardPolicy ：</strong>该策略默默地丢弃无法处理的任务，不予任何处理。如果允许任务丢失，这是最好的一种方案。</p><h4 id="4、Execuors类实现线程池"><a href="#4、Execuors类实现线程池" class="headerlink" title="4、Execuors类实现线程池"></a><strong>4、Execuors类实现线程池</strong></h4><p><img src="https://s0.lgstatic.com/i/image3/M01/63/5A/CgpOIF4z1EiAFjNQAAAtVe5xjgQ999.png" alt="img" style="zoom: 50%;"></p><ul><li><strong>newSingleThreadExecutor()：</strong>只有一个线程的线程池，任务是顺序执行，适用于一个一个任务执行的场景</li><li><strong>newCachedThreadPool()：</strong>线程池里有很多线程需要同时执行，60s内复用，适用执行很多短期异步的小程序或者负载较轻的服务</li><li><strong>newFixedThreadPool()：</strong>拥有固定线程数的线程池，如果没有任务执行，那么线程会一直等待，适用执行长期的任务。</li><li><strong>newScheduledThreadPool()：</strong>用来调度即将执行的任务的线程池</li><li><strong>newWorkStealingPool()</strong>：底层采用forkjoin的Deque，采用独立的任务队列可以减少竞争同时加快任务处理</li><li></li><li><img src="https://s0.lgstatic.com/i/image2/M01/AF/80/CgoB5l3kzomAckv5AAAxf6FCPco696.png" alt="img" style="zoom:50%;"></li></ul><p><strong>因为以上方式都存在弊端：</strong></p><p>​        FixedThreadPool 和 SingleThreadExecutor ： 允许请求的<strong>队列⻓度</strong>为 Integer.MAX_VALUE，会导致OOM。<br>​        CachedThreadPool 和 ScheduledThreadPool ： 允许创建的<strong>线程数量</strong>为 Integer.MAX_VALUE，会导致OOM。</p><p>手动创建的线程池底层使用的是ArrayBlockingQueue可以防止OOM。</p><h4 id="5、线程池大小设置"><a href="#5、线程池大小设置" class="headerlink" title="5、线程池大小设置"></a><strong>5、线程池大小设置</strong></h4><ul><li>CPU 密集型（n+1）</li></ul><p>​    CPU 密集的意思是该任务需要大量的运算，而没有阻塞，CPU 一直全速运行。</p><p>​    CPU 密集型任务尽可能的少的线程数量，一般为 CPU 核数 + 1 个线程的线程池。</p><ul><li>IO 密集型（2*n）</li></ul><p>​    由于 IO 密集型任务线程并不是一直在执行任务，可以多分配一点线程数，如 CPU * 2 </p><p>​    也可以使用公式：CPU 核心数 *（1+平均等待时间/平均工作时间）。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="1、乐观锁，CAS思想"><a href="#1、乐观锁，CAS思想" class="headerlink" title="1、乐观锁，CAS思想"></a><strong>1、乐观锁，CAS思想</strong></h4><p><strong>java乐观锁机制：</strong></p><p>​        乐观锁体现的是悲观锁的反面。它是一种积极的思想，它总是认为数据是不会被修改的，所以是不会对数据上锁的。但是乐观锁在更新的时候会去判断数据是否被更新过。乐观锁的实现方案一般有两种（版本号机制和CAS）。乐观锁适用于<strong>读多写少的场景，这样可以提高系统的并发量</strong>。在Java中 <strong>java.util.concurrent.atomic</strong>下的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>　　乐观锁，大多是基于数据版本  (Version)记录机制实现。即为数据增加一个版本标识，在基于数据库表的版本解决方案中，一般是通过为数据库表增加一个 “version” 字段来 实现。 读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。此时，将提 交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果提交的数据 版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。</p><p><strong>CAS思想：</strong></p><p>​        CAS就是compare and swap（<strong>比较交换</strong>），是一种很出名的无锁的算法，就是可以不使用锁机制实现线程间的同步。使用CAS线程是不会被阻塞的，所以又称为非阻塞同步。CAS算法涉及到三个操作：</p><p>​        需要读写内存值V；进行比较的值A；准备写入的值B</p><p>​        当且仅当V的值等于A的值等于V的值的时候，才用B的值去更新V的值，否则不会执行任何操作（比较和替换是一个原子操作-A和V比较，V和B替换），一般情况下是一个<strong>自旋操作</strong>，即<strong>不断重试</strong></p><p><strong>缺点：</strong></p><p>​        <a href="https://www.zhihu.com/question/23281499/answer/854522984" target="_blank" rel="noopener">ABA问题-知乎</a></p><p>​        高并发的情况下，很容易发生并发冲突，如果CAS一直失败，那么就会一直重试，浪费CPU资源</p><p><strong>原子性：</strong></p><p>​        功能限制CAS是能保证单个变量的操作是原子性的，在Java中要配合使用volatile关键字来保证线程的安全；当涉及到多个变量的时候CAS无能为力；除此之外CAS实现需要硬件层面的支持，在Java的普通用户中无法直接使用，只能<strong>借助atomic包下的原子类</strong>实现，灵活性受到了限制</p><h4 id="2、synchronized底层实现"><a href="#2、synchronized底层实现" class="headerlink" title="2、synchronized底层实现"></a><strong>2、synchronized底层实现</strong></h4><p><strong>使用方法：</strong>主要的三种使⽤⽅式</p><p>​        <strong>修饰实例⽅法:</strong> 作⽤于当前对象实例加锁，进⼊同步代码前要获得当前对象实例的锁</p><p>​        <strong>修饰静态⽅法:</strong> 也就是给当前类加锁，会作⽤于类的所有对象实例，因为静态成员不属于任何⼀个实例对象，是类成员。</p><p>​        <strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进⼊同步代码库前要获得给定对象的锁。</p><p>​        <strong>总结：</strong>synchronized锁住的资源只有两类：一个是<strong>对象</strong>，一个是<strong>类</strong>。</p><p><strong>底层实现：</strong></p><p>​        对象头是我们需要关注的重点，它是synchronized实现锁的基础，因为synchronized申请锁、上锁、释放锁都与对象头有关。对象头主要结构是由<code>Mark Word</code> 组成，<strong>其中<code>Mark Word</code>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</strong>。</p><p>​        锁也分不同状态，JDK6之前只有两个状态：无锁、有锁（重量级锁），而在JDK6之后对synchronized进行了优化，新增了两种状态，总共就是四个状态：<strong>无锁状态、偏向锁、轻量级锁、重量级锁</strong>，其中无锁就是一种状态了。锁的类型和状态在对象头<code>Mark Word</code>中都有记录，在申请锁、锁升级等过程中JVM都需要读取对象的<code>Mark Word</code>数据。</p><p>​        同步代码块是利用 monitorenter 和 monitorexit 指令实现的，而同步方法则是利用 flags 实现的。</p><h4 id="3、ReenTrantLock底层实现"><a href="#3、ReenTrantLock底层实现" class="headerlink" title="3、ReenTrantLock底层实现"></a><strong>3、ReenTrantLock底层实现</strong></h4><p>​        由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能</p><p><strong>使用方法：</strong></p><p>​        基于API层面的互斥锁，需要lock()和unlock()方法配合try/finally语句块来完成</p><p><strong>底层实现：</strong></p><p>​        ReenTrantLock的实现是一种自旋锁，通过循环调用CAS操作来实现加锁。它的性能比较好也是因为避免了使线程进入内核态的阻塞状态。想尽办法避免线程进入内核的阻塞状态是我们去分析和理解锁设计的关键钥匙。</p><p><strong>和synchronized区别：</strong></p><p>​        1、<strong>底层实现</strong>：synchronized 是<strong>JVM</strong>层面的锁，是<strong>Java关键字</strong>，通过monitor对象来完成（monitorenter与monitorexit），ReentrantLock 是从jdk1.5以来（java.util.concurrent.locks.Lock）提供的<strong>API层面</strong>的锁。</p><p>​        2、<strong>实现原理**</strong>：synchronized 的实现涉及到<strong>锁的升级</strong>，具体为无锁、偏向锁、自旋锁、向OS申请重量级锁；ReentrantLock实现则是通过利用<strong>CAS</strong>（CompareAndSwap）自旋机制保证线程操作的原子性和volatile保证数据可见性以实现锁的功能。</p><p>​        3、<strong>是否可手动释放：</strong>synchronized 不需要用户去手动释放锁，synchronized 代码执行完后系统会自动让线程释放对锁的占用； ReentrantLock则需要用户去手动释放锁，如果没有手动释放锁，就可能导致<strong>死锁现象</strong>。</p><p>​        4、<strong>是否可中断</strong>synchronized是不可中断类型的锁，除非加锁的代码中出现异常或正常执行完成； ReentrantLock则可以中断，可通过trylock(long timeout,TimeUnit unit)设置超时方法或者将lockInterruptibly()放到代码块中，调用interrupt方法进行中断。</p><p>​        5、<strong>是否公平锁</strong>synchronized为非公平锁 ReentrantLock则即可以选公平锁也可以选非公平锁，通过构造方法new ReentrantLock时传入boolean值进行选择，为空默认false非公平锁，true为公平锁,公平锁性能非常低。</p><h4 id="4、公平锁和非公平锁区别"><a href="#4、公平锁和非公平锁区别" class="headerlink" title="4、公平锁和非公平锁区别"></a><strong>4、公平锁和非公平锁区别</strong></h4><p><strong>公平锁：</strong></p><p>​        公平锁自然是遵循<strong>FIFO</strong>（先进先出）原则的，先到的线程会优先获取资源，后到的会进行排队等待</p><p>​        <strong>优点：</strong>所有的线程都能得到资源，不会饿死在队列中。适合大任务</p><p>​        <strong>缺点：</strong>吞吐量会下降，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销大</p><p><strong>非公平锁：</strong></p><p>​        多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。</p><p>​        <strong>优点：</strong>可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。</p><p>​        <strong>缺点：</strong>你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁</p><p><img src="https://s0.lgstatic.com/i/image3/M01/02/7D/Ciqah157DAiAK_DJAAC0JawhGp4730.png" alt="img" style="zoom:67%;"></p><p><strong>公平锁效率低原因：</strong></p><p>​        公平锁要维护一个队列，后来的线程要加锁，即使锁空闲，也要先检查有没有其他线程在 wait，如果有自己要挂起，加到队列后面，然后唤醒队列最前面线程。这种情况下相比较非公平锁多了一次<strong>挂起和唤醒</strong>。</p><p>​        <strong>线程切换的开销</strong>，其实就是非公平锁效率高于公平锁的原因，因为<strong>非公平锁减少了线程挂起的几率</strong>，后来的线程有一定几率逃离被挂起的开销。</p><h4 id="5、使用层面锁优化"><a href="#5、使用层面锁优化" class="headerlink" title="5、使用层面锁优化"></a><strong>5、使用层面锁优化</strong></h4><p>​    【1】<strong>减少锁的时间：</strong><br>​        不需要同步执行的代码，能不放在同步快里面执行就不要放在同步快内，可以让锁尽快释放；</p><p>​    【2】<strong>减少锁的粒度：</strong><br>​        它的思想是将物理上的一个锁，拆成逻辑上的多个锁，增加并行度，从而降低锁竞争。它的思想也是用空间来换时间；java中很多数据结构都是采用这种方法提高并发操作的效率，比如：</p><p>​        <strong>ConcurrentHashMap：</strong></p><p>​        java中的ConcurrentHashMap在jdk1.8之前的版本，使用一个Segment 数组：Segment&lt; K,V &gt;[] segments</p><p>​        Segment继承自ReenTrantLock，所以每个Segment是个可重入锁，每个Segment 有一个HashEntry&lt; K,V &gt;数组用来存放数据，put操作时，先确定往哪个Segment放数据，只需要锁定这个Segment，执行put，其它的Segment不会被锁定；所以数组中有多少个Segment就允许同一时刻多少个线程存放数据，这样增加了并发能力。</p><p>​    【3】<strong>锁粗化：</strong><br>​        大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度; </p><p>​        假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的；</p><p>​    【4】<strong>使用读写锁：</strong></p><p>​        ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可并发读，写操作使用写锁，只能单线程写；</p><p>​    【5】<strong>使用CAS：</strong></p><p>​        如果需要同步的操作执行速度非常快，并且线程竞争并不激烈，这时候使用cas效率会更高，因为加锁会导致线程的上下文切换，如果上下文切换的耗时比同步操作本身更耗时，且线程对资源的竞争不激烈，使用volatiled+cas操作会是非常高效的选择；</p><h4 id="6、系统层面锁优化"><a href="#6、系统层面锁优化" class="headerlink" title="6、系统层面锁优化"></a>6、系统层面锁优化</h4><p><strong>自适应自旋锁：</strong></p><p>​        自旋锁可以避免等待竞争锁进入阻塞挂起状态被唤醒造成的<strong>内核态和用户态之间的切换</strong>的损耗，它们只需要等一等（自旋），但是如果锁被其他线程长时间占用，一直不释放CPU，死等会带来更多的性能开销；自旋次数默认值是10</p><p>​        对上面自旋锁优化方式的进一步优化，它的自旋的次数不再固定，其自旋的次数由前一次在同一个锁上的<strong>自旋时间及锁的拥有者的状态</strong>来决定，这就解决了自旋锁带来的缺点</p><p><strong>锁消除：</strong></p><p>​        锁削除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行削除。Netty中无锁化设计pipeline中channelhandler会进行锁消除的优化。</p><p><strong>锁升级：</strong></p><p>​    <strong>偏向锁：</strong></p><p>​        如果线程已经占有这个锁，当他在次试图去获取这个锁的时候，他会已最快的方式去拿到这个锁，而不需要在进行一些monitor操作，因为在大部分情况下是没有竞争的，所以使用偏向锁是可以提高性能的；</p><p>​    <strong>轻量级锁：</strong></p><p>​        在竞争不激烈的情况下，通过CAS避免线程上下文切换，可以显著的提高性能。</p><p>​    <strong>重量级锁：</strong></p><p>​        重量级锁的加锁、解锁过程造成的损耗是固定的，重量级锁适合于竞争激烈、高并发、同步块执行时间长的情况。</p><h4 id="7、ThreadLocal原理"><a href="#7、ThreadLocal原理" class="headerlink" title="7、ThreadLocal原理"></a><strong>7、ThreadLocal原理</strong></h4><p><strong>ThreadLocal简介：</strong></p><p>​        通常情况下，我们创建的变量是可以被任何⼀个线程访问并修改的。如果想实现每⼀个线程都有⾃⼰的<br>专属本地变量该如何解决呢？ JDK中提供的 ThreadLocal 类正是为了解决这样的问题。类似操作系统中的TLAB</p><p><strong>原理：</strong></p><p>​        首先 ThreadLocal 是一个泛型类，保证可以接受任何类型的对象。因为一个线程内可以存在多个 ThreadLocal 对象，所以其实是 ThreadLocal 内部维护了一个 Map ，是 ThreadLocal 实现的一个叫做 ThreadLocalMap 的静态内部类。</p><p>​        最终的变量是放在了当前线程的 <code>ThreadLocalMap</code> 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</p><p>​        我们使用的 get()、set() 方法其实都是调用了这个ThreadLocalMap类对应的 get()、set() 方法。例如下面的 </p><p><strong>如何使用：</strong></p><p>​        1）存储用户Session</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal threadSession <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>​        2）解决线程安全的问题</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> ThreadLocal<span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span> format1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>SimpleDateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>ThreadLocal内存泄漏的场景</strong> </p><p>​        实际上 ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用，⽽ value 是强引⽤。弱引用的特点是，如果这个对象持有弱引用，那么在下一次垃圾回收的时候必然会被清理掉。</p><p>​        所以如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会被清理掉的，这样一来 ThreadLocalMap中使用这个 ThreadLocal 的 key 也会被清理掉。但是，value 是强引用，不会被清理，这样一来就会出现 key 为 null 的 value。 假如我们不做任何措施的话，value 永远⽆法被GC 回收，如果线程长时间不被销毁，可能会产⽣内存泄露。</p><p><img src="https://s0.lgstatic.com/i/image3/M01/68/C4/Cgq2xl5Pld-AHFhJAADLtGXmSxc833.png" alt="img" style="zoom:67%;"></p><p>​        ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。如果说会出现内存泄漏，那只有在出现了 key 为 null 的记录后，没有手动调用 remove() 方法，并且之后也不再调用 get()、set()、remove() 方法的情况下。因此使⽤完ThreadLocal ⽅法后，<strong>最好⼿动调⽤ remove() ⽅法</strong>。</p><h4 id="8、HashMap线程安全"><a href="#8、HashMap线程安全" class="headerlink" title="8、HashMap线程安全"></a><strong>8、HashMap线程安全</strong></h4><p>​    <strong>死循环造成 CPU 100%</strong></p><p>​        HashMap 有可能会发生死循环并且造成  CPU 100% ，这种情况发生最主要的原因就是在<strong>扩容</strong>的时候，也就是内部<strong>新建新的 HashMap</strong> 的时候，扩容的逻辑会<strong>反转散列桶中的节点顺序</strong>，当有多个线程同时进行扩容的时候，由于 HashMap 并非线程安全的，所以如果<strong>两个线程同时反转的话，便可能形成一个循环</strong>，并且这种循环是链表的循环，相当于 A 节点指向 B 节点，B 节点又指回到 A 节点，这样一来，在下一次想要获取该 key 所对应的 value 的时候，便会在遍历链表的时候发生永远无法遍历结束的情况，也就发生 CPU 100% 的情况。</p><p>​        所以综上所述，HashMap 是线程不安全的，在多线程使用场景中推荐使用线程安全同时性能比较好的 ConcurrentHashMap。</p><h4 id="9、String不可变原因"><a href="#9、String不可变原因" class="headerlink" title="9、String不可变原因"></a>9、String不可变原因</h4><ol><li><p>可以使用<strong>字符串常量池</strong>，多次创建同样的字符串会指向同一个内存地址</p></li><li><p>可以很方便地用作 <strong>HashMap 的 key</strong>。通常建议把不可变对象作为 HashMap的 key</p></li><li><p>hashCode生成后就不会改变，使用时无需重新计算</p></li><li><p>线程安全，因为具备不变性的对象一定是线程安全的</p></li></ol><h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><p>​        Java 内存模型（Java Memory Model，JMM）就是一种符合内存模型规范的，屏蔽了各种硬件和操作系统的访问差异的，保证了 Java 程序在各种平台下对内存的访问都能保证效果一致的机制及规范。</p><p><img src="https://s0.lgstatic.com/i/image3/M01/7A/05/Cgq2xl54fTKALhevAAB_l3axT_o532.png" alt="img"></p><p>​        JMM 是一种规范，是解决由于多线程通过共享内存进行通信时，存在的本地内存数据不一致、编译器会对代码指令重排序、处理器会对代码乱序执行等带来的问题。目的是保证并发编程场景中的原子性、可见性和有序性。</p><p><strong>原子性：</strong></p><p>​        在 Java 中，为了保证原子性，提供了两个高级的字节码指令 Monitorenter 和 Monitorexit。这两个字节码，在 Java 中对应的关键字就是 Synchronized。因此，在 Java 中可以使用 Synchronized 来保证方法和代码块内的操作是原子性的。</p><p><strong>可见性：</strong></p><p>​        Java 中的 Volatile 关键字修饰的变量在被修改后可以立即同步到主内存。被其修饰的变量在每次使用之前都从主内存刷新。因此，可以使用 Volatile 来保证多线程操作时变量的可见性。除了 Volatile，Java 中的 Synchronized 和 Final 两个关键字也可以实现可见性。只不过实现方式不同</p><p><strong>有序性</strong></p><p>​        在 Java 中，可以使用 Synchronized 和 Volatile 来保证多线程之间操作的有序性。区别：Volatile 禁止指令重排。Synchronized 保证同一时刻只允许一条线程操作。</p><h4 id="1、volatile底层实现"><a href="#1、volatile底层实现" class="headerlink" title="1、volatile底层实现"></a><strong>1、volatile底层实现</strong></h4><p><strong>作用：</strong></p><p>​        保证数据的“可见性”：被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</p><p>​        禁止指令重排：在多线程操作情况下，指令重排会导致计算结果不一致</p><p><strong>底层实现：</strong></p><p>​        “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”</p><p>　　lock前缀指令实际上相当于一个<strong>内存屏障</strong>（也成内存栅栏），内存屏障会提供3个功能：</p><p>　　1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；</p><p>　　2）它会强制将对缓存的修改操作立即写入主存；</p><p>　　3）如果是写操作，它会导致其他CPU中对应的缓存行无效。</p><p><strong>单例模式中volatile的作用：</strong></p><p>防止代码读取到instance不为null时，instance引用的对象有可能还没有完成初始化。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Singleton</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton instance <span class="token operator">=</span> null<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//禁止指令重排</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//减少加锁的损耗</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>instance<span class="token operator">==</span>null<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//确认是否初始化完成</span>                    instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2、AQS思想"><a href="#2、AQS思想" class="headerlink" title="2、AQS思想"></a><strong>2、AQS思想</strong></h4><p>​        AQS的全称为（AbstractQueuedSynchronizer）抽象的队列式的同步器，是⼀个⽤来构建锁和同步器的框架，使⽤AQS能简单且⾼效地构造出应⽤⼴泛的⼤量的同步器，如：基于AQS实现的lock, CountDownLatch、CyclicBarrier、Semaphore需解决的问题：</p><pre><code>状态的原子性管理线程的阻塞与解除阻塞队列的管理</code></pre><p>​        AQS核⼼思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的⼯作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占⽤，那么就需要⼀套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是⽤<strong>CLH（虚拟的双向队列）</strong>队列锁实现的，即将暂时获取不到锁的线程加⼊到队列中。</p><p><strong>lock：</strong></p><p>​        是一种可重入锁，除了能完成 synchronized 所能完成的所有工作外，还提供了诸如可响应中断锁、可轮询锁请求、定时锁等避免多线程死锁的方法。默认为非公平锁，但可以初始化为公平锁； 通过方法 lock()与 unlock()来进行加锁与解锁操作；</p><p><strong>CountDownLatch：</strong></p><p>​        通过计数法（倒计时器），让一些线程堵塞直到另一个线程完成一系列操作后才被唤醒；该⼯具通常⽤来控制线程等待，它可以让某⼀个线程等待直到倒计时结束，再开始执⾏。具体可以使用countDownLatch.await()来等待结果。多用于多线程信息汇总。</p><p><strong>CompletableFuture：</strong></p><p>​        通过设置参数，可以完成CountDownLatch同样的多平台响应问题，但是可以针对其中部分返回结果做更加灵活的展示。</p><p><strong>CyclicBarrier：</strong></p><p>​        字面意思是可循环(Cyclic)使用的屏障（Barrier）。他要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活，线程进入屏障通过CyclicBarrier的await()方法。可以用于批量发送消息队列信息、异步限流。</p><p><strong>Semaphore：</strong></p><p>​        信号量主要用于两个目的，一个是用于多个共享资源的互斥作用，另一个用于并发线程数的控制。SpringHystrix限流的思想</p><h4 id="3、happens-before"><a href="#3、happens-before" class="headerlink" title="3、happens-before"></a>3、happens-before</h4><p>​        用来描述和可见性相关问题：如果第一个操作 happens-before 第二个操作，那么我们就说第一个操作对于第二个操作是可见的</p><p>​        常见的happens-before：volatile 、锁、线程生命周期。</p><h1 id="四、MySQL篇"><a href="#四、MySQL篇" class="headerlink" title="四、MySQL篇"></a>四、MySQL篇</h1><h3 id="WhyMysql？"><a href="#WhyMysql？" class="headerlink" title="WhyMysql？"></a>WhyMysql？</h3><p>NoSQL数据库四大家族 </p><ul><li>列存储 Hbase</li><li>K-V存储 Redis</li><li>图像存储 Neo4j</li><li>文档存储 MongoDB</li></ul><p>云存储OSS</p><h4 id="海量Aerospike"><a href="#海量Aerospike" class="headerlink" title="海量Aerospike"></a>海量Aerospike</h4><p>​    Aerospike（简称AS）是一个分布式，可扩展的键值存储的NoSQL<strong>数据库</strong>。T级别大数据高并发的结构化<strong>数据存储，</strong>采用混合架构，索引存储在内存中，而数据可存储在机械硬盘(HDD)或固态硬盘(SSD) 上，读写操作达微妙级，99%的响应可在1毫秒内实现。</p><table><thead><tr><th></th><th>Aerospike</th><th>Redis</th></tr></thead><tbody><tr><td>类型</td><td>Nosql数据库</td><td>缓存</td></tr><tr><td>线程数</td><td>多线程</td><td>单线程</td></tr><tr><td>数据分片</td><td>自动处理相当于分片</td><td>提供分片算法、平衡各分片数据</td></tr><tr><td>数据扩容</td><td>动态增加数据卷平衡流量</td><td>需停机</td></tr><tr><td>数据同步</td><td>设置复制因子后可以透明的完成故障转移</td><td>手动故障转移和数据同步</td></tr><tr><td>载体</td><td>内存存储索引+SSD存储数据</td><td>内存</td></tr></tbody></table><p>​    Aerospike作为一个大容量的NoSql解决方案，适合对<strong>容量要求比较大，QPS相对低</strong>一些的场景，主要用在广告行业，<strong>个性化推荐厂告</strong>是建立在了和掌握消费者独特的偏好和习性的基础之上，对消费者的购买需求做出准确的预测或引导，在合适的位置、合适的时间，以合适的形式向消费者呈现与其需求高度吻合的广告，以此来促进用户的消费行为。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmam43b44bj30d90d4aa7.jpg" alt="image-20210103170039711" style="zoom:50%;"></p><p>​    （ETL数据仓库技术）抽取（extract）、转换（transform）、加载（load）</p><ul><li><p>用户行为日志收集系统收集日志之后推送到ETL做数据的清洗和转换</p></li><li><p>把ETL过后的数据发送到推荐引擎计算每个消费者的推荐结果，其中推荐逻辑包括规则和算法两部分</p></li><li><p>收集用户最近浏览、最长停留等特征，分析商品相似性、用户相似性、相似性等算法。</p></li><li><p>把推荐引擎的结果存入Aerospike集群中，并提供给广告投放引擎实时获取</p><p>分别通过HDFS和HBASE对日志进行离线和实时的分析，然后把用户画像的标签(tag : 程序猿、宅男…)结果存入高性能的Nosql数据库Aerospike中，同时把数据备份到异地数据中心。前端广告投放请求通过决策引擎（投放引擎）向用户画像数据库中读取相应的用户画像数据，然后根据竞价算法出价进行竞价。竞价成功之后就可以展现广告了。而在竞价成功之后，具体给用户展现什么样的广告，就是有上面说的个性化推荐广告来完成的。</p></li></ul><table><thead><tr><th></th><th>Aerospike</th><th>Mysql</th></tr></thead><tbody><tr><td>库名</td><td>Namespace</td><td>Database</td></tr><tr><td>表名</td><td>Set</td><td>Table</td></tr><tr><td>记录</td><td>Bin</td><td>Column</td></tr><tr><td>字段</td><td>Record</td><td>Row</td></tr><tr><td>索引</td><td>key 、 pk 、kv</td><td>pk</td></tr></tbody></table><h4 id="图谱Neo4j"><a href="#图谱Neo4j" class="headerlink" title="图谱Neo4j"></a>图谱Neo4j</h4><blockquote><p>Neo4j是一个开源基于java开发的图形noSql数据库，它将结构化数据存储在图中而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎。程序数据是在一个面向对象的、灵活的网络结构下，而不是严格的表中，但具备完全的事务特性、企业级的数据库的所有好处。</p></blockquote><p>一种基于图的数据结构，由节点(Node)和边(Edge)组成。其中节点即实体，由一个全局唯一的ID标示，边就是关系用于连接两个节点。通俗地讲，知识图谱就是把所有不同种类的信息，连接在一起而得到的一个关系网络。知识图谱提供了从“关系”的角度去分析问题的能力。</p><p>互联网、大数据的背景下，谷歌、百度、搜狗等搜索引擎纷纷基于该背景，创建自己的知识图<strong>Knowledge Graph（谷歌</strong>）、<strong>知心（百度）</strong>和<strong>知立方（搜狗）</strong>，主要用于改进搜索质量。</p><p>自己项目主要用作好友推荐，图数据库(Graph database)指的是以图数据结构的形式来存储和查询数据的数据库。关系图谱中，关系的组织形式采用的就是图结构，所以非常适合用图库进行存储。</p><ul><li><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaq0j9otdj30pz0en0vm.jpg" alt="image-20210103191540372"></p><p>优势总结:</p></li><li><p>性能上，使用cql查询，对长程关系的查询速度快</p></li><li><p>擅于发现隐藏的关系，例如通过判断图上两点之间有没有走的通的路径，就可以发现事物间的关联</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqc75y6bj30wc0d60u4.jpg" alt="image-20210103192653004"></p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 查询三层级关系节点如下：with可以将前面查询结果作为后面查询条件</span><span class="token function">match</span> <span class="token punctuation">(</span>na<span class="token operator">:</span>Person<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">[</span>re<span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>nb<span class="token operator">:</span>Person<span class="token punctuation">)</span> where na<span class="token punctuation">.</span>name<span class="token operator">=</span><span class="token string">"林婉儿"</span> WITH na<span class="token punctuation">,</span>re<span class="token punctuation">,</span>nb <span class="token function">match</span> <span class="token punctuation">(</span>nb<span class="token operator">:</span>Person<span class="token punctuation">)</span><span class="token operator">-</span> <span class="token punctuation">[</span>re2<span class="token operator">:</span>Friends<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>nc<span class="token operator">:</span>Person<span class="token punctuation">)</span> <span class="token keyword">return</span> na<span class="token punctuation">,</span>re<span class="token punctuation">,</span>nb<span class="token punctuation">,</span>re2<span class="token punctuation">,</span>nc<span class="token comment" spellcheck="true">// 直接拼接关系节点查询</span>match data<span class="token operator">=</span><span class="token punctuation">(</span>na<span class="token operator">:</span>Person<span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">"范闲"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">[</span>re<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>nb<span class="token operator">:</span>Person<span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">[</span>re2<span class="token punctuation">]</span><span class="token operator">-</span><span class="token operator">></span><span class="token punctuation">(</span>nc<span class="token operator">:</span>Person<span class="token punctuation">)</span> <span class="token keyword">return</span> data<span class="token comment" spellcheck="true">// 使用深度运算符</span>显然使用以上方式比较繁琐<span class="token punctuation">,</span>可变数量的关系<span class="token operator">-</span><span class="token operator">></span>节点可以使用<span class="token operator">-</span><span class="token punctuation">[</span><span class="token operator">:</span>TYPE<span class="token operator">*</span>minHops<span class="token punctuation">.</span><span class="token punctuation">.</span>maxHops<span class="token punctuation">]</span><span class="token operator">-</span>。match data<span class="token operator">=</span><span class="token punctuation">(</span>na<span class="token operator">:</span>Person<span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">"范闲"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">[</span><span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">-</span><span class="token punctuation">(</span>nb<span class="token operator">:</span>Person<span class="token punctuation">)</span> <span class="token keyword">return</span> data</code></pre><h4 id="文档MongoDB"><a href="#文档MongoDB" class="headerlink" title="文档MongoDB"></a><strong>文档MongoDB</strong></h4><blockquote><p>MongoDB 是一个基于分布式文件存储的数据库，是非关系数据库中功能最丰富、最像关系数据库的。在高负载的情况下，通过添加更多的节点，可以保证服务器性能。由 C++ 编写，可以为 WEB 应用提供可扩展、高性能、易部署的数据存储解决方案。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaqyp75qsj312q0i8q5f.jpg" alt="image-20210103194830654" style="zoom:80%;"></p><p><strong>什么是BSON</strong></p><blockquote><p>{key:value,key2:value2}和Json类似，是一种二进制形式的存储格式，支持内嵌的文档对象和数组对象，但是BSON有JSON没有的一些数据类型，比如 value包括字符串,double,Array,DateBSON可以做为网络数据交换的一种存储形式,它的优点是灵活性高，但它的缺点是空间利用率不是很理想。</p></blockquote><p>BSON有三个特点：轻量性、可遍历性、高效性</p><pre class=" language-mysql"><code class="language-mysql">/* 查询 find() 方法可以传入多个键(key)，每个键(key)以逗号隔开*/db.collection.find({key1:value1, key2:value2}).pretty()/* 更新 $set ：设置字段值 $unset :删除指定字段 $inc：对修改的值进行自增*/db.collection.update({where},{$set:{字段名:值}},{multi:true})/* 删除 justOne :如果设为true，只删除一个文档，默认false，删除所有匹配条件的文档*/db.collection.remove({where}, {justOne: <boolean>, writeConcern: <回执> } )</code></pre><p><strong>优点：</strong></p><ul><li><p><strong>文档结构的存储方式，能够更便捷的获取数据。</strong></p><p>对于一个层级式的数据结构来说，使用扁平式的，表状的结构来查询保存数据非常的困难。</p></li><li><p><strong>内置GridFS，支持大容量的存储。</strong></p><p>GridFS是一个出色的分布式文件系统，支持海量的数据存储，满足对大数据集的快速范围查询。</p></li><li><p><strong>性能优越</strong></p><p>千万级别的文档对象，近10G的数据，对有索引的ID的查询 不会比mysql慢，而对非索引字段的查询，则是全面胜出。 mysql实际无法胜任大数据量下任意字段的查询，而mongodb的查询性能实在牛逼。写入性能同样很令人满意，同样写入百万级别的数据，mongodb基本10分钟以下可以解决。</p></li></ul><p>缺点：</p><ul><li>不支持事务</li><li>磁盘占用空间大</li></ul><p>MySQL 8.0 版本</p><p><strong>1. 性能</strong>：MySQL 8.0 的速度要比 MySQL 5.7 快 2 倍。</p><p><strong>2. NoSQL</strong>：MySQL 从 5.7 版本开始提供 NoSQL 存储功能，在 8.0 版本中nosql得到了更大的改进。</p><p><strong>3. 窗口函数</strong>：实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种集合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中，即窗口函数不需要 GROUP BY。</p><p><strong>4. 隐藏索引</strong>：在 MySQL 8.0 中，索引可以被“隐藏”和“显示”。当对索引进行隐藏时，它不会被查询优化器所使用。我们可以使用这个特性用于性能调试，例如我们先隐藏一个索引，然后观察其对数据库的影响。如果数据库性能有所下降，说明这个索引是有用的，然后将其“恢复显示”即可；如果数据库性能看不出变化，说明这个索引是多余的，可以考虑删掉。</p><h4 id="云存储"><a href="#云存储" class="headerlink" title="云存储"></a><strong>云存储</strong></h4><table><thead><tr><th></th><th>OSS</th><th>自建</th></tr></thead><tbody><tr><td>可靠性</td><td>可用性不低于99.995%<br>数据设计持久性不低于99.9999999999%（12个9）</td><td>受限于硬件可靠性，易出问题，一旦出现磁盘坏道，容易出现不可逆转的数据丢失。人工数据恢复困难、耗时、耗力。</td></tr><tr><td>安全</td><td>服务端加密、客户端加密、防盗链、IP黑白名单等。多用户资源隔离机制，支持异地容灾机制。</td><td>需要另外购买清洗和黑洞设备。需要单独实现安全机制。</td></tr><tr><td>成本</td><td>多线BGP骨干网络，无带宽限制，上行流量免费。无需运维人员与托管费用，0成本运维。</td><td>单线或双线接入速度慢，有带宽限制，峰值时期需人工扩容。需专人运维，成本高。</td></tr></tbody></table><p><strong>使用步骤</strong></p><p>​    1、开通服务</p><p>​    2、创建存储空间</p><p>​    3、上传文件、下载文件、删除文件</p><p>​    4、域名绑定、日志记录</p><p>​    5、根据开放接口进行鉴权访问</p><p><strong>功能</strong></p><p>​    图片编辑（裁剪、模糊、水印）</p><p>​    视频截图</p><p>​    音频转码、视频修复</p><p><strong>CDN加速</strong></p><p>​    对象存储OSS与阿里云CDN服务结合，可优化静态热点文件下载加速的场景（即同一地区大量用户同时下载同一个静态文件的场景）。可以将OSS的存储空间（Bucket）作为源站，利用阿里云CDN将源内容发布到边缘节点。当大量终端用户重复访问同一文件时，可以直接从边缘节点获取已缓存的数据，提高访问的响应速度</p><h4 id="FastDFS"><a href="#FastDFS" class="headerlink" title="FastDFS"></a><strong>FastDFS</strong></h4><blockquote><p><strong>开源的轻量级分布式文件系统</strong>。它对文件进行管理，功能包括：<strong>文件存储、文件同步、文件访问</strong>（文件上传、文件下载）等，解决了<strong>大容量存储和负载均衡</strong>的问题。使用FastDFS很容易搭建一套高性能的文件服务器集群提供文件上传、下载等服务。如<strong>相册网站、视频网站</strong>等</p></blockquote><p><strong>扩展能力:</strong> 支持水平扩展，可以动态扩容；</p><p><strong>高可用性:</strong> 一是整个文件系统的可用性，二是数据的完整和一致性；</p><p><strong>弹性存储:</strong> 可以根据业务需要灵活地增删存储池中的资源，而不需要中断系统运行。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhjkvo59j30zu0b4dib.jpg" alt="image-20210107221022658"></p><p>特性</p><ul><li>和流行的web server无缝衔接，FastDFS已提供apache和nginx扩展模块</li><li>文件ID由FastDFS生成，作为文件访问凭证，FastDFS不需要传统的name server</li><li>分组存储，灵活简洁、对等结构，不存在单点</li><li>文件不分块存储，上传的文件和OS文件系统中的文件一一对应</li><li>中、小文件均可以很好支持，支持海量小文件存储</li><li>支持相同内容的文件只保存一份，节约磁盘空间</li><li>支持多块磁盘，支持单盘数据恢复</li><li>支持在线扩容 支持主从文件</li><li>下载文件支持多线程方式，支持断点续传</li></ul><p><strong>组成</strong></p><ul><li><p><strong>客户端（client）</strong></p><p>通过专有接口，使用TCP/IP协议与跟踪器服务器或存储节点进行数据交互。</p></li><li><p><strong>跟踪器（tracker）</strong> </p><p>Trackerserver作用是负载均衡和调度，通过Tracker server在文件上传时可以根据策略找到文件上传的地址。Tracker在访问上起负载均衡的作用。</p></li><li><p><strong>存储节点（storage）</strong></p><p>Storageserver作用是文件存储，客户端上传的文件最终存储在Storage服务器上，Storage server<strong>没有实现自己的文件系统而是利用操作系统的文件系统来管理文件</strong>。存储节点中的服务器均可以<strong>随时增加或下线而不会影响线上服务</strong>。</p></li></ul><p><strong>上传</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhvk0wwzj30ue0h4dlw.jpg" alt="image-20210107222155291" style="zoom:50%;"></p><p><strong>下载</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfhww8zmfj30uw0g6n37.jpg" alt="image-20210107222312338" style="zoom:50%;"></p><p><strong>断点续传</strong></p><p>​    续传涉及到的文件大小MD5不会改变。续传流程与文件上传类似，先<strong>定位到源storage</strong>，完成完整或部分上传，再<strong>通过binlog进行同group内server文件同步</strong>。</p><p><strong>配置优化</strong></p><p>配置文件：tracker.conf 和 storage.conf </p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// FastDFS采用内存池的做法。 </span><span class="token comment" spellcheck="true">// v5.04对预分配采用增量方式，tracker一次预分配 1024个，storage一次预分配256个。 </span>max_connections <span class="token operator">=</span> <span class="token number">10240</span><span class="token comment" spellcheck="true">// 根据实际需要将 max_connections 设置为一个较大的数值，比如 10240 甚至更大。</span><span class="token comment" spellcheck="true">// 同时需要将一个进程允许打开的最大文件数调大</span>vi <span class="token operator">/</span>etc<span class="token operator">/</span>security<span class="token operator">/</span>limits<span class="token punctuation">.</span>conf 重启系统生效 <span class="token operator">*</span> soft nofile <span class="token number">65535</span> <span class="token operator">*</span> hard nofile <span class="token number">65535</span></code></pre><pre class=" language-java"><code class="language-java">work_threads <span class="token operator">=</span> <span class="token number">4</span> <span class="token comment" spellcheck="true">// 说明：为了避免CPU上下文切换的开销，以及不必要的资源消耗，不建议将本参数设置得过大。</span><span class="token comment" spellcheck="true">// 公式为： work_threads + (reader_threads + writer_threads) = CPU数</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 对于单盘挂载方式，磁盘读写线程分 别设置为 1即可 </span><span class="token comment" spellcheck="true">// 如果磁盘做了RAID，那么需要酌情加大读写线程数，这样才能最大程度地发挥磁盘性能</span>disk_rw_separated：磁盘读写是否分离 disk_reader_threads：单个磁盘读线程数 disk_writer_threads：单个磁盘写线程数 </code></pre><p><strong>避免重复</strong></p><p>​    如何避免文件重复上传 解决方案 上传成功后计算文件对应的MD5然后<strong>存入MySQL</strong>,添加文件时把<strong>文件MD5和之前存入MYSQL中的存储的信息对比</strong> 。DigestUtils.md5DigestAsHex(bytes)。</p><h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3><h4 id="1、事务4大特性"><a href="#1、事务4大特性" class="headerlink" title="1、事务4大特性"></a><strong>1、事务4大特性</strong></h4><p><strong>事务4大特性：</strong>原子性、一致性、隔离性、持久性</p><p>​    <strong>原⼦性：</strong> 事务是最⼩的执⾏单位，不允许分割。事务的原⼦性确保动作要么全部完成，要么全不执行</p><p>​    <strong>一致性：</strong> 执⾏事务前后，数据保持⼀致，多个事务对同⼀个数据读取的结果是相同的；</p><p>​    <strong>隔离性：</strong> 并发访问数据库时，⼀个⽤户的事务不被其他事务所⼲扰，各并发事务之间数据库是独⽴的；</p><p>​    <strong>持久性：</strong> ⼀个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发⽣故障也不应该对其有任何影响。</p><p><strong>实现保证：</strong></p><p>​        MySQL的存储引擎InnoDB使用重做日志保证一致性与持久性，回滚日志保证原子性，使用各种锁来保证隔离性。</p><h4 id="2、事务隔离级别"><a href="#2、事务隔离级别" class="headerlink" title="2、事务隔离级别"></a><strong>2、事务隔离级别</strong></h4><p><strong>读未提交：</strong>最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>读已提交：</strong>允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</p><p><strong>可重复读：</strong>同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，会有幻读。</p><p><strong>串行化：</strong>最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰。</p><table><thead><tr><th>隔离级别</th><th>并发问题</th></tr></thead><tbody><tr><td>读未提交</td><td>可能会导致脏读、幻读或不可重复读</td></tr><tr><td>读已提交</td><td>可能会导致幻读或不可重复读</td></tr><tr><td>可重复读</td><td>可能会导致幻读</td></tr><tr><td>可串行化</td><td>不会产⽣⼲扰</td></tr></tbody></table><p>ms</p><h4 id="3、默认隔离级别-RR"><a href="#3、默认隔离级别-RR" class="headerlink" title="3、默认隔离级别-RR"></a><strong>3、默认隔离级别-RR</strong></h4><p><strong>默认隔离级别：</strong>可重复读；</p><p>​        同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改；</p><p>​        可重复读是有可能出现幻读的，如果要保证绝对的安全只能把隔离级别设置成SERIALIZABLE；这样所有事务都只能顺序执行，自然不会因为并发有什么影响了，但是性能会下降许多。</p><p>​        第二种方式，使用MVCC解决<strong>快照读幻读问题</strong>（如简单select），读取的不是最新的数据。维护一个字段作为version，这样可以控制到每次只能有一个人更新一个版本。</p><pre class=" language-mysql"><code class="language-mysql">select id from table_xx where id = ? and version = Vupdate id from table_xx where id = ? and version = V+1</code></pre><p>​        第三种方式，如果需要读最新的数据，可以通过GapLock+Next-KeyLock可以解决<strong>当前读幻读问题</strong>，</p><pre class=" language-mysql"><code class="language-mysql">select id from table_xx where id > 100 for update;select id from table_xx where id > 100 lock in share mode;</code></pre><h4 id="4、RR和RC使用场景"><a href="#4、RR和RC使用场景" class="headerlink" title="4、RR和RC使用场景"></a><strong>4、RR和RC使用场景</strong></h4><p>​        事务隔离级别RC(read commit)和RR（repeatable read）两种事务隔离级别基于多版本并发控制MVCC(multi-version concurrency control）来实现。</p><table><thead><tr><th></th><th>RC</th><th>RR</th></tr></thead><tbody><tr><td>实现</td><td>多条查询语句会创建多个不同的ReadView</td><td>仅需要一个版本的ReadView</td></tr><tr><td>粒度</td><td>语句级读一致性</td><td>事务级读一致性</td></tr><tr><td>准确性</td><td>每次语句执行时间点的数据</td><td>第一条语句执行时间点的数据</td></tr></tbody></table><h4 id="5、行锁，表锁，意向锁"><a href="#5、行锁，表锁，意向锁" class="headerlink" title="5、行锁，表锁，意向锁"></a><strong>5、行锁，表锁，意向锁</strong></h4><p><strong>InnoDB⽀持⾏级锁(row-level locking)和表级锁,默认为⾏级锁</strong>    </p><p>​    InnoDB按照不同的分类的锁：</p><p>​    共享/排它锁(Shared and Exclusive Locks)：行级别锁，</p><p>​    意向锁(Intention Locks)，表级别锁</p><p>​    间隙锁(Gap Locks)，锁定一个区间</p><p>​    记录锁(Record Locks)，锁定一个行记录</p><p><strong>表级锁：（串行化）</strong></p><p>​        Mysql中锁定 粒度最大的一种锁，对当前操作的整张表加锁，实现简单 ，资源消耗也比较少，加锁快，不会出现死锁 。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</p><p><strong>行级锁：（RR、RC）</strong></p><p>​        Mysql中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB支持的行级锁，包括如下几种：</p><p>​        <strong>记录锁（Record Lock）:</strong> 对索引项加锁，锁定<strong>符合条件的行</strong>。其他事务不能修改和删除加锁项；</p><p>​        <strong>间隙锁（Gap Lock）:</strong> 对索引项之间的“间隙”加锁，锁定<strong>记录的范围</strong>，不包含索引项本身，其他事务不能在锁范围内插入数据。</p><p>​        <strong>Next-key Lock：</strong> 锁定索引项本身和索引范围。即Record Lock和Gap Lock的结合。可解决幻读问题。</p><p>InnoDB 支持多粒度锁（multiple granularity locking），它允许行级锁与表级锁共存，而意向锁就是其中的一种表锁。</p><p><strong>共享锁</strong>（ shared lock, S ）锁允许持有锁读取行的事务。加锁时将自己和子节点全加S锁，父节点直到表头全加IS锁</p><p><strong>排他锁</strong>（ exclusive lock， X ）锁允许持有锁修改行的事务。 加锁时将自己和子节点全加X锁，父节点直到表头全加IX锁  </p><p><strong>意向共享锁</strong>（intention shared lock, IS）：事务有意向对表中的某些行加<strong>共享锁</strong>（S锁）</p><p><strong>意向排他锁</strong>（intention exclusive lock, IX）：事务有意向对表中的某些行加<strong>排他锁</strong>（X锁）</p><table><thead><tr><th>互斥性</th><th>共享锁（S）</th><th>排它锁（X）</th><th>意向共享锁IS</th><th>意向排他锁IX</th></tr></thead><tbody><tr><td>共享锁（S）</td><td>✅</td><td>❌</td><td>✅</td><td>❌</td></tr><tr><td>排它锁（X）</td><td>❌</td><td>❌</td><td>❌</td><td>❌</td></tr><tr><td>意向共享锁IS</td><td>✅</td><td>❌</td><td>✅</td><td>✅</td></tr><tr><td>意向排他锁IX</td><td>❌</td><td>❌</td><td>✅</td><td>✅</td></tr></tbody></table><h4 id="6、MVCC多版本并发控制"><a href="#6、MVCC多版本并发控制" class="headerlink" title="6、MVCC多版本并发控制"></a><strong>6、MVCC多版本并发控制</strong></h4><p>​        MVCC是一种多版本并发控制机制，通过事务的可见性看到自己预期的数据，能降低其系统开销.（RC和RR级别工作）</p><p>​        InnoDB的MVCC,是通过在每行记录后面保存系统版本号(可以理解为事务的ID)，每开始一个新的事务，系统版本号就会自动递增，事务开始时刻的系统版本号会作为事务的ID。这样可以确保事务读取的行，要么是在事务开始前已经存在的，要么是事务自身插入或者修改过的，防止幻读的产生。</p><p>​        1.MVCC手段只适用于Msyql隔离级别中的读已提交（Read committed）和可重复读（Repeatable Read）.</p><p>​        2.Read uncimmitted由于存在脏读，即能读到未提交事务的数据行，所以不适用MVCC.</p><p>​        3.简单的select快照度不会加锁，删改及select for update等需要当前读的场景会加锁</p><p>​        原因是MVCC的创建版本和删除版本只要在事务提交后才会产生。客观上，mysql使用的是乐观锁的一整实现方式，就是每行都有版本号，保存时根据版本号决定是否成功。Innodb的MVCC使用到的快照存储在Undo日志中，该日志通过回滚指针把一个数据行所有快照连接起来。</p><p><strong>版本链</strong></p><p>在InnoDB引擎表中，它的聚簇索引记录中有两个必要的隐藏列：</p><p><strong>trx_id</strong></p><p>这个id用来存储的每次对某条聚簇索引记录进行修改的时候的事务id。</p><p><strong>roll_pointer</strong></p><p>每次对哪条聚簇索引记录有修改的时候，都会把老版本写入undo日志中。这个roll_pointer就是存了一个指针，它指向这条聚簇索引记录的上一个版本的位置，通过它来获得上一个版本的记录信息。(注意插入操作的undo日志没有这个属性，因为它没有老版本)</p><p>每次修改都会在版本链中记录。<strong>SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，</strong>提升了系统的性能。</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="1、Innodb和Myisam引擎"><a href="#1、Innodb和Myisam引擎" class="headerlink" title="1、Innodb和Myisam引擎"></a><strong>1、Innodb和Myisam引擎</strong></h4><p><strong>Myisam：</strong>支持表锁，适合读密集的场景，不支持外键，不支持事务，索引与数据在不同的文件</p><p><strong>Innodb：</strong>支持行、表锁，默认为行锁，适合并发场景，支持外键，支持事务，索引与数据同一文件</p><h4 id="2、哈希索引"><a href="#2、哈希索引" class="headerlink" title="2、哈希索引"></a><strong>2、哈希索引</strong></h4><p>​        哈希索引用索引列的值计算该值的hashCode，然后在hashCode相应的位置存执该值所在行数据的物理位置，因为使用散列算法，因此访问速度非常快，但是一个值只能对应一个hashCode，而且是散列的分布方式，因此哈希索引不支持范围查找和排序的功能</p><h4 id="3、B-树索引"><a href="#3、B-树索引" class="headerlink" title="3、B+树索引"></a><strong>3、B+树索引</strong></h4><p><strong>优点：</strong></p><p>​        B+树的磁盘读写代价低，更少的查询次数，查询效率更加稳定，有利于对数据库的扫描</p><p>​        B+树是B树的升级版，B+树只有叶节点存放数据，其余节点用来索引。索引节点可以全部加入内存，增加查询效率，叶子节点可以做双向链表，从而<strong>提高范围查找的效率，增加的索引的范围</strong></p><p>​        在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树与B+树可以有多个子女，从几十到上千，可以降低树的高度。</p><p>​        <strong>磁盘预读原理</strong>：将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><h4 id="4、创建索引"><a href="#4、创建索引" class="headerlink" title="4、创建索引"></a>4、创建索引</h4><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span>  <span class="token punctuation">[</span><span class="token keyword">UNIQUE</span> <span class="token operator">|</span> FULLTEXT<span class="token punctuation">]</span>  <span class="token keyword">INDEX</span>  索引名 <span class="token keyword">ON</span>  表名<span class="token punctuation">(</span>字段名<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">USING</span> 索引方法<span class="token punctuation">]</span>；说明：<span class="token keyword">UNIQUE</span>:可选。表示索引为唯一性索引。FULLTEXT:可选。表示索引为全文索引。<span class="token keyword">INDEX</span>和<span class="token keyword">KEY</span>:用于指定字段为索引，两者选择其中之一就可以了，作用是一样的。索引名:可选。给创建的索引取一个新名称。字段名<span class="token number">1</span>:指定索引对应的字段的名称，该字段必须是前面定义好的字段。注：索引方法默认使用B<span class="token operator">+</span>TREE。</code></pre><h4 id="5、聚簇索引和非聚簇索引"><a href="#5、聚簇索引和非聚簇索引" class="headerlink" title="5、聚簇索引和非聚簇索引"></a><strong>5、聚簇索引和非聚簇索引</strong></h4><p>​    <strong>聚簇索引：</strong>将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据（<strong>主键索引</strong>）</p><p>​    <strong>非聚簇索引：</strong>将数据与索引分开存储，索引结构的叶子节点指向了数据对应的位置（<strong>辅助索引</strong>）</p><p>​    聚簇索引的叶子节点就是数据节点，而非聚簇索引的叶子节点仍然是索引节点，只不过有指向对应数据块的指针。</p><h4 id="6、最左前缀问题"><a href="#6、最左前缀问题" class="headerlink" title="6、最左前缀问题"></a>6、最左前缀问题</h4><p>​        最左前缀原则主要使用在联合索引中，联合索引的B+Tree是按照第一个关键字进行索引排列的。</p><p>​        联合索引的底层是一颗B+树，只不过联合索引的B+树节点中存储的是键值。由于构建一棵B+树只能根据一个值来确定索引关系，所以数据库依赖联合索引最左的字段来构建。</p><p>​        采用&gt;、&lt;等进行匹配都会导致后面的列无法走索引，因为通过以上方式匹配到的数据是不可知的。</p><h3 id="SQL查询"><a href="#SQL查询" class="headerlink" title="SQL查询"></a>SQL查询</h3><h4 id="1、SQL语句的执行过程"><a href="#1、SQL语句的执行过程" class="headerlink" title="1、SQL语句的执行过程"></a><strong>1、SQL语句的执行过程</strong></h4><p><strong>查询语句：</strong></p><pre class=" language-mysql"><code class="language-mysql">select * from student  A where A.age='18' and A.name='张三';</code></pre><p><img src="http://s0.lgstatic.com/i/image2/M01/8B/0F/CgotOV14ySKAMxohAAH2VHcAzkE612.png" alt="img" style="zoom: 67%;"></p><p>结合上面的说明，我们分析下这个语句的执行流程：</p><p>①通过客户端/服务器通信协议与 MySQL 建立连接。并查询是否有权限</p><p>②Mysql8.0之前开看是否开启缓存，开启了 Query Cache 且命中完全相同的 SQL 语句，则将查询结果直接返回给客户端；</p><p>③由解析器进行语法语义解析，并生成解析树。如查询是select、表名tb_student、条件是id=’1’</p><p>④查询优化器生成执行计划。根据索引看看是否可以优化</p><p>⑤查询执行引擎执行 SQL 语句，根据存储引擎类型，得到查询结果。若开启了 Query Cache，则缓存，否则直接返回。</p><h4 id="2、回表查询和覆盖索引"><a href="#2、回表查询和覆盖索引" class="headerlink" title="2、回表查询和覆盖索引"></a><strong>2、回表查询和覆盖索引</strong></h4><p><strong>普通索引</strong>（唯一索引+联合索引+全文索引）需要扫描两遍索引树</p><p>（1）先通过普通索引定位到主键值id=5；</p><p>（2）在通过聚集索引定位到行记录；</p><p>这就是所谓的<strong>回表查询</strong>，先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。</p><p><strong>覆盖索引</strong>：主键索引==聚簇索引==覆盖索引</p><p>​    如果where条件的列和返回的数据在一个索引中，那么不需要回查表，那么就叫覆盖索引。</p><p><strong>实现覆盖索引</strong>：常见的方法是，将被查询的字段，建立到联合索引里去。</p><h4 id="3、Explain及优化"><a href="#3、Explain及优化" class="headerlink" title="3、Explain及优化"></a>3、Explain及优化</h4><p>参考：<a href="https://www.jianshu.com/p/8fab76bbf448" target="_blank" rel="noopener">https://www.jianshu.com/p/8fab76bbf448</a></p><pre class=" language-mysql"><code class="language-mysql">mysql> explain select * from staff;+----+-------------+-------+------+---------------+------+---------+------+------+-------+| id | select_type | table | type | possible_keys | key  | key_len | ref  | rows | Extra |+----+-------------+-------+------+---------------+------+---------+------+------+-------+|  1 | SIMPLE      | staff | ALL  | NULL          | 索引  | NULL    | NULL |    2 | NULL  |+----+-------------+-------+------+---------------+------+---------+------+------+-------+1 row in set</code></pre><p><strong>索引优化：</strong></p><p>​    ①最左前缀索引：like只用于’string%’，语句中的=和in会动态调整顺序</p><p>​    ②唯一索引：唯一键区分度在0.1以上</p><p>​    ③无法使用索引：!=  、is null 、 or、&gt;&lt; 、（<strong>5.7以后根据数量自动判定）in 、not in</strong></p><p>​    ④联合索引：避免select * ，查询列使用覆盖索引</p><pre class=" language-mysql"><code class="language-mysql">SELECT uid From user Where gid = 2 order by ctime asc limit 10ALTER TABLE user add index idx_gid_ctime_uid(gid,ctime,uid) #创建联合覆盖索引，避免回表查询</code></pre><p><strong>语句优化：</strong></p><p>​    ①char固定长度查询效率高，varchar第一个字节记录数据长度</p><p>​    ②应该针对Explain中Rows增加索引</p><p>​    ③group/order by字段均会涉及索引</p><p>​    ④Limit中分页查询会随着start值增大而变缓慢，通过子查询+表连接解决</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mytbl <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span>  改进后的SQL语句如下：<span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mytbl <span class="token keyword">where</span> id <span class="token operator">>=</span> <span class="token punctuation">(</span> <span class="token keyword">select</span> id <span class="token keyword">from</span> mytbl <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token punctuation">)</span> <span class="token keyword">limit</span> <span class="token number">10</span><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> mytbl <span class="token keyword">inner</span> ori <span class="token keyword">join</span> <span class="token punctuation">(</span><span class="token keyword">select</span> id <span class="token keyword">from</span> mytbl <span class="token keyword">order</span> <span class="token keyword">by</span> id <span class="token keyword">limit</span> <span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token keyword">as</span> tmp <span class="token keyword">on</span> tmp<span class="token punctuation">.</span>id<span class="token operator">=</span>ori<span class="token punctuation">.</span>id<span class="token punctuation">;</span></code></pre><p>​    ⑤count会进行全表扫描，如果估算可以使用explain</p><p>​    ⑥delete删除表时会增加大量undo和redo日志， 确定删除可使用trancate</p><p><strong>表结构优化：</strong></p><p>​    ①单库不超过200张表</p><p>​    ②单表不超过500w数据</p><p>​    ③单表不超过40列</p><p>​    ④单表索引不超过5个</p><p><strong>数据库范式</strong> ：</p><p>​    ①第一范式（1NF）列不可分割</p><p>​    ②第二范式（2NF）属性完全依赖于主键 [ 消除部分子函数依赖 ]</p><p>​    ③第三范式（3NF）属性不依赖于其它非主属性 [ 消除传递依赖 ]</p><p><strong>配置优化：</strong></p><p>​    配置连接数、禁用Swap、增加内存、升级SSD硬盘</p><h4 id="4、JOIN查询"><a href="#4、JOIN查询" class="headerlink" title="4、JOIN查询"></a>4、JOIN查询</h4><p><img src="https://image-static.segmentfault.com/276/780/2767807589-5c122586a23c4_articlex" style="align:left;zoom: 60%;"></p><p><strong>left join(左联接)</strong> 返回包括左表中的所有记录和右表中关联字段相等的记录 </p><p><strong>right join(右联接)</strong> 返回包括右表中的所有记录和左表中关联字段相等的记录</p><p><strong>inner join(等值连接)</strong> 只返回两个表中关联字段相等的行</p><h3 id="集群"><a href="#集群" class="headerlink" title="集群"></a><strong>集群</strong></h3><h4 id="1、主从复制过程"><a href="#1、主从复制过程" class="headerlink" title="1、主从复制过程"></a>1、主从复制过程</h4><p><strong>MySQl主从复制：</strong></p><ul><li><strong>原理</strong>：将主服务器的binlog日志复制到从服务器上执行一遍，达到主从数据的一致状态。</li><li><strong>过程</strong>：从库开启一个I/O线程，向主库请求Binlog日志。主节点开启一个binlog dump线程，检查自己的二进制日志，并发送给从节点；从库将接收到的数据保存到中继日志（Relay log）中，另外开启一个SQL线程，把Relay中的操作在自身机器上执行一遍</li><li><strong>优点</strong>：<ul><li>作为备用数据库，并且不影响业务</li><li>可做读写分离，一个写库，一个或多个读库，在不同的服务器上，充分发挥服务器和数据库的性能，但要保证数据的一致性</li></ul></li></ul><p><strong>binlog记录格式：</strong>statement、row、mixed</p><p>​        基于语句statement的复制、基于行row的复制、基于语句和行（mix）的复制。其中基于row的复制方式更能保证主从库数据的一致性，但日志量较大，在设置时考虑磁盘的空间问题</p><h4 id="2、数据一致性问题"><a href="#2、数据一致性问题" class="headerlink" title="2、数据一致性问题"></a>2、数据一致性问题</h4><p>“主从复制有延时”，这个延时期间读取从库，可能读到不一致的数据。</p><p><strong>缓存记录写key法：</strong></p><p>​        在cache里记录哪些记录发生过的写请求，来路由读主库还是读从库</p><p><strong>异步复制：</strong></p><p>​        在异步复制中，主库执行完操作后，写入binlog日志后，就返回客户端，这一动作就结束了，并不会验证从库有没有收到，完不完整，所以这样可能<strong>会造成数据的不一致</strong>。</p><p><strong>半同步复制：</strong></p><p>​        当主库每提交一个事务后，不会立即返回，而是等待其中一个从库接收到Binlog并成功写入Relay-log中才返回客户端，通过一份在主库的Binlog，另一份在其中一个从库的Relay-log，可以保证了数据的安全性和一致性。</p><p><strong>全同步复制：</strong></p><p>​        指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的<strong>性能必然会收到严重的影响</strong>。</p><h4 id="3、集群架构"><a href="#3、集群架构" class="headerlink" title="3、集群架构"></a>3、集群架构</h4><p> <strong>Keepalived + VIP + MySQL 主从/双主</strong></p><p>​        当写节点 Master db1 出现故障时，由 MMM Monitor 或 Keepalived 触发切换脚本，将 VIP 漂移到可用的 Master db2 上。当出现网络抖动或网络分区时，MMM Monitor 会误判，严重时来回切换写 VIP 导致集群双写，当数据复制延迟时，应用程序会出现数据错乱或数据冲突的故障。有效避免单点失效的架构就是采用共享存储，单点故障切换可以通过分布式哨兵系统监控。</p><p><img src="http://s0.lgstatic.com/i/image2/M01/89/48/CgoB5l12KuGALf-cAAGuHVmMkHs743.png" alt="img" style="zoom: 67%;"></p><p> <strong>架构选型：</strong>MMM 集群  -&gt; MHA集群 -&gt; MHA+Arksentinel。</p><p><img src="http://s0.lgstatic.com/i/image2/M01/89/68/CgotOV12KuKAe_HOAABl-wRATa0772.png" alt="img"></p><h4 id="4、故障转移和恢复"><a href="#4、故障转移和恢复" class="headerlink" title="4、故障转移和恢复"></a>4、故障转移和恢复</h4><p><strong>转移方式及恢复方法</strong></p><pre><code>1. 虚拟IP或DNS服务 （Keepalived +VIP/DNS  和 MMM 架构）</code></pre><p>​    问题：在虚拟 IP 运维过程中，刷新ARP过程中有时会出现一个 VIP 绑定在多台服务器同时提供连接的问题。这也是为什么要避免使用 Keepalived+VIP 和 MMM 架构的原因之一，因为它处理不了这类问题而导致集群多点写入。</p><pre><code>2. 提升备库为主库（MHA、QMHA）</code></pre><p>​    尝试将原 Master 设置 read_only 为 on，避免集群多点写入。借助 binlog server 保留 Master 的 Binlog；当出现数据延迟时，再提升 Slave 为新 Master 之前需要进行数据补齐，否则会丢失数据。</p><h3 id="面试题-1"><a href="#面试题-1" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h5 id="如何进行分库分表"><a href="#如何进行分库分表" class="headerlink" title="如何进行分库分表"></a>如何进行分库分表</h5><blockquote><p><strong>分表</strong>用户id进行分表，每个表控制在300万数据。</p><p><strong>分库</strong>根据业务场景和地域分库，每个库并发不超过2000</p></blockquote><p><strong>Sharding-jdbc</strong> 这种 client 层方案的<strong>优点在于不用部署，运维成本低，不需要代理层的二次转发请求，性能很高</strong>，但是各个系统都需要<strong>耦合</strong> Sharding-jdbc 的依赖，升级比较麻烦</p><p><strong>Mycat</strong> 这种 proxy 层方案的<strong>缺点在于需要部署</strong>，自己运维一套中间件，运维成本高，但是<strong>好处在于对于各个项目是透明的</strong>，如果遇到升级之类的都是自己中间件那里搞就行了</p><p><strong>水平拆分</strong>：一个表放到多个库，分担高并发，加快查询速度</p><ul><li><strong>id</strong>保证业务在关联多张表时可以在同一库上操作</li><li><strong>range</strong>方便扩容和数据统计</li><li><strong>hash</strong>可以使得数据更加平均</li></ul><p><strong>垂直拆分</strong>：一个表拆成多个表，可以将一些冷数据拆分到冗余库中</p><blockquote><p>不是写瓶颈优先进行分表</p></blockquote><ul><li><p>分库数据间的数据无法再通过数据库直接查询了。会产生深分页的问题</p></li><li><p>分库越多，出现问题的可能性越大，维护成本也变得更高。</p></li><li><p>分库后无法保障跨库间事务，只能借助其他中间件实现最终一致性。</p></li></ul><p>分库首先需考虑满足业务最核心的场景：</p><p>1、订单数据按<strong>用户</strong>分库，可以<strong>提升用户的全流程体验</strong></p><p>2、超级客户导致<strong>数据倾斜</strong>可以使用最细粒度唯一标识进行hash拆分</p><p>3、按照最细粒度如订单号拆分以后，数据库就无法进行单库排重了</p><p>三个问题：</p><ul><li><p>富查询：采用分库分表之后，如何满足跨越分库的查询？<strong>使用ES</strong>的宽表</p><p>借助<strong>分库网关+分库业务</strong>虽然能够实现<strong>多维度查询的能力</strong>，但整体上性能不佳且对正常的写入请求有一定的影响。业界应对<strong>多维度实时查询</strong>的最常见方式便是借助 <strong>ElasticSearch</strong></p></li><li><p>数据倾斜：数据分库基础上再进行分表</p></li><li><p>分布式事务：跨多库的修改及多个微服务间的写操作导致的分布式事务问题？</p></li><li><p>深分页问题：按游标查询，或者叫每次查询都带上上一次查询经过排序后的最大 ID</p></li></ul><h4 id="如何将老数据进行迁移"><a href="#如何将老数据进行迁移" class="headerlink" title="如何将老数据进行迁移"></a>如何将老数据进行迁移</h4><p><strong>双写不中断迁移</strong></p><ul><li>线上系统里所有写库的地方，增删改操作，<strong>除了对老库增删改，都加上对新库的增删改</strong></li><li>系统部署以后，还需要跑程序读老库数据写新库，写的时候需要判断updateTime</li><li>循环执行，直至两个库的数据完全一致，最后重新部署分库分表的代码就行了</li></ul><h4 id="系统性能的评估及扩容"><a href="#系统性能的评估及扩容" class="headerlink" title="系统性能的评估及扩容"></a>系统性能的评估及扩容</h4><p>和家亲目前有1亿用户：场景 10万写并发，100万读并发，60亿数据量</p><p>设计时考虑极限情况，32库*32表~64个表，一共1000 ~ 2000张表</p><ul><li>支持<strong>3万</strong>的写并发，配合MQ实现每秒10万的写入速度</li><li>读写分离<strong>6万</strong>读并发，配合分布式缓存每秒100读并发</li><li><p>2000张表每张300万，可以最多写入60亿的数据</p></li><li><p>32张用户表，支撑亿级用户，后续最多也就扩容一次</p></li></ul><p><strong>动态扩容的步骤</strong></p><ol><li>推荐是 32 库 * 32 表，对于我们公司来说，可能几年都够了。</li><li>配置路由的规则，uid % 32 = 库，uid / 32 % 32 = 表</li><li>扩容的时候，申请增加更多的数据库服务器，呈倍数扩容</li><li>由 DBA 负责将原先数据库服务器的库，迁移到新的数据库服务器上去</li><li>修改一下配置，重新发布系统，上线，原先的路由规则变都不用变</li><li>直接可以基于 n 倍的数据库服务器的资源，继续进行线上系统的提供服务。</li></ol><h4 id="如何生成自增的id主键"><a href="#如何生成自增的id主键" class="headerlink" title="如何生成自增的id主键"></a>如何生成自增的id主键</h4><ul><li>使用redis可以</li><li>并发不高可以单独起一个<strong>服务</strong>，生成自增id</li><li>设置数据库<strong>step</strong>自增步长可以支撑水平伸缩</li><li>UUID适合文件名、编号，但是<strong>不适合做主键</strong></li><li><strong>snowflake雪花算法</strong>，综合了<strong>41时间</strong>（ms）、<strong>10机器</strong>、<strong>12序列号</strong>（ms内自增）</li></ul><p>其中机器预留的10bit可以根据自己的业务场景配置</p><h3 id="线上故障及优化"><a href="#线上故障及优化" class="headerlink" title="线上故障及优化"></a>线上故障及优化</h3><h4 id="更新失败-主从同步延时"><a href="#更新失败-主从同步延时" class="headerlink" title="更新失败 | 主从同步延时"></a>更新失败 | 主从同步延时</h4><p>以前线上确实处理过因为主从同步延时问题而导致的线上的 bug，属于小型的生产事故。</p><p>是这个么场景。有个同学是这样写代码逻辑的。先插入一条数据，再把它查出来，然后更新这条数据。在生产环境高峰期，写并发达到了 2000/s，这个时候，主从复制延时大概是在小几十毫秒。线上会发现，每天总有那么一些数据，我们期望更新一些重要的数据状态，但在高峰期时候却没更新。用户跟客服反馈，而客服就会反馈给我们。</p><p>我们通过 MySQL 命令：</p><pre><code>show slave status</code></pre><p>查看 <code>Seconds_Behind_Master</code> ，可以看到从库复制主库的数据落后了几 ms。</p><p>一般来说，如果主从延迟较为严重，有以下解决方案：</p><ul><li>分库，拆分为多个主库，每个主库的写并发就减少了几倍，主从延迟可以忽略不计。</li><li>重写代码，写代码的同学，要慎重，插入数据时立马查询可能查不到。</li><li>如果确实是存在必须先插入，立马要求就查询到，然后立马就要反过来执行一些操作，对这个查询<strong>设置直连主库</strong>或者<strong>延迟查询</strong>。主从复制延迟一般不会超过50ms</li></ul><h4 id="应用崩溃-分库分表优化"><a href="#应用崩溃-分库分表优化" class="headerlink" title="应用崩溃 | 分库分表优化"></a><strong>应用崩溃 | 分库分表优化</strong></h4><p>​    我们有一个线上通行记录的表，由于数据量过大，进行了分库分表，当时分库分表初期经常产生一些问题。典型的就是通行记录查询中使用了深分页，通过一些工具如MAT、Jstack追踪到是由于sharding-jdbc内部引用造成的。</p><p>​    通行记录数据被存放在两个库中。如果没有提供<strong>切分键</strong>，查询语句就会被分发到所有的数据库中，比如查询语句是 limit 10、offset 1000，最终结果只需要返回 10 条记录，但是数据库中间件要完成这种计算，则需要 (1000+10)*2=2020 条记录来完成这个计算过程。如果 offset 的值过大，使用的内存就会暴涨。虽然 sharding-jdbc 使用归并算法进行了一些优化，但在实际场景中，深分页仍然引起了<strong>内存和性能</strong>问题。</p><p>​    这种在中间节点进行<strong>归并聚合</strong>的操作，在分布式框架中非常常见。比如在 ElasticSearch 中，就存在相似的数据获取逻辑，<strong>不加限制的深分页</strong>，同样会造成 ES 的内存问题。</p><p><strong>业界解决方案：</strong></p><p><strong>方法一：全局视野法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset 0 limit X+Y</p><p>（2）服务层对得到的N*(X+Y)条数据进行内存排序，内存排序后再取偏移量X后的Y条记录</p><p>这种方法随着翻页的进行，性能越来越低。</p><p><strong>方法二：业务折衷法-禁止跳页查询</strong></p><p>（1）用正常的方法取得第一页数据，并得到第一页记录的time_max</p><p>（2）每次翻页，将order by time offset X limit Y，改写成order by time where time&gt;$time_max limit Y</p><p>以保证每次只返回一页数据，性能为常量。</p><p><strong>方法三：业务折衷法-允许模糊数据</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X/N limit Y/N</p><p><strong>方法四：二次查询法</strong></p><p>（1）将order by time offset X limit Y，改写成order by time offset X/N limit Y</p><p>（2）找到最小值time_min</p><p>（3）between二次查询，order by time between $time_min and $time_i_max</p><p>（4）设置虚拟time_min，找到time_min在各个分库的offset，从而得到time_min在全局的offset</p><p>（5）得到了time_min在全局的offset，自然得到了全局的offset X limit Y</p><h4 id="查询异常-SQL-调优"><a href="#查询异常-SQL-调优" class="headerlink" title="查询异常 | SQL 调优"></a>查询异常 | SQL 调优</h4><p>分库分表前，有一段用用户名来查询某个用户的 SQL 语句：</p><pre class=" language-python"><code class="language-python">select <span class="token operator">*</span> <span class="token keyword">from</span> user where name <span class="token operator">=</span> <span class="token string">"xxx"</span> <span class="token operator">and</span> community<span class="token operator">=</span><span class="token string">"other"</span><span class="token punctuation">;</span></code></pre><p>为了达到动态拼接的效果，这句 SQL 语句被一位同事进行了如下修改。他的本意是，当 name 或者 community 传入为空的时候，动态去掉这些查询条件。这种写法，在 MyBaits 的配置文件中，也非常常见。大多数情况下，这种写法是没有问题的，因为结果集合是可以控制的。但随着系统的运行，用户表的记录越来越多，当传入的 name 和 community 全部为空时，悲剧的事情发生了:</p><pre><code>select * from user where 1=1</code></pre><p>数据库中的所有记录，都会被查询出来，载入到 JVM 的内存中。由于数据库记录实在太多，直接把内存给撑爆了。由于这种原因引起的内存溢出，发生的频率非常高，比如导入Excel文件时。</p><p>通常的解决方式是<strong>强行加入分页功能</strong>，或者对一些<strong>必填的参数进行校验</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gobovqjvijj30zd0lctbp.jpg" alt="img"></p><p><strong>Controller 层</strong></p><p>现在很多项目都采用前后端分离架构，所以 Controller 层的方法，一般使用 @ResponseBody 注解，把查询的结果，解析成 JSON 数据返回。这在数据集非常大的情况下，会占用很多内存资源。假如结果集在解析成 JSON 之前，占用的内存是 10MB，那么在解析过程中，有可能会使用 20M 或者更多的内存</p><p>因此，保持结果集的精简，是非常有必要的，这也是 DTO（Data Transfer Object）存在的必要。互联网环境不怕小结果集的高并发请求，却非常恐惧大结果集的耗时请求，这是其中一方面的原因。</p><p><strong>Service 层</strong></p><p>Service 层用于处理具体的业务，更加贴合业务的功能需求。一个 Service，可能会被多个 Controller 层所使用，也可能会使用多个 dao 结构的查询结果进行计算、拼装。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> <span class="token function">getUserSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>User<span class="token operator">></span> users <span class="token operator">=</span> dao<span class="token punctuation">.</span><span class="token function">getAllUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null <span class="token operator">==</span> users <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> users<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>代码review中发现了定时炸弹，这种在数据量达到一定程度后，才会暴露问题。</p><p><strong>ORM 层</strong></p><p>比如使用Mybatis时，有一个批量导入服务，在 MyBatis 执行批量插入的时候，竟然产生了内存溢出，按道理这种插入操作是不会引起额外内存占用的，最后通过源码追踪到了问题。</p><p>这是因为 MyBatis 循环处理 batch 的时候，操作对象是数组，而我们在接口定义的时候，使用的是 List；当传入一个非常大的 List 时，它需要调用 List 的 toArray 方法将列表转换成数组（浅拷贝）；在最后的拼装阶段，又使用了 StringBuilder 来拼接最终的 SQL，所以实际使用的内存要比 List 多很多。</p><p>事实证明，不论是插入操作还是查询动作，只要涉及的数据集非常大，就容易出现问题。由于项目中众多框架的引入，想要分析这些具体的内存占用，就变得非常困难。所以保持小批量操作和结果集的干净，是一个非常好的习惯。</p><h1 id="五、Redis篇"><a href="#五、Redis篇" class="headerlink" title="五、Redis篇"></a><strong>五、Redis篇</strong></h1><h3 id="WhyRedis"><a href="#WhyRedis" class="headerlink" title="WhyRedis"></a>WhyRedis</h3><p>​        速度快，完全基于内存，使用C语言实现，网络层使用epoll解决高并发问题，单线程模型避免了不必要的上下文切换及竞争条件；</p><table><thead><tr><th></th><th>GuavaCache</th><th>Tair</th><th>EVCache</th><th>Aerospike</th></tr></thead><tbody><tr><td>类别</td><td>本地JVM缓存</td><td>分布式缓存</td><td>分布式缓存</td><td>分布式nosql数据库</td></tr><tr><td>应用</td><td>本地缓存</td><td>淘宝</td><td>Netflix、AWS</td><td>广告</td></tr><tr><td>性能</td><td>非常高</td><td>较高</td><td>很高</td><td>较高</td></tr><tr><td>持久化</td><td>无</td><td>有</td><td>有</td><td>有</td></tr><tr><td>集群</td><td>无</td><td>灵活配置</td><td>有</td><td>自动扩容</td></tr></tbody></table><p>​        与传统数据库不同的是 Redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。另外，Redis 也经常用来做分布式锁。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h4 id="1、简单高效"><a href="#1、简单高效" class="headerlink" title="1、简单高效"></a>1、简单高效</h4><p>​        1）完全基于内存，绝大部分请求是纯粹的内存操作。数据存在内存中，类似于 HashMap，查找和操作的时间复杂度都是O(1)；</p><p>​        2）数据结构简单，对数据操作也简单，Redis 中的数据结构是专门进行设计的；</p><p>​        3）采用单线程，避免了多线程不必要的上下文切换和竞争条件，不存在加锁释放锁操作，减少了因为锁竞争导致的性能消耗；（6.0以后多线程）</p><p>​        4）使用EPOLL多路 I/O 复用模型，非阻塞 IO；</p><p>​        5）使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis 直接自己构建了 VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；</p><h4 id="2、Memcache"><a href="#2、Memcache" class="headerlink" title="2、Memcache"></a>2、Memcache</h4><table><thead><tr><th>redis</th><th>Memcached</th></tr></thead><tbody><tr><td>内存高速数据库</td><td>高性能分布式内存缓存数据库</td></tr><tr><td>支持hash、list、set、zset、string结构</td><td>只支持key-value结构</td></tr><tr><td>将大部分数据放到内存</td><td>全部数据放到内存中</td></tr><tr><td>支持持久化、主从复制备份</td><td>不支持数据持久化及数据备份</td></tr><tr><td>数据丢失可通过AOF恢复</td><td>挂掉后，数据不可恢复</td></tr><tr><td>单线程（2~4万TPS）</td><td>多线程（20-40万TPS）</td></tr></tbody></table><p><strong>使用场景：</strong></p><p>​    1、如果有持久方面的需求或对数据类型和处理有要求的应该选择redis。<br>​    2、如果简单的key/value 存储应该选择memcached。    </p><h4 id="3、Tair"><a href="#3、Tair" class="headerlink" title="3、Tair"></a>3、Tair</h4><p>​    Tair(Taobao Pair)是淘宝开发的分布式Key-Value存储引擎，既可以做缓存也可以做数据源（三种引擎切换）</p><ul><li>MDB（Memcache）属于内存型产品,支持kv和类hashMap结构,性能最优</li><li>RDB（Redis）支持List.Set.Zset等复杂的数据结构,性能次之,可提供缓存和持久化存储两种模式</li><li>LDB（levelDB）属于持久化产品,支持kv和类hashmap结构,性能较前两者稍低,但持久化可靠性最高</li></ul><p><strong>分布式缓存</strong></p><p>大访问少量临时数据的存储（kb左右）</p><p>用于缓存，降低对后端数据库的访问压力</p><p>session场景</p><p>高速访问某些数据结构的应用和计算（rdb）</p><p><strong>数据源存储</strong></p><p>快速读取数据（fdb）</p><p>持续大数据量的存入读取（ldb），交易快照</p><p>高频度的更新读取（ldb），库存</p><p><strong>痛点</strong>：redis集群中，想借用缓存资源必须得指明redis服务器地址去要。这就增加了程序的维护复杂度。因为redis服务器很可能是需要频繁变动的。所以人家淘宝就想啊，为什么不能像操作分布式数据库或者hadoop那样。增加一个中央节点，让他去代理所有事情。在tair中程序只要跟tair中心节点交互就OK了。同时tair里还有配置服务器概念。又免去了像操作hadoop那样，还得每台hadoop一套一模一样配置文件。改配置文件得整个集群都跟着改。</p><h4 id="4、Guava"><a href="#4、Guava" class="headerlink" title="4、Guava"></a>4、Guava</h4><p>​        分布式缓存一致性更好一点，用于集群环境下多节点使用同一份缓存的情况；有网络IO，吞吐率与缓存的数据大小有较大关系；</p><p>​        本地缓存非常高效，本地缓存会占用堆内存，影响垃圾回收、影响系统性能。</p><p><strong>本地缓存设计：</strong></p><p>​        以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p><strong>解决缓存过期：</strong></p><p>​    1、将缓存过期时间调为永久</p><p>​    2、将缓存失效时间分散开，不要将缓存时间长度都设置成一样；比如我们可以在原有的失效时间基础上增加一个随机值，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p><p><strong>解决内存溢出：</strong></p><p>​    <strong>第一步</strong>，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)</p><p>　<strong>第二步</strong>，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</p><p>　<strong>第三步</strong>，对代码进行走查和分析，找出可能发生内存溢出的位置。</p><p><strong>Google Guava Cache</strong> </p><p><strong>自己设计本地缓存痛点：</strong></p><ul><li>不能按照一定的规则淘汰数据，如 LRU，LFU，FIFO 等。</li><li>清除数据时的回调通知</li><li>并发处理能力差，针对并发可以使用CurrentHashMap，但缓存的其他功能需要自行实现</li><li>缓存过期处理，缓存数据加载刷新等都需要手工实现</li></ul><p><strong>Guava Cache 的场景：</strong></p><ul><li>对性能有非常高的要求</li><li>不经常变化，占用内存不大</li><li>有访问整个集合的需求</li><li>数据允许不实时一致</li></ul><p><strong>Guava Cache 的优势</strong>：</p><ul><li>缓存过期和淘汰机制</li></ul><p>在GuavaCache中可以设置Key的过期时间，包括访问过期和创建过期。GuavaCache在缓存容量达到指定大小时，采用LRU的方式，将不常使用的键值从Cache中删除</p><ul><li>并发处理能力</li></ul><p>GuavaCache类似CurrentHashMap，是线程安全的。提供了设置并发级别的api，使得缓存支持并发的写入和读取，采用分离锁机制，分离锁能够减小锁力度，提升并发能力，分离锁是分拆锁定，把一个集合看分成若干partition, 每个partiton一把锁。更新锁定</p><ul><li>防止缓存击穿</li></ul><p>一般情况下，在缓存中查询某个key，如果不存在，则查源数据，并回填缓存。（Cache Aside Pattern）在高并发下会出现，多次查源并重复回填缓存，可能会造成源的宕机（DB），性能下降 GuavaCache可以在CacheLoader的load方法中加以控制，对同一个key，只让一个请求去读源并回填缓存，其他请求阻塞等待。（相当于集成数据源，方便用户使用）</p><ul><li>监控缓存加载/命中情况</li></ul><p>统计</p><p><strong>问题：</strong></p><p>​    OOM-&gt;设置过期时间、使用弱引用、配置过期策略</p><h4 id="5、EVCache"><a href="#5、EVCache" class="headerlink" title="5、EVCache"></a>5、EVCache</h4><p>EVCache是一个Netflflix（网飞）公司开源、快速的分布式缓存，是基于Memcached的内存存储实现的，用以构建超大容量、高性能、低延时、跨区域的全球可用的缓存数据层。</p><p>E：Ephemeral：数据存储是短暂的，有自身的存活时间</p><p>V：Volatile：数据可以在任何时候消失</p><p>EVCache典型地适合对强一致性没有必须要求的场合</p><p>典型用例：Netflflix向用户推荐用户感兴趣的电影</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapdnh0yaj30ku0aigmc.jpg" alt="image-20210103185340548" style="zoom:50%;"></p><p><strong>EVCache集群</strong>在峰值每秒可以处理<strong>200kb</strong>的请求，</p><p>Netflflix生产系统中部署的EVCache经常要处理超过<strong>每秒3000万个</strong>请求，存储数十亿个对象，</p><p>跨数千台memcached服务器。整个EVCache集群<strong>每天处理近2万亿个</strong>请求。</p><p>EVCache集群响应平均延时大约是1-5毫秒，最多不会超过20毫秒。</p><p>EVCache集群的缓存命中率在99%左右。</p><p><strong>典型部署</strong></p><p>EVCache 是线性扩展的，可以在一分钟之内完成扩容，在几分钟之内完成负载均衡和缓存预热。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmapg99q8lj30ix0f3jrw.jpg" alt="image-20210103185611516" style="zoom:50%;"></p><p>1、集群启动时，EVCache向服务注册中心（Zookeeper、Eureka）注册各个实例</p><p>2、在web应用启动时，查询命名服务中的EVCache服务器列表，并建立连接。</p><p>3、客户端通过key使用一致性hash算法，将数据分片到集群上。</p><h4 id="6、ETCD"><a href="#6、ETCD" class="headerlink" title="6、ETCD"></a>6、ETCD</h4><p>​    <strong>和Zookeeper一样，CP模型追求数据一致性，</strong>越来越多的系统开始用它保存关键数据。比如，秒杀系统经常用它<strong>保存各节点信</strong>息，以便控制消费 MQ 的服务数量。还有些业务系统的<strong>配置数据</strong>，也会通过 etcd 实时同步给业务系统的各节点，比如，秒杀管理后台会使用 etcd 将秒杀活动的<strong>配置数据实时同步给秒杀 API 服务各节点</strong>。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2tg9qs00j30ta0g40vc.jpg" alt="image-20210418174251742"></p><h3 id="Redis底层"><a href="#Redis底层" class="headerlink" title="Redis底层"></a>Redis底层</h3><h4 id="1、redis数据类型"><a href="#1、redis数据类型" class="headerlink" title="1、redis数据类型"></a>1、redis数据类型</h4><table><thead><tr><th>类型</th><th>底层</th><th>应用场景</th><th>编码类型</th></tr></thead><tbody><tr><td>String</td><td>SDS数组</td><td>帖子、评论、热点数据、输入缓冲</td><td>RAW &lt;&lt; EMBSTR &lt;&lt; INT</td></tr><tr><td>List</td><td>QuickList</td><td>评论列表、商品列表、发布与订阅、慢查询、监视器</td><td>LINKEDLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Set</td><td>intSet</td><td>适合交集、并集、查集操作，例如朋友关系</td><td>HT &lt;&lt; INSET</td></tr><tr><td>Zset</td><td>跳跃表</td><td>去重后排序，适合排名场景</td><td>SKIPLIST &lt;&lt; ZIPLIST</td></tr><tr><td>Hash</td><td>哈希</td><td>结构化数据，比如存储对象</td><td>HT &lt;&lt; ZIPLIST</td></tr><tr><td>Stream</td><td>紧凑列表</td><td>消息队列</td></tr></tbody></table><h4 id="2、相关API"><a href="#2、相关API" class="headerlink" title="2、相关API"></a><strong>2、相关API</strong></h4><blockquote><p><a href="http://redisdoc.com" target="_blank" rel="noopener">http://redisdoc.com</a></p></blockquote><table><thead><tr><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>String</td><td>SET</td><td>SETNX</td><td>SETEX</td><td>GET</td><td>GETSET</td><td>INCR</td><td>DECR</td><td>MSET</td><td>MGET</td></tr><tr><td>Hash</td><td>HSET</td><td>HSETNX</td><td>HGET</td><td>HDEL</td><td>HLEN</td><td>HMSET</td><td>HMGET</td><td>HKEYS</td><td>HGETALL</td></tr><tr><td>LIST</td><td>LPUSH</td><td>LPOP</td><td>RPUSH</td><td>RPOP</td><td>LINDEX</td><td>LREM</td><td>LRANGE</td><td>LLEN</td><td>RPOPLPUSH</td></tr><tr><td>ZSET</td><td>ZADD</td><td>ZREM</td><td>ZSCORE</td><td>ZCARD</td><td>ZRANGE</td><td>ZRANK</td><td>ZREVRANK</td><td></td><td>ZREVRANGE</td></tr><tr><td>SET</td><td>SADD</td><td>SREM</td><td>SISMEMBER</td><td>SCARD</td><td>SINTER</td><td>SUNION</td><td>SDIFF</td><td>SPOP</td><td>SMEMBERS</td></tr><tr><td>事务</td><td>MULTI</td><td>EXEC</td><td>DISCARD</td><td>WATCH</td><td>UNWATCH</td><td></td><td></td><td></td></tr></tbody></table><h4 id="3、redis底层结构"><a href="#3、redis底层结构" class="headerlink" title="3、redis底层结构"></a>3、redis底层结构</h4><p><strong>SDS数组结构</strong>，用于存储字符串和整型数据及输入缓冲。</p><pre class=" language-java"><code class="language-java">struct sdshdr<span class="token punctuation">{</span>   <span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//记录buf数组中已使用字节的数量 </span>  <span class="token keyword">int</span> free<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//记录 buf 数组中未使用字节的数量 </span>  <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字符数组，用于保存字符串</span><span class="token punctuation">}</span></code></pre><p><strong>跳跃表</strong>：将有序链表中的部分节点分层，每一层都是一个有序链表。</p><p>​    1、可以快速查找到需要的节点 O(logn) ，额外存储了一倍的空间</p><p>​    2、可以在O(1)的时间复杂度下，快速获得跳跃表的头节点、尾结点、长度和高度。            </p><p><strong>字典dict:</strong> 又称散列表(hash)，是用来存储键值对的一种数据结构。 </p><p>​    Redis整个数据库是用字典来存储的(K-V结构) —Hash+数组+链表</p><p>​    Redis字典实现包括:<strong>字典(dict)、Hash表(dictht)、Hash表节点(dictEntry)</strong>。</p><p>​    字典达到存储上限(阈值 0.75)，需要rehash(扩容)</p><p>​    1、初次申请默认容量为4个dictEntry，非初次申请为当前hash表容量的一倍。</p><p>​    2、rehashidx=0表示要进行rehash操作。</p><p>​    3、新增加的数据在新的hash表h[1] 、修改、删除、查询在老hash表h[0]</p><p>​    4、将老的hash表h[0]的数据重新计算索引值后全部迁移到新的hash表h[1]中，这个过程称为 rehash。</p><p>​    <strong>渐进式rehash</strong></p><pre><code> 由于当数据量巨大时rehash的过程是非常缓慢的，所以需要进行优化。 可根据服务器空闲程度批量rehash部分节点</code></pre><p><strong>压缩列表zipList</strong></p><p>​    压缩列表(ziplist)是由一系列特殊编码的连续内存块组成的顺序型数据结构，节省内容</p><p>​    <strong>sorted-set和hash元素个数少</strong>且是小整数或短字符串(直接使用) </p><p>​    list用快速链表(quicklist)数据结构存储，而<strong>快速链表是双向列表与压缩列表</strong>的组合。(间接使用)</p><p><strong>整数集合intSet</strong></p><p>​    整数集合(intset)是一个有序的(整数升序)、存储整数的连续存储结构。 </p><p>​    当Redis集合类型的元素都是整数并且都处在64位有符号整数范围内(2^64)，使用该结构体存储。</p><p><strong>快速列表quickList</strong></p><p>​    快速列表(quicklist)是Redis底层重要的数据结构。是Redis3.2列表的底层实现。</p><p>​    (在Redis3.2之前，Redis采 用双向链表(adlist)和压缩列表(ziplist)实现。)</p><p><strong>Redis Stream</strong>的底层主要使用了listpack(紧凑列表)和Rax树(基数树)。</p><p>​    <strong>listpack</strong>表示一个字符串列表的序列化，listpack可用于存储字符串或整数。用于存储stream的消息内 容。</p><p>​    <strong>Rax树</strong>是一个有序字典树 (基数树 Radix Tree)，按照 key 的字典序排列，支持快速地定位、插入和删除操 作。</p><h4 id="4、Zset底层实现"><a href="#4、Zset底层实现" class="headerlink" title="4、Zset底层实现"></a>4、Zset底层实现</h4><p>​        跳表(skip List)是一种随机化的数据结构，基于并联的链表，实现简单，插入、删除、查找的复杂度均为O(logN)。简单说来跳表也是链表的一种，只不过它在链表的基础上增加了跳跃功能，正是这个跳跃的功能，使得在查找元素时，跳表能够提供O(logN)的时间复杂度</p><p>​        Zset<strong>数据量少的时候使用压缩链表ziplist</strong>实现，有序集合使用紧挨在一起的压缩列表节点来保存，第一个节点保存member，第二个保存score。ziplist内的集合元素按score从小到大排序，score较小的排在表头位置。 <strong>数据量大的时候使用跳跃列表skiplist和哈希表hash_map</strong>结合实现，查找删除插入的时间复杂度都是O(longN)</p><p>​        Redis使用跳表而不使用红黑树，是因为跳表的索引结构序列化和反序列化更加快速，方便持久化。</p><p><strong>搜索</strong></p><p>​        跳跃表按 score 从小到大保存所有集合元素，查找时间复杂度为平均 <em>O(logN)，最坏 O(N) 。</em></p><p><strong>插入</strong></p><p>  选用链表作为底层结构支持，为了高效地动态增删。因为跳表底层的单链表是有序的，为了维护这种有序性，在插入前需要遍历链表，找到该插入的位置，单链表遍历查找的时间复杂度是O(n)，同理可得，跳表的遍历也是需要遍历索引数，所以是O(logn)。</p><p><strong>删除</strong></p><p>  如果该节点还在索引中，删除时不仅要删除单链表中的节点，还要删除索引中的节点；单链表在知道删除的节点是谁时，时间复杂度为O(1)，但针对单链表来说，删除时都需要拿到前驱节点O(logN)才可改变引用关系从而删除目标节点。</p><h3 id="Redis可用性"><a href="#Redis可用性" class="headerlink" title="Redis可用性"></a><strong>Redis可用性</strong></h3><h4 id="1、redis持久化"><a href="#1、redis持久化" class="headerlink" title="1、redis持久化"></a>1、redis持久化</h4><p>持久化就是把内存中的数据持久化到本地磁盘，防止服务器宕机了内存数据丢失</p><p>Redis 提供两种持久化机制 <strong>RDB（默认）</strong> 和 <strong>AOF 机制</strong>，Redis4.0以后采用混合持久化，用 AOF 来<strong>保证数据不丢失</strong>，作为数据恢复的第一选择; 用 RDB 来做不同程度的<strong>冷备</strong></p><p><strong>RDB：</strong>是Redis DataBase缩写快照</p><p>​        RDB是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。</p><p>​    <strong>优点：</strong></p><p>​    1）只有一个文件 dump.rdb，方便持久化；</p><p>​    2）容灾性好，一个文件可以保存到安全的磁盘。</p><p>​    3）性能最大化，fork 子进程来进行持久化写操作，让主进程继续处理命令，只存在毫秒级不响应请求。</p><p>​    4）相对于数据集大时，比 AOF 的启动效率更高。</p><p>​    <strong>缺点：</strong></p><p>​    数据安全性低，RDB 是间隔一段时间进行持久化，如果持久化之间 redis 发生故障，会发生数据丢失。</p><p><strong>AOF：持久化</strong></p><p>​        AOF持久化(即Append Only File持久化)，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。</p><p>​    <strong>优点：</strong></p><p>​    1）数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。</p><p>​    2）通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。</p><p><strong>缺点：</strong></p><p>​    1）AOF 文件比 RDB 文件大，且恢复速度慢。</p><p>​    2）数据集大的时候，比 rdb 启动效率低。</p><h4 id="2、redis事务"><a href="#2、redis事务" class="headerlink" title="2、redis事务"></a>2、redis事务</h4><p>​        事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p><p><strong>Redis事务的概念</strong></p><p>​        Redis 事务的本质是通过MULTI、EXEC、WATCH等一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。</p><p>Redis的事务总是具有ACID中的<strong>一致性和隔离性</strong>，其他特性是不支持的。当服务器运行在AOF持久化模式下，并且appendfsync选项的值为always时，事务也具有耐久性。</p><p>Redis事务功能是通过MULTI、EXEC、DISCARD和WATCH 四个原语实现的</p><p><strong>事务命令：</strong></p><p><strong>MULTI：</strong>用于开启一个事务，它总是返回OK。MULTI执行之后，客户端可以继续向服务器发送任意多条命令，这些命令不会立即被执行，而是被放到一个队列中，当EXEC命令被调用时，所有队列中的命令才会被执行。</p><p><strong>EXEC：</strong>执行所有事务块内的命令。返回事务块内所有命令的返回值，按命令执行的先后顺序排列。当操作被打断时，返回空值 nil 。</p><p><strong>WATCH ：</strong>是一个乐观锁，可以为 Redis 事务提供 check-and-set （CAS）行为。可以监控一个或多个键，一旦其中有一个键被修改（或删除），之后的事务就不会执行，监控一直持续到EXEC命令。（<strong>秒杀场景</strong>）</p><p><strong>DISCARD：</strong>调用该命令，客户端可以清空事务队列，并放弃执行事务，且客户端会从事务状态中退出。</p><p><strong>UNWATCH</strong>：命令可以取消watch对所有key的监控。</p><h4 id="3、redis失效策略"><a href="#3、redis失效策略" class="headerlink" title="3、redis失效策略"></a>3、redis失效策略</h4><p><strong>内存淘汰策略</strong></p><p>1）全局的键空间选择性移除</p><p>​    <strong>noeviction</strong>：当内存不足以容纳新写入数据时，新写入操作会报错。（字典库常用）</p><p>​    <strong>allkeys-lru</strong>：在键空间中，移除最近最少使用的key。（缓存常用）</p><p>​    <strong>allkeys-random</strong>：在键空间中，随机移除某个key。</p><p>2）设置过期时间的键空间选择性移除</p><p>​    <strong>volatile-lru</strong>：在设置了过期时间的键空间中，移除最近最少使用的key。</p><p>​    <strong>volatile-random</strong>：在设置了过期时间的键空间中，随机移除某个key。</p><p>​    <strong>volatile-ttl</strong>：在设置了过期时间的键空间中，有更早过期时间的key优先移除。</p><p><strong>缓存失效策略</strong></p><p>​    <strong>定时清除：</strong>针对每个设置过期时间的key都创建指定定时器</p><p>​    <strong>惰性清除：</strong>访问时判断，对内存不友好</p><p>​    <strong>定时扫描清除：</strong>定时100ms随机20个检查过期的字典，若存在25%以上则继续循环删除。</p><h4 id="4、redis读写模式"><a href="#4、redis读写模式" class="headerlink" title="4、redis读写模式"></a>4、redis读写模式</h4><p>​    <strong>CacheAside旁路缓存</strong></p><p>写请求更新数据库后删除缓存数据。读请求不命中查询数据库，查询完成写入缓存</p><p><img src="https://img-blog.csdnimg.cn/20200806194316539.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 15%;"></p><p><img src="https://img-blog.csdnimg.cn/20200806194300826.png" style="zoom: 15%;"></p><p>​    业务端处理所有数据访问细节，同时利用 <strong>Lazy 计算</strong>的思想，更新 DB 后，直接删除 cache 并通过 DB 更新，确保数据以 DB 结果为准，则可以大幅降低 cache 和 DB 中数据不一致的概率</p><p>​    如果没有专门的存储服务，同时是对<strong>数据一致性要求比较高的业务，或者是缓存数据更新比较复杂的业务</strong>，适合使用 Cache Aside 模式。如微博发展初期，不少业务采用这种模式</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 延迟双删，用以保证最终一致性,防止小概率旧数据读请求在第一次删除后更新数据库</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">write</span><span class="token punctuation">(</span>String key<span class="token punctuation">,</span>Object data<span class="token punctuation">)</span><span class="token punctuation">{</span>    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    db<span class="token punctuation">.</span><span class="token function">updateData</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    redis<span class="token punctuation">.</span><span class="token function">delKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>高并发下保证绝对的一致，先删缓存再更新数据，需要用到<strong>内存队列做异步串行化</strong>。非高并发场景，先更新数据再删除缓存，<strong>延迟双删</strong>策略基本满足了</p><ul><li>先更新db后删除redis：删除redis失败则出现问题</li><li>先删redis后更新db：删除redis瞬间，旧数据被回填redis</li><li>先删redis后更新db休眠后删redis：同第二点，休眠后删除redis 可能宕机</li><li>java内部jvm队列：不适用分布式场景且降低并发</li></ul><p>​    <strong>Read/Write Though</strong>（读写穿透）</p><p>​        <strong>先查询</strong>缓存中数据是否存在,如果存在则直接返回,如果<strong>不存在</strong>,则由<strong>缓存组件负责从数据库中同步加载数据.</strong></p><p>​    <img src="https://img-blog.csdnimg.cn/20200806194334623.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%;"></p><p>​    先查询要<strong>写入的数据在缓存中</strong>是否已经存在,如果已经存在,则<strong>更新缓存中的数据</strong>，并且由<strong>缓存组件同步更新</strong>到数据库中。</p><p>​    <img src="https://img-blog.csdnimg.cn/20200806194346642.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x6eF92aWN0b3J5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom: 50%"></p><p>​    用户<strong>读操作</strong>较多.相较于Cache aside而言更适合缓存一致的场景。使用简单屏蔽了<strong>底层数据库的操作</strong>,只是操作缓存.</p><p><strong>场景：</strong></p><p>微博 Feed 的 Outbox Vector（即用户最新微博列表）就采用这种模式。一些粉丝较少且不活跃的用户发表微博后，Vector 服务会首先查询 Vector Cache，如果 cache 中没有该用户的 Outbox 记录，则不写该用户的 cache 数据，直接更新 DB 后就返回，只有 cache 中存在才会通过 CAS 指令进行更新。</p><p>​    </p><p><strong>Write Behind Caching（异步缓存写入）</strong></p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorlsg74i6j31950e3dhs.jpg" alt="img" style="zoom:35%;"></p><p>比如对一些计数业务，一条 <strong>Feed 被点赞</strong> 1万 次，如果更新 1万 次 DB 代价很大，而合并成一次请求直接加 1万，则是一个非常轻量的操作。但这种模型有个显著的缺点，即数据的一致性变差，甚至在一些极端场景下可能会丢失数据。</p><h4 id="5、多级缓存"><a href="#5、多级缓存" class="headerlink" title="5、多级缓存"></a>5、多级缓存</h4><p><strong>浏览器本地内存缓存：</strong>专题活动，一旦上线，在活动期间是不会随意变更的。</p><p><strong>浏览器本地磁盘缓存：</strong>Logo缓存，大图片懒加载</p><p><strong>服务端本地内存缓存：</strong>由于没有持久化，重启时必定会被穿透</p><p><strong>服务端网络内存缓存</strong>：Redis等，针对穿透的情况下可以继续分层，必须保证数据库不被压垮</p><p><strong>为什么不是使用服务器本地磁盘做缓存？</strong></p><p>​    当系统处理大量磁盘 IO 操作的时候，由于 CPU 和内存的速度远高于磁盘，可能导致 CPU 耗费太多时间等待磁盘返回处理的结果。对于这部分 CPU 在 IO 上的开销，我们称为 <strong>iowait</strong></p><h3 id="Redis七大经典问题"><a href="#Redis七大经典问题" class="headerlink" title="Redis七大经典问题"></a>Redis七大经典问题</h3><h4 id="1、缓存雪崩"><a href="#1、缓存雪崩" class="headerlink" title="1、缓存雪崩"></a>1、缓存雪崩</h4><p>​        指缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​    <strong>解决方案：</strong></p><ul><li><strong>Redis 高可用</strong>，主从+哨兵，Redis cluster，避免全盘崩溃</li><li>本地 ehcache 缓存 + hystrix <strong>限流&amp;降级</strong>，避免 MySQL 被打死</li><li><p>缓存数据的<strong>过期时间设置随机</strong>，防止同一时间大量数据过期现象发生。</p></li><li><p><strong>逻辑上永不过期</strong>给每一个缓存数据增加相应的<strong>缓存标记</strong>，缓存标记失效则更新数据缓存</p></li><li><strong>多级缓存</strong>，失效时通过二级更新一级，由第三方插件更新二级缓存。</li></ul><h4 id="2、缓存穿透"><a href="#2、缓存穿透" class="headerlink" title="2、缓存穿透"></a><strong>2、缓存穿透</strong></h4><p>​        <a href="https://blog.csdn.net/lin777lin/article/details/105666839" target="_blank" rel="noopener">https://blog.csdn.net/lin777lin/article/details/105666839</a></p><p>​        缓存穿透是指缓存和数据库中都没有的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>​    <strong>解决方案：</strong></p><p>​    1）<strong>接口层增加校验</strong>，如用户鉴权校验，id做基础校验，id&lt;=0的直接拦截；</p><p>​    2）从缓存取不到的数据，在数据库中也没有取到，这时也可以将<strong>key-value对写为key-null</strong>，缓存有效时间可以设置短点，如30秒。这样可以防止攻击用户反复用同一个id暴力攻击；</p><p>​    3）采用<strong>布隆过滤器</strong>，将所有可能存在的数据哈希到一个足够大的 bitmap 中，一个一定不存在的数据会被这个 bitmap 拦截掉，从而避免了对底层存储系统的查询压力。（宁可错杀一千不可放过一人）</p><h4 id="3、缓存击穿"><a href="#3、缓存击穿" class="headerlink" title="3、缓存击穿"></a><strong>3、缓存击穿</strong></h4><p>​        这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力。和缓存雪崩不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库</p><p>​    <strong>解决方案：</strong></p><p>​    1）设置<strong>热点数据永远不过期</strong>，异步线程处理。</p><p>​    2）加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</p><p>​    3）缓存预热</p><p>​        系统上线后，将相关<strong>可预期（例如排行榜）</strong>热点数据直接加载到缓存。</p><p>​        写一个缓存刷新页面，手动操作热点数据<strong>（例如广告推广）</strong>上下线。</p><h4 id="4、数据不一致"><a href="#4、数据不一致" class="headerlink" title="4、数据不一致"></a>4、数据不一致</h4><p>​    在缓存机器的带宽被打满，或者机房网络出现波动时，缓存更新失败，新数据没有写入缓存，就会导致缓存和 DB 的数据不一致。缓存 rehash 时，某个缓存机器反复异常，多次上下线，更新请求多次 rehash。这样，一份数据存在多个节点，且每次 rehash 只更新某个节点，导致一些缓存节点产生脏数据。</p><ul><li><p>Cache 更新失败后，可以进行重试，则将重试失败的 key 写入mq，待缓存访问恢复后，将这些 key 从缓存删除。这些 key 在再次被查询时，重新从 DB 加载，从而保证数据的一致性</p></li><li><p>缓存时间适当调短，让缓存数据及早过期后，然后从 DB 重新加载，确保数据的最终一致性。</p></li><li><p>不采用 rehash 漂移策略，而采用缓存分层策略，尽量避免脏数据产生。</p></li></ul><h4 id="5、数据并发竞争"><a href="#5、数据并发竞争" class="headerlink" title="5、数据并发竞争"></a>5、数据并发竞争</h4><p>​    数据并发竞争在大流量系统也比较常见，比如车票系统，如果某个火车车次缓存信息过期，但仍然有大量用户在查询该车次信息。又比如微博系统中，如果某条微博正好被缓存淘汰，但这条微博仍然有大量的转发、评论、赞。上述情况都会造成并发竞争读取的问题。</p><ul><li>​    加<strong>写回操作加互斥锁</strong>，查询失败默认值快速返回。</li><li>​    对缓存数据保持多个备份，减少并发竞争的概率</li></ul><p>​    </p><h4 id="6、热点key问题"><a href="#6、热点key问题" class="headerlink" title="6、热点key问题"></a>6、热点key问题</h4><p>​    明星结婚、离婚、出轨这种特殊突发事件，比如奥运、春节这些重大活动或节日，还比如秒杀、双12、618 等线上促销活动，都很容易出现 Hot key 的情况。</p><p>如何提前发现HotKey？</p><ul><li>对于重要节假日、线上促销活动这些提前已知的事情，可以提前评估出可能的热 key 来。</li><li>而对于突发事件，无法提前评估，可以<strong>通过 Spark，对应流任务进行实时分析</strong>，及时发现新发布的热点 key。而对于之前已发出的事情，逐步发酵成为热 key 的，则可以通过 Hadoop 对批处理任务离线计算，找出最近历史数据中的高频热 key。</li></ul><p><strong>解决方案：</strong></p><ul><li><p>这 n 个 key 分散存在多个缓存节点，然后 client 端请求时，随机访问其中某个后缀的 hotkey，这样就可以把热 key 的请求打散，避免一个缓存节点过载</p></li><li><p>缓存集群可以单节点进行主从复制和垂直扩容</p></li><li><p>利用应用内的前置缓存，但是需注意需要设置上限</p></li><li><p>延迟不敏感，定时刷新，实时感知用主动刷新</p></li><li><p>和缓存穿透一样，限制逃逸流量，单请求进行数据回源并刷新前置</p></li><li><p>无论如何设计，最后都要写一个兜底逻辑，千万级流量说来就来</p></li></ul><h4 id="7、BigKey问题"><a href="#7、BigKey问题" class="headerlink" title="7、BigKey问题"></a>7、BigKey问题</h4><p>​    比如互联网系统中需要保存用户最新 1万 个粉丝的业务，比如一个用户个人信息缓存，包括基本资料、关系图谱计数、发 feed 统计等。微博的 feed 内容缓存也很容易出现，一般用户微博在 140 字以内，但很多用户也会发表 1千 字甚至更长的微博内容，这些长微博也就成了大 key</p><ul><li>首先Redis底层数据结构里，根据Value的不同，会进行数据结构的重新选择</li><li>可以扩展新的数据结构，进行序列化构建，然后通过 restore 一次性写入</li><li>将大 key 分拆为多个 key，设置较长的过期时间</li></ul><h3 id="Redis分区容错"><a href="#Redis分区容错" class="headerlink" title="Redis分区容错"></a>Redis分区容错</h3><h4 id="1、redis数据分区"><a href="#1、redis数据分区" class="headerlink" title="1、redis数据分区"></a><strong>1、redis数据分区</strong></h4><p><strong>Hash：（不稳定）</strong></p><p>​        客户端分片：哈希+取余</p><p>​        节点伸缩：数据节点关系变化，导致数据迁移</p><p>​        迁移数量和添加节点数量有关：建议翻倍扩容</p><p>​        一个简单直观的想法是直接用Hash来计算，以Key做哈希后对节点数取模。可以看出，在key足够分散的情况下，均匀性可以获得，但一旦有节点加入或退出，所有的原有节点都会受到影响，稳定性无从谈起。</p><p><strong>一致性Hash：（不均衡）</strong></p><p>​        客户端分片：哈希+顺时针（优化取余）</p><p>​        节点伸缩：只影响邻近节点，但是还是有数据迁移</p><p>​        翻倍伸缩：保证最小迁移数据和负载均衡</p><p>​        一致性Hash可以很好的解决稳定问题，可以将所有的存储节点排列在收尾相接的Hash环上，每个key在计算Hash后会顺时针找到先遇到的一组存储节点存放。而当有节点加入或退出时，仅影响该节点在Hash环上顺时针相邻的后续节点，将数据从该节点接收或者给予。但这又带来均匀性的问题，即使可以将存储节点等距排列，也会在<strong>存储节点个数变化时带来数据的不均匀</strong>。</p><p><strong>Codis的Hash槽</strong></p><p>​        Codis 将所有的 key 默认划分为 1024 个槽位(slot)，它首先对客户端传过来的 key 进行 crc32 运算计算 哈希值，再将 hash 后的整数值对 1024 这个整数进行取模得到一个余数，这个余数就是对应 key 的槽位。</p><p><strong>RedisCluster</strong></p><p>​        Redis-cluster把所有的物理节点映射到[0-16383]个<strong>slot</strong>上,对key采用crc16算法得到hash值后对16384取模，基本上采用平均分配和连续分配的方式。</p><h4 id="2、主从模式-简单"><a href="#2、主从模式-简单" class="headerlink" title="2、主从模式=简单"></a><strong>2、主从模式=简单</strong></h4><p>​    主从模式最大的优点是<strong>部署简单</strong>，最少<strong>两个节点便可以构成主从模式</strong>，并且可以通过<strong>读写分离避免读和写同时不可用</strong>。不过，一旦 Master 节点出现故障，主从节点就<strong>无法自动切换</strong>，直接导致 SLA 下降。所以，主从模式一般<strong>适合业务发展初期，并发量低，运维成本低</strong>的情况</p><p><img src="https://s0.lgstatic.com/i/image/M00/80/25/Ciqc1F_QgPOAaL8TAAC5EiNlvo4795.png" alt="Drawing 1.png" style="zoom:50%;"></p><p><strong>主从复制原理：</strong></p><p>​    ①通过从服务器发送到PSYNC命令给主服务器</p><p>​    ②如果是首次连接，触发一次<strong>全量复制</strong>。此时主节点会启动一个后台线程，生成 RDB 快照文件</p><p>​    ③主节点会将这个 RDB 发送给从节点，slave 会先写入本地磁盘，再从本地磁盘加载到内存中</p><p>​    ④master会将此过程中的写命令写入缓存，从节点<strong>实时同步</strong>这些数据</p><p>​    ⑤如果网络断开了连接，自动重连后主节点通过命令传播<strong>增量复制</strong>给从节点部分缺少的数据</p><p><strong>缺点</strong></p><p>​    所有的slave节点数据的复制和同步都由master节点来处理，会照成master节点压力太大，使用主从从结构来解决，redis4.0中引入psync2 解决了slave重启后仍然可以增量同步。</p><h4 id="3、哨兵模式-读多"><a href="#3、哨兵模式-读多" class="headerlink" title="3、哨兵模式=读多"></a>3、<strong>哨兵模式</strong>=读多</h4><p>​    由一个或多个sentinel实例组成sentinel集群可以监视一个或多个主服务器和多个从服务器。<strong>哨兵模式适合读请求远多于写请求的业务场景，比如在秒杀系统</strong>中用来缓存活动信息。 如果写请求较多，当集群 Slave 节点数量多了后，Master 节点同步数据的压力会非常大。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gluq6vlvglj30nw0e076f.jpg" alt="image-20201220231241725" style="zoom:50%;"></p><p>当主服务器进入下线状态时，sentinel可以将该主服务器下的某一从服务器升级为主服务器继续提供服务，从而保证redis的高可用性。</p><p><strong>检测主观下线状态</strong></p><p>​    Sentinel每秒一次向所有与它建立了命令连接的实例(主服务器、从服务器和其他Sentinel)发送PING命 令</p><p>​    实例在down-after-milliseconds毫秒内返回无效回复Sentinel就会认为该实例主观下线(<strong>SDown</strong>)</p><p><strong>检查客观下线状态</strong></p><p>​    当一个Sentinel将一个主服务器判断为主观下线后 ，Sentinel会向监控这个主服务器的所有其他Sentinel发送查询主机状态的命令</p><p>​    如果达到Sentinel配置中的quorum数量的Sentinel实例都判断主服务器为主观下线，则该主服务器就会被判定为客观下线(<strong>ODown</strong>)。</p><p><strong>选举Leader Sentinel</strong> </p><p>​    当一个主服务器被判定为客观下线后，监视这个主服务器的所有Sentinel会通过选举算法(raft)，选出一个Leader Sentinel去执行<strong>failover(故障转移)</strong>操作。</p><p>​    <strong>Raft算法</strong></p><p>​    Raft协议是用来解决分布式系统一致性问题的协议。 Raft协议描述的节点共有三种状态:Leader, Follower, Candidate。 Raft协议将时间切分为一个个的Term(任期)，可以认为是一种“逻辑时间”。 选举流程:<br>     ①Raft采用心跳机制触发Leader选举系统启动后，全部节点初始化为Follower，term为0</p><p>​     ②节点如果收到了RequestVote或者AppendEntries，就会保持自己的Follower身份 </p><p>​     ③节点如果一段时间内没收到AppendEntries消息，在该节点的超时时间内还没发现Leader，Follower就会转换成Candidate，自己开始竞选Leader。 一旦转化为Candidate，该节点立即开始下面几件事情:<br>​        –增加自己的term，启动一个新的定时器<br>​        –给自己投一票，向所有其他节点发送RequestVote，并等待其他节点的回复。</p><p>​     ④如果在计时器超时前，节点收到多数节点的同意投票，就转换成Leader。同时通过 AppendEntries，向其他节点发送通知。</p><p>​     ⑤每个节点在一个term内只能投一票，采取先到先得的策略，Candidate投自己， Follower会投给第一个收到RequestVote的节点。</p><p>​     ⑥Raft协议的定时器采取随机超时时间（选举的关键），先转为Candidate的节点会先发起投票，从而获得多数票。</p><p><strong>主服务器的选择</strong></p><p>​    当选举出Leader Sentinel后，Leader Sentinel会根据以下规则去从服务器中选择出新的主服务器。</p><ol><li>过滤掉主观、客观下线的节点</li><li>选择配置slave-priority最高的节点，如果有则返回没有就继续选择</li><li>选择出复制偏移量最大的系节点，因为复制偏移量越大则数据复制的越完整</li><li>选择run_id最小的节点，因为run_id越小说明重启次数越少</li></ol><p><strong>故障转移</strong></p><p>​    当Leader Sentinel完成新的主服务器选择后，Leader Sentinel会对下线的主服务器执行故障转移操作，主要有三个步骤:</p><p>​    1、它会将失效 Master 的其中一个 Slave 升级为新的 Master , 并让失效 Master 的其他 Slave 改为复制新的 Master ;</p><p>​    2、当客户端试图连接失效的 Master 时，集群会向客户端返回新 Master 的地址，使得集群当前状态只有一个Master。</p><p>​    3、Master 和 Slave 服务器切换后， Master 的 redis.conf 、 Slave 的 redis.conf 和 sentinel.conf 的配置文件的内容都会发生相应的改变，即 Master 主服务器的 redis.conf配置文件中会多一行 replicaof 的配置， sentinel.conf 的监控目标会随之调换。</p><h4 id="4、集群模式-写多"><a href="#4、集群模式-写多" class="headerlink" title="4、集群模式=写多"></a>4、集群模式=写多</h4><p>​    为了避免单一节点负载过高导致不稳定，集群模式采用<strong>一致性哈希算法或者哈希槽的方法</strong>将 Key 分布到各个节点上。其中，每个 Master 节点后跟若干个 Slave 节点，用于<strong>出现故障时做主备切换</strong>，客户端可以<strong>连接任意 Master 节点</strong>，集群内部会按照<strong>不同 key 将请求转发到不同的 Master</strong> 节点</p><p>​    集群模式是如何实现高可用的呢？集群内部节点之间会<strong>互相定时探测</strong>对方是否存活，如果多数节点判断某个节点挂了，则会将其踢出集群，然后从 <strong>Slave</strong> 节点中选举出一个节点<strong>替补</strong>挂掉的 Master 节点。<strong>整个原理基本和哨兵模式一致</strong></p><p>​    虽然集群模式避免了 Master 单节点的问题，但<strong>集群内同步数据时会占用一定的带宽</strong>。所以，只有在<strong>写操作比较多的情况下人们才使用集群模式</strong>，其他大多数情况，使用<strong>哨兵模式</strong>都能满足需求</p><h4 id="5、分布式锁"><a href="#5、分布式锁" class="headerlink" title="5、分布式锁"></a>5、分布式锁</h4><p><strong>利用Watch实现Redis乐观锁</strong></p><p>​    乐观锁基于CAS(Compare And Swap)比较并替换思想，不会产生锁等待而消耗资源，但是需要反复的重试，但也是因为重试的机制，能比较快的响应。因此我们可以利用redis来实现乐观锁<strong>（秒杀）</strong>。具体思路如下:</p><p>1、利用redis的watch功能，监控这个redisKey的状态值<br>2、获取redisKey的值，创建redis事务，给这个key的值+1<br>3、执行这个事务，如果key的值被修改过则回滚，key不加1</p><p><strong>利用setnx防止库存超卖</strong><br>    分布式锁是控制分布式系统之间同步访问共享资源的一种方式。 利用Redis的单线程特性对共享资源进行串行化处理</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取锁推荐使用set的方式</span>String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">,</span> <span class="token string">"NX"</span><span class="token punctuation">,</span> <span class="token string">"EX"</span><span class="token punctuation">,</span> expireTime<span class="token punctuation">)</span><span class="token punctuation">;</span>String result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">setnx</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">,</span> requestId<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//如线程死掉，其他线程无法获取到锁</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 释放锁，非原子操作，可能会释放其他线程刚加上的锁</span><span class="token keyword">if</span> <span class="token punctuation">(</span>requestId<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>jedis<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   jedis<span class="token punctuation">.</span><span class="token function">del</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 推荐使用redis+lua脚本</span>String lua <span class="token operator">=</span> <span class="token string">"if redis.call('get',KEYS[1]) == ARGV[1] then return redis.call('del',KEYS[1]) else return 0 end"</span><span class="token punctuation">;</span>Object result <span class="token operator">=</span> jedis<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span>lua<span class="token punctuation">,</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>lockKey<span class="token punctuation">)</span><span class="token punctuation">,</span></code></pre><p><strong>分布式锁存在的问题</strong>：</p><ul><li><strong>客户端长时间阻塞导致锁失效问题</strong></li></ul><p>​    计算时间内异步启动另外一个线程去检查的问题，这个key是否超时，当锁超时时间快到期且逻辑未执行完，延长锁超时时间。</p><ul><li><p><strong>Redis服务器时钟漂移问题导致同时加锁<br>redis的过期时间是依赖系统时钟的，如果时钟漂移过大时 理论上是可能出现的 </strong>会影响到过期时间的计算。</p></li><li><p><strong>单点实例故障，锁未及时同步导致丢失</strong></p><p><strong>RedLock算法</strong></p></li></ul><ol><li><p>获取当前时间戳T0，配置时钟漂移误差T1</p></li><li><p>短时间内逐个获取全部N/2+1个锁，结束时间点T2</p></li><li><p>实际锁能使用的处理时长变为：TTL - （T2 - T0）- T1</p><p>该方案通过多节点来<strong>防止Redis的单点故障</strong>，效果一般，也无法防止：</p></li></ol><ul><li><p><strong>主从切换导致的两个客户端同时持有锁</strong></p><p>大部分情况下<strong>持续时间极短</strong>，而且使用<strong>Redlock在切换的瞬间</strong>获取到节点的锁，也存在问题。已经是极低概率的时间，无法避免。<strong>Redis分布式锁适合幂等性事务</strong>，如果一定要<strong>保证安全</strong>，应该<strong>使用Zookeeper或者DB</strong>，但是，<strong>性能会急剧下降</strong>。</p></li></ul><p><strong>与zookeeper分布式锁对比</strong></p><ul><li>redis 分布式锁，其实<strong>需要自己不断去尝试获取锁</strong>，比较消耗性能。</li><li>zk 分布式锁，注册个监听器即可，不需要不断主动尝试获取锁，ZK获取锁会按照加锁的顺序，所以是公平锁，性能和mysql差不多，和redis差别大</li></ul><p><strong>Redission生产环境的分布式锁</strong></p><p>​    Redisson是基于NIO的Netty框架上的一个Java驻内存数据网格(In-Memory Data Grid)分布式锁开源组件。 </p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glurlfrrp4j30qk0g876c.jpg" alt="image-20201221000119586" style="zoom:67%;"></p><p>但当业务必须要数据的强一致性，即不允许重复获得锁，比如金融场景(重复下单，重复转账)，<strong>请不要使用redis分布式锁</strong>。可以使用CP模型实现，比如:<strong>zookeeper和etcd。</strong></p><table><thead><tr><th></th><th>Redis</th><th>zookeeper</th><th>etcd</th></tr></thead><tbody><tr><td>一致性算法</td><td>无</td><td>paxos(ZAB)</td><td>raft</td></tr><tr><td>CAP</td><td>AP</td><td>CP</td><td>CP</td></tr><tr><td>高可用</td><td>主从集群</td><td>n+1</td><td>n+1</td></tr><tr><td>实现</td><td>setNX</td><td>createNode</td><td>restfulAPI</td></tr></tbody></table><h4 id="6、redis心跳检测"><a href="#6、redis心跳检测" class="headerlink" title="6、redis心跳检测"></a>6、redis心跳检测</h4><p>在命令传播阶段，从服务器默认会以每秒一次的频率向主服务器发送ACK命令:</p><p>​    1、检测主从的连接状态 检测主从服务器的网络连接状态</p><p>​            lag的值应该在0或1之间跳动，如果超过1则说明主从之间的连接有 故障。</p><p>​    2、辅助实现min-slaves,Redis可以通过配置防止主服务器在不安全的情况下执行写命令</p><pre class=" language-yaml"><code class="language-yaml">min<span class="token punctuation">-</span>slaves<span class="token punctuation">-</span>to<span class="token punctuation">-</span>write 3 (min<span class="token punctuation">-</span>replicas<span class="token punctuation">-</span>to<span class="token punctuation">-</span>write 3 )min<span class="token punctuation">-</span>slaves<span class="token punctuation">-</span>max<span class="token punctuation">-</span>lag 10 (min<span class="token punctuation">-</span>replicas<span class="token punctuation">-</span>max<span class="token punctuation">-</span>lag 10)</code></pre><p>​        上面的配置表示:从服务器的数量少于3个，或者三个从服务器的延迟(lag)值都大于或等于10 秒时，主服务器将拒绝执行写命令。</p><p>​    3、检测命令丢失，增加重传机制</p><p>​        如果因为网络故障，主服务器传播给从服务器的写命令在半路丢失，那么当从服务器向主服务器发 送REPLCONF ACK命令时，主服务器将发觉从服务器当前的复制偏移量少于自己的复制偏移量， 然后主服务器就会根据从服务器提交的复制偏移量，在复制积压缓冲区里面找到从服务器缺少的数据，并将这些数据重新发送给从服务器。</p><h3 id="Redis实战"><a href="#Redis实战" class="headerlink" title="Redis实战"></a>Redis实战</h3><h4 id="1、Redis优化"><a href="#1、Redis优化" class="headerlink" title="1、Redis优化"></a>1、Redis优化</h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gorm5m7b4gj30uy0hjwfp.jpg" alt="img"></p><p><strong>读写方式</strong><br>    简单来说就是不用<strong>keys</strong>等，用<strong>range、contains</strong>之类。比如，用户粉丝数，大 V 的粉丝更是高达几千万甚至过亿，因此，获取粉丝列表只能部分获取。另外在判断某用户是否关注了另外一个用户时，也只需要关注列表上进行检查判断，然后返回 True/False 或 0/1 的方式更为高效。</p><p><strong>KV size</strong><br>    如果单个业务的 KV size 过大，需要分拆成多个 KV 来缓存。拆分时应<strong>考虑访问频率</strong></p><p><strong>key 的数量</strong><br>    如果数据量巨大，则在缓存中尽可能只保留频繁访问的热数据，对于冷数据直接访问 DB。</p><p><strong>读写峰值</strong><br>    如果小于 10万 级别，简单分拆到独立 Cache 池即可<br>    如果达到 100万 级的QPS，则需要对 Cache 进行分层处理，可以同时使用 Local-Cache 配合远程 cache，甚至远程缓存内部继续分层叠加分池进行处理。<strong>（多级缓存）</strong></p><p><strong>命中率</strong><br>    缓存的命中率对整个服务体系的性能影响甚大。对于核心高并发访问的业务，需要预留足够的容量，确保核心业务缓存维持较高的命中率。比如微博中的 Feed Vector Cache（<strong>热点资讯</strong>），常年的命中率高达 99.5% 以上。为了持续保持缓存的命中率，缓存体系需要持续监控，及时进行故障处理或故障转移。同时在部分缓存节点异常、命中率下降时，故障转移方案，需要考虑是采用一致性 Hash 分布的访问漂移策略，还是采用数据多层备份策略。</p><p><strong>过期策略</strong></p><p>​    可以设置较短的过期时间，让冷 key 自动过期；也可以让 key 带上时间戳，同时设置较长的过期时间，比如很多业务系统内部有这样一些 key：key_20190801。</p><p><strong>缓存穿透时间</strong><br>    平均缓存穿透加载时间在某些业务场景下也很重要，对于一些缓存穿透后，加载时间特别长或者需要复杂计算的数据，而且访问量还比较大的业务数据，要配置更多容量，维持更高的命中率，从而减少穿透到 DB 的概率，来确保整个系统的访问性能。</p><p><strong>缓存可运维性</strong><br>    对于缓存的可运维性考虑，则需要考虑缓存体系的集群管理，如何进行一键扩缩容，如何进行缓存组件的升级和变更，如何快速发现并定位问题，如何持续监控报警，最好有一个完善的运维平台，将各种运维工具进行集成。</p><p><strong>缓存安全性</strong><br>    对于缓存的安全性考虑，一方面可以限制来源 IP，只允许内网访问，同时加密鉴权访问。</p><h4 id="2、Redis热升级"><a href="#2、Redis热升级" class="headerlink" title="2、Redis热升级"></a>2、Redis热升级</h4><blockquote><p>在 Redis 需要升级版本或修复 bug 时，如果直接重启变更，由于需要数据恢复，这个过程需要近 10 分钟的时间，时间过长，会严重影响系统的可用性。面对这种问题，可以对 Redis 扩展热升级功能，从而在毫秒级完成升级操作，完全不影响业务访问。</p></blockquote><p>热升级方案如下，首先构建一个 Redis 壳程序，将 redisServer 的所有属性（包括redisDb、client等）保存为全局变量。然后将 Redis 的处理逻辑代码全部封装到动态连接库 so 文件中。Redis 第一次启动，从磁盘加载恢复数据，在后续升级时，通过指令，壳程序重新加载 Redis 新的 redis-4.so 到 redis-5.so 文件，即可完成功能升级，毫秒级完成 Redis 的版本升级。而且整个过程中，所有 Client 连接仍然保留，在升级成功后，原有 Client 可以继续进行读写操作，整个过程对业务完全透明。</p><h1 id="六、Kafka篇"><a href="#六、Kafka篇" class="headerlink" title="六、Kafka篇"></a>六、Kafka篇</h1><h3 id="Why-kafka"><a href="#Why-kafka" class="headerlink" title="Why kafka"></a>Why kafka</h3><p>消息队列的作用：<strong>异步、削峰填谷、解耦</strong></p><p><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 <strong>RabbitMQ</strong> （开源、社区活跃）是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 <strong>RocketMQ</strong>（Java二次开发） 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 <strong>Kafka</strong> 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfiyienm0j30zu0hago7.jpg" alt="image-20210107225921930" style="zoom:50%;"></p><p><strong>RabbitMQ</strong></p><p>RabbitMQ开始是用在电信业务的可靠通信的，也是少有的几款<strong>支持AMQP</strong>协议的产品之一。</p><p><strong>优点：</strong></p><ul><li>轻量级，快速，部署使用方便</li><li>支持灵活的路由配置。RabbitMQ中，在生产者和队列之间有一个交换器模块。根据配置的路由规则，生产者发送的消息可以发送到不同的队列中。路由规则很灵活，还可以自己实现。</li><li>RabbitMQ的客户端支持大多数的编程语言，支持<strong>AMQP</strong>协议。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmfjicxzb2j30u80hx0uw.jpg" alt="image-20210107231826261" style="zoom:40%;"></p><p><strong>缺点：</strong></p><ul><li>如果有大量消息堆积在队列中，性能会急剧下降</li><li>每秒处理几万到几十万的消息。如果应用要求高的性能，不要选择RabbitMQ。 </li><li>RabbitMQ是Erlang开发的，功能扩展和二次开发代价很高。</li></ul><p><strong>RocketMQ</strong></p><p>借鉴了Kafka的设计并做了很多改进，<strong>几乎具备了消息队列应该具备的所有特性和功能</strong>。</p><ul><li>RocketMQ主要用于有序，事务，流计算，消息推送，日志流处理，binlog分发等场景。</li><li>经过了历次的双11考验，性能，稳定性可靠性没的说。</li><li>java开发，阅读源代码、扩展、二次开发很方便。</li><li>对电商领域的响应延迟做了很多优化。</li><li>每秒处理几十万的消息，同时响应在毫秒级。如果应用很关注响应时间，可以使用RocketMQ。</li><li>性能比RabbitMQ高一个数量级，。</li><li>支持死信队列，DLX 是一个非常有用的特性。它可以处理<strong>异常情况下，消息不能够被消费者正确消费而被置入死信队列中</strong>的情况，后续分析程序可以通过消费这个死信队列中的内容来分析当时所遇到的异常情况，进而可以<strong>改善和优化系统</strong>。</li></ul><p><strong>缺点</strong>：</p><p>​    跟周边系统的整合和兼容不是很好。</p><p><strong>Kafka</strong></p><p><strong>高可用</strong>，几乎所有相关的开源软件都支持，满足大多数的应用场景，尤其是<strong>大数据和流计算</strong>领域，</p><ul><li>Kafka高效，可伸缩，消息持久化。支持分区、副本和容错。</li><li>对批处理和异步处理做了大量的设计，因此Kafka可以得到非常高的性能。</li><li>每秒处理几十万异步消息消息，如果开启了压缩，最终可以达到每秒处理2000w消息的级别。</li><li>但是由于是异步的和批处理的，延迟也会高，不适合电商场景。</li></ul><h3 id="What-Kafka"><a href="#What-Kafka" class="headerlink" title="What Kafka"></a>What Kafka</h3><ul><li>Producer API：允许应用程序将记录流发布到一个或多个Kafka主题。</li><li>Consumer API：允许应用程序订阅一个或多个主题并处理为其生成的记录流。</li><li>Streams API：允许应用程序充当流处理器，将输入流转换为输出流。</li></ul><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gme95cirjfj31000kb41j.jpg" alt="image-20210106203420526" style="zoom: 40%;"></p><p><strong>消息Message</strong></p><p>​    Kafka的数据单元称为消息。可以把消息看成是数据库里的一个“数据行”或一条“记录”。</p><p><strong>批次</strong></p><p>​    为了提高效率，消息被分批写入Kafka。提高吞吐量却加大了响应时间</p><p><strong>主题Topic</strong></p><p>​    通过主题进行分类，类似数据库中的表，</p><p><strong>分区Partition</strong></p><p>​    Topic可以被分成若干分区分布于kafka集群中，方便扩容</p><p>​    单个分区内是有序的，partition设置为一才能保证全局有序</p><p><strong>副本Replicas</strong></p><p>​    每个主题被分为若干个分区，每个分区有多个副本。</p><p><strong>生产者Producer</strong></p><p>​    生产者在默认情况下把<strong>消息均衡地分布</strong>到主题的所有分区上：</p><ul><li>直接指定消息的分区</li><li>根据消息的key散列取模得出分区</li><li>轮询指定分区。</li></ul><p><strong>消费者Comsumer</strong></p><p>​    消费者通过<strong>偏移量</strong>来区分已经读过的消息，从而消费消息。把每个分区最后读取的消息偏移量保存在Zookeeper 或Kafka上，如果消费者关闭或重启，它的<strong>读取状态不会丢失</strong>。</p><p><strong>消费组ComsumerGroup</strong></p><p>​    消费组保证<strong>每个分区只能被一个消费者</strong>使用，避免重复消费。如果群组内一个<strong>消费者失效</strong>，消费组里的其他消费者可以<strong>接管失效消费者的工作再平衡</strong>，重新分区</p><p><strong>节点Broker</strong></p><p>​    连接生产者和消费者，<strong>单个</strong>broker<strong>可以轻松处理</strong>数千个分区<strong>以及</strong>每秒百万级的消息量。</p><ul><li>broker接收来自生产者的消息，为消息设置偏移量，并提交<strong>消息到磁盘保存</strong>。</li><li>broker为消费者提供服务，响应读取分区的请求，<strong>返回已经提交到磁盘上的消息</strong>。</li></ul><p><strong>集群</strong></p><p>​    每隔分区都有一个<strong>首领</strong>，当分区被分配给多个broker时，会通过首领进行<strong>分区复制</strong>。    </p><p><strong>生产者Offset</strong></p><p>​    消息写入的时候，每一个分区都有一个offset，即每个分区的最新最大的offset。</p><p><strong>消费者Offset</strong></p><p>​    不同消费组中的消费者可以针对一个分区存储不同的Offset，互不影响</p><p><strong>LogSegment</strong></p><ul><li>一个分区由多个LogSegment组成，</li><li>一个LogSegment由<code>.log .index .timeindex</code>组成</li><li><code>.log</code>追加是顺序写入的，文件名是以文件中第一条message的offset来命名的</li><li><code>.Index</code>进行日志删除的时候和数据查找的时候可以快速定位。</li><li><code>.timeStamp</code>则根据<strong>时间戳查找对应的偏移量</strong>。</li></ul><h3 id="How-Kafka"><a href="#How-Kafka" class="headerlink" title="How Kafka"></a>How Kafka</h3><p><strong>优点</strong></p><ul><li><strong>高吞吐量</strong>：单机每秒处理几十上百万的消息量。即使存储了TB及消息，也保持稳定的性能。<ul><li><strong>零拷贝</strong> 减少内核态到用户态的拷贝，磁盘通过sendfile实现<strong>DMA</strong> 拷贝Socket buffer</li><li><strong>顺序读写</strong> 充分利用磁盘顺序读写的超高性能</li><li><strong>页缓存mmap</strong>，将磁盘文件<strong>映射</strong>到内存, 用户通过修改内存就能修改磁盘文件。</li></ul></li><li><strong>高性能</strong>：单节点支持上千个客户端，并保证零停机和零数据丢失。</li><li><strong>持久化</strong>：将消息持久化到磁盘。通过将数据持久化到硬盘以及replication防止数据丢失。</li><li><strong>分布式系统</strong>，易扩展。所有的组件均为分布式的，无需停机即可扩展机器。</li><li><strong>可靠性</strong> - Kafka是分布式，分区，复制和容错的。</li><li><strong>客户端状态维护</strong>：消息被处理的状态是在Consumer端维护，当失败时能自动平衡。</li></ul><p><strong>应用场景</strong></p><ul><li><strong>日志收集：</strong>用Kafka可以收集各种服务的Log，通过大数据平台进行处理；</li><li><strong>消息系统：</strong>解耦生产者和消费者、缓存消息等；</li><li><strong>用户活动跟踪：</strong>Kafka经常被用来记录Web用户或者App用户的各种活动，如浏览网页、搜索、点击等活动，这些活动信息被各个服务器发布到Kafka的Topic中，然后消费者通过订阅这些Topic来做<strong>运营数据</strong>的实时的监控分析，也可保存到数据库；</li></ul><h3 id="生产消费基本流程"><a href="#生产消费基本流程" class="headerlink" title="生产消费基本流程"></a><strong>生产消费基本流程</strong></h3><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmeb1cw09gj313m0kgwgb.jpg" alt="image-20210106213944461" style="zoom:40%;"></p><ol><li><p>Producer创建时，会创建一个Sender线程并设置为守护线程。</p></li><li><p>生产的消息先经过拦截器-&gt;序列化器-&gt;分区器，然后将消息缓存在缓冲区。</p></li><li><p>批次发送的条件为：缓冲区数据大小达到<strong>batch.size</strong>或者<strong>linger.ms</strong>达到上限。</p></li><li><p>批次发送后，发往指定分区，然后落盘到broker；</p><ul><li><p><strong>acks=0</strong>只要将消息放到缓冲区，就认为消息已经发送完成。</p></li><li><p><strong>acks=1</strong>表示消息<strong>只需要写到主分区</strong>即可。在该情形下，如果主分区收到消息确认之后就宕机了，而副本分区还没来得及同步该消息，则该消息丢失。</p></li><li><p><strong>acks=all （默认）</strong>首领分区会等待<strong>所有的ISR副本分区确认记录</strong>。该处理保证了只要有一个ISR副本分区存活，消息就不会丢失。</p></li></ul></li><li><p>如果生产者配置了<strong>retrires参数大于0并且未收到确认</strong>，那么客户端会对该消息进行重试。</p></li><li><p>落盘到broker成功，返回生产元数据给生产者。</p></li></ol><p><strong>Leader选举</strong></p><ul><li><p>Kafka会在Zookeeper上针对每个Topic维护一个称为ISR（in-sync replica）的集合</p></li><li><p>当集合中副本都跟Leader中的副本同步了之后，kafka才会认为消息已提交</p></li><li><p>只有这些跟Leader保持同步的Follower才应该被选作新的Leader</p></li><li><p>假设某个topic有N+1个副本，kafka可以容忍N个服务器不可用，冗余度较低</p><p>如果ISR中的副本都丢失了，则：</p><ul><li>可以等待ISR中的副本任何一个恢复，接着对外提供服务，需要时间等待</li><li>从OSR中选出一个副本做Leader副本，此时会造成数据丢失</li></ul></li></ul><p><strong>副本消息同步</strong></p><p>​    首先，Follower 发送 FETCH 请求给 Leader。接着，Leader 会读取底层日志文件中的消 息数据，再更新它内存中的 Follower 副本的 LEO 值，更新为 FETCH 请求中的 fetchOffset 值。最后，尝试更新分区高水位值。Follower 接收到 FETCH 响应之后，会把消息写入到底层日志，接着更新 LEO 和 HW 值。</p><p><strong>相关概念</strong>：<strong>LEO</strong>和<strong>HW</strong>。</p><ul><li>LEO：即日志末端位移(log end offset)，记录了该副本日志中下一条消息的位移值。如果LEO=10，那么表示该副本保存了10条消息，位移值范围是[0, 9]</li><li>HW：水位值HW（high watermark）即已备份位移。对于同一个副本对象而言，其HW值不会大于LEO值。小于等于HW值的所有消息都被认为是“已备份”的（replicated）</li></ul><p><strong>Rebalance</strong></p><ul><li>组成员数量发生变化</li><li>订阅主题数量发生变化</li><li>订阅主题的分区数发生变化</li></ul><p>leader选举完成后，当以上三种情况发生时，Leader根据配置的<strong>RangeAssignor</strong>开始分配消费方案，即哪个consumer负责消费哪些topic的哪些partition。一旦完成分配，leader会将这个方案封装进<strong>SyncGroup</strong>请求中发给coordinator，非leader也会发SyncGroup请求，只是内容为空。coordinator接收到分配方案之后会把方案塞进SyncGroup的response中发给各个consumer。这样组内的所有成员就都知道自己应该消费哪些分区了。</p><p><strong>分区分配算法RangeAssignor</strong></p><ul><li><p>原理是按照消费者总数和分区总数进行整除运算平均分配给所有的消费者。</p></li><li><p>订阅Topic的消费者按照名称的字典序排序，分均分配，剩下的字典序从前往后分配</p></li></ul><p><strong>增删改查</strong></p><pre class=" language-bash"><code class="language-bash">kafka-topics.sh --zookeeper localhost:2181/myKafka --create --topic topic_x                                 --partitions 1 --replication-factor 1kafka-topics.sh --zookeeper localhost:2181/myKafka --delete --topic topic_xkafka-topics.sh --zookeeper localhost:2181/myKafka --alter --topic topic_x                                --config max.message.bytes<span class="token operator">=</span>1048576kafka-topics.sh --zookeeper localhost:2181/myKafka --describe --topic topic_x</code></pre><p><strong>如何查看偏移量为23的消息？</strong></p><p>通过查询跳跃表<code>ConcurrentSkipListMap</code>，定位到在00000000000000000000.index ，通过二分法在偏移量索引文件中找到不大于 23 的<strong>最大索引项</strong>，即offset 20 那栏，然后从日志分段文件中的物理位置为320 开始顺序查找偏移量为 23 的消息。</p><p><img src="https://img-blog.csdnimg.cn/20191230225447849.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwMjMzNzA2,size_16,color_FFFFFF,t_70" alt="img" style="zoom:50%;"></p><p><strong>切分文件</strong></p><ul><li><strong>大小分片</strong> 当前日志分段文件的大小超过了 broker 端参数 <code>log.segment.bytes</code> 配置的值</li><li><strong>时间分片</strong> 当前日志分段中消息的最大时间戳与系统的时间戳的差值大于<code>log.roll.ms</code>配置的值</li><li><strong>索引分片</strong> 偏移量或时间戳索引文件大小达到broker端 <code>log.index.size.max.bytes</code>配置的值</li><li><strong>偏移分片</strong> 追加的消息的偏移量与当前日志分段的偏移量之间的差值大于 Integer.MAX_VALUE </li></ul><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p><strong>幂等性</strong></p><p>保证在消息重发的时候，消费者不会重复处理。即使在<strong>消费者收到重复消息的时候，重复处理</strong>，也</p><p>要<strong>保证最终结果的一致性</strong>。所谓幂等性，数学概念就是： f(f(x)) = f(x) </p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefdeas1vj315i0bgmya.jpg" alt="image-20210107000942286"></p><p><strong>如何实现？</strong></p><p>​    添加唯一ID，类似于数据库的主键，用于唯一标记一个消息。</p><pre class=" language-bash"><code class="language-bash">ProducerID：<span class="token comment" spellcheck="true">#在每个新的Producer初始化时，会被分配一个唯一的PID</span>SequenceNumber：<span class="token comment" spellcheck="true">#对于每个PID发送数据的每个Topic都对应一个从0开始单调递增的SN值</span></code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmefjpeet8j317e0cgmyp.jpg" alt="image-20210107001546404" style="zoom:80%;"></p><p><strong>如何选举</strong></p><ol><li>使用 Zookeeper 的<strong>分布式锁选举控制器</strong>，并在节点加入集群或退出集群时通知控制器。</li><li>控制器负责在节点加入或离开集群时进行分区Leader选举。</li><li>控制器使用epoch<code>忽略小的纪元</code>来避免<strong>脑裂</strong>：两个节点同时认为自己是当前的控制器。</li></ol><h3 id="可用性"><a href="#可用性" class="headerlink" title="可用性"></a>可用性</h3><ul><li>创建Topic的时候可以指定 –replication-factor 3 ，表示不超过broker的副本数</li><li>只有Leader是负责读写的节点，Follower定期地到Leader上Pull数据。</li><li>ISR是Leader负责维护的与其保持同步的Replica列表，即当前活跃的副本列表。如果一个Follow落后太多，Leader会将它从ISR中移除。选举时优先从ISR中挑选Follower。 </li><li>设置 acks=all 。Leader收到了ISR中所有Replica的ACK，才向Producer发送ACK。</li></ul><h3 id="面试题-2"><a href="#面试题-2" class="headerlink" title="面试题"></a>面试题</h3><h4 id="线上问题rebalance"><a href="#线上问题rebalance" class="headerlink" title="线上问题rebalance"></a><strong>线上问题rebalance</strong></h4><blockquote><p>因集群架构变动导致的消费组内重平衡，如果kafka集内节点较多，比如数百个，那重平衡可能会耗时导致<strong>数分钟到数小时</strong>，此时kafka基本处于不可用状态，对kafka的TPS影响极大</p></blockquote><p>产生的原因：</p><ul><li><p>组成员数量发生变化</p></li><li><p>订阅主题数量发生变化</p></li><li><p>订阅主题的分区数发生变化</p><p><strong>组成员崩溃和组成员主动离开是两个不同的场景。</strong>因为在崩溃时成员并不会主动地告知coordinator此事，coordinator有可能需要一个完整的session.timeout周期(心跳周期)才能检测到这种崩溃，这必然会造成consumer的滞后。可以说离开组是主动地发起rebalance；而崩溃则是被动地发起rebalance。</p><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gooe9o07fvj30p00btju1.jpg" alt="img"></p></li></ul><p>解决方案：</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">加大超时时间</span> <span class="token attr-value">session.timout.ms=6s</span><span class="token attr-name">加大心跳频率</span> <span class="token attr-value">heartbeat.interval.ms=2s</span><span class="token attr-name">增长推送间隔</span> <span class="token attr-value">max.poll.interval.ms=t+1 minutes</span></code></pre><p><a href>这些年，为了进阿里背过的面试题</a></p><h4 id="ZooKeeper-的作用"><a href="#ZooKeeper-的作用" class="headerlink" title="ZooKeeper 的作用"></a>ZooKeeper 的作用</h4><p>目前，Kafka 使用 ZooKeeper 存放集群元数据、成员管理、Controller 选举，以及其他一些管理类任务。之后，等 KIP-500 提案完成后，Kafka 将完全不再依赖于 ZooKeeper。</p><ul><li><strong>存放元数据</strong>是指主题分区的所有数据都保存在 ZooKeeper 中，其他“人”都要与它保持对齐。</li><li><strong>成员管理</strong>是指 Broker 节点的注册、注销以及属性变更等 。</li><li><strong>Controller 选举</strong>是指选举集群 Controller，包括但不限于主题删除、参数配置等。</li></ul><p>一言以蔽之:<strong>KIP-500 ，是使用社区自研的基于 Raft 的共识算法，实现 Controller 自选举</strong>。</p><p>同样是存储元数据，这几年<strong>基于Raft算法的etcd</strong>认可度越来越高</p><p>​    越来越多的系统开始用它保存关键数据。比如，<strong>秒杀系统经常用它保存各节点信息</strong>，以便控制消费 MQ 的服务数量。还有些<strong>业务系统的配置数据</strong>，也会通过 etcd 实时<strong>同步给业务系统的各节点</strong>，比如，秒杀管理后台会使用 etcd 将<strong>秒杀活动的配置数据实时同步给秒杀 API 服务各节点</strong>。</p><h4 id="Replica副本的作用"><a href="#Replica副本的作用" class="headerlink" title="Replica副本的作用"></a>Replica副本的作用</h4><p><strong>Kafka 只有 Leader 副本才能 对外提供读写服务，响应 Clients 端的请求。Follower 副本只是采用拉(PULL)的方 式，被动地同步 Leader 副本中的数据，并且在 Leader 副本所在的 Broker 宕机后，随时准备应聘 Leader 副本。</strong></p><ul><li><strong>自 Kafka 2.4 版本开始</strong>，社区可以通过配置参数，允许 Follower 副本有限度地提供读服务。</li><li>之前确保一致性的主要手段是高水位机制， 但高水位值无法保证 Leader 连续变更场景下的数据一致性，因此，社区引入了 <strong>Leader Epoch</strong> 机制，来修复高水位值的弊端。</li></ul><h4 id="为什么不支持读写分离"><a href="#为什么不支持读写分离" class="headerlink" title="为什么不支持读写分离?"></a>为什么不支持读写分离?</h4><ul><li><p><strong>自 Kafka 2.4 之后</strong>，Kafka 提供了有限度的读写分离。</p></li><li><p><strong>场景不适用</strong>。读写分离适用于那种读负载很大，而写操作相对不频繁的场景。</p></li><li><strong>同步机制</strong>。Kafka 采用 PULL 方式实现 Follower 的同步，同时复制延迟较大。</li></ul><h4 id="如何防止重复消费"><a href="#如何防止重复消费" class="headerlink" title="如何防止重复消费"></a>如何防止重复消费</h4><ul><li>代码层面每次消费需提交offset</li><li>通过Mysql的<strong>唯一键约束</strong>，结合Redis查看<strong>id是否被消费</strong>，存Redis可以直接使用set方法</li><li>量大且允许误判的情况下，使用布隆过滤器也可以</li></ul><h4 id="如何保证数据不会丢失"><a href="#如何保证数据不会丢失" class="headerlink" title="如何保证数据不会丢失"></a><strong>如何保证数据不会丢失</strong></h4><ul><li><strong>生产者</strong>生产消息可以通过comfirm配置<strong>ack=all</strong>解决</li><li><strong>Broker</strong>同步过程中leader宕机可以通过配置<strong>ISR副本+重试</strong>解决</li><li><strong>消费者</strong>丢失可以<strong>关闭自动提交</strong>offset功能，系统处理完成时提交offset</li></ul><h4 id="如何保证顺序消费"><a href="#如何保证顺序消费" class="headerlink" title="如何保证顺序消费"></a><strong>如何保证顺序消费</strong></h4><ul><li>单 topic，单partition，单 consumer，单线程消费，吞吐量低，不推荐</li><li><strong>如只需保证单key有序</strong>，为每个key申请单独内存 queue，每个线程分别消费一个内存 queue 即可，这样就能保证单key（例如用户id、活动id）顺序性。</li></ul><h4 id="【线上】如何解决积压消费"><a href="#【线上】如何解决积压消费" class="headerlink" title="【线上】如何解决积压消费"></a>【线上】如何解决积压消费</h4><ul><li><strong>修复consumer</strong>，使其具备消费能力，并且扩容N台</li><li>写一个<strong>分发的程序</strong>，将Topic均匀分发到临时Topic中</li><li>同时<strong>起N台consumer</strong>，消费不同的<strong>临时Topic</strong></li></ul><h4 id="如何避免消息积压"><a href="#如何避免消息积压" class="headerlink" title="如何避免消息积压"></a>如何避免消息积压</h4><ul><li>提高消费并行度</li><li>批量消费</li><li>减少组件IO的交互次数</li><li>优先级消费</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>maxOffset <span class="token operator">-</span> curOffset <span class="token operator">></span> <span class="token number">100000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// TODO 消息堆积情况的优先处理逻辑</span>  <span class="token comment" spellcheck="true">// 未处理的消息可以选择丢弃或者打日志</span>  <span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// TODO 正常消费过程</span><span class="token keyword">return</span> ConsumeConcurrentlyStatus<span class="token punctuation">.</span>CONSUME_SUCCESS<span class="token punctuation">;</span></code></pre><h4 id="如何设计消息队列"><a href="#如何设计消息队列" class="headerlink" title="如何设计消息队列"></a>如何设计消息队列</h4><p>需要支持快速水平扩容，broker+partition，partition放不同的机器上，增加机器时将数据根据topic做迁移，分布式需要考虑一致性、可用性、分区容错性</p><ul><li><strong>一致性：</strong>生产者的消息确认、消费者的幂等性、Broker的数据同步</li><li><strong>可用性：</strong>数据如何保证不丢不重、数据如何持久化、持久化时如何读写</li><li><strong>分区容错：</strong>采用何种选举机制、如何进行多副本同步</li><li><strong>海量数据：</strong>如何解决消息积压、海量Topic性能下降</li></ul><p>性能上，可以借鉴<strong>时间轮、零拷贝、IO多路复用、顺序读写、压缩批处理</strong></p><h1 id="七、Spring篇"><a href="#七、Spring篇" class="headerlink" title="七、Spring篇"></a>七、Spring篇</h1><h3 id="设计思想-amp-Beans"><a href="#设计思想-amp-Beans" class="headerlink" title="设计思想&amp;Beans"></a>设计思想&amp;Beans</h3><h4 id="1、IOC-控制反转"><a href="#1、IOC-控制反转" class="headerlink" title="1、IOC 控制反转"></a><strong>1、IOC 控制反转</strong></h4><p>​        IoC（Inverse of Control:控制反转）是⼀种设计思想，就是将原本在程序中⼿动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语⾔中也有应⽤，并⾮ Spring 特有。 </p><p>​        IoC 容器是 Spring⽤来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注⼊。这样可以很⼤程度上简化应⽤的开发，把应⽤从复杂的依赖关系中解放出来。 IoC 容器就像是⼀个⼯⼚⼀样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可，完全不⽤考虑对象是如何被创建出来的。</p><p><strong>DI 依赖注入</strong></p><p>​    DI:（Dependancy Injection：依赖注入)站在容器的角度，将对象创建依赖的其他对象注入到对象中。</p><h4 id="2、AOP-动态代理"><a href="#2、AOP-动态代理" class="headerlink" title="2、AOP 动态代理"></a><strong>2、AOP 动态代理</strong></h4><p>​        AOP(Aspect-Oriented Programming:⾯向切⾯编程)能够将那些与业务⽆关，却为业务模块所共同调⽤的逻辑或责任（例如事务处理、⽇志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>​        Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接⼝，那么Spring AOP会使⽤JDKProxy，去创建代理对象，⽽对于没有实现接⼝的对象，就⽆法使⽤ JDK Proxy 去进⾏代理了，这时候Spring AOP会使⽤基于asm框架字节流的Cglib动态代理 ，这时候Spring AOP会使⽤ Cglib ⽣成⼀个被代理对象的⼦类来作为代理。</p><h4 id="3、Bean生命周期"><a href="#3、Bean生命周期" class="headerlink" title="3、Bean生命周期"></a><strong>3、Bean生命周期</strong></h4><p><strong>单例对象：</strong> singleton                    </p><p>总结：单例对象的生命周期和容器相同        </p><p><strong>多例对象：</strong> prototype           </p><p>出生：使用对象时spring框架为我们创建            </p><p>活着：对象只要是在使用过程中就一直活着            </p><p>死亡：当对象长时间不用且没有其它对象引用时，由java的垃圾回收机制回收</p><p><img src="https://s0.lgstatic.com/i/image3/M01/89/0C/Cgq2xl6WvHqAdmt4AABGAn2eSiI631.png" alt="img" style="zoom:67%;"></p><p>IOC容器初始化加载Bean流程：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException<span class="token punctuation">,</span> IllegalStateException <span class="token punctuation">{</span> <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 第一步:刷新前的预处理 </span>  <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//第二步: 获取BeanFactory并注册到 BeanDefitionRegistry</span>  ConfigurableListableBeanFactory beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 第三步:加载BeanFactory的预准备工作(BeanFactory进行一些设置，比如context的类加载器等)</span>  <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 第四步:完成BeanFactory准备工作后的前置处理工作 </span>    <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第五步:实例化BeanFactoryPostProcessor接口的Bean </span>    <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第六步:注册BeanPostProcessor后置处理器，在创建bean的后执行 </span>    <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第七步:初始化MessageSource组件(做国际化功能;消息绑定，消息解析); </span>    <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第八步:注册初始化事件派发器 </span>    <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第九步:子类重写这个方法，在容器刷新的时候可以自定义逻辑 </span>    <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第十步:注册应用的监听器。就是注册实现了ApplicationListener接口的监听器</span>    <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第十一步:初始化所有剩下的非懒加载的单例bean 初始化创建非懒加载方式的单例Bean实例(未设置属性)</span>    <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//第十二步: 完成context的刷新。主要是调用LifecycleProcessor的onRefresh()方法，完成创建</span>    <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  ……<span class="token punctuation">}</span> </code></pre><p>总结：</p><p><strong>四个阶段</strong></p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p><strong>多个扩展点</strong></p><ul><li>影响多个Bean<ul><li>BeanPostProcessor</li><li>InstantiationAwareBeanPostProcessor</li></ul></li><li>影响单个Bean<ul><li>Aware</li></ul></li></ul><p><strong>完整流程</strong>  </p><ol><li>实例化一个Bean－－也就是我们常说的<strong>new</strong>；</li><li>按照Spring上下文对实例化的Bean进行配置－－<strong>也就是IOC注入</strong>；</li><li>如果这个Bean已经实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法，也就是根据就是Spring配置文件中<strong>Bean的id和name进行传递</strong></li><li>如果这个Bean已经实现了BeanFactoryAware接口，会调用它实现setBeanFactory(BeanFactory)也就是Spring配置文件配置的<strong>Spring工厂自身进行传递</strong>；</li><li>如果这个Bean已经实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法，和4传递的信息一样但是因为ApplicationContext是BeanFactory的子接口，所以<strong>更加灵活</strong></li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()方法，BeanPostProcessor经常被用作是Bean内容的更改，由于这个是在Bean初始化结束时调用那个的方法，也可以被应用于<strong>内存或缓存技</strong>术</li><li>如果Bean在Spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。</li><li>如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()，<strong>打印日志或者三级缓存技术里面的bean升级</strong></li><li>以上工作完成以后就可以应用这个Bean了，那这个Bean是一个Singleton的，所以一般情况下我们调用同一个id的Bean会是在内容地址相同的实例，当然在Spring配置文件中也可以配置非Singleton，这里我们不做赘述。</li><li>当Bean不再需要时，会经过清理阶段，如果Bean实现了DisposableBean这个接口，或者根据spring配置的destroy-method属性，调用实现的destroy()方法</li></ol><h4 id="4、Bean作用域"><a href="#4、Bean作用域" class="headerlink" title="4、Bean作用域"></a><strong>4</strong>、Bean作用域</h4><table><thead><tr><th>名称</th><th>作用域</th></tr></thead><tbody><tr><td><strong>singleton</strong></td><td><strong>单例对象，默认值的作用域</strong></td></tr><tr><td><strong>prototype</strong></td><td><strong>每次获取都会创建⼀个新的 bean 实例</strong></td></tr><tr><td>request</td><td>每⼀次HTTP请求都会产⽣⼀个新的bean，该bean仅在当前HTTP request内有效。</td></tr><tr><td>session</td><td>在一次 HTTP session 中，容器将返回同一个实例</td></tr><tr><td>global-session</td><td>将对象存入到web项目集群的session域中,若不存在集群,则global session相当于session</td></tr></tbody></table><p>默认作用域是singleton，多个线程访问同一个bean时会存在线程不安全问题</p><p><strong>保障线程安全方法：</strong></p><ol><li><p>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</p></li><li><p>在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中</p><p><strong>ThreadLocal</strong>：</p><p>​        每个线程中都有一个自己的ThreadLocalMap类对象，可以将线程自己的对象保持到其中，各管各的，线程可以正确的访问到自己的对象。</p><p>​        将一个共用的ThreadLocal静态实例作为key，将不同对象的引用保存到不同线程的ThreadLocalMap中，然后<strong>在线程执行的各处通过这个静态ThreadLocal实例的get()方法取得自己线程保存的那个对象</strong>，避免了将这个对象作为参数传递的麻烦。</p></li></ol><h4 id="5、循环依赖"><a href="#5、循环依赖" class="headerlink" title="5、循环依赖"></a>5、循环依赖</h4><p>​    循环依赖其实就是循环引用，也就是两个或者两个以上的 Bean 互相持有对方，最终形成闭环。比如A 依赖于B，B又依赖于A</p><p>Spring中循环依赖场景有: </p><ul><li><p>prototype 原型 bean循环依赖</p></li><li><p>构造器的循环依赖（构造器注入）</p></li><li><p>Field 属性的循环依赖（set注入）</p><p>其中，构造器的循环依赖问题无法解决，在解决属性循环依赖时，可以使用懒加载，spring采用的是提前暴露对象的方法。</p></li></ul><p><strong>懒加载@Lazy解决循环依赖问题</strong></p><p>​    Spring 启动的时候会把所有bean信息(包括XML和注解)解析转化成Spring能够识别的BeanDefinition并存到Hashmap里供下面的初始化时用，然后对每个 BeanDefinition 进行处理。普通 Bean 的初始化是在容器启动初始化阶段执行的，而被lazy-init=true修饰的 bean 则是在从容器里第一次进行<strong>context.getBean() 时进行触发</strong>。</p><p>​     </p><p><strong>三级缓存解决循环依赖问题</strong></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1glv7ivru2lj31980qcn13.jpg" alt="循环依赖问题" style="zoom: 33%;"></p><ol><li><p>Spring容器初始化ClassA通过构造器初始化对象后提前暴露到Spring容器中的singletonFactorys（三级缓存中）。</p></li><li><p>ClassA调用setClassB方法，Spring首先尝试从容器中获取ClassB，此时ClassB不存在Spring 容器中。</p></li><li><p>Spring容器初始化ClassB，ClasssB首先将自己暴露在三级缓存中，然后从Spring容器一级、二级、三级缓存中一次中获取ClassA 。</p></li><li><p>获取到ClassA后将自己实例化放入单例池中，实例 ClassA通过Spring容器获取到ClassB，完成了自己对象初始化操作。</p></li><li><p>这样ClassA和ClassB都完成了对象初始化操作，从而解决了循环依赖问题。</p></li></ol><h3 id="Spring注解"><a href="#Spring注解" class="headerlink" title="Spring注解"></a>Spring注解</h3><h4 id="1、-SpringBoot"><a href="#1、-SpringBoot" class="headerlink" title="1、@SpringBoot"></a>1、@SpringBoot</h4><p>​    <strong>声明bean的注解</strong></p><p>​    <strong>@Component</strong> 通⽤的注解，可标注任意类为  Spring 组件</p><p>​    <strong>@Service</strong> 在业务逻辑层使用（service层）</p><p>​    <strong>@Repository</strong> 在数据访问层使用（dao层）</p><p>​    <strong>@Controller</strong> 在展现层使用，控制器的声明（controller层）</p><p>​    <strong>注入bean的注解</strong></p><p>​    <strong>@Autowired</strong>：默认按照类型来装配注入，<strong>@Qualifier</strong>：可以改成名称</p><p>​    <strong>@Resource</strong>：默认按照名称来装配注入，JDK的注解，新版本已经弃用</p><p><strong>@Autowired注解原理</strong> </p><p>​         @Autowired的使用简化了我们的开发，</p><p>​                实现 AutowiredAnnotationBeanPostProcessor 类，该类实现了 Spring 框架的一些扩展接口。<br>​                实现 BeanFactoryAware 接口使其内部持有了 BeanFactory（可轻松的获取需要依赖的的 Bean）。<br>​                实现 MergedBeanDefinitionPostProcessor 接口，实例化Bean 前获取到 里面的 @Autowired 信息并缓存下来；<br>​                实现 postProcessPropertyValues 接口， 实例化Bean 后从缓存取出注解信息，通过反射将依赖对象设置到 Bean 属性里面。</p><p><strong>@SpringBootApplication</strong></p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@SpringBootApplication</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">JpaApplication</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SpringApplication<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span>JpaApplication<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>@SpringBootApplication</strong>注解等同于下面三个注解：</p><ul><li><strong>@SpringBootConfiguration：</strong> 底层是<strong>Configuration</strong>注解，说白了就是支持<strong>JavaConfig</strong>的方式来进行配置</li><li><strong>@EnableAutoConfiguration：</strong>开启<strong>自动配置</strong>功能</li><li><strong>@ComponentScan：</strong>就是<strong>扫描</strong>注解，默认是扫描<strong>当前类下</strong>的package</li></ul><p>其中<code>@EnableAutoConfiguration</code>是关键(启用自动配置)，内部实际上就去加载<code>META-INF/spring.factories</code>文件的信息，然后筛选出以<code>EnableAutoConfiguration</code>为key的数据，加载到IOC容器中，实现自动配置功能！</p><p>它主要加载了@SpringBootApplication注解主配置类，这个@SpringBootApplication注解主配置类里边最主要的功能就是SpringBoot开启了一个@EnableAutoConfiguration注解的自动配置功能。</p><p> <strong>@EnableAutoConfiguration作用：</strong></p><p>它主要利用了一个</p><p>EnableAutoConfigurationImportSelector选择器给Spring容器中来导入一些组件。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span>EnableAutoConfigurationImportSelector<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">EnableAutoConfiguration</span> </code></pre><h4 id="2、-SpringMVC"><a href="#2、-SpringMVC" class="headerlink" title="2、@SpringMVC"></a><strong>2、@SpringMVC</strong></h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Controller</span> 声明该类为SpringMVC中的Controller<span class="token annotation punctuation">@RequestMapping</span> 用于映射Web请求<span class="token annotation punctuation">@ResponseBody</span> 支持将返回值放在response内，而不是一个页面，通常用户返回json数据<span class="token annotation punctuation">@RequestBody</span> 允许request的参数在request体中，而不是在直接连接在地址后面。<span class="token annotation punctuation">@PathVariable</span> 用于接收路径参数<span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span><span class="token string">"/hello/{name}"</span><span class="token punctuation">)</span>申明的路径，将注解放在参数中前，即可获取该值，通常作为Restful的接口实现方法。</code></pre><p><strong>SpringMVC原理</strong> </p><p><img src="https://img-blog.csdn.net/20181022224058617?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2F3YWtlX2xxaA==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" style="zoom: 50%;"></p><ol><li>客户端（浏览器）发送请求，直接请求到  DispatcherServlet 。</li><li>DispatcherServlet 根据请求信息调⽤  HandlerMapping ，解析请求对应的  Handler 。</li><li>解析到对应的  Handler （也就是  Controller 控制器）后，开始由HandlerAdapter 适配器处理。</li><li>HandlerAdapter 会根据  Handler 来调⽤真正的处理器开处理请求，并处理相应的业务逻辑。</li><li>处理器处理完业务后，会返回⼀个  ModelAndView 对象， Model 是返回的数据对象</li><li>ViewResolver 会根据逻辑  View 查找实际的  View 。</li><li>DispaterServlet 把返回的  Model 传给  View （视图渲染）。</li><li>把  View 返回给请求者（浏览器）</li></ol><h4 id="3、-SpringMybatis"><a href="#3、-SpringMybatis" class="headerlink" title="3、@SpringMybatis"></a>3、@SpringMybatis</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Insert</span> ： 插入sql <span class="token punctuation">,</span>和xml insert sql语法完全一样<span class="token annotation punctuation">@Select</span> ： 查询sql<span class="token punctuation">,</span> 和xml select sql语法完全一样<span class="token annotation punctuation">@Update</span> ： 更新sql<span class="token punctuation">,</span> 和xml update sql语法完全一样<span class="token annotation punctuation">@Delete</span> ： 删除sql<span class="token punctuation">,</span> 和xml delete sql语法完全一样<span class="token annotation punctuation">@Param</span> ： 入参<span class="token annotation punctuation">@Results</span> ： 设置结果集合<span class="token annotation punctuation">@Result</span> ： 结果<span class="token annotation punctuation">@ResultMap</span> ： 引用结果集合<span class="token annotation punctuation">@SelectKey</span> ： 获取最新插入id </code></pre><p><strong>mybatis如何防止sql注入？</strong></p><p>​    简单的说就是#{}是经过预编译的，是安全的，<strong>$</strong>{}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。在编写mybatis的映射语句时，尽量采用<strong>“#{xxx}”</strong>这样的格式。如果需要实现动态传入表名、列名，还需要做如下修改：添加属性<strong>statementType=”STATEMENT”</strong>，同时sql里的属有变量取值都改成<strong>${xxxx}</strong></p><p><strong>Mybatis和Hibernate的区别</strong> </p><p><strong>Hibernate 框架：</strong> </p><p>​    <strong>Hibernate</strong>是一个开放源代码的对象关系映射框架,它对JDBC进行了非常轻量级的对象封装,建立对象与数据库表的映射。是一个全自动的、完全面向对象的持久层框架。</p><p><strong>Mybatis框架：</strong></p><p>​    <strong>Mybatis</strong>是一个开源对象关系映射框架，原名：ibatis,2010年由谷歌接管以后更名。是一个半自动化的持久层框架。</p><p><strong>区别：</strong></p><p>  <strong>开发方面</strong></p><p>​    在项目开发过程当中，就速度而言：</p><p>​      hibernate开发中，sql语句已经被封装，直接可以使用，加快系统开发；</p><p>​      Mybatis 属于半自动化，sql需要手工完成，稍微繁琐；</p><p>​    但是，凡事都不是绝对的，如果对于庞大复杂的系统项目来说，复杂语句较多，hibernate 就不是好方案。</p><p>  <strong>sql优化方面</strong></p><p>​    Hibernate 自动生成sql,有些语句较为繁琐，会多消耗一些性能；</p><p>​    Mybatis 手动编写sql，可以避免不需要的查询，提高系统性能；</p><p>  <strong>对象管理比对</strong></p><p>​    Hibernate 是完整的对象-关系映射的框架，开发工程中，无需过多关注底层实现，只要去管理对象即可；</p><p>​    Mybatis 需要自行管理映射关系；</p><h4 id="4、-Transactional"><a href="#4、-Transactional" class="headerlink" title="4、@Transactional"></a>4、@Transactional</h4><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@EnableTransactionManagement</span> <span class="token annotation punctuation">@Transactional</span></code></pre><p>注意事项：</p><p>​    ①事务函数中不要处理耗时任务，会导致长期占有数据库连接。</p><p>​    ②事务函数中不要处理无关业务，防止产生异常导致事务回滚。</p><p><strong>事务传播属性</strong></p><p><strong>1) REQUIRED（默认属性）</strong> 如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。 </p><p>2) MANDATORY  支持当前事务，如果当前没有事务，就抛出异常。 </p><p>3) NEVER  以非事务方式执行，如果当前存在事务，则抛出异常。 </p><p>4) NOT_SUPPORTED  以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p><p>5) REQUIRES_NEW  新建事务，如果当前存在事务，把当前事务挂起。 </p><p>6) SUPPORTS  支持当前事务，如果当前没有事务，就以非事务方式执行。 </p><p><strong>7) NESTED</strong> （<strong>局部回滚</strong>） 支持当前事务，新增Savepoint点，与当前事务同步提交或回滚。 <strong>嵌套事务一个非常重要的概念就是内层事务依赖于外层事务。外层事务失败时，会回滚内层事务所做的动作。而内层事务操作失败并不会引起外层事务的回滚。</strong></p><h3 id="Spring源码阅读"><a href="#Spring源码阅读" class="headerlink" title="Spring源码阅读"></a>Spring源码阅读</h3><h4 id="1、Spring中的设计模式"><a href="#1、Spring中的设计模式" class="headerlink" title="1、Spring中的设计模式"></a><strong>1、Spring中的设计模式</strong></h4><p>参考：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&amp;mid=2247485303&amp;idx=1&amp;sn=9e4626a1e3f001f9b0d84a6fa0cff04a&amp;chksm=cea248bcf9d5c1aaf48b67cc52bac74eb29d6037848d6cf213b0e5466f2d1fda970db700ba41&amp;token=255050878&amp;lang=zh_CN%23rd" target="_blank" rel="noopener">spring中的设计模式</a></p><p><strong>单例设计模式 :</strong> Spring 中的 Bean 默认都是单例的。</p><p><strong>⼯⼚设计模式 :</strong> Spring使⽤⼯⼚模式通过  BeanFactory 、 ApplicationContext 创建bean 对象。</p><p><strong>代理设计模式 :</strong> Spring AOP 功能的实现。</p><p><strong>观察者模式：</strong> Spring 事件驱动模型就是观察者模式很经典的⼀个应⽤。</p><p><strong>适配器模式：</strong>Spring AOP 的增强或通知(Advice)使⽤到了适配器模式、spring MVC 中也是⽤到了适配器模式适配 Controller 。</p><h1 id="八、SpringCloud篇"><a href="#八、SpringCloud篇" class="headerlink" title="八、SpringCloud篇"></a>八、SpringCloud篇</h1><h4 id="Why-SpringCloud"><a href="#Why-SpringCloud" class="headerlink" title="Why SpringCloud"></a>Why SpringCloud</h4><blockquote><p>​    Spring cloud 是一系列框架的有序集合。它利用 spring boot 的开发便利性巧妙地简化了分布式系统基础设施的开发，如<strong>服务发现注册</strong>、<strong>配置中心</strong>、<strong>消息总线</strong>、<strong>负载均衡</strong>、<strong>断路器</strong>、<strong>数据监控</strong>等，都可以用 spring boot 的开发风格做到一键启动和部署。</p></blockquote><table><thead><tr><th>SpringCloud（微服务解决方案）</th><th>Dubbo（分布式服务治理框架）</th></tr></thead><tbody><tr><td>Rest API （轻量、灵活、swagger）</td><td>RPC远程调用（高效、耦合）</td></tr><tr><td>Eureka、Nacos</td><td>Zookeeper</td></tr><tr><td>使用方便</td><td>性能好</td></tr><tr><td>即将推出SpringCloud2.0</td><td>断档5年后17年重启</td></tr></tbody></table><p>​    SpringBoot是Spring推出用于解决传统框架配置文件冗余,装配组件繁杂的基于Maven的解决方案,<strong>旨在快速搭建单个微服务</strong>，SpringCloud是依赖于SpringBoot的,而SpringBoot并不是依赖与SpringCloud,甚至还可以和Dubbo进行优秀的整合开发</p><p>​    MartinFlower 提出的微服务之间是通过RestFulApi进行通信，具体实现</p><ul><li>RestTemplate：基于HTTP协议</li><li>Feign：封装了ribbon和Hystrix 、RestTemplate 简化了客户端开发工作量</li><li>RPC：基于TCP协议，序列化和传输效率提升明显</li><li>MQ：异步解耦微服务之间的调用</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawejgpgwj30ht0bnt9d.jpg" alt="img" style="zoom:67%;"></p><h4 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h4><blockquote><p>Spring Boot 通过<strong>简单的步骤</strong>就可以创建一个 Spring 应用。</p><p>Spring Boot 为 Spring 整合第三方框架提供了<strong>开箱即用功能</strong>。</p><p>Spring Boot 的核心思想是<strong>约定大于配置</strong>。</p></blockquote><p><strong>Spring Boot 解决的问题</strong></p><ul><li><p>搭建后端框架时需要手动添加 Maven 配置，涉及很多 XML 配置文件，增加了搭建难度和时间成本。</p></li><li><p>将项目编译成 war 包，部署到 Tomcat 中，项目部署依赖 Tomcat，这样非常不方便。</p></li><li><p>应用监控做的比较简单，通常都是通过一个没有任何逻辑的接口来判断应用的存活状态。</p></li></ul><p><strong>Spring Boot 优点</strong></p><p><strong>自动装配：</strong>Spring Boot 会根据某些规则对所有配置的 Bean 进行初始化。可以减少了很多重复性的工作。</p><p>​    比如使用 MongoDB 时，只需加入 MongoDB 的 Starter 包，然后配置  的连接信息，就可以直接使用 MongoTemplate 自动装配来操作数据库了。简化了 Maven Jar 包的依赖，降低了烦琐配置的出错几率。</p><p><strong>内嵌容器：</strong>Spring Boot 应用程序可以不用部署到外部容器中，比如 Tomcat。</p><p>​    应用程序可以直接通过 Maven 命令编译成可执行的 jar 包，通过 java-jar 命令启动即可，非常方便。</p><p><strong>应用监控：</strong>Spring Boot 中自带监控功能 Actuator，可以实现对程序内部运行情况进行监控，</p><p>​    比如 Bean 加载情况、环境变量、日志信息、线程信息等。当然也可以自定义跟业务相关的监控，通过Actuator 的端点信息进行暴露。</p><pre class=" language-java"><code class="language-java">spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>web          <span class="token comment" spellcheck="true">//用于快速构建基于 Spring MVC 的 Web 项目。</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>redis   <span class="token comment" spellcheck="true">//用于快速整合并操作 Redis。</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>mongodb <span class="token comment" spellcheck="true">//用于对 MongoDB 的集成。</span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>starter<span class="token operator">-</span>data<span class="token operator">-</span>jpa     <span class="token comment" spellcheck="true">//用于操作 MySQL。</span></code></pre><p><strong>自定义一个Starter</strong></p><ol><li><p>创建 Starter 项目，定义 Starter 需要的配置（Properties）类，比如数据库的连接信息；</p></li><li><p>编写自动配置类，自动配置类就是获取配置，根据配置来自动装配 Bean；</p></li><li><p>编写 spring.factories 文件加载自动配置类，Spring 启动的时候会扫描 spring.factories 文件，；</p></li><li><p>编写配置提示文件 spring-configuration-metadata.json（不是必须的），在添加配置的时候，我们想要知道具体的配置项是什么作用，可以通过编写提示文件来提示；</p></li><li><p>在项目中引入自定义 Starter 的 Maven 依赖，增加配置值后即可使用。</p></li></ol><p><strong>Spring Boot Admin</strong>（将 actuator 提供的数据进行可视化）</p><ul><li><p>显示应用程序的监控状态、查看 JVM 和线程信息</p></li><li><p>应用程序上下线监控  </p></li><li><p>可视化的查看日志、动态切换日志级别</p></li><li><p>HTTP 请求信息跟踪等实用功能</p></li></ul><h4 id="GateWay-Zuul"><a href="#GateWay-Zuul" class="headerlink" title="GateWay / Zuul"></a>GateWay / Zuul</h4><blockquote><p>GateWay⽬标是取代Netflflix Zuul，它基于Spring5.0+SpringBoot2.0+WebFlux等技术开发，提供<strong>统⼀的路由</strong>⽅式（反向代理）并且基于 <strong>Filter</strong>(定义过滤器对请求过滤，完成⼀些功能) 链的⽅式提供了⽹关基本的功能，例如：鉴权、流量控制、熔断、路径重写、⽇志监控。</p></blockquote><p><strong>组成：</strong></p><ul><li><p><strong>路由route：</strong> ⽹关最基础的⼯作单元。路由由⼀个ID、⼀个⽬标URL、⼀系列的断⾔（匹配条件判断）和Filter过滤器组成。如果断⾔为true，则匹配该路由。</p></li><li><p><strong>断⾔predicates：</strong>参考了Java8中的断⾔Predicate，匹配Http请求中的所有内容（类似于nginx中的location匹配⼀样），如果断⾔与请求相匹配则路由。</p></li><li><p><strong>过滤器filter：</strong>标准的Spring webFilter，使⽤过滤器在请求之前或者之后执⾏业务逻辑。</p><p>请求前<code>pre</code>类型过滤器：做<strong>参数校验</strong>、<strong>权限校验</strong>、<strong>流量监控</strong>、<strong>⽇志输出</strong>、<strong>协议转换</strong>等，</p><p>请求前<code>post</code>类型的过滤器：做<strong>响应内容</strong>、<strong>响应头</strong>的修改、<strong>⽇志的输出</strong>、<strong>流量监控</strong>等。</p></li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc49l9babj31do0n7n13.jpg" alt="image-20210105001419761" style="zoom: 50%;"></p><p><strong>GateWayFilter</strong> 应⽤到单个路由路由上 、<strong>GlobalFilter</strong> 应⽤到所有的路由上</p><h4 id="Eureka-Zookeeper"><a href="#Eureka-Zookeeper" class="headerlink" title="Eureka / Zookeeper"></a>Eureka / Zookeeper</h4><blockquote><p>服务注册中⼼本质上是为了解耦服务提供者和服务消费者，为了⽀持弹性扩缩容特性，⼀个微服务的提供者的数量和分布往往是动态变化的。</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmawwm3k7bj30o80ecq3u.jpg" alt="image-20210103231405882" style="zoom: 50%;"></p><table><thead><tr><th>区别</th><th>Zookeeper</th><th>Eureka</th><th>Nacos</th></tr></thead><tbody><tr><td>CAP</td><td>CP</td><td>AP</td><td>CP/AP切换</td></tr><tr><td>可用性</td><td>选举期间不可用</td><td>自我保护机制，数据不是最新的</td><td></td></tr><tr><td>组成</td><td>Leader和Follower</td><td>节点平等</td><td></td></tr><tr><td>优势</td><td>分布式协调</td><td>注册与发现</td><td>注册中心和配置中心</td></tr><tr><td>底层</td><td>进程</td><td>服务</td><td>Jar包</td></tr></tbody></table><p><strong>Eureka</strong>通过<strong>⼼跳检测</strong>、<strong>健康检查</strong>和<strong>客户端缓存</strong>等机制，提⾼系统的灵活性、可伸缩性和可⽤性。</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxc493qyj30ji0a6mxx.jpg" alt="image-20210103232900353" style="zoom:67%;"></p><ol><li>us-east-1c、us-east-1d，us-east-1e代表不同的机房，<strong>每⼀个Eureka Server都是⼀个集群</strong>。</li><li>Service作为服务提供者向Eureka中注册服务，Eureka接受到注册事件会在<strong>集群和分区中进⾏数据同步</strong>，Client作为消费端（服务消费者）可以从Eureka中获取到服务注册信息，进⾏服务调⽤。</li><li>微服务启动后，会周期性地向Eureka<strong>发送⼼跳</strong>（默认周期为30秒）以续约⾃⼰的信息</li><li>Eureka在⼀定时间内<strong>（默认90秒）没有接收</strong>到某个微服务节点的⼼跳，Eureka将会注销该微服务节点</li><li>Eureka Client<strong>会缓存Eureka Server中的信息</strong>。即使所有的Eureka Server节点都宕掉，服务消费者依然可以使⽤缓存中的信息找到服务提供者</li></ol><p><strong>Eureka缓存</strong></p><blockquote><p>新服务上线后，服务消费者<strong>不能立即访问</strong>到刚上线的新服务，需要过⼀段时间后才能访问？或是将服务下线后，服务还是会被调⽤到，⼀段时候后<strong>才彻底停⽌服务</strong>，访问前期会导致频繁报错！</p></blockquote><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmaxmk97q0j30vw0j6gmu.jpg" alt="image-20210103233902439" style="zoom:50%;"></p><p>​    服务注册到注册中⼼后，服务实例信息是<strong>存储在Registry表</strong>中的，也就是内存中。但Eureka为了提⾼响应速度，在内部做了优化，加⼊了两层的缓存结构，将Client需要的实例信息，直接缓存起来，获取的时候直接从缓存中拿数据然后响应给 Client。 </p><ul><li><p>第⼀层缓存是<strong>readOnlyCacheMap</strong>，采⽤<strong>ConcurrentHashMap</strong>来存储数据的，主要负责定时与readWriteCacheMap进⾏数据同步，默认同步时间为 <strong>30</strong> 秒⼀次。</p></li><li><p>第⼆层缓存是<strong>readWriteCacheMap</strong>，采⽤<strong>Guava</strong>来实现缓存。缓存过期时间默认为<strong>180</strong>秒，当服务<strong>下线、过期、注册、状态变更</strong>等操作都会清除此缓存中的数据。</p></li><li><p>如果两级缓存都无法查询，会<strong>触发缓存的加载</strong>，从存储层拉取数据到缓存中，然后再返回给 Client。</p><p>Eureka之所以设计⼆级缓存机制，也是为了<strong>提⾼ Eureka Server 的响应速度</strong>，缺点是缓存会导致 Client<strong>获取不到最新的服务实例信息</strong>，然后导致⽆法快速发现新的服务和已下线的服务。</p></li></ul><p><strong>解决方案</strong></p><ul><li>我们可以<strong>缩短读缓存的更新时间</strong>让服务发现变得更加及时，或者<strong>直接将只读缓存关闭</strong>，同时可以缩短客户端如ribbon服务的定时刷新间隔，多级缓存也导致C层⾯（数据⼀致性）很薄弱。</li><li>Eureka Server 中会有<strong>定时任务去检测失效</strong>的服务，将服务实例信息从注册表中移除，也可以将这个失效检测的<strong>时间缩短</strong>，这样服务下线后就能够及时从注册表中清除。</li></ul><p><strong>自我保护机制开启条件</strong></p><ul><li>期望最小每分钟能够续租的次数（实例<em> 频率 </em> 比例==10<em> 2 </em>0.85）</li><li>期望的服务实例数量（10）</li></ul><p><strong>健康检查</strong></p><ul><li><p>Eureka Client 会定时发送心跳给 Eureka Server 来证明自己处于健康的状态</p></li><li><p>集成SBA以后可以把所有健康状态信息一并返回给eureka</p></li></ul><h4 id="Feign-Ribbon"><a href="#Feign-Ribbon" class="headerlink" title="Feign / Ribbon"></a>Feign / Ribbon</h4><ul><li>Feign 可以与 Eureka 和 Ribbon 组合使用以支持负载均衡，</li><li>Feign 可以与 Hystrix 组合使用，支持熔断回退</li><li>Feign 可以与ProtoBuf实现快速的RPC调用</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbxsh2rfnj30uo0fgmxz.jpg" alt="img" style="zoom:80%;"></p><ul><li><p><strong>InvocationHandlerFactory 代理</strong></p><p>采用 JDK 的动态代理方式生成代理对象，当我们调用这个接口，实际上是要去调用远程的 HTTP API</p></li><li><p><strong>Contract 契约组件</strong></p><p>比如请求类型是 GET 还是 POST，请求的 URI 是什么</p></li><li><p><strong>Encoder 编码组件 \ Decoder 解码组件</strong></p><p>通过该组件我们可以将请求信息采用指定的编码方式进行编解码后传输</p></li><li><p><strong>Logger 日志记录</strong></p><p>负责 Feign 中记录日志的，可以指定 Logger 的级别以及自定义日志的输出</p></li><li><p><strong>Client 请求执行组件</strong></p><p>负责 HTTP 请求执行的组件，Feign 中默认的 Client 是通过 JDK 的 HttpURLConnection 来发起请求的，在每次发送请求的时候，都会创建新的 HttpURLConnection 链接，Feign 的性能会很差，可以通过扩展该接口，使用 Apache HttpClient 等基于连接池的高性能 HTTP 客户端。</p></li><li><p><strong>Retryer 重试组件</strong></p><p>负责重试的组件，Feign 内置了重试器，当 HTTP 请求出现 IO 异常时，Feign 会限定一个最大重试次数来进行重试操作。</p></li><li><p><strong>RequestInterceptor 请求拦截器</strong></p><p>可以为 Feign 添加多个拦截器，在请求执行前设置一些扩展的参数信息。</p></li></ul><p><strong>Feign最佳使用技巧</strong></p><ul><li><p>继承特性</p></li><li><p>拦截器</p><p>比如添加指定的请求头信息，这个可以用在服务间传递某些信息的时候。</p></li><li><p>GET 请求多参数传递</p></li><li><p>日志配置</p><p>FULL 会输出全部完整的请求信息。</p></li><li><p>异常解码器</p><p>异常解码器中可以获取异常信息，而不是简单的一个code，然后转换成对应的异常对象返回。</p></li><li><p>源码查看是如何继承Hystrix</p><p>HystrixFeign.builder 中可以看到继承了 Feign 的 Builder，增加了 Hystrix的SetterFactory， build 方法里，对 invocationHandlerFactory 进行了重写， create 的时候<strong>返回HystrixInvocationHandler</strong>， 在 invoke 的时候<strong>会将请求包装成 HystrixCommand</strong> 去执行，这里就自然的集成了 Hystrix</p></li></ul><p><strong>Ribbon</strong></p><p><img src="http://s0.lgstatic.com/i/image2/M01/93/96/CgotOV2Nux-AO2PcAAEcl4M1Zi4629.png" alt="img" style="zoom: 50%;"></p><p><strong>使用方式</strong></p><ul><li><p><strong>原生 API</strong>，Ribbon 是 Netflix 开源的，没有使用 Spring Cloud，需要使用 Ribbon 的原生 API。</p></li><li><p><strong>Ribbon + RestTemplate</strong>，整合Spring Cloud 后，可以基于 RestTemplate 提供负载均衡的服务</p></li><li><p><strong>Ribbon + Feign</strong></p><p><img src="http://s0.lgstatic.com/i/image2/M01/93/76/CgoB5l2NuyCALoefAAAdV1DlSHY088.png" alt="img" style="zoom: 67%;"></p></li></ul><p><strong>负载均衡算法</strong></p><ul><li><p>RoundRobinRule 是<strong>轮询的算法</strong>，A和B轮流选择。</p></li><li><p>RandomRule 是<strong>随机算法</strong>，这个就比较简单了，在服务列表中随机选取。</p></li><li><p>BestAvailableRule 选择一个最<strong>小的并发请求 server</strong></p></li></ul><p><strong>自定义负载均衡算法</strong></p><ul><li>实现 Irule 接口</li><li>继承 AbstractLoadBalancerRule 类</li></ul><p><strong>自定义负载均衡使用场景</strong>（核心）</p><ul><li><p><strong>灰度发布</strong></p><p>灰度发布是能够平滑过渡的一种发布方式，在发布过程中，先发布一部分应用，让指定的用户使用刚发布的应用，等到测试没有问题后，再将其他的全部应用发布。如果新发布的有问题，只需要将这部分恢复即可，不用恢复所有的应用。</p></li><li><p><strong>多版本隔离</strong></p><p>多版本隔离跟灰度发布类似，为了兼容或者过度，某些应用会有多个版本，这个时候如何保证 1.0 版本的客户端不会调用到 1.1 版本的服务，就是我们需要考虑的问题。</p></li><li><p><strong>故障隔离</strong></p><p>当线上某个实例发生故障后，为了不影响用户，我们一般都会先留存证据，比如：线程信息、JVM 信息等，然后将这个实例重启或直接停止。然后线下根据一些信息分析故障原因，如果我能做到故障隔离，就可以直接将出问题的实例隔离，不让正常的用户请求访问到这个出问题的实例，只让指定的用户访问，这样就可以单独用特定的用户来对这个出问题的实例进行测试、故障分析等。</p></li></ul><h4 id="Hystrix-Sentinel"><a href="#Hystrix-Sentinel" class="headerlink" title="Hystrix / Sentinel"></a>Hystrix / Sentinel</h4><p><strong>服务雪崩场景</strong></p><p>自己即是服务消费者，同时也是服务提供者，同步调用等待结果导致资源耗尽</p><p><strong>解决方案</strong></p><p>服务方：扩容、限流，排查代码问题，增加硬件监控</p><p>消费方：使用Hystrix资源隔离，熔断降级，快速失败</p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmby7y9ykzj30wr0ehac5.jpg" alt="img" style="zoom:150%;"></p><p><strong>Hystrix断路保护器的作用</strong></p><ul><li><strong>封装请求</strong>会将用户的操作进行统一封装，统一封装的目的在于进行统一控制。</li><li><strong>资源隔离限流</strong>会将对应的资源按照指定的类型进行隔离，比如<strong>线程池</strong>和<strong>信号量</strong>。<ul><li>计数器限流，例如5秒内技术1000请求，超数后限流，未超数重新计数</li><li>滑动窗口限流，解决计数器不够精确的问题，把一个窗口拆分多滚动窗口</li><li>令牌桶限流，类似景区售票，售票的速度是固定的，拿到令牌才能去处理请求</li><li>漏桶限流，生产者消费者模型，实现了恒定速度处理请求，能够绝对防止突发流量</li></ul></li><li><strong>失败回退</strong>其实是一个备用的方案，就是说当请求失败后，有没有备用方案来满足这个请求的需求。</li><li><strong>断路器</strong>这个是<strong>最核心</strong>的，，如果断路器处于打开的状态，那么所有请求都将失败，执行回退逻辑。如果断路器处于关闭状态，那么请求将会被正常执行。有些场景我们需要手动<strong>打开断路器强制降级</strong>。</li><li><strong>指标监控</strong>会对请求的生<strong>命周期进行监控</strong>，请求成功、失败、超时、拒绝等状态，都会被监控起来。</li></ul><p><strong>Hystrix使用上遇到的坑</strong></p><ul><li><p>配置可以对接<strong>配置中心</strong>进行动态调整</p><p>Hystrix 的配置项非常多，如果不对接配置中心，所有的配置只能在代码里修改，在集群部署的难以应对紧急情况，我们项目只设置一个 CommandKey，其他的都在配置中心进行指定，紧急情况如需隔离部分请求时，只需在配置中心进行修改以后，强制更新即可。</p></li><li><p>回退逻辑中可以<strong>手动埋点</strong>或者通过<strong>输出日志</strong>进行告警</p><p>当请求失败或者超时，会执行回退逻辑，如果有大量的回退，则证明某些服务出问题了，这个时候我们可以在回退的逻辑中进行埋点操作，上报数据给监控系统，也可以输出回退的日志，统一由日志收集的程序去进行处理，这些方式都可以将问题暴露出去，然后通过实时数据分析进行告警操作</p></li><li><p>用 <strong>ThreadLocal</strong>配合<strong>线程池隔离</strong>模式需当心</p><p>当我们用了线程池隔离模式的时候，被隔离的方法会包装成一个 Command 丢入到独立的线程池中进行执行，这个时候就是从 A 线程切换到了 B 线程，ThreadLocal 的数据就会丢失</p></li><li><p><strong>Gateway中</strong>多用信号量隔离</p><p>网关是所有请求的入口，路由的服务数量会很多，几十个到上百个都有可能，如果用线程池隔离，那么需要创建上百个独立的线程池，开销太大，用信号量隔离开销就小很多，还能起到限流的作用。</p></li></ul><p>[^常见问题]: Hystrix的超时时间要⼤于Ribbon的超时时间，因为Hystrix将请求包装了起来，特别需要注意的是，如果Ribbon开启了重试机制，⽐如重试3 次，Ribbon 的超时为 1 秒，那么Hystrix 的超时时间应该⼤于 3 秒，否则就会出现 Ribbon 还在重试中，⽽ Hystrix 已经超时的现象。</p><p><strong>Sentinel</strong> </p><blockquote><p>Sentinel是⼀个⾯向云原⽣微服务的流量控制、熔断降级组件。</p><p>替代Hystrix，针对问题：服务雪崩、服务降级、服务熔断、服务限流</p></blockquote><p>Hystrix区别：</p><ul><li>独⽴可部署Dashboard（基于 Spring Boot 开发）控制台组件</li><li>不依赖任何框架/库，减少代码开发，通过UI界⾯配置即可完成细粒度控制</li></ul><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmbza4zixbj30kl09sq4p.jpg" alt="image-20210104212151598" style="zoom:80%;"></p><p><strong>丰富的应⽤场景</strong>：Sentinel 承接了阿⾥巴巴近 10 年的双⼗⼀⼤促流量的核⼼场景，例如秒杀、消息削峰填⾕、集群流量控制、实时熔断下游不可⽤应⽤等。</p><p><strong>完备的实时监控</strong>：可以看到500 台以下规模的集群的汇总也可以看到单机的秒级数据。</p><p><strong>⼴泛的开源⽣态：</strong>与 SpringCloud、Dubbo的整合。您只需要引⼊相应的依赖并进⾏简单的配置即可快速地接⼊ Sentinel。</p><p><strong>区别：</strong></p><ul><li>Sentinel不会像Hystrix那样放过⼀个请求尝试⾃我修复，就是明明确确按照时间窗⼝来，熔断触发后，时间窗⼝内拒绝请求，时间窗⼝后就恢复。</li><li>Sentinel Dashboard中添加的规则数据存储在内存，微服务停掉规则数据就消失，在⽣产环境下不合适。可以将Sentinel规则数据持久化到Nacos配置中⼼，让微服务从Nacos获取。</li></ul><table><thead><tr><th>#</th><th>Sentinel</th><th>Hystrix</th></tr></thead><tbody><tr><td>隔离策略</td><td>信号量隔离</td><td>线程池隔离/信号量隔离</td></tr><tr><td>熔断降级策略</td><td>基于响应时间或失败比率</td><td>基于失败比率</td></tr><tr><td>实时指标实现</td><td>滑动窗口</td><td>滑动窗口（基于 RxJava）</td></tr><tr><td>扩展性</td><td>多个扩展点</td><td>插件的形式</td></tr><tr><td>限流</td><td>基于 QPS，支持基于调用关系的限流</td><td>不支持</td></tr><tr><td>流量整形</td><td>支持慢启动、匀速器模式</td><td>不支持</td></tr><tr><td>系统负载保护</td><td>支持</td><td>不支持</td></tr><tr><td>控制台</td><td>开箱即用，可配置规则、查看秒级监控、机器发现等</td><td>不完善</td></tr><tr><td>常见框架的适配</td><td>Servlet、Spring Cloud、Dubbo、gRPC</td><td>Servlet、Spring Cloud Netflix</td></tr></tbody></table><h4 id="Config-Nacos"><a href="#Config-Nacos" class="headerlink" title="Config / Nacos"></a>Config / Nacos</h4><blockquote><p>Nacos是阿⾥巴巴开源的⼀个针对微服务架构中<strong>服务发现</strong>、<strong>配置管理</strong>和<strong>服务管理平台</strong>。</p><p>Nacos就是<strong>注册中⼼+配置中⼼</strong>的组合（Nacos=Eureka+Confifig+Bus）</p></blockquote><p><strong>Nacos</strong>功能特性</p><ul><li>服务发现与健康检查</li><li>动态配置管理</li><li>动态DNS服务</li><li>服务和元数据管理</li></ul><p><strong>保护阈值：</strong></p><p>当服务A健康实例数/总实例数 &lt; 保护阈值 的时候，说明健康实例真的不多了，这个时候保护阈值会被触发（状态true），nacos将会把该服务所有的实例信息（健康的+不健康的）全部提供给消费者，消费者可能访问到不健康的实例，请求失败，但这样也⽐造成雪崩要好，牺牲了⼀些请求，保证了整个系统的⼀个可⽤。</p><p><strong>Nacos</strong> 数据模型（领域模型）</p><ul><li><strong>Namespace</strong> 代表不同的环境，如开发dev、测试test、⽣产环境prod</li><li><strong>Group</strong> 代表某项⽬，⽐如爪哇云项⽬</li><li><strong>Service</strong> 某个项⽬中具体xxx服务</li><li><strong>DataId</strong> 某个项⽬中具体的xxx配置⽂件</li></ul><p>可以通过 Spring Cloud 原⽣注解 <code>@RefreshScope</code> 实现配置⾃动更新</p><h4 id="Bus-Stream"><a href="#Bus-Stream" class="headerlink" title="Bus / Stream"></a>Bus / Stream</h4><blockquote><p>Spring Cloud Stream 消息驱动组件帮助我们更快速，更⽅便的去构建<strong>消息驱动</strong>微服务的</p><p>本质：屏蔽掉了底层不同<strong>MQ</strong>消息中间件之间的差异，统⼀了<strong>MQ</strong>的编程模型，降低了学习、开发、维护<strong>MQ</strong>的成本，⽬前⽀持Rabbit、Kafka两种消息</p></blockquote><h4 id="Sleuth-Zipkin"><a href="#Sleuth-Zipkin" class="headerlink" title="Sleuth / Zipkin"></a><strong>Sleuth / Zipkin</strong></h4><p><strong>全链路追踪</strong></p><p><img src="https://tva1.sinaimg.cn/large/0081Kckwly1gmc3avezqrj30xb0lw76z.jpg" alt="image-20210104234058218" style="zoom:67%;"></p><p><strong>Trace ID</strong>：当请求发送到分布式系统的⼊⼝端点时，Sleuth为该请求创建⼀个唯⼀的跟踪标识Trace ID，在分布式系统内部流转的时候，框架始终保持该唯⼀标识，直到返回给请求⽅</p><p><strong>Span ID</strong>：为了统计各处理单元的时间延迟，当请求到达各个服务组件时，也是通过⼀个唯⼀标识SpanID来标记它的开始，具体过程以及结束。</p><p>Spring Cloud Sleuth （追踪服务框架）可以追踪服务之间的调⽤，Sleuth可以记录⼀个服务请求经过哪些服务、服务处理时⻓等，根据这些，我们能够理清各微服务间的调⽤关系及进⾏问题追踪分析。</p><p><strong>耗时分析</strong>：通过 Sleuth 了解采样请求的耗时，分析服务性能问题（哪些服务调⽤⽐较耗时）</p><p><strong>链路优化</strong>：发现频繁调⽤的服务，针对性优化等</p><p><strong>聚合展示</strong>：数据信息发送给 Zipkin 进⾏聚合，利⽤ Zipkin 存储并展示数据。</p><h3 id="安全认证"><a href="#安全认证" class="headerlink" title="安全认证"></a><strong>安全认证</strong></h3><ul><li><p>Session</p><p>认证中最常用的一种方式，也是最简单的。存在<strong>多节点session丢失</strong>的情况，可通过<strong>nginx粘性Cookie</strong>和Redis集中式Session存储解决</p></li><li><p>HTTP Basic Authentication </p><p>服务端针对请求头中base64加密的Authorization 和用户名和密码进行<strong>校验</strong>。</p></li><li><p>Token</p><p>Session 只是一个 key，<strong>会话信息存储在后端</strong>。而 Token 中会存储用户的信息，然后通过加密算法进行加密，只有服务端才能解密，<strong>服务端拿到 Token 后进行解密获取用户信息</strong>。</p></li><li><p>JWT认证</p></li></ul><blockquote><p>JWT（JSON Web Token）用户提供用户名和密码给认证服务器，服务器验证用户提交信息的合法性；如果验证成功，会产生并返回一个 Token，用户可以使用这个 Token 访问服务器上受保护的资源。</p></blockquote><p><img src="http://s0.lgstatic.com/i/image2/M01/AB/87/CgotOV3WUG2ARl98AAD_xcd-ElM857.png" alt="img" style="zoom:70%;"></p><ol><li>认证服务提供认证的 API，校验用户信息，返回认证结果</li><li>通过JWTUtils中的RSA算法，生成JWT token，token里封装用户id和有效期</li><li>服务间参数通过请求头进行传递，服务内部通过 ThreadLocal 进行上下文传递。</li><li>Hystrix导致ThreadLocal失效的问题可以通过，重写 Hystrix 的 Callable 方法，传递需要的数据。</li></ol><p><strong>Token最佳实践</strong></p><ul><li><p>设置<strong>较短（合理）的过期时间</strong>。</p></li><li><p>注销的 Token <strong>及时清除</strong>（放入 Redis 中做一层过滤）。</p><p>虽然不能修改 Token 的信息，但是能在验证层面做一层过滤来进行处理。</p></li><li><p>监控 Token 的<strong>使用频率</strong>。</p><p>为了防止数据被别人爬取，最常见的就是监控使用频率，程序写出来的爬虫程序访问频率是有迹可循的 </p></li><li><p>核心功能敏感操作可以使用<strong>动态验证</strong>（验证码）。</p><p>比如提现的功能，要求在提现时再次进行验证码的验证，防止不是本人操作。</p></li><li><p><strong>网络环境、浏览器</strong>信息等识别。</p><p>银行 APP 对环境有很高的要求，使用时如果断网，APP 会自动退出，重新登录，因为网络环境跟之前使用的不一样了，还有一些浏览器的信息之类的判断，这些都是可以用来保证后端 API 的安全。</p></li><li><p><strong>加密密钥</strong>支持动态修改。</p><p>如果 Token 的加密密钥泄露了，也就意味着别人可以伪造你的 Token，可以将密钥存储在配置中心，以支持动态修改刷新，需要注意的是建议在流量低峰的时候去做更换的操作，否则 Token 全部失效，所有在线的请求都会重新申请 Token，并发量会比较大。</p></li></ul><h3 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h3><p><strong>痛点：</strong></p><ul><li><p>服务数量多，业务变动频繁，一周一发布</p></li><li><p>灰度发布能降低发布失败风险，<strong>减少影响范围</strong></p><p>通过灰度发布，先让一部分用户体验新的服务，或者只让测试人员进行测试，等功能正常后再全部发布，这样能降低发布失败带来的影响范围。 </p></li><li><p>当发布出现故障时，可以<strong>快速回滚</strong>，不影响用户</p><p>灰度后如果发现这个节点有问题，那么只需回滚这个节点即可，当然不回滚也没关系，通过灰度策略隔离，也不会影响正常用户</p></li></ul><p>可以通过Ribbon的负载均衡策略进行灰度发布，可以使用更可靠的Discovery</p><p><strong>Discovery</strong></p><blockquote><p>基于Discovery 服务注册发现、Ribbon 负载均衡、Feign 和 RestTemplate 调用等组件的企业级微服务开源解决方案，包括灰度发布、灰度路由、服务隔离等功能</p></blockquote><p><img src="https://s0.lgstatic.com/i/image3/M01/54/41/CgpOIF3nXSaAB9bRAAE8rktrUyY037.png" alt="img" style="zoom:50%;"></p><ol><li><p>首先将需要发布的服务从转发过程中移除，等流量剔除之后再发布。</p></li><li><p>部分机器中的版本进行升级，用户默认还是请求老的服务，通过版本来支持测试请求。</p></li><li><p>测试完成之后，让新的版本接收正常流量，然后部署下一个节点，以此类推。</p></li></ol><pre class=" language-java"><code class="language-java">grayVersions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"discovery-article-service"</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token string">"1.01"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="多版本隔离"><a href="#多版本隔离" class="headerlink" title="多版本隔离"></a>多版本隔离</h3><p><img src="https://s0.lgstatic.com/i/image3/M01/54/41/Cgq2xl3nXSeAZMTOAAE2sCaIhPE668.png" alt="img" style="zoom:50%;"></p><p><strong>本地复用测试服务</strong>-Eureka Zone亮点</p><p>​    <strong>region</strong> 地理上的分区，比如北京、上海等</p><p>​    <strong>zone</strong> 可以简单理解为 region 内的具体机房</p><p>​    在调用的过程中会优先选择相同的 zone 发起调用，当找不到相同名称的 zone 时会选择其他的 zone 进行调用，我们可以利用这个特性来解决本地需要启动多个服务的问题。</p><p>[^]: 当你访问修改的服务 A 时，这个服务依赖了 B、C 两个服务，B 和 C 本地没有启动，B 和 C 找不到相同的 zone 就会选择其他的 zone 进行调用，也就是会调用到测试环境部署的 B 和 C 服务，这样一来就解决了本地部署多个服务的问题。</p><h4 id="各组件调优"><a href="#各组件调优" class="headerlink" title="各组件调优"></a><strong>各组件调优</strong></h4><p>当你对网关进行压测时，会发现并发量一直上不去，错误率也很高。因为你用的是默认配置，这个时候我们就需要去调整配置以达到最优的效果。</p><p>首先我们可以对容器进行调优，最常见的就是<strong>内置的 Tomcat</strong> 容器了，</p><pre class=" language-java"><code class="language-java">server<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>accept<span class="token operator">-</span>count <span class="token comment" spellcheck="true">//请求队列排队数</span>server<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>max<span class="token operator">-</span>threads <span class="token comment" spellcheck="true">//最大线程数</span>server<span class="token punctuation">.</span>tomcat<span class="token punctuation">.</span>max<span class="token operator">-</span>connections <span class="token comment" spellcheck="true">//最大连接数</span></code></pre><p><strong>Hystrix</strong> 的信号量（semaphore）隔离模式，并发量上不去很大的原因都在这里，信号量默认值是 100，也就是最大并发只有 100，超过 100 就得等待。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//信号量</span>zuul<span class="token punctuation">.</span>semaphore<span class="token punctuation">.</span>max<span class="token operator">-</span>semaphores <span class="token comment" spellcheck="true">//信号量：最大并发数</span><span class="token comment" spellcheck="true">//线程池</span>hystrix<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>coreSize <span class="token comment" spellcheck="true">//最大线程数</span>hystrix<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>maximumSize <span class="token comment" spellcheck="true">//队列的大</span>hystrix<span class="token punctuation">.</span>threadpool<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span>maxQueueSize <span class="token comment" spellcheck="true">//等参数</span></code></pre><p>配置<strong>Gateway</strong>并发信息，</p><pre class=" language-java"><code class="language-java">gateway<span class="token punctuation">.</span>host<span class="token punctuation">.</span>max<span class="token operator">-</span>per<span class="token operator">-</span>route<span class="token operator">-</span>connections <span class="token comment" spellcheck="true">//每个路由的连接数 </span>gateway<span class="token punctuation">.</span>host<span class="token punctuation">.</span>max<span class="token operator">-</span>total<span class="token operator">-</span>connections <span class="token comment" spellcheck="true">//总连接数</span></code></pre><p>调整<strong>Ribbon</strong> 的并发配置，</p><pre class=" language-java"><code class="language-java">ribbon<span class="token punctuation">.</span>MaxConnectionsPerHost <span class="token comment" spellcheck="true">//单服务并发数</span>ribbon<span class="token punctuation">.</span>MaxTotalConnections   <span class="token comment" spellcheck="true">//总并发数</span></code></pre><p>修改<strong>Feign</strong>默认的HttpURLConnection 替换成 httpclient 来提高性能</p><pre class=" language-java"><code class="language-java">feign<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>max<span class="token operator">-</span>connections<span class="token operator">-</span>per<span class="token operator">-</span>route<span class="token comment" spellcheck="true">//每个路由的连接数</span>feign<span class="token punctuation">.</span>httpclient<span class="token punctuation">.</span>max<span class="token operator">-</span>connections <span class="token comment" spellcheck="true">//总连接数</span></code></pre><p>Gateway+配置中心实现动态路由</p><p>Feign+配置中心实现动态日志</p><h1 id="九、分布式篇"><a href="#九、分布式篇" class="headerlink" title="九、分布式篇"></a><strong>九、分布式篇</strong></h1><blockquote><p>分布式系统是一个硬件或软件组件分布在不同的网络计算机上，彼此之间仅仅通过消息传递进行通信和协调的系统。</p></blockquote><h3 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a><strong>发展历程</strong></h3><ul><li>入口级负载均衡<ul><li>网关负载均衡</li><li>客户端负载均衡</li></ul></li><li><p>单应用架构</p><ul><li>应用服务和数据服务分离</li><li>应用服务集群</li><li>应用服务中心化SAAS</li></ul></li><li><p>数据库主备读写分离</p><ul><li>全文搜索引擎加快数据统计</li><li>缓存集群缓解数据库读压力</li><li>分布式消息中间件缓解数据库写压力</li><li>数据库水平拆分适应微服务</li><li>数据库垂直拆分解决慢查询</li></ul></li><li><p>划分上下文拆分微服务</p><ul><li>服务注册发现（Eureka、Nacos）</li><li>配置动态更新（Config、Apollo）</li><li>业务灰度发布（Gateway、Feign）</li><li>统一安全认证（Gateway、Auth）</li><li>服务降级限流（Hystrix、Sentinel）</li><li>接口检查监控（Actuator、Prometheus）</li><li>服务全链路追踪（Sleuth、Zipkin）</li></ul></li></ul><h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><ul><li><strong>一致性</strong>（2PC、3PC、Paxos、Raft）<ul><li>强一致性：<strong>数据库一致性</strong>，牺牲了性能<ul><li><strong>ACID</strong>：原子性、一致性、隔离性、持久性</li></ul></li><li>弱一致性：<strong>数据库和缓存</strong>，<strong>延迟双删、重试</strong></li><li>单调读一致性：<strong>缓存一致性</strong>，ID或者IP哈希</li><li>最终一致性：<strong>边缘业务</strong>，消息队列</li></ul></li><li><strong>可用性</strong>（多级缓存、读写分离）<ul><li><strong>BASE</strong> 基本可用：限流导致响应速度慢、降级导致用户体验差<ul><li>Basically Availabe 基本可用  </li><li>Soft state 软状态</li><li>Eventual Consistency 最终一致性</li></ul></li></ul></li><li>分区容忍性（一致性Hash解决扩缩容问题）</li></ul><h3 id="一致性-1"><a href="#一致性-1" class="headerlink" title="一致性"></a>一致性</h3><h4 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>2PC</strong>协议：两阶段提交协议，P是指<strong>准备</strong>阶段，C是指<strong>提交</strong>阶段</p><ul><li>准备阶段：询问是否可以开始，写Undo、Redo日志，收到响应</li><li>提交阶段：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong> </li></ul><p><strong>3PC</strong>协议：将提交阶段分为<strong>CanCommit</strong>、<strong>PreCommit</strong>、<strong>DoCommit</strong>三个阶段</p><p><strong>CanCommit</strong>：发送canCommit请求，并开始等待</p><p><strong>PreCommit</strong>：收到全部Yes，写Undo、Redo日志。超时或者No，则中断</p><p><strong>DoCommit</strong>：执行Redo日志进行<strong>Commit</strong>，执行Undo日志进行<strong>Rollback</strong> </p><p>区别是第二步，参与者<strong>自身增加了超时</strong>，如果<strong>失败可以及时释放资源</strong></p><h4 id="Paxos算法"><a href="#Paxos算法" class="headerlink" title="Paxos算法"></a><strong>Paxos算法</strong></h4><blockquote><p>如何在一个发生异常的分布式系统中，快速且正确地在集群内部对某个数据的值达成一致</p></blockquote><p>​    参与者（例如Kafka）的一致性可以由协调者（例如Zookeeper）来保证，<strong>协调者的一致性就只能由Paxos保证了</strong></p><p>Paxos算法中的角色：</p><ul><li><strong>Client</strong>：客户端、例如，对分布式文件服务器中文件的写请求。</li><li><strong>Proposer</strong>：提案发起者，根据Accept返回选择最大N对应的V，发送[N+1,V]</li><li><strong>Acceptor</strong>：决策者，Accept以后会拒绝小于N的提案，并把自己的[N,V]返回给Proposer</li><li><strong>Learners</strong>：最终决策的学习者、学习者充当该协议的复制因素</li></ul><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//算法约束</span>P1<span class="token operator">:</span>一个Acceptor必须接受它收到的第一个提案。<span class="token comment" spellcheck="true">//考虑到半数以上才作数，一个Accpter得接受多个相同v的提案</span>P2a<span class="token operator">:</span>如果某个v的提案被accept，那么被Acceptor接受编号更高的提案必须也是vP2b<span class="token operator">:</span>如果某个v的提案被accept，那么从Proposal提出编号更高的提案必须也是v<span class="token comment" spellcheck="true">//如何确保v的提案Accpter被选定后，Proposal都能提出编号更高的提案呢</span>针对任意的<span class="token punctuation">[</span>Mid<span class="token punctuation">,</span>Vid<span class="token punctuation">]</span>，有半数以上的Accepter集合S，满足以下二选一：  S中接受的提案都大于Mid  S中接受的提案若小于Mid，编号最大的那个值为Vid</code></pre><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmlato63bnj319m0u0wmi.jpg" alt="image-20210112225118095"></p><p>面试题：如何保证Paxos算法活性</p><p>​    假设存在这样一种极端情况，有两个Proposer依次提出了一系列编号递增的提案，导致最终陷入死循环，没有value被选定</p><ul><li><strong>通过选取主Proposer</strong>，规定只有主Proposer才能提出议案。只要主Proposer和过半的Acceptor能够正常网络通信，主Proposer提出一个编号更高的提案，该提案终将会被批准。</li><li>每个Proposer发送提交提案的时间设置为<strong>一段时间内随机</strong>，保证不会一直死循环</li></ul><h4 id="ZAB算法"><a href="#ZAB算法" class="headerlink" title="ZAB算法"></a><strong>ZAB算法</strong></h4><h4 id="Raft算法"><a href="#Raft算法" class="headerlink" title="Raft算法"></a>Raft算法</h4><blockquote><p>Raft 是一种为了管理复制日志的一致性算法</p></blockquote><p>Raft使用<strong>心跳机制</strong>来触发选举。当server启动时，初始状态都是<strong>follower</strong>。每一个server都有一个定时器，超时时间为election timeout（<strong>一般为150-300ms</strong>），如果某server<strong>没有超时的情况下收到</strong>来自领导者或者候选者的任何消息，<strong>定时器重启</strong>，如果超时，它就<strong>开始一次选举</strong>。</p><p><strong>Leader异常</strong>：异常期间Follower会超时选举，完成后Leader比较彼此步长</p><p><strong>Follower异常：</strong>恢复后直接同步至Leader当前状态</p><p><strong>多个Candidate：</strong>选举时失败，失败后超时继续选举</p><h4 id="数据库和Redis的一致性"><a href="#数据库和Redis的一致性" class="headerlink" title="数据库和Redis的一致性"></a>数据库和Redis的一致性</h4><p><strong>全量缓存保证高效读取</strong></p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u2g0qkvj31500la0uf.jpg" alt="image-20211205121457205" style="zoom: 50%;"></p><p>所有数据都存储在缓存里，读服务在查询时不会再降级到数据库里，所有的请求都完全依赖缓存。此时，因降级到数据库导致的毛刺问题就解决了。但全量缓存并<strong>没有解决更新时的分布式事务</strong>问题，反而把问题放大了。因为全量缓存<strong>对数据更新要求更加严格</strong>，要求所有数据库<strong>已有数据和实时更新</strong>的数据必须完全同步至缓存，不能有遗漏。对于此问题，一种有效的方案是采用<strong>订阅数据库的 Binlog</strong> 实现数据同步</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u9jj094j31c60padiu.jpg" alt="image-20211205121611997" style="zoom:50%;"></p><p>​    现在很多开源工具（如<strong>阿里的 Canal</strong>等）可以模拟主从复制的协议。通过模拟协议读取主数据库的 Binlog 文件，从而获取主库的所有变更。对于这些变更，它们开放了各种接口供业务服务获取数据。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ugzh9ohj31hc0g00ud.jpg" alt="image-20211205121730145" style="zoom:50%;"></p><p>​    将 Binlog 的中间件挂载至目标数据库上，就可以<strong>实时获取该数据库的所有变更数据</strong>。对这些变更数据解析后，便可<strong>直接写入缓存里</strong>。优点还有：</p><ul><li><p>大幅提升了读取的速度，降低了延迟</p></li><li><p>Binlog 的主从复制是基于 <strong>ACK</strong> 机制， 解决了分布式事务的问题</p><p>如果同步缓存失败了，被消费的 Binlog 不会被确认，下一次会重复消费，数据最终会写入缓存中</p></li></ul><p><strong>缺点</strong>不可避免：1、增加复杂度 2、消耗缓存资源 3、需要筛选和压缩数据 4、极端情况数据丢失</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2u6ltwa4j314s0hs765.jpg" alt="image-20211205121850418" style="zoom:50%;"></p><p>可以通过异步校准方案进行补齐，但是会损耗数据库性能。但是此方案会隐藏中间件使用错误的细节，线上环境前期更重要的是记录日志排查在做后续优化，不能本末倒置。</p><h3 id="可用性-1"><a href="#可用性-1" class="headerlink" title="可用性"></a>可用性</h3><h4 id="心跳检测"><a href="#心跳检测" class="headerlink" title="心跳检测"></a><strong>心跳检测</strong></h4><blockquote><p>以<strong>固定的频率</strong>向其他节点汇报当前节点状态的方式。收到心跳，说明网络和节点的状态是健康的。心跳汇报时，一般会携带一些附加的<strong>状态、元数据，以便管理</strong></p></blockquote><p><strong>周期检测心跳机制</strong>：超时未返回</p><p><strong>累计失效检测机制</strong>：重试超次数</p><h4 id="多机房实时热备"><a href="#多机房实时热备" class="headerlink" title="多机房实时热备"></a><strong>多机房实时热备</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gx2ufbmlkmj31fw0mutc1.jpg" alt="image-20211205122631299" style="zoom:50%;"></p><p>两套缓存集群可以分别部署到不同城市的机房。读服务也相应地部署到不同城市或不同分区。在承接请求时，不同机房或分区的读服务只依赖同样属性的缓存集群。此方案有两个好处。</p><ol><li><strong>提升了性能。</strong>读服务不要分层，读服务要尽可能地和缓存数据源靠近。</li><li><strong>增加了可用。</strong>当单机房出现故障时，可以秒级将所有流量都切换至存活的机房或分区</li></ol><p>此方案虽然带来了性能和可用性的提升，但代价是资源成本的上升。</p><h3 id="分区容错性"><a href="#分区容错性" class="headerlink" title="分区容错性"></a>分区容错性</h3><blockquote><p>分布式系统对于错误包容的能力</p></blockquote><p>通过限流、降级、兜底、重试、负载均衡等方式增强系统的健壮性</p><h4 id="日志复制"><a href="#日志复制" class="headerlink" title="日志复制"></a>日志复制</h4><p><img src="https://i.loli.net/2021/01/14/fmYEJy9N7Zjp2Xd.png" alt="image-20210114154435003"></p><ol><li><strong>Leader</strong>把指令添加到日志中，发起 RPC 给其他的服务器，让他们复制这条信息</li><li><strong>Leader</strong>会不断的重试，直到所有的 Follower响应了ACK并复制了所有的日志条目</li><li>通知所有的<strong>Follower</strong>提交，同时Leader该表这条日志的状态，并返回给客户端</li></ol><h4 id="主备（Master-Slave）"><a href="#主备（Master-Slave）" class="headerlink" title="主备（Master-Slave）"></a><strong>主备（Master-Slave）</strong></h4><p>​    主机宕机时，备机接管主机的一切工作，主机恢复正常后，以自动（<strong>热备</strong>）或手动（<strong>冷备</strong>）方式将服务切换到主机上运行，<strong>Mysql</strong>和<strong>Redis</strong>中常用。</p><p>​    MySQL之间数据复制的基础是<strong>二进制日志文件</strong>（binary log fifile）。它的数据库中所有操作都会以<strong>“事件”</strong>的方式记录在二进制日志中，其他数据库作为slave通过一个<strong>I/O线程与主服务器保持通信</strong>，并<strong>监控</strong>master的二进制日志文件的变化，如果发现master二进制日志文件<strong>发生变化</strong>，则会把变化复制到自己的<strong>中继日志</strong>中，然后slave的一个SQL线程会把相关的“事件”<strong>执行</strong>到自己的数据库中，以此实现从数据库和主数据库的<strong>一致性</strong>，也就实现了<strong>主从复制</strong></p><h4 id="互备（Active-Active）"><a href="#互备（Active-Active）" class="headerlink" title="互备（Active-Active）"></a><strong>互备（Active-Active）</strong></h4><p>​    指两台主机<strong>同时运行</strong>各自的服务工作且<strong>相互监测</strong>情况。在数据库高可用部分，常见的互备是<strong>MM</strong>模式。MM模式即<strong>Multi-Master</strong>模式，指一个系统存在多个master，每个master都具有<strong>read-write</strong>能力，会根据<strong>时间戳</strong>或<strong>业务逻辑</strong>合并版本。</p><h4 id="集群（Cluster）模式"><a href="#集群（Cluster）模式" class="headerlink" title="集群（Cluster）模式"></a><strong>集群（Cluster）模式</strong></h4><p>​    是指有多个节点在运行，同时可以通过主控节点<strong>分担服务</strong>请求。如Zookeeper。集群模式需要解决主控节点<strong>本身的高可用</strong>问题，一般采用主备模式。</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><h4 id="XA方案-1"><a href="#XA方案-1" class="headerlink" title="XA方案"></a>XA方案</h4><p><strong>两阶段提交</strong> | <strong>三阶段提交</strong></p><ul><li>准备阶段的资源锁定，存在性能问题，严重时会造成死锁问题</li><li>提交事务请求后，出现网络异常，部分数据收到并执行，会造成一致性问</li></ul><h4 id="TCC方案"><a href="#TCC方案" class="headerlink" title="TCC方案"></a>TCC方案</h4><p><strong>Try Confirm Cancel / 短事务</strong></p><ul><li><p><strong>Try</strong> 阶段：这个阶段说的是对各个服务的资源做检测以及对资源进行<strong>锁定或者预留</strong></p></li><li><p><strong>Confirm</strong> 阶段：这个阶段说的是在各个服务中<strong>执行实际的操作</strong></p></li><li><p><strong>Cancel</strong> 阶段：如果任何一个服务的业务方法执行出错，那么就需要<strong>进行补偿</strong>/回滚</p></li></ul><h4 id="Saga方案"><a href="#Saga方案" class="headerlink" title="Saga方案"></a><strong>Saga方案</strong></h4><p>事务性补偿 / 长事务</p><ul><li>流程<strong>长</strong>、流程<strong>多</strong>、调用第三方业务</li></ul><h4 id="本地消息表（eBay）"><a href="#本地消息表（eBay）" class="headerlink" title="本地消息表（eBay）"></a><strong>本地消息表（eBay）</strong></h4><h4 id="MQ最终一致性"><a href="#MQ最终一致性" class="headerlink" title="MQ最终一致性"></a><strong>MQ最终一致性</strong></h4><p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gmr1k3dfbxj31h00pkjy8.jpg" alt="image-20210117220405706" style="zoom:50%;"></p><p>比如阿里的 RocketMQ 就支持消息事务（核心：<strong>双端确认，重试幂等</strong>）</p><ol><li>A<strong>(订单)</strong> 系统先发送一个 <strong>prepared</strong> 消息到 mq，prepared 消息发送失败则取消操作不执行了</li><li>发送成功后，那么执行本地事务，执行成功和和失败发送<strong>确认和回滚</strong>消息到mq</li><li>如果发送了确认消息，那么此时 B<strong>(仓储)</strong> 系统会接收到确认消息，然后执行本地的事务</li><li>mq 会自动<strong>定时轮询</strong>所有 prepared 消息回调的接口，确认事务执行状态</li><li>B 的事务失败后自动<strong>不断重试</strong>直到成功，达到一定次数后发送报警由人工来<strong>手工回滚</strong>和<strong>补偿</strong></li></ol><h4 id="最大努力通知方案（订单-gt-积分）"><a href="#最大努力通知方案（订单-gt-积分）" class="headerlink" title="最大努力通知方案（订单 -&gt; 积分）"></a>最大努力通知方案（订单 -&gt; 积分）</h4><ol><li>系统 A 本地事务执行完之后，发送个消息到 MQ；</li><li>这里会有个专门消费 MQ 的<strong>最大努力通知服务</strong>，接着调用系统 B 的接口；</li><li>要是系统 B 执行失败了，就定时尝试重新调用系统 B，<strong>反复 N 次</strong>，最后还是不行就<strong>放弃</strong></li></ol><p>你找一个严格<strong>资金</strong>要求绝对不能错的场景，你可以说你是用的 <strong>TCC 方案</strong>；</p><p>如果是一般的分布式事务场景，例如<strong>积分</strong>数据，可以用可靠消息<strong>最终一致性方案</strong></p><p>如果分布式场景<strong>允许不一致</strong>，可以使用最大努力通知方案</p><h3 id="面试题-3"><a href="#面试题-3" class="headerlink" title="面试题"></a>面试题</h3><h4 id="分布式Session实现方案"><a href="#分布式Session实现方案" class="headerlink" title="分布式Session实现方案"></a>分布式Session实现方案</h4><ul><li>基于JWT的Token，数据从cache或者数据库中获取</li><li>基于Tomcat的Redis，简单配置conf文件</li><li>基于Spring的Redis，支持SpringCloud和Springb</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClickHose原理解析与应用实践</title>
      <link href="/2021/12/18/ClickHose%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/"/>
      <url>/2021/12/18/ClickHose%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90%E4%B8%8E%E5%BA%94%E7%94%A8%E5%AE%9E%E8%B7%B5/</url>
      
        <content type="html"><![CDATA[<h3 id="ClickHouse的架构概述"><a href="#ClickHouse的架构概述" class="headerlink" title="ClickHouse的架构概述"></a>ClickHouse的架构概述</h3><h4 id="ClickHouse的核心特性"><a href="#ClickHouse的核心特性" class="headerlink" title="ClickHouse的核心特性"></a>ClickHouse的核心特性</h4><h5 id="完备的DBMS功能"><a href="#完备的DBMS功能" class="headerlink" title="完备的DBMS功能"></a><strong>完备的DBMS功能</strong></h5><p>ClickHouse拥有完备的管理功能，所以它称得上是一个 DBMS（Database Management System，数据库管理系统）</p><ul><li>DDL ：可以动态地创建、修改或删除数据库、 表和视图，而无须重启服务。</li><li>DML：可以动态查询、插入、修改或删除数 据。</li><li>权限控制：可以按照用户粒度设置数据库或者表的操作权限，保 障数据的安全性。</li><li>数据备份与恢复：提供了数据备份导出与导入恢复机制，满足生 产环境的要求。</li><li>分布式管理：提供集群模式，能够自动管理多个数据库节点。</li></ul><h5 id="分布式存储与数据压缩"><a href="#分布式存储与数据压缩" class="headerlink" title="分布式存储与数据压缩"></a><strong>分布式存储与数据压缩</strong></h5><p>列式存储与按行存储相比，可以有效地减少查询时所需扫描地数据量，按列存储地另外一个优势是对数据压缩的友好性，列式存储是数据压缩地前提,列与列之间由不同的文件分别保存(这里主要指MergeTree表引擎)，数据默认使用LZ4算法压缩。</p><p>数据压缩示例：</p><pre class=" language-java"><code class="language-java">压缩前：abcdefghi_bcdefghi压缩后：<span class="token function">abcdefghi_</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span></code></pre><h5 id="向量化执行引擎"><a href="#向量化执行引擎" class="headerlink" title="向量化执行引擎"></a><strong>向量化执行引擎</strong></h5><p>向量化执行，可以简单地看作一项消除程序中循环的优化,为了实现向量化执行，需要利用CPU的SIMD指令。SIMD的全称是 Single Instruction Multiple Data。即用单条指令操作多条数据，通过数据并行提高性能的一种实现方式，它的原理是在CPU寄存器层面实现 数据的并行操作。</p><p>存储媒介距离CPU越近，访问速度越快，使用CPU向量化执行的特性，对程序的性能提升很大，ClickHouse目前利用SSE4.2指令集实现向量化执行。</p><p><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/uTools_1639818902027.png" alt></p><h5 id="关系模型与SQL查询"><a href="#关系模型与SQL查询" class="headerlink" title="关系模型与SQL查询"></a><strong>关系模型与SQL查询</strong></h5><p>ClickHouse使用关系模型 描述数据并提供了传统数据库的概念（数据库、表、视图和函数 等）完全使用SQL作为查询语言，SQL大小写敏感。</p><h5 id="多样化的表引擎"><a href="#多样化的表引擎" class="headerlink" title="多样化的表引擎"></a>多样化的表引擎</h5><p>ClickHouse使用关系模型 描述数据并提供了传统数据库的概念（数据库、表、视图和函数 等），，ClickHouse 共拥有合并树、内存、文件、接口和其他6大类20多种表引擎。</p><h5 id="多线程与分布式"><a href="#多线程与分布式" class="headerlink" title="多线程与分布式"></a>多线程与分布式</h5><p>多 线程处理就是通过线程级并行的方式实现了性能的提升,相比基于底 层硬件实现的向量化执行SIMD，线程级并行通常由更高层次的软件层 面控制,和向量化执行形成互补.</p><p>ClickHouse在数据存取方面，既支持分区（纵向扩 展，利用多线程原理），也支持分片（横向扩展，利用分布式原 理）.</p><h5 id="多主架构"><a href="#多主架构" class="headerlink" title="多主架构"></a>多主架构</h5><p>HDFS、Spark、HBase和Elasticsearch这类分布式系统，都采用了 Master-Slave主从架构，由一个管控节点作为Leader统筹全局。而 ClickHouse则采用Multi-Master多主架构，集群中的每个节点角色对 等，客户端访问任意一个节点都能得到相同的效果.</p><h5 id="在线查询"><a href="#在线查询" class="headerlink" title="在线查询"></a>在线查询</h5><p>ClickHouse与其他分析型数据库对比，比如 Vertica、SparkSQL、Hive和Elasticsearch，这些分析型数据库，它们都可以支撑海量数据的查询场景，都拥有 分布式架构，都支持列存、数据分片、计算下推等特性。</p><p>ClickHouse对比下的优势：适用于复杂查询，又快又开源。</p><p>Vertica格高昂、SparkSQL与Hive这类系统无法保障90%的查询在1秒内返回，查询分钟级响应，Elasticsearch搜索引擎在处理亿级数据聚合查询时效率低。</p><h5 id="数据分片与分布式查询"><a href="#数据分片与分布式查询" class="headerlink" title="数据分片与分布式查询"></a>数据分片与分布式查询</h5><p>数据分片是将数据进行横向切分，ClickHouse支持分片，每个分片对应ClickHouse的一个服务节点，分片的上限取决于节点数。</p><p>ClickHouse提供了本地表与分布式表的概念，一张本地表相当于一份数据分片，分布式表不存储任何数据，他是本地表的访问代理，作用类似于分库中间件，借助分布式表，代理访问多个数据分片，实现分布式查询。</p><h4 id="ClickHouse的架构设计"><a href="#ClickHouse的架构设计" class="headerlink" title="ClickHouse的架构设计"></a>ClickHouse的架构设计</h4><h5 id="Column与Field"><a href="#Column与Field" class="headerlink" title="Column与Field"></a>Column与Field</h5><p>Column和Field是ClickHouse数据最基础的映射单元，内存中的一列 数据由一个Column对象表示，Field对象代表一个单值，单列中的一行数据。</p><h5 id="DataType"><a href="#DataType" class="headerlink" title="DataType"></a>DataType</h5><p>DataType负责数据的序列化与反序列化，IDataType接口定 义正反序列化的方法。</p><h5 id="Block与Block流"><a href="#Block与Block流" class="headerlink" title="Block与Block流"></a>Block与Block流</h5><p>ClickHouse内部的数据操作是面向Block对象进行的，并且采用了 流的形式，Block对象的本质是由数据对象、数据类型和列名称组成的三元 组，即Column、DataType及列名称字符串。</p><h5 id="Table"><a href="#Table" class="headerlink" title="Table"></a>Table</h5><p>使用 IStorage接口指代数据表,表引擎是ClickHouse的一个显著特性，不同 的表引擎由不同的子类实现。</p><h5 id="Parser与Interpreter"><a href="#Parser与Interpreter" class="headerlink" title="Parser与Interpreter"></a>Parser与Interpreter</h5><p>Parser分析器负责创建 AST对象；而Interpreter解释器则负责解释AST，并进一步创建查询的 执行管道，它们与IStorage一起，串联起了整个数据查询的过程。</p><h5 id="Functions与Aggregate-Functions"><a href="#Functions与Aggregate-Functions" class="headerlink" title="Functions与Aggregate Functions"></a>Functions与Aggregate Functions</h5><p>ClickHouse主要提供两类函数——普通函数和聚合函数。普通函 数由IFunction接口定义，拥有数十种函数实现，例如 FunctionFormatDateTime、FunctionSubstring等，聚合函数由IAggregateFunction接口定义，相比无状态的普通函 数，聚合函数是有状态的。</p><h5 id="Cluster与Replication"><a href="#Cluster与Replication" class="headerlink" title="Cluster与Replication"></a>Cluster与Replication</h5><p>ClickHouse的集群由分片（Shard）组成，而每个分片又通过副本 （Replica）组成    。</p><ul><li>ClickHouse的1个节点只能拥有1个分片，也就是说如果要实 现1分片、1副本，则至少需要部署2个服务节点</li><li>分片只是一个逻辑概念，其物理承载还是由副本承担的。</li></ul><h4 id="ClickHouse为何如此之快"><a href="#ClickHouse为何如此之快" class="headerlink" title="ClickHouse为何如此之快"></a>ClickHouse为何如此之快</h4><ul><li>列式存储</li><li>向量化引擎</li><li>着眼硬件，先想后做，充分考虑硬件性能带来的提升。</li><li>算法在前，抽象在后，对于常量，使用Volnitsky算法；对于 非常量，使用CPU的向量化执行SIMD，暴力优化；正则匹配使用re2 和hyperscan算法。性能是算法选择的首要考量指标。</li><li>勇于尝鲜，不行就换。</li><li>特定化场景、特殊优化。根据数据量的不同，场景不同，选择不同的算法进行处理。</li><li>持续测试，持续改进。真实数据做测试验证，快速迭代下进行持续改进。</li></ul><h3 id="第三章-ClickHouse的安装与部署"><a href="#第三章-ClickHouse的安装与部署" class="headerlink" title="第三章 ClickHouse的安装与部署"></a>第三章 ClickHouse的安装与部署</h3><h5 id="ClickHouse安装过程"><a href="#ClickHouse安装过程" class="headerlink" title="ClickHouse安装过程"></a>ClickHouse安装过程</h5><p>ClickHouse可以在任何具有x86_64，AArch64或PowerPC64LE CPU架构的Linux，FreeBSD或Mac OS X上运行。</p><p>官方预构建的二进制文件通常针对x86_64进行编译，并利用<code>SSE 4.2</code>指令集，因此，除非另有说明，支持它的CPU使用将成为额外的系统需求。下面是检查当前CPU是否支持SSE 4.2的命令:</p><pre class=" language-java"><code class="language-java">$ grep <span class="token operator">-</span>q sse4_2 <span class="token operator">/</span>proc<span class="token operator">/</span>cpuinfo <span class="token operator">&amp;&amp;</span> echo <span class="token string">"SSE 4.2 supported"</span> <span class="token operator">||</span> echo <span class="token string">"SSE 4.2 not supported"</span></code></pre><p>Ubuntu的官方预编译<code>deb</code>软件包。运行以下命令来安装包:</p><pre class=" language-java"><code class="language-java">sudo apt<span class="token operator">-</span>get install apt<span class="token operator">-</span>transport<span class="token operator">-</span>https ca<span class="token operator">-</span>certificates dirmngrsudo apt<span class="token operator">-</span>key adv <span class="token operator">--</span>keyserver hkp<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>keyserver<span class="token punctuation">.</span>ubuntu<span class="token punctuation">.</span>com<span class="token operator">:</span><span class="token number">80</span> <span class="token operator">--</span>recv E0C56BD4echo <span class="token string">"deb https://repo.clickhouse.com/deb/stable/ main/"</span> <span class="token operator">|</span> sudo tee \    <span class="token operator">/</span>etc<span class="token operator">/</span>apt<span class="token operator">/</span>sources<span class="token punctuation">.</span>list<span class="token punctuation">.</span>d<span class="token operator">/</span>clickhouse<span class="token punctuation">.</span>listsudo apt<span class="token operator">-</span>get updatesudo apt<span class="token operator">-</span>get install <span class="token operator">-</span>y clickhouse<span class="token operator">-</span>server clickhouse<span class="token operator">-</span>clientsudo service clickhouse<span class="token operator">-</span>server startclickhouse<span class="token operator">-</span>client</code></pre><p>Mac下单机安装部署Clickhouse</p><p>1、安装docker</p><p>2、安装ClickHouse</p><p>客户端：docker pull yandex/clickhouse-client<br>服务端：docker pull yandex/clickhouse-server</p><p>3、命令启动镜像或者docker控制台启动</p><pre><code>docker run -d --name ch-server --ulimit nofile=262144:262144 -p 8123:8123 -p 9000:9000 -p 9009:9009 yandex/clickhouse-server</code></pre><p>4、启动命令</p><pre class=" language-java"><code class="language-java">clickhouse<span class="token operator">-</span>client</code></pre><p>5、使用idea 连接clickhouse 做数据增删改查。</p><h5 id="ClickHouse客户端的访问接口"><a href="#ClickHouse客户端的访问接口" class="headerlink" title="ClickHouse客户端的访问接口"></a>ClickHouse客户端的访问接口</h5><p>ClickHouse的底层访问接口支持TCP和HTTP两种协议，TCP协议拥有更好的性能，其默认端口为9000,而HTTP协议则拥有更好的兼容性，可以通过 REST服务的形式被广泛用于JAVA、Python等编程语言的客户端，其默 认端口为8123.</p><p>ClickHouse支持标准的JDBC协议，底层基于HTTP接口通信.</p><p><strong>JDBC访问ClickHouse</strong></p><p>1、引入Maven依赖</p><pre class=" language-xml"><code class="language-xml">    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>ru.yandex.clickhouse<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>clickhouse-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>0.2.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.logging.log4j<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>log4j-slf4j-impl<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.11.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span></code></pre><p>2、连接JDBC操作ClickHouse</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">,</span> SQLException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 初始化驱动</span>        Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"ru.yandex.clickhouse.ClickHouseDriver"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// url</span>        String url <span class="token operator">=</span> <span class="token string">"jdbc:clickhouse://localhost:8123"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 用户名密码</span>        String user <span class="token operator">=</span> <span class="token string">"default"</span><span class="token punctuation">;</span>        String password <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 登录</span>        Connection con <span class="token operator">=</span> DriverManager<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> user<span class="token punctuation">,</span> password<span class="token punctuation">)</span><span class="token punctuation">;</span>        Statement stmt <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 查询</span>        ResultSet rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"SELECT 1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"res "</span> <span class="token operator">+</span> rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>高可用集群模式操作</strong></p><p>高可用模式允许设置多个host地址，每次会从可用的地址中随机 选择一个进行连接，在高可用模式下，需要通过BalancedClickhouseDataSource对象获 取连接。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> SQLException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//多个地址使用逗号分隔</span>        String url <span class="token operator">=</span> <span class="token string">"jdbc:clickhouse://localhost:8123,localhost:8123/default"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//设置JDBC参数</span>        ClickHouseProperties clickHouseProperties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ClickHouseProperties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        clickHouseProperties<span class="token punctuation">.</span><span class="token function">setUser</span><span class="token punctuation">(</span><span class="token string">"default"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//声明数据源</span>        BalancedClickhouseDataSource balanced <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BalancedClickhouseDataSource</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span>            clickHouseProperties<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//对每个host进行ping操作, 排除不可用的dead连接</span>        balanced<span class="token punctuation">.</span><span class="token function">actualize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//获得JDBC连接</span>        Connection con <span class="token operator">=</span> balanced<span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Statement stmt <span class="token operator">=</span> con<span class="token punctuation">.</span><span class="token function">createStatement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//查询</span>        ResultSet rs <span class="token operator">=</span> stmt<span class="token punctuation">.</span><span class="token function">executeQuery</span><span class="token punctuation">(</span><span class="token string">"SELECT 1 , hostName()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        rs<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"res "</span><span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token string">","</span><span class="token operator">+</span>rs<span class="token punctuation">.</span><span class="token function">getString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h3 id="第四章：数据定义"><a href="#第四章：数据定义" class="headerlink" title="第四章：数据定义"></a>第四章：数据定义</h3><h4 id="ClickHouse的数据类型"><a href="#ClickHouse的数据类型" class="headerlink" title="ClickHouse的数据类型"></a>ClickHouse的数据类型</h4><h5 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h5><p>基础类型只有数值、字符串和时间三种类型，没有Boolean类型， 但可以使用整型的0或1替代。</p><h5 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h5><ul><li>Int类型，使用Int8、Int16、Int32和Int64指代4种大 小的Int类型，可对应mysql中的Tinyint、Smallint、Int和Bigint，支持无符号数，分别用Uint8、Uint16、Uint32、Uint64表示。</li><li><p>Float类型，使用Float32和Float64代表单精度浮点 数以及双精度浮点数，Float32有效精度7位，Float64有效精度16位，支持正无穷、负无穷、非数字的表达式。</p></li><li><p>Decimal, ClickHouse提 供了Decimal32、Decimal64和Decimal128三种精度的定点数</p><ul><li>简写方式： Decimal32(S) 等效于Decimal(1-9,S) 、Decimal64(S) 等效于Decimal(10-18,S) 、 Decimal128(S) 等效于Decimal(19-38,S) 三种</li><li>原生方式：Decimal(P,S)，P代表精度，决定总位数（整数部分+小数部分），取值范围是1 ～38，S代表规模，决定小数位数，取值范围是0～P。</li></ul></li><li>字符串类型：分为String、FixedString和UUID三类<ul><li>字符串由String定义，长度不限</li><li>FixedString类型，定长字符串类型，和传统意义上的Char类型有些类似，定长字符串通过 FixedString(N)声明，其中N表示字符串长度。</li><li>UUID共有32位，它的格式为8-4-4-4-12，如： 4d4d4a1d-c30c-4727-bade-298a1930231f</li></ul></li></ul><h5 id="时间类型"><a href="#时间类型" class="headerlink" title="时间类型"></a>时间类型</h5><ul><li>DateTime :DateTime类型包含时、分、秒信息，精确到秒，支持使用字符串形 式写入</li><li>DateTime64:DateTime64可以记录亚秒，它在DateTime之上增加了精度的设置</li><li>Date:Date类型不包含具体的时间信息，只精确到天，它同样也支持字符 串形式写入</li></ul><h5 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h5><ul><li>数组类型 Array<ul><li>例子：SELECT tuple(1,’a’,now()) AS x, toTypeName(x)</li><li>定义字段：CREATE TABLE Array_TEST ( c1 Array(String) ) eng</li></ul></li><li>Tuple：元组类型由1～n个元素组成，每个元素之间允许设置不同的数据 类型，且彼此之间不要求兼容<ul><li>例子：SELECT tuple(1,’a’,now()) AS x, toTypeName(x)</li><li>定义字段：CREATE TABLE Tuple_TEST ( c1 Tuple(String,Int8) ) ENGINE = Memory;</li></ul></li><li><p>Enum类型：提供了Enum8和Enum16两种枚举类型，</p><ul><li>定义字段：CREATE TABLE Enum_TEST ( c1 Enum8(‘ready’ = 1, ‘start’ = 2, ‘success’ = 3, ‘error’ = 4) ) ENGINE = Memory;</li><li>注意：Key和Value是 不允许重复的，要保证唯一性。其次，Key和Value的值都不能为 Null，但Key允许是空字符串</li></ul></li><li><p>Nested：嵌套类型：一张数据表，可以定义 任意多个嵌套类型字段，但每个字段的嵌套层级只支持一级，即嵌套 表内不能继续使用嵌套类型。</p><ul><li>定义语句：CREATE TABLE nested_test ( name String, age UInt8 , dept Nested( id UInt8, name String ) ) ENGINE = Memory;</li></ul></li></ul><h5 id="特殊类型"><a href="#特殊类型" class="headerlink" title="特殊类型"></a>特殊类型</h5><ul><li>Nullable </li><li>Domain： 域名类型：域名类型分为IPv4和IPv6两类，本质上它们是对整型和字符串的 进一步封装。IPv4类型是基于UInt32封装的</li></ul><h4 id="如何定义数据表"><a href="#如何定义数据表" class="headerlink" title="如何定义数据表"></a>如何定义数据表</h4><p>ClickHouse一共支持五种引擎</p><ul><li>Ordinary：默认引擎，在绝大多数情况下我们都会使用默认引 擎，使用时无须刻意声明。在此数据库下可以使用任意类型的表引 擎。</li><li>Dictionary:字典引擎，此类数据库会自动为所有数据字典创建 它们的数据表</li><li>Memory：内存引擎，用于存放临时数据。此类数据库下的数据 表只会停留在内存中，不会涉及任何磁盘操作，当服务重启后数据会 被清除。</li><li>Lazy:日志引擎，此类数据库下只能使用Log系列的表引擎</li><li>Mysql:mysql引擎：此类数据库下会自动拉取远端MySQL中 的数据，并为它们创建MySQL表引擎的数据表。</li></ul><h5 id="基本DDL操作"><a href="#基本DDL操作" class="headerlink" title="基本DDL操作"></a>基本DDL操作</h5><p>删除数据库、删除表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> db_name<span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> table_name</code></pre><h5 id="数据表"><a href="#数据表" class="headerlink" title="数据表"></a>数据表</h5><p>建表语句</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name <span class="token punctuation">(</span>name1 <span class="token punctuation">[</span><span class="token keyword">type</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token operator">|</span>MATERIALIZED<span class="token operator">|</span>ALIAS expr<span class="token punctuation">]</span><span class="token punctuation">,</span>name2 <span class="token punctuation">[</span><span class="token keyword">type</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token keyword">DEFAULT</span><span class="token operator">|</span>MATERIALIZED<span class="token operator">|</span>ALIAS expr<span class="token punctuation">]</span><span class="token punctuation">,</span>省略…<span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">engine</span></code></pre><p>复制其他表结构：</p><pre class=" language-sql"><code class="language-sql">复制表<span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name1<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name <span class="token keyword">AS</span> <span class="token punctuation">[</span>db_name2<span class="token punctuation">.</span><span class="token punctuation">]</span> table_name2<span class="token punctuation">[</span><span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">engine</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">--创建新的数据库</span><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> new_db<span class="token comment" spellcheck="true">--将default.hits_v1的结构复制到new_db.hits_v1</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span> new_db<span class="token punctuation">.</span>hits_v1 <span class="token keyword">AS</span> <span class="token keyword">default</span><span class="token punctuation">.</span>hits_v1 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> TinyLog<span class="token comment" spellcheck="true">//select方式复制</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token operator">NOT</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> <span class="token punctuation">[</span>db_name<span class="token punctuation">.</span><span class="token punctuation">]</span>table_name <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">engine</span> <span class="token keyword">AS</span> <span class="token keyword">SELECT</span> …例子：<span class="token keyword">create</span> <span class="token keyword">table</span> test1 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> TinyLog <span class="token keyword">AS</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> test<span class="token punctuation">;</span><span class="token keyword">create</span> <span class="token keyword">table</span> test3 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> TinyLog <span class="token keyword">AS</span> test1 <span class="token keyword">ENGINE</span> <span class="token operator">=</span> TinyLog<span class="token punctuation">;</span></code></pre><h5 id="默认表示值"><a href="#默认表示值" class="headerlink" title="默认表示值"></a>默认表示值</h5><p>表字段支持三种默认值表达式的定义方法，分别是DEFAULT、 MATERIALIZED和ALIAS。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> dfv_v1 <span class="token punctuation">(</span>id String<span class="token punctuation">,</span><span class="token number">c1</span> <span class="token keyword">DEFAULT</span> <span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">c2</span> String <span class="token keyword">DEFAULT</span> <span class="token number">c1</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> TinyLog</code></pre><p>修改默认值</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> <span class="token punctuation">[</span>db_name<span class="token punctuation">.</span><span class="token punctuation">]</span><span class="token keyword">table</span> <span class="token keyword">MODIFY</span> <span class="token keyword">COLUMN</span> col_name <span class="token keyword">DEFAULT</span> <span class="token keyword">value</span></code></pre><h5 id="临时表"><a href="#临时表" class="headerlink" title="临时表"></a>临时表</h5><p>创建临时表，临时表引擎是内存，如果会话结束、表会被销毁。</p><pre><code>CREATE TEMPORARY TABLE [IF NOT EXISTS] table_name (name1 [type] [DEFAULT|MATERIALIZED|ALIAS expr],name2 [type] [DEFAULT|MATERIALIZED|ALIAS expr],)</code></pre><h5 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h5><p>数据分区（partition）和数据分片（shard）是完全不同的两个概 念。数据分区是针对本地数据而言的，是数据的一种纵向切分。而数 据分片是数据的一种横向切分</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> partition_v1 <span class="token punctuation">(</span>ID String<span class="token punctuation">,</span>URL String<span class="token punctuation">,</span>EventTime <span class="token keyword">Date</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> toYYYYMM<span class="token punctuation">(</span>EventTime<span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ID</code></pre><h5 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h5><p>ClickHouse拥有普通和物化两种视图，其中物化视图拥有独立的 存储，而普通视图只是一层简单的查询代理</p><h4 id="数据表的基本操作"><a href="#数据表的基本操作" class="headerlink" title="数据表的基本操作"></a>数据表的基本操作</h4><p>追加新字段</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> testcol_v1 <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> OS String <span class="token keyword">DEFAULT</span> <span class="token string">'mac'</span><span class="token comment" spellcheck="true">//在指定字段后面追加</span><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> testcol_v1 <span class="token keyword">ADD</span> <span class="token keyword">COLUMN</span> IP String <span class="token keyword">AFTER</span> ID</code></pre><p>修改数据类型</p><pre><code>ALTER TABLE tb_name MODIFY COLUMN [IF EXISTS] name [type] [default_expr]//例子ALTER TABLE testcol_v1 MODIFY COLUMN IP IPv4</code></pre><p>修改备注</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> testcol_v1 <span class="token keyword">COMMENT</span> <span class="token keyword">COLUMN</span> ID <span class="token string">'主键ID'</span></code></pre><p>删除已有字段</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> tb_name <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> <span class="token punctuation">[</span><span class="token keyword">IF</span> <span class="token keyword">EXISTS</span><span class="token punctuation">]</span> name<span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> testcol_v1 <span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> UR</code></pre><p>清空数据表</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> db_test<span class="token punctuation">.</span>testcol_v2</code></pre><h4 id="数据分区的基本操作"><a href="#数据分区的基本操作" class="headerlink" title="数据分区的基本操作"></a>数据分区的基本操作</h4><p>删除指定分区</p><pre><code>ALTER TABLE partition_v2 DROP PARTITION 201907</code></pre><p>复制分区数据</p><p>适用于快速数据写入、多表间数据同步和备份等场景，复制的前提条件，两张表需要拥有相同的分区键，它们的表结构完全相同。</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> B REPLACE <span class="token keyword">PARTITION</span> partition_expr <span class="token keyword">FROM</span> A</code></pre><p>重置分区数据</p><p>如果数据表某一列的数据有误，需要将其重置为初始值，此时可 以使用下面的语句实现：</p><pre><code>ALTER TABLE tb_name CLEAR COLUMN column_name IN PARTITION partition_expr//例子ALTER TABLE partition_v2 CLEAR COLUMN URL in PARTITION 201908</code></pre><h4 id="分布式DDL执行"><a href="#分布式DDL执行" class="headerlink" title="分布式DDL执行"></a>分布式DDL执行</h4><p>如果在集群中任意一个节点上执行DDL 语句，那么集群中的每个节点都会以相同的顺序执行相同的语句。</p><p>加上ON CLUSTER cluster_name声明即可 ，执行命令</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> partition_v3 <span class="token keyword">ON</span> CLUSTER ch_cluster<span class="token punctuation">(</span>ID String<span class="token punctuation">,</span>URL String<span class="token punctuation">,</span>EventTime <span class="token keyword">Date</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> MergeTree<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">PARTITION</span> <span class="token keyword">BY</span> toYYYYMM<span class="token punctuation">(</span>EventTime<span class="token punctuation">)</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ID</code></pre><h5 id="数据的写入"><a href="#数据的写入" class="headerlink" title="数据的写入"></a>数据的写入</h5><p>支持批量插入</p><pre class=" language-sql"><code class="language-sql"><span class="token comment" spellcheck="true">//支持批量插入</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> partition_v2 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A0011'</span><span class="token punctuation">,</span><span class="token string">'www.nauu.com'</span><span class="token punctuation">,</span> <span class="token string">'2019-10-01'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'A0012'</span><span class="token punctuation">,</span><span class="token string">'www.nauu.com'</span><span class="token punctuation">,</span> <span class="token string">'2019-11-20'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">'A0013'</span><span class="token punctuation">,</span><span class="token string">'www.nauu.com'</span><span class="token punctuation">,</span> <span class="token string">'2019-12-20'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//支持表达式或函数</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> partition_v2 <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'A0014'</span><span class="token punctuation">,</span>toString<span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//select 查询写入</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> partition_v2 <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> partition_v1</code></pre><h5 id="数据的删除和修改"><a href="#数据的删除和修改" class="headerlink" title="数据的删除和修改"></a>数据的删除和修改</h5><p>ClickHouse提供了DELETE和UPDATE的能力，这类操作被称为 Mutation查询，不支持事务，异步执行。hexo g -dg</p><p><code>`</code>sql<br>//数据删除的范围由WHERE查询子句决定<br>ALTER TABLE partition_v2 DELETE WHERE ID = ‘A003’</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库索引</title>
      <link href="/2021/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
      <url>/2021/04/27/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本 500 页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。<a id="more"></a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础架构</title>
      <link href="/2021/03/01/Mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/"/>
      <url>/2021/03/01/Mysql%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要 ：</strong></p><blockquote><p>通过把 MySQL 拆解一下，看看里面都有哪些“零件”，借由这个拆解过程，对 MySQL 有更深入的理解。这样当我们碰到 MySQL 的一些异常或者问题时，就能够直戳本质，更为快速地定位并解决问题。</p></blockquote><p>MySQL基础架构示意图：能看到SQL 语句在 MySQL 的各个功能模块中的执行过程</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/0d2070e8f84c4801adbfa03bda1f98d9.png" alt></p><p>MySQL可以分为Service层和存储引擎层两部分。</p><p>Server 层包括连接器、查询缓存、分析器、优化器、执行器，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。现在最常用的存储引擎是 InnoDB</p><h3 id="MySQL日志系统"><a href="#MySQL日志系统" class="headerlink" title="MySQL日志系统"></a>MySQL日志系统</h3><h5 id="重要的日志模块：redo-log"><a href="#重要的日志模块：redo-log" class="headerlink" title="重要的日志模块：redo log"></a>重要的日志模块：redo log</h5><p>作用：确保事务的持久性。<br>防止在发生故障的时间点，尚有脏页未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达到事务的持久性这一特.</p><p>InnoDB 使用 Redo Log 来保证数据的一致性和可持久性，它采用 WAL 机制，即先写日志再写数据。具体来说，InnoDB 进行写操作时，先将数据操作记录在 log buffer 中，然后将 log buffer 中的数据刷到磁盘 log file 中，后续数据再落到数据 ibd 文件这一步骤由 checkpoint 来保证</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/b075250cad8d9f6c791a52b6a600f69c.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程珠玑</title>
      <link href="/2021/02/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/"/>
      <url>/2021/02/01/%E7%BC%96%E7%A8%8B%E7%8F%A0%E7%8E%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>计算机编程充满乐趣。有时候，它是一门优雅的科学，有时候，它要去开发和使用新的软件工具。编程与人息息相关：客户实际想解决什么问题？</p><a id="more"></a></blockquote><h3 id="解题模板"><a href="#解题模板" class="headerlink" title="解题模板"></a>解题模板</h3><h4 id="双指针解题模板"><a href="#双指针解题模板" class="headerlink" title="双指针解题模板"></a>双指针解题模板</h4><p>我们通过迭代数组来解决一些问题。通常，我们只需要一个指针进行迭代，即从数组中的第一个元素开始，最后一个元素结束。然而，有时我们会使用两个指针进行迭代。<br><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/bfdf27723d1b26ee06a56adbf6206fb9d1f7446e297ce05e74e0275b268cd945-1.png" alt></p><p>示例<br>让我们从一个经典问题开始：</p><blockquote><p>反转数组中的元素。比如数组为 [‘l’, ‘e’, ‘e’, ‘t’, ‘c’, ‘o’, ‘d’, ‘e’]，反转之后变为 [‘e’, ‘d’, ‘o’, ‘c’, ‘t’, ‘e’, ‘e’, ‘l’]。</p></blockquote><p>使用双指针技巧，其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/84f9f1fce23655fcc653179b26d9800edf54858f790be1bc7573eb228f2aac00-2.gif" alt></p><h4 id="原地哈希-哈希表"><a href="#原地哈希-哈希表" class="headerlink" title="原地哈希(哈希表)"></a>原地哈希(哈希表)</h4><h4 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h4><h4 id="KMP算法"><a href="#KMP算法" class="headerlink" title="KMP算法"></a>KMP算法</h4><h4 id="马拉车算法"><a href="#马拉车算法" class="headerlink" title="马拉车算法"></a>马拉车算法</h4><h4 id="回溯算法"><a href="#回溯算法" class="headerlink" title="回溯算法"></a>回溯算法</h4><h4 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h4><h4 id="数据结构与算法总结"><a href="#数据结构与算法总结" class="headerlink" title="数据结构与算法总结"></a>数据结构与算法总结</h4><h4 id="通用方法代码"><a href="#通用方法代码" class="headerlink" title="通用方法代码"></a>通用方法代码</h4><h4 id="485-最大连续-1-的个数"><a href="#485-最大连续-1-的个数" class="headerlink" title="485. 最大连续 1 的个数"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续 1 的个数</a></h4><pre class=" language-java"><code class="language-java">反转字符串<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span><span class="token keyword">int</span> begin<span class="token punctuation">,</span><span class="token keyword">int</span> end<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> begin<span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> end<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>x<span class="token operator">&lt;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">char</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>x<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        x<span class="token operator">++</span><span class="token punctuation">;</span>        y<span class="token operator">--</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> nums<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//反转链表</span><span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode temp <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">//数组实现栈</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayStack</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 数组     */</span>    <span class="token keyword">private</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 栈元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 栈大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ArrayStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">//入栈操作</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">push</span><span class="token punctuation">(</span>String item<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> size<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        nums<span class="token punctuation">[</span>count<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>        count<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String res <span class="token operator">=</span> nums<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isFull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//链表基本操作</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ListNodeDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ListNode</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 节点数据         */</span>        <span class="token keyword">private</span> Object data<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 指针         */</span>        <span class="token keyword">private</span> ListNode next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">/**         * 构造函数         * @param data         */</span>        <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span>Object data<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 头结点     */</span>    <span class="token keyword">private</span> ListNode head<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 临时变量     */</span>    <span class="token keyword">private</span> ListNode temp<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     *初始化链表     */</span>    <span class="token keyword">public</span> <span class="token function">ListNodeDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取链表长度     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      temp <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>         temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>         length<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> length<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 添加链表节点     * @param data     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span>Object data<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        temp<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 指定位置新增节点     * @param index     * @param data     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNodeByIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token punctuation">,</span>Object data<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> index <span class="token operator">></span> <span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>                node<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                temp<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除指定位置节点     * @param index     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteNodeByIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">||</span> index<span class="token operator">></span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        temp <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> index<span class="token punctuation">)</span><span class="token punctuation">{</span>                temp<span class="token punctuation">.</span>next <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            count<span class="token operator">++</span><span class="token punctuation">;</span>            temp <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从头到尾打印链表     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printNodeFromHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>cur<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{"</span><span class="token operator">+</span>cur<span class="token punctuation">.</span>next<span class="token punctuation">.</span>data<span class="token operator">+</span><span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            cur <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 从尾到头打印链表     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">printNodeFromTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//先反转链表再打印</span>        ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode cur <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>cur <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp <span class="token operator">=</span> cur<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            cur<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> cur<span class="token punctuation">;</span>            cur <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>prev<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"{"</span><span class="token operator">+</span>prev<span class="token punctuation">.</span>data<span class="token operator">+</span><span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span>    <span class="token punctuation">{</span>        ListNodeDemo list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNodeDemo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNode</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNode</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNode</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNode</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNode</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">printNodeFromHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">printNodeFromTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">addNodeByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2.8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">printNodeFromHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">deleteNodeByIndex</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        list<span class="token punctuation">.</span><span class="token function">printNodeFromHead</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="每日一题"><a href="#每日一题" class="headerlink" title="每日一题"></a>每日一题</h3><h4 id="561-数组拆分-I"><a href="#561-数组拆分-I" class="headerlink" title="561. 数组拆分 I"></a><a href="https://leetcode-cn.com/problems/array-partition-i/" target="_blank" rel="noopener">561. 数组拆分 I</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定长度为 2n 的整数数组 nums ，你的任务是将这些数分成 n 对, 例如 (a1, b1), (a2, b2), ..., (an, bn) ，使得</span><span class="token comment" spellcheck="true">//从 1 到 n 的 min(ai, bi) 总和最大。 </span><span class="token comment" spellcheck="true">// 返回该 最大总和 。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [1,4,3,2]</span><span class="token comment" spellcheck="true">//输出：4</span><span class="token comment" spellcheck="true">//解释：所有可能的分法（忽略元素顺序）为：</span><span class="token comment" spellcheck="true">//1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3</span><span class="token comment" spellcheck="true">//2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3</span><span class="token comment" spellcheck="true">//3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4</span><span class="token comment" spellcheck="true">//所以最大总和为 4 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：nums = [6,2,6,5,1,2]</span><span class="token comment" spellcheck="true">//输出：9</span><span class="token comment" spellcheck="true">//解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + </span><span class="token comment" spellcheck="true">//6 = 9</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= n &lt;= 104 </span><span class="token comment" spellcheck="true">// nums.length == 2 * n </span><span class="token comment" spellcheck="true">// -104 &lt;= nums[i] &lt;= 104 </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 240 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">arrayPairSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               res <span class="token operator">=</span> res <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路分析：</p><p>我们先对数组进行排序。</p><p>由于每两个数，我们只能选择当前小的一个进行累加。</p><p>因此我们猜想应该从第一个位置进行选择，然后隔一步选择下一个数。这样形成的序列的求和值最大</p><h4 id="566-重塑矩阵"><a href="#566-重塑矩阵" class="headerlink" title="566. 重塑矩阵"></a><a href="https://leetcode-cn.com/problems/reshape-the-matrix/" target="_blank" rel="noopener">566. 重塑矩阵</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在MATLAB中，有一个非常有用的函数 reshape，它可以将一个矩阵重塑为另一个大小不同的新矩阵，但保留其原始数据。 </span><span class="token comment" spellcheck="true">// 给出一个由二维数组表示的矩阵，以及两个正整数r和c，分别表示想要的重构的矩阵的行数和列数。 </span><span class="token comment" spellcheck="true">// 重构后的矩阵需要将原始矩阵的所有元素以相同的行遍历顺序填充。 </span><span class="token comment" spellcheck="true">// 如果具有给定参数的reshape操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: </span><span class="token comment" spellcheck="true">//nums = </span><span class="token comment" spellcheck="true">//[[1,2],</span><span class="token comment" spellcheck="true">// [3,4]]</span><span class="token comment" spellcheck="true">//r = 1, c = 4</span><span class="token comment" spellcheck="true">//输出: </span><span class="token comment" spellcheck="true">//[[1,2,3,4]]</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//行遍历nums的结果是 [1,2,3,4]。新的矩阵是 1 * 4 矩阵, 用之前的元素值一行一行填充新矩阵。</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: </span><span class="token comment" spellcheck="true">//nums = </span><span class="token comment" spellcheck="true">//[[1,2],</span><span class="token comment" spellcheck="true">// [3,4]]</span><span class="token comment" spellcheck="true">//r = 2, c = 4</span><span class="token comment" spellcheck="true">//输出: </span><span class="token comment" spellcheck="true">//[[1,2],</span><span class="token comment" spellcheck="true">// [3,4]]</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//没有办法将 2 * 2 矩阵转化为 2 * 4 矩阵。 所以输出原矩阵。</span><span class="token comment" spellcheck="true">// 注意： </span><span class="token comment" spellcheck="true">// 给定矩阵的宽和高范围在 [1, 100]。 </span><span class="token comment" spellcheck="true">// 给定的 r 和 c 都是正数。 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 183 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">matrixReshape</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> m <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">*</span>n <span class="token operator">!=</span> r<span class="token operator">*</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> nums<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">[</span>c<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>x<span class="token operator">&lt;</span>m<span class="token operator">*</span>n<span class="token punctuation">;</span>x<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           ans<span class="token punctuation">[</span>x <span class="token operator">/</span> c<span class="token punctuation">]</span><span class="token punctuation">[</span>x <span class="token operator">%</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>x <span class="token operator">/</span> n<span class="token punctuation">]</span><span class="token punctuation">[</span>x <span class="token operator">%</span> n<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="1004-最大连续1的个数-III"><a href="#1004-最大连续1的个数-III" class="headerlink" title="1004. 最大连续1的个数 III"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">1004. 最大连续1的个数 III</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。 </span><span class="token comment" spellcheck="true">// 返回仅包含 1 的最长（连续）子数组的长度。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><span class="token comment" spellcheck="true">//输出：6</span><span class="token comment" spellcheck="true">//解释： </span><span class="token comment" spellcheck="true">//[1,1,1,0,0,1,1,1,1,1,1]</span><span class="token comment" spellcheck="true">//粗体数字从 0 翻转到 1，最长的子数组长度为 6。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><span class="token comment" spellcheck="true">//输出：10</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><span class="token comment" spellcheck="true">//粗体数字从 0 翻转到 1，最长的子数组长度为 10。 </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= A.length &lt;= 20000 </span><span class="token comment" spellcheck="true">// 0 &lt;= K &lt;= A.length </span><span class="token comment" spellcheck="true">// A[i] 为 0 或 1 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 双指针 Sliding Window </span><span class="token comment" spellcheck="true">// 👍 218 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestOnes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路:滑动窗口法，//TODO</p><h3 id="数组的遍历"><a href="#数组的遍历" class="headerlink" title="数组的遍历"></a>数组的遍历</h3><h5 id="485-最大连续1的个数"><a href="#485-最大连续1的个数" class="headerlink" title="485. 最大连续1的个数"></a><a href="https://leetcode-cn.com/problems/max-consecutive-ones/" target="_blank" rel="noopener">485. 最大连续1的个数</a></h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个二进制数组， 计算其中最大连续1的个数。 </span><span class="token comment" spellcheck="true">//示例 1: </span><span class="token comment" spellcheck="true">//输入: [1,1,0,1,1,1]</span><span class="token comment" spellcheck="true">//输出: 3</span><span class="token comment" spellcheck="true">//解释: 开头的两位和最后的三位都是连续1，所以最大连续1的个数是 3.</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 注意： </span><span class="token comment" spellcheck="true">// 输入的数组只包含 0 和1。 </span><span class="token comment" spellcheck="true">// 输入数组的长度是正整数，且不超过 10,000。 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 165 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMaxConsecutiveOnes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             count<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">></span>maxCount<span class="token punctuation">)</span><span class="token punctuation">{</span>                 maxCount <span class="token operator">=</span> count<span class="token punctuation">;</span>             <span class="token punctuation">}</span>             count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> count<span class="token operator">></span>maxCount<span class="token operator">?</span>count<span class="token operator">:</span>maxCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>思路：遍历数组，用一个计数器(count)记录1的数量，用另一个计数器记录当前1的最大出行次数，如果遇到0 ，比较count与maxCount ,maxCount 记录较大值，同时将count置为0；</p><h4 id="495-提莫攻击"><a href="#495-提莫攻击" class="headerlink" title="495. 提莫攻击"></a><a href="https://leetcode-cn.com/problems/teemo-attacking/" target="_blank" rel="noopener">495. 提莫攻击</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在《英雄联盟》的世界中，有一个叫 “提莫” 的英雄，他的攻击可以让敌方英雄艾希（编者注：寒冰射手）进入中毒状态。现在，给出提莫对艾希的攻击时间序列和提莫攻击</span><span class="token comment" spellcheck="true">//的中毒持续时间，你需要输出艾希的中毒状态总时长。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 你可以认为提莫在给定的时间点进行攻击，并立即使艾希处于中毒状态。 </span><span class="token comment" spellcheck="true">// 示例1: </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: [1,4], 2</span><span class="token comment" spellcheck="true">//输出: 4</span><span class="token comment" spellcheck="true">//原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。</span><span class="token comment" spellcheck="true">//第 4 秒初，提莫再次攻击艾希，使得艾希获得另外 2 秒中毒时间。</span><span class="token comment" spellcheck="true">//所以最终输出 4 秒。</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 示例2: </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: [1,2], 2</span><span class="token comment" spellcheck="true">//输出: 3</span><span class="token comment" spellcheck="true">//原因: 第 1 秒初，提莫开始对艾希进行攻击并使其立即中毒。中毒状态会维持 2 秒钟，直到第 2 秒末结束。</span><span class="token comment" spellcheck="true">//但是第 2 秒初，提莫再次攻击了已经处于中毒状态的艾希。</span><span class="token comment" spellcheck="true">//由于中毒状态不可叠加，提莫在第 2 秒初的这次攻击会在第 3 秒末结束。</span><span class="token comment" spellcheck="true">//所以最终输出 3 。</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 你可以假定时间序列数组的总长度不超过 10000。 </span><span class="token comment" spellcheck="true">// 你可以假定提莫攻击时间序列中的数字和提莫攻击的中毒持续时间都是非负整数，并且不超过 10,000,000。 </span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findPoisonedDuration</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> timeSeries<span class="token punctuation">,</span> <span class="token keyword">int</span> duration<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>timeSeries<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>timeSeries<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> duration<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>timeSeries<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span>timeSeries<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;</span>duration<span class="token punctuation">)</span><span class="token punctuation">{</span>             res <span class="token operator">=</span> res <span class="token operator">+</span> timeSeries<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> timeSeries<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             res<span class="token operator">=</span> res <span class="token operator">+</span> duration<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token operator">+</span>duration<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>思路：按照时间序列的话，数组一定是递增的如果第二个时间点和前一个时间之差大于了中毒时间，明显总中毒时间加duration<br>否则，则有重叠，总中毒时间加上第二个时间点和前一个时间之差。</p><h4 id="414-第三大的数"><a href="#414-第三大的数" class="headerlink" title="414. 第三大的数"></a><a href="https://leetcode-cn.com/problems/third-maximum-number/" target="_blank" rel="noopener">414. 第三大的数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个非空数组，返回此数组中 第三大的数 。如果不存在，则返回数组中最大的数。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：[3, 2, 1]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">//解释：第三大的数是 1 。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：[1, 2]</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">//解释：第三大的数不存在, 所以返回最大的数 2 。</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：[2, 2, 3, 1]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">//解释：注意，要求返回第三大的数，是指第三大且唯一出现的数。</span><span class="token comment" spellcheck="true">//存在两个值为2的数，它们都排第二。</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= nums.length &lt;= 104 </span><span class="token comment" spellcheck="true">// -231 &lt;= nums[i] &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 进阶：你能设计一个时间复杂度 O(n) 的解决方案吗？ </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 201 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">thirdMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span><span class="token number">3</span><span class="token operator">?</span>set<span class="token punctuation">.</span><span class="token function">last</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span>set<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>思路：维护一个只有3个元素的TreeSet，如果大于三个元素就就把Set中的最小最小值remove掉。<br>最后如果Set中元素小于3就返回Set最大值，否则返回最小值。</p><h4 id="628-三个数的最大乘积"><a href="#628-三个数的最大乘积" class="headerlink" title="628. 三个数的最大乘积"></a><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers/" target="_blank" rel="noopener">628. 三个数的最大乘积</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个整型数组 nums ，在数组中找出由三个数组成的最大乘积，并输出这个乘积。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [1,2,3]</span><span class="token comment" spellcheck="true">//输出：6</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">//输入：nums = [1,2,3,4]</span><span class="token comment" spellcheck="true">//输出：24</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//输入：nums = [-1,-2,-3]</span><span class="token comment" spellcheck="true">//输出：-6</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 3 &lt;= nums.length &lt;= 104 </span><span class="token comment" spellcheck="true">// -1000 &lt;= nums[i] &lt;= 1000 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 数学 </span><span class="token comment" spellcheck="true">// 👍 278 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maximumProduct</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> max1 <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> max2 <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">*</span>nums<span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max1<span class="token punctuation">,</span>max2<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>思路：首先将数组排序。</p><p>如果数组中全是非负数，则排序后最大的三个数相乘即为最大乘积；如果全是非正数，则最大的三个数相乘同样也为最大乘积。</p><p>如果数组中有正数有负数，则最大乘积既可能是三个最大正数的乘积，也可能是两个最小负数（即绝对值最大）与最大正数的乘积。</p><p>综上，我们在给数组排序后，分别求出三个最大正数的乘积，以及两个最小负数与最大正数的乘积，二者之间的最大值即为所求答案。</p><h3 id="统计数组中的元素"><a href="#统计数组中的元素" class="headerlink" title="统计数组中的元素"></a>统计数组中的元素</h3><h4 id="645-错误的集合"><a href="#645-错误的集合" class="headerlink" title="645. 错误的集合"></a><a href="https://leetcode-cn.com/problems/set-mismatch/" target="_blank" rel="noopener">645. 错误的集合</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//集合 s 包含从 1 到 n 的整数。不幸的是，因为数据错误，导致集合里面某一个数字复制了成了集合里面的另外一个数字的值，导致集合 丢失了一个数字 并且 有</span><span class="token comment" spellcheck="true">//一个数字重复 。 </span><span class="token comment" spellcheck="true">// 给定一个数组 nums 代表了集合 S 发生错误后的结果。 </span><span class="token comment" spellcheck="true">// 请你找出重复出现的整数，再找到丢失的整数，将它们以数组的形式返回。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [1,2,2,4]</span><span class="token comment" spellcheck="true">//输出：[2,3]</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：nums = [1,1]</span><span class="token comment" spellcheck="true">//输出：[1,2]</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 2 &lt;= nums.length &lt;= 104 </span><span class="token comment" spellcheck="true">// 1 &lt;= nums[i] &lt;= 104 </span><span class="token comment" spellcheck="true">// Related Topics 哈希表 数学 </span><span class="token comment" spellcheck="true">// 👍 150 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findErrorNums</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="448-找到所有数组中消失的数字"><a href="#448-找到所有数组中消失的数字" class="headerlink" title="448. 找到所有数组中消失的数字"></a><a href="https://leetcode-cn.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">448. 找到所有数组中消失的数字</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个范围在 1 ≤ a[i] ≤ n ( n = 数组大小 ) 的 整型数组，数组中的元素一些出现了两次，另一些只出现一次。</span><span class="token comment" spellcheck="true">// 找到所有在 [1, n] 范围之间没有出现在数组中的数字。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 您能在不使用额外空间且时间复杂度为O(n)的情况下完成这个任务吗? 你可以假定返回的数组不算在额外空间内。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例:</span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//[4,3,2,7,8,2,3,1]</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[5,6]</span><span class="token comment" spellcheck="true">// Related Topics 数组</span><span class="token comment" spellcheck="true">// 👍 641 👎 0</span><span class="token comment" spellcheck="true">//暴力解法，超出时间限制</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>list<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//思路二 通过</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findDisappearedNumbers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> index <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         nums<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路：</p><p>使用数组的下标来标记数字的出现于否，通过一遍遍历即可标记出全部已经出现的数组</p><p>[4,3,2,7,8,2,3,1] 初始数据</p><p>[4,3,2,-7,8,2,3,1] 第一个数据 4 出现，将数组的第四个也就是下标 3 的数据修改为负数。-7 计算时，通过绝对值处理一下即可不影响数据的计算</p><p> [4,3,-2,-7,8,2,3,1]<br> [4,-3,-2,-7,8,2,3,1]<br> [4,-3,-2,-7,8,2,-3,1]<br> [4,-3,-2,-7,8,2,-3,-1]<br> [4,-3,-2,-7,8,2,-3,-1]<br> [4,-3,-2,-7,8,2,-3,-1]<br> [-4,-3,-2,-7,8,2,-3,-1]</p><h4 id="442-数组中重复的数据"><a href="#442-数组中重复的数据" class="headerlink" title="442. 数组中重复的数据"></a><a href="https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">442. 数组中重复的数据</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个整数数组 a，其中1 ≤ a[i] ≤ n （n为数组长度）, 其中有些元素出现两次而其他元素出现一次。 </span><span class="token comment" spellcheck="true">// 找到所有出现两次的元素。 </span><span class="token comment" spellcheck="true">// 你可以不用到任何额外空间并在O(n)时间复杂度内解决这个问题吗？ </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//[4,3,2,7,8,2,3,1]</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[2,3] </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 337 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">findDuplicates</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span></code></pre><p>解题思路：</p><p>对数组进行排序，如果相邻两数相等，则为重复元素。</p><h4 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">41. 缺失的第一个正数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。 </span><span class="token comment" spellcheck="true">// 进阶：你可以实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案吗？ </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [1,2,0]</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：nums = [3,4,-1,1]</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：nums = [7,8,9,11,12]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 300 </span><span class="token comment" spellcheck="true">// -231 &lt;= nums[i] &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 954 👎 0</span><span class="token comment" spellcheck="true">//哈希表解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> i<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> nums<span class="token punctuation">.</span>length <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//暴力破解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstMissingPositive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>     Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> min<span class="token punctuation">)</span><span class="token punctuation">{</span>            min<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> min<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//原地哈希法</span></code></pre><p>解题思路：</p><p>1、哈希表 我们可以将数组所有的数放入哈希表，随后从 11 开始依次枚举正整数，并判断其是否在哈希表中。</p><p>2、原地哈希：我们对数组进行遍历，对于遍历到的数 x，如果它在 [1, N][1,N] 的范围内，那么就将数组中的第 x-1 个位置（注意：数组下标从 0 开始）打上「标记」。在遍历结束之后，如果所有的位置都被打上了标记，那么答案是 N+1，否则答案是最小的没有打上标记的位置加 1。</p><h4 id="485274-H-指数"><a href="#485274-H-指数" class="headerlink" title="485274. H 指数"></a><a href="https://leetcode-cn.com/problems/h-index/" target="_blank" rel="noopener">485274. H 指数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一位研究者论文被引用次数的数组（被引用次数是非负整数）。编写一个方法，计算出研究者的 h 指数。 </span><span class="token comment" spellcheck="true">// h 指数的定义：h 代表“高引用次数”（high citations），一名科研人员的 h 指数是指他（她）的 （N 篇论文中）总共有 h 篇论文分别被引</span><span class="token comment" spellcheck="true">//用了至少 h 次。且其余的 N - h 篇论文每篇被引用次数 不超过 h 次。 </span><span class="token comment" spellcheck="true">// 例如：某人的 h 指数是 20，这表示他已发表的论文中，每篇被引用了至少 20 次的论文总共有 20 篇。 </span><span class="token comment" spellcheck="true">// 示例：  </span><span class="token comment" spellcheck="true">//输入：citations = [3,0,6,1,5]</span><span class="token comment" spellcheck="true">//输出：3 </span><span class="token comment" spellcheck="true">//解释：给定数组表示研究者总共有 5 篇论文，每篇论文相应的被引用了 3, 0, 6, 1, 5 次。</span><span class="token comment" spellcheck="true">//     由于研究者有 3 篇论文每篇 至少 被引用了 3 次，其余两篇论文每篇被引用 不多于 3 次，所以她的 h 指数是 3。 </span><span class="token comment" spellcheck="true">// 提示：如果 h 有多种可能的值，h 指数是其中最大的那个。 </span><span class="token comment" spellcheck="true">// Related Topics 排序 哈希表 </span><span class="token comment" spellcheck="true">// 👍 129 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hIndex</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> citations<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="453-最小操作次数使数组元素相等"><a href="#453-最小操作次数使数组元素相等" class="headerlink" title="453. 最小操作次数使数组元素相等"></a><a href="https://leetcode-cn.com/problems/minimum-moves-to-equal-array-elements/" target="_blank" rel="noopener">453. 最小操作次数使数组元素相等</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个长度为 n 的 非空 整数数组，每次操作将会使 n - 1 个元素增加 1。找出让数组所有元素相等的最小操作次数。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">//输入：</span><span class="token comment" spellcheck="true">//[1,2,3]</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//3</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//只需要3次操作（注意每次操作会增加两个元素的值）：</span><span class="token comment" spellcheck="true">//[1,2,3]  =>  [2,3,3]  =>  [3,4,3]  =>  [4,4,4]</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 190 👎 0</span><span class="token comment" spellcheck="true">//排序解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">minMoves</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       res <span class="token operator">=</span> res <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//数学解法：</span></code></pre><p>解题思路：先找出数组中的最小值，然后让数组中的每一个值减去最小值,代表着这个数要移动的次数。然后把所有次数累加求和即是结果。</p><h4 id="665-非递减数列"><a href="#665-非递减数列" class="headerlink" title="665. 非递减数列"></a><a href="https://leetcode-cn.com/problems/non-decreasing-array/" target="_blank" rel="noopener">665. 非递减数列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个长度为 n 的整数数组，请你判断在 最多 改变 1 个元素的情况下，该数组能否变成一个非递减数列。 </span><span class="token comment" spellcheck="true">// 我们是这样定义一个非递减数列的： 对于数组中任意的 i (0 &lt;= i &lt;= n-2)，总满足 nums[i] &lt;= nums[i + 1]。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: nums = [4,2,3]</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释: 你可以通过把第一个4变成1来使得它成为一个非递减数列。</span><span class="token comment" spellcheck="true">// 示例 2:  </span><span class="token comment" spellcheck="true">//输入: nums = [4,2,1]</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">//解释: 你不能在只改变一个元素的情况下将其变为非递减数列。</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= n &lt;= 10 ^ 4 </span><span class="token comment" spellcheck="true">// - 10 ^ 5 &lt;= nums[i] &lt;= 10 ^ 5 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 532 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkPossibility</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//出现递减</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">||</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>              count<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>               count<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> count<span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路:贪心算法，遍历数组，查看是哪个数遍历数组，如果遇到递减：</p><ul><li>还能修改：<ul><li>修改方案1：将nums[i]缩小至nums[i 1 1]；</li><li>修改方案2：将nums[i - 1]放大至nums[i]；</li></ul></li></ul><h4 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener">283. 移动零</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个数组 nums，编写一个函数将所有 0 移动到数组的末尾，同时保持非零元素的相对顺序。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: [0,1,0,3,12]</span><span class="token comment" spellcheck="true">//输出: [1,3,12,0,0] </span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">// 必须在原数组上操作，不能拷贝额外的数组。 </span><span class="token comment" spellcheck="true">// 尽量减少操作次数。 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数组 双指针 </span><span class="token comment" spellcheck="true">// 👍 955 👎 0</span><span class="token comment" spellcheck="true">//暴力解法 使用了额外数组,定义一个新数组，不等于0的放前面，后面的都是0了</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> temp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             temp<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             j<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双指针交换</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span><span class="token punctuation">;</span>             nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>             start<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双指针解法(快慢指针) 优化上面交换方法，减少操作次数</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveZeroes</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">==</span> null <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>      <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             nums<span class="token punctuation">[</span>start<span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>             start<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>start<span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路：</p><h4 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode-cn.com/problems/container-with-most-water/" target="_blank" rel="noopener">11. 盛最多水的容器</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你 n 个非负整数 a1，a2，...，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i,</span><span class="token comment" spellcheck="true">//ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</span><span class="token comment" spellcheck="true">// 说明：你不能倾斜容器。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输出：49</span><span class="token comment" spellcheck="true">//解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：height = [1,1]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：height = [4,3,2,1,4]</span><span class="token comment" spellcheck="true">//输出：16</span><span class="token comment" spellcheck="true">// 示例 4：</span><span class="token comment" spellcheck="true">//输入：height = [1,2,1]</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// n = height.length</span><span class="token comment" spellcheck="true">// 2 &lt;= n &lt;= 3 * 104</span><span class="token comment" spellcheck="true">// 0 &lt;= height[i] &lt;= 3 * 104</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组 双指针</span><span class="token comment" spellcheck="true">// 👍 2215 👎 0</span><span class="token comment" spellcheck="true">//暴力破解，双层循环找出最大值</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>height<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             maxCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>j <span class="token operator">-</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> maxCount<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> maxCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双指针解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxArea</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> height<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> height<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">,</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>right <span class="token operator">-</span> left<span class="token punctuation">)</span><span class="token punctuation">,</span> maxCount<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>height<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> height<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token operator">++</span>left<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token operator">--</span>right<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxCount<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode-cn.com/problems/climbing-stairs/" target="_blank" rel="noopener">70. 爬楼梯</a></h4><h3 id="二维数组及滚动数组"><a href="#二维数组及滚动数组" class="headerlink" title="二维数组及滚动数组"></a>二维数组及滚动数组</h3><h4 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode-cn.com/problems/pascals-triangle/" target="_blank" rel="noopener">118. 杨辉三角</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 </span><span class="token comment" spellcheck="true">// 在杨辉三角中，每个数是它左上方和右上方的数的和。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: 5</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//     [1],</span><span class="token comment" spellcheck="true">//    [1,1],</span><span class="token comment" spellcheck="true">//   [1,2,1],</span><span class="token comment" spellcheck="true">//  [1,3,3,1],</span><span class="token comment" spellcheck="true">// [1,4,6,4,1]</span><span class="token comment" spellcheck="true">//] </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 454 👎 0</span><span class="token comment" spellcheck="true">//数学解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>      List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span>  res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>numRows<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>                  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">else</span><span class="token punctuation">{</span>                 list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="119-杨辉三角-II"><a href="#119-杨辉三角-II" class="headerlink" title="119. 杨辉三角 II"></a><a href="https://leetcode-cn.com/problems/pascals-triangle-ii/" target="_blank" rel="noopener">119. 杨辉三角 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个非负索引 k，其中 k ≤ 33，返回杨辉三角的第 k 行。 </span><span class="token comment" spellcheck="true">// 在杨辉三角中，每个数是它左上方和右上方的数的和。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: 3</span><span class="token comment" spellcheck="true">//输出: [1,3,3,1]</span><span class="token comment" spellcheck="true">// 进阶： </span><span class="token comment" spellcheck="true">// 你可以优化你的算法到 O(k) 空间复杂度吗？ </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 263 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token function">getRow</span><span class="token punctuation">(</span><span class="token keyword">int</span> rowIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>       List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span>  res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>rowIndex<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>i<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">==</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>                  list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>              <span class="token keyword">else</span><span class="token punctuation">{</span>                 list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rowIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="数组的旋转"><a href="#数组的旋转" class="headerlink" title="数组的旋转"></a>数组的旋转</h3><h4 id="189-旋转数组"><a href="#189-旋转数组" class="headerlink" title="189. 旋转数组"></a><a href="https://leetcode-cn.com/problems/rotate-array/" target="_blank" rel="noopener">189. 旋转数组</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个数组，将数组中的元素向右移动 k 个位置，其中 k 是非负数。 </span><span class="token comment" spellcheck="true">// 进阶： </span><span class="token comment" spellcheck="true">// 尽可能想出更多的解决方案，至少有三种不同的方法可以解决这个问题。 </span><span class="token comment" spellcheck="true">// 你可以使用空间复杂度为 O(1) 的 原地 算法解决这个问题吗？ </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: nums = [1,2,3,4,5,6,7], k = 3</span><span class="token comment" spellcheck="true">//输出: [5,6,7,1,2,3,4]</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//向右旋转 1 步: [7,1,2,3,4,5,6]</span><span class="token comment" spellcheck="true">//向右旋转 2 步: [6,7,1,2,3,4,5]</span><span class="token comment" spellcheck="true">//向右旋转 3 步: [5,6,7,1,2,3,4]</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入：nums = [-1,-100,3,99], k = 2</span><span class="token comment" spellcheck="true">//输出：[3,99,-1,-100]</span><span class="token comment" spellcheck="true">//解释: </span><span class="token comment" spellcheck="true">//向右旋转 1 步: [99,-1,-100,3]</span><span class="token comment" spellcheck="true">//向右旋转 2 步: [3,99,-1,-100] </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= nums.length &lt;= 2 * 104 </span><span class="token comment" spellcheck="true">// -231 &lt;= nums[i] &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// 0 &lt;= k &lt;= 105 </span><span class="token comment" spellcheck="true">// Related Topics 数组 </span><span class="token comment" spellcheck="true">// 👍 880 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">rotate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="520-检测大写字母"><a href="#520-检测大写字母" class="headerlink" title="520. 检测大写字母"></a><a href="https://leetcode-cn.com/problems/detect-capital/" target="_blank" rel="noopener">520. 检测大写字母</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个单词，你需要判断单词的大写使用是否正确。 </span><span class="token comment" spellcheck="true">// 我们定义，在以下情况时，单词的大写用法是正确的： </span><span class="token comment" spellcheck="true">// 全部字母都是大写，比如"USA"。 </span><span class="token comment" spellcheck="true">// 单词中所有字母都不是大写，比如"leetcode"。 </span><span class="token comment" spellcheck="true">// 如果单词不只含有一个字母，只有首字母大写， 比如 "Google"。 </span><span class="token comment" spellcheck="true">// 否则，我们定义这个单词没有正确使用大写字母。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: "USA"</span><span class="token comment" spellcheck="true">//输出: True</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: "FlaG"</span><span class="token comment" spellcheck="true">//输出: False</span><span class="token comment" spellcheck="true">// 注意: 输入是由大写和小写拉丁字母组成的非空单词。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 123 👎 0</span><span class="token comment" spellcheck="true">//解题思路：字符串转字符串数组，判断大写个数，全大写，全小写校验通过，第一个字符大写，校验通过</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">detectCapitalUse</span><span class="token punctuation">(</span>String word<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> word<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token string">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> count<span class="token operator">==</span>chars<span class="token punctuation">.</span>length <span class="token operator">||</span> <span class="token punctuation">(</span>count<span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">>=</span><span class="token string">'A'</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'Z'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="125-验证回文串"><a href="#125-验证回文串" class="headerlink" title="125. 验证回文串"></a><a href="https://leetcode-cn.com/problems/valid-palindrome/" target="_blank" rel="noopener">125. 验证回文串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。 </span><span class="token comment" spellcheck="true">// 说明：本题中，我们将空字符串定义为有效的回文串。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: "A man, a plan, a canal: Panama"</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: "race a car"</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">// Related Topics 双指针 字符串 </span><span class="token comment" spellcheck="true">// 👍 330 👎 0</span><span class="token comment" spellcheck="true">//双指针解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">>=</span><span class="token string">'a'</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span><span class="token string">'z'</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token string">'0'</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'9'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> sb<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14. 最长公共前缀"></a><a href="https://leetcode-cn.com/problems/longest-common-prefix/" target="_blank" rel="noopener">14. 最长公共前缀</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//编写一个函数来查找字符串数组中的最长公共前缀。 </span><span class="token comment" spellcheck="true">// 如果不存在公共前缀，返回空字符串 ""。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：strs = ["flower","flow","flight"]</span><span class="token comment" spellcheck="true">//输出："fl"</span><span class="token comment" spellcheck="true">// 示例 2：  </span><span class="token comment" spellcheck="true">//输入：strs = ["dog","racecar","car"]</span><span class="token comment" spellcheck="true">//输出：""</span><span class="token comment" spellcheck="true">//解释：输入不存在公共前缀。 </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= strs.length &lt;= 200 </span><span class="token comment" spellcheck="true">// 0 &lt;= strs[i].length &lt;= 200 </span><span class="token comment" spellcheck="true">// strs[i] 仅由小写英文字母组成 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 1466 👎 0</span><span class="token comment" spellcheck="true">//解题思路：纵向比较字符串的位置值是否相等</span><span class="token comment" spellcheck="true">//flower</span><span class="token comment" spellcheck="true">//flow</span><span class="token comment" spellcheck="true">//flight</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestCommonPrefix</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> strs <span class="token operator">||</span> strs<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> c <span class="token operator">=</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span> strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> strs<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> c<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> strs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="434-字符串中的单词数"><a href="#434-字符串中的单词数" class="headerlink" title="434. 字符串中的单词数"></a><a href="https://leetcode-cn.com/problems/number-of-segments-in-a-string/" target="_blank" rel="noopener">434. 字符串中的单词数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//统计字符串中的单词个数，这里的单词指的是连续的不是空格的字符。 </span><span class="token comment" spellcheck="true">// 请注意，你可以假定字符串里不包括任何不可打印的字符。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: "Hello, my name is John"</span><span class="token comment" spellcheck="true">//输出: 5</span><span class="token comment" spellcheck="true">//解释: 这里的单词是指连续的不是空格的字符，所以 "Hello," 算作 1 个单词。</span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 77 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSegments</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">''</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路：计算单词的数量，就等同于计数单词开始的下标个数。因此，只需要定义好下标的条件，就可以遍历整个字符串，检测每个下标。定义如下：若该下标前为空格（或者为初始下标），且自身不为空格，则其为单词开始的下标。该条件可以以常数时间检测。最后，返回满足条件的下标个数。</p><h4 id="58-最后一个单词的长度"><a href="#58-最后一个单词的长度" class="headerlink" title="58. 最后一个单词的长度"></a><a href="https://leetcode-cn.com/problems/length-of-last-word/" target="_blank" rel="noopener">58. 最后一个单词的长度</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个字符串 s，由若干单词组成，单词之间用空格隔开。返回字符串中最后一个单词的长度。如果不存在最后一个单词，请返回 0 。 </span><span class="token comment" spellcheck="true">// 单词 是指仅由字母组成、不包含任何空格字符的最大子字符串。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：s = "Hello World"</span><span class="token comment" spellcheck="true">//输出：5</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：s = " "</span><span class="token comment" spellcheck="true">//输出：0</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 104 </span><span class="token comment" spellcheck="true">// s 仅有英文字母和空格 ' ' 组成 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 280 👎 0</span><span class="token comment" spellcheck="true">//字符串分割法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null <span class="token operator">||</span> s<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span>length <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> s1<span class="token punctuation">[</span>s1<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//从尾部开始遍历字符串</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLastWord</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null <span class="token operator">||</span> s<span class="token operator">==</span><span class="token string">""</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">char</span> k <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">!=</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               count<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> k <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">break</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="344-反转字符串"><a href="#344-反转字符串" class="headerlink" title="344. 反转字符串"></a><a href="https://leetcode-cn.com/problems/reverse-string/" target="_blank" rel="noopener">344. 反转字符串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。 </span><span class="token comment" spellcheck="true">// 不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。 </span><span class="token comment" spellcheck="true">// 你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：["h","e","l","l","o"]</span><span class="token comment" spellcheck="true">//输出：["o","l","l","e","h"]</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：["H","a","n","n","a","h"]</span><span class="token comment" spellcheck="true">//输出：["h","a","n","n","a","H"] </span><span class="token comment" spellcheck="true">// Related Topics 双指针 字符串 </span><span class="token comment" spellcheck="true">// 👍 358 👎 0</span><span class="token comment" spellcheck="true">//暴力破解，双层循环交换</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null <span class="token operator">||</span> s<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                s<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双指针解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseString</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null <span class="token operator">||</span> s<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">[</span>left<span class="token punctuation">]</span><span class="token punctuation">;</span>            s<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">;</span>            s<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            left<span class="token operator">++</span><span class="token punctuation">;</span>            right<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="541-反转字符串-II"><a href="#541-反转字符串-II" class="headerlink" title="541. 反转字符串 II"></a><a href="https://leetcode-cn.com/problems/reverse-string-ii/" target="_blank" rel="noopener">541. 反转字符串 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串 s 和一个整数 k，你需要对从字符串开头算起的每隔 2k 个字符的前 k 个字符进行反转。 </span><span class="token comment" spellcheck="true">// 如果剩余字符少于 k 个，则将剩余字符全部反转。 </span><span class="token comment" spellcheck="true">// 如果剩余字符小于 2k 但大于或等于 k 个，则反转前 k 个字符，其余字符保持原样。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: s = "abcdefg", k = 2</span><span class="token comment" spellcheck="true">//输出: "bacdfeg"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 该字符串只包含小写英文字母。 </span><span class="token comment" spellcheck="true">// 给定字符串的长度和 k 在 [1, 10000] 范围内。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 116 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseStr</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>start<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>start <span class="token operator">=</span> start<span class="token operator">+</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> i<span class="token operator">=</span> start<span class="token punctuation">;</span>            <span class="token keyword">int</span> j<span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>start<span class="token operator">+</span>k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="557-反转字符串中的单词-III"><a href="#557-反转字符串中的单词-III" class="headerlink" title="557. 反转字符串中的单词 III"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii/" target="_blank" rel="noopener">557. 反转字符串中的单词 III</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">// 输入："Let's take LeetCode contest"</span><span class="token comment" spellcheck="true">//输出："s'teL ekat edoCteeL tsetnoc"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 274 👎 0</span><span class="token comment" spellcheck="true">//暴力破解</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">==</span>null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> s<span class="token operator">==</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           String s1 <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>i <span class="token operator">!=</span>ans<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="151-翻转字符串里的单词"><a href="#151-翻转字符串里的单词" class="headerlink" title="151. 翻转字符串里的单词"></a><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">151. 翻转字符串里的单词</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，逐个翻转字符串中的每个单词。 </span><span class="token comment" spellcheck="true">// 说明： </span><span class="token comment" spellcheck="true">// 无空格字符构成一个 单词 。 </span><span class="token comment" spellcheck="true">// 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。 </span><span class="token comment" spellcheck="true">// 如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入："the sky is blue"</span><span class="token comment" spellcheck="true">//输出："blue is sky the"</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入："  hello world!  "</span><span class="token comment" spellcheck="true">//输出："world! hello"</span><span class="token comment" spellcheck="true">//解释：输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入："a good   example"</span><span class="token comment" spellcheck="true">//输出："example good a"</span><span class="token comment" spellcheck="true">//解释：如果两个单词间有多余的空格，将反转后单词间的空格减少到只含一个。</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">// 输入：s = "  Bob    Loves  Alice   "</span><span class="token comment" spellcheck="true">//输出："Alice Loves Bob"</span><span class="token comment" spellcheck="true">// 示例 5： </span><span class="token comment" spellcheck="true">// 输入：s = "Alice does not even like bob"</span><span class="token comment" spellcheck="true">//输出："bob like even not does Alice"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 104 </span><span class="token comment" spellcheck="true">// s 包含英文大小写字母、数字和空格 ' ' </span><span class="token comment" spellcheck="true">// s 中 至少存在一个 单词 </span><span class="token comment" spellcheck="true">// 进阶： </span><span class="token comment" spellcheck="true">// 请尝试使用 O(1) 额外空间复杂度的原地解法。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 281 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>s <span class="token operator">==</span> null <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> null<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     String<span class="token punctuation">[</span><span class="token punctuation">]</span> s1 <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>s1<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> null <span class="token operator">||</span> s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">continue</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="387-字符串中的第一个唯一字符"><a href="#387-字符串中的第一个唯一字符" class="headerlink" title="387. 字符串中的第一个唯一字符"></a><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string/" target="_blank" rel="noopener">387. 字符串中的第一个唯一字符</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">// s = "leetcode"</span><span class="token comment" spellcheck="true">//返回 0</span><span class="token comment" spellcheck="true">//s = "loveleetcode"</span><span class="token comment" spellcheck="true">//返回 2</span><span class="token comment" spellcheck="true">// 提示：你可以假定该字符串只包含小写字母。 </span><span class="token comment" spellcheck="true">// Related Topics 哈希表 字符串 </span><span class="token comment" spellcheck="true">// 👍 351 👎 0</span><span class="token comment" spellcheck="true">//暴露解法 超时</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>         <span class="token keyword">char</span> ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> ans<span class="token punctuation">)</span><span class="token punctuation">{</span>               count<span class="token operator">++</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> i<span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//HashMap 计数</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">firstUniqChar</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer integer <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> integer <span class="token operator">||</span> integer <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> integer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> i<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="389-找不同"><a href="#389-找不同" class="headerlink" title="389. 找不同"></a><a href="https://leetcode-cn.com/problems/find-the-difference/" target="_blank" rel="noopener">389. 找不同</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个字符串 s 和 t，它们只包含小写字母。 </span><span class="token comment" spellcheck="true">// 字符串 t 由字符串 s 随机重排，然后在随机位置添加一个字母。 </span><span class="token comment" spellcheck="true">// 请找出在 t 中被添加的字母。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：s = "abcd", t = "abcde"</span><span class="token comment" spellcheck="true">//输出："e"</span><span class="token comment" spellcheck="true">//解释：'e' 是那个被添加的字母。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：s = "", t = "y"</span><span class="token comment" spellcheck="true">//输出："y"</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：s = "a", t = "aa"</span><span class="token comment" spellcheck="true">//输出："a"</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">// 输入：s = "ae", t = "aea"</span><span class="token comment" spellcheck="true">//输出："a"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 1000 </span><span class="token comment" spellcheck="true">// t.length == s.length + 1 </span><span class="token comment" spellcheck="true">// s 和 t 只包含小写字母 </span><span class="token comment" spellcheck="true">// Related Topics 位运算 哈希表 </span><span class="token comment" spellcheck="true">// 👍 235 👎 0</span><span class="token comment" spellcheck="true">//解题思路1：HashMap 分别统计s、t字母个数，遍历t,如果字母个数不相等，则返回字母。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">findTheDifference</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Integer integer <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> integer <span class="token operator">||</span> integer <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> integer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            Integer integer <span class="token operator">=</span> map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>null <span class="token operator">==</span> integer <span class="token operator">||</span> integer <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                map1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                map1<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> integer <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> map1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">' '</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法2：将字符串 *s* 中每个字符的 ASCII 码的值求和，得到 *A_s*；对字符串 *t* 同样的方法得到 *A_t*。两者的差值 *A_t-A_s* 即代表了被添加的字符。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">findTheDifference</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> anst <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">int</span> anss <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          anss <span class="token operator">=</span> anss <span class="token operator">+</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          anst <span class="token operator">=</span> anst<span class="token operator">+</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span><span class="token punctuation">(</span>anst <span class="token operator">-</span> anss<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//把字符串s和t合并，然后遍历合并的每个字符，判断集合set中是否有这个字符，如果有就移除，否则就加入到集合set中。最后集合set中只有一个字符，这个字符就是我们要求的。</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">char</span> <span class="token function">findTheDifference</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>Character<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> charArr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> charArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>charArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                set<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>charArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">else</span>                set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>charArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> set<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>    </code></pre><h4 id="383-赎金信"><a href="#383-赎金信" class="headerlink" title="383. 赎金信"></a><a href="https://leetcode-cn.com/problems/ransom-note/" target="_blank" rel="noopener">383. 赎金信</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个赎金信 (ransom) 字符串和一个杂志(magazine)字符串，判断第一个字符串 ransom 能不能由第二个字符串 magazines 里面</span><span class="token comment" spellcheck="true">//的字符构成。如果可以构成，返回 true ；否则返回 false。 </span><span class="token comment" spellcheck="true">// (题目说明：为了不暴露赎金信字迹，要从杂志上搜索各个需要的字母，组成单词来表达意思。杂志字符串中的每个字符只能在赎金信字符串中使用一次。) </span><span class="token comment" spellcheck="true">// 注意： </span><span class="token comment" spellcheck="true">// 你可以假设两个字符串均只含有小写字母。 </span><span class="token comment" spellcheck="true">// canConstruct("a", "b") -> false</span><span class="token comment" spellcheck="true">//canConstruct("aa", "ab") -> false</span><span class="token comment" spellcheck="true">//canConstruct("aa", "aab") -> true</span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 135 👎 0</span><span class="token comment" spellcheck="true">//HashMap 分别统计赎金与杂志里的字符个数，如果杂志里没有赎金里的字符或者赎金里的字符个数大于杂志里的字符个数，返回false,不然返回true</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canConstruct</span><span class="token punctuation">(</span>String ransomNote<span class="token punctuation">,</span> String magazine<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> mMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> rMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> magazine<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer count <span class="token operator">=</span> mMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>magazine<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> null <span class="token operator">||</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>magazine<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                mMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>magazine<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Integer count <span class="token operator">=</span> rMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> null <span class="token operator">||</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                rMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                rMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>ransomNote<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> ransomNote<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> ans <span class="token operator">=</span> ransomNote<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> rMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>rMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">></span> mMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="242-有效的字母异位词"><a href="#242-有效的字母异位词" class="headerlink" title="242. 有效的字母异位词"></a><a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242. 有效的字母异位词</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: s = "anagram", t = "nagaram"</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: s = "rat", t = "car"</span><span class="token comment" spellcheck="true">//输出: false </span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">//你可以假设字符串只包含小写字母。 </span><span class="token comment" spellcheck="true">// 进阶: </span><span class="token comment" spellcheck="true">//如果输入字符串包含 unicode 字符怎么办？你能否调整你的解法来应对这种情况？ </span><span class="token comment" spellcheck="true">// Related Topics 排序 哈希表 </span><span class="token comment" spellcheck="true">// 👍 345 👎 0</span><span class="token comment" spellcheck="true">//HashMap 统计单次个数</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> sMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             sMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> sMap<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          Integer nums <span class="token operator">=</span>  sMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>nums <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>              sMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>nums<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法2 使用数组保存字母个数，由于内存是连续的，-'a' 表示对应字母索引个数</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isAnagram</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      ans<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       ans<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'a'</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>        <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>  </code></pre><h4 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49. 字母异位词分组</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入: ["eat", "tea", "tan", "ate", "nat", "bat"]</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//  ["ate","eat","tea"],</span><span class="token comment" spellcheck="true">//  ["nat","tan"],</span><span class="token comment" spellcheck="true">//  ["bat"]</span><span class="token comment" spellcheck="true">//] </span><span class="token comment" spellcheck="true">// 说明： </span><span class="token comment" spellcheck="true">// 所有输入均为小写字母。 </span><span class="token comment" spellcheck="true">// 不考虑答案输出的顺序。 </span><span class="token comment" spellcheck="true">// Related Topics 哈希表 字符串 </span><span class="token comment" spellcheck="true">// 👍 668 👎 0</span><span class="token comment" spellcheck="true">//HashMap 解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>strs<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>           String key <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>           List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>list <span class="token operator">==</span> null <span class="token operator">||</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>strs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Java8写法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span>            <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>str <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 返回 str 排序后的结果。</span>                <span class="token comment" spellcheck="true">// 按排序后的结果来grouping by，算子类似于 sql 里的 group by。</span>                <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一行代码</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">groupAnagrams</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strs<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>str <span class="token operator">-</span><span class="token operator">></span> str<span class="token punctuation">.</span><span class="token function">chars</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>StringBuilder<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">,</span> StringBuilder<span class="token operator">:</span><span class="token operator">:</span>appendCodePoint<span class="token punctuation">,</span> StringBuilder<span class="token operator">:</span><span class="token operator">:</span>append<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="451-根据字符出现频率排序"><a href="#451-根据字符出现频率排序" class="headerlink" title="451. 根据字符出现频率排序"></a><a href="https://leetcode-cn.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">451. 根据字符出现频率排序</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，请将字符串里的字符按照出现的频率降序排列。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//"tree"</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//"eert"</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//'e'出现两次，'r'和't'都只出现一次。</span><span class="token comment" spellcheck="true">//因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//"cccaaa"</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//"cccaaa"</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。</span><span class="token comment" spellcheck="true">//注意"cacaca"是不正确的，因为相同的字母必须放在一起。</span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//"Aabb"</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//"bbAa"</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。</span><span class="token comment" spellcheck="true">//注意'A'和'a'被认为是两种不同的字符。</span><span class="token comment" spellcheck="true">// Related Topics 堆 哈希表 </span><span class="token comment" spellcheck="true">// 👍 220 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">frequencySort</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       Integer num <span class="token operator">=</span>  map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> i<span class="token punctuation">)</span><span class="token punctuation">{</span>              sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="423-从英文中重建数字"><a href="#423-从英文中重建数字" class="headerlink" title="423. 从英文中重建数字"></a><a href="https://leetcode-cn.com/problems/reconstruct-original-digits-from-english/" target="_blank" rel="noopener">423. 从英文中重建数字</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个非空字符串，其中包含字母顺序打乱的英文单词表示的数字0-9。按升序输出原始的数字。 </span><span class="token comment" spellcheck="true">// 注意: </span><span class="token comment" spellcheck="true">// 输入只包含小写英文字母。 </span><span class="token comment" spellcheck="true">// 输入保证合法并可以转换为原始的数字，这意味着像 "abc" 或 "zerone" 的输入是不允许的。 </span><span class="token comment" spellcheck="true">// 输入字符串的长度小于 50,000。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: "owoztneoer"</span><span class="token comment" spellcheck="true">//输出: "012" (zeroonetwo)</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: "fviefuro"</span><span class="token comment" spellcheck="true">//输出: "45" (fourfive)</span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 56 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">originalDigits</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="657-机器人能否返回原点"><a href="#657-机器人能否返回原点" class="headerlink" title="657. 机器人能否返回原点"></a><a href="https://leetcode-cn.com/problems/robot-return-to-origin/" target="_blank" rel="noopener">657. 机器人能否返回原点</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在二维平面上，有一个机器人从原点 (0, 0) 开始。给出它的移动顺序，判断这个机器人在完成移动后是否在 (0, 0) 处结束。 </span><span class="token comment" spellcheck="true">// 移动顺序由字符串表示。字符 move[i] 表示其第 i 次移动。机器人的有效动作有 R（右），L（左），U（上）和 D（下）。如果机器人在完成所有动作后</span><span class="token comment" spellcheck="true">//返回原点，则返回 true。否则，返回 false。 </span><span class="token comment" spellcheck="true">// 注意：机器人“面朝”的方向无关紧要。 “R” 将始终使机器人向右移动一次，“L” 将始终向左移动等。此外，假设每次移动机器人的移动幅度相同。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: "UD"</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释：机器人向上移动一次，然后向下移动一次。所有动作都具有相同的幅度，因此它最终回到它开始的原点。因此，我们返回 true。 </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: "LL"</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">//解释：机器人向左移动两次。它最终位于原点的左侧，距原点有两次 “移动” 的距离。我们返回 false，因为它在移动结束时没有返回原点。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 189 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judgeCircle</span><span class="token punctuation">(</span>String moves<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> x <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> y<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>moves<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>moves<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            x<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>moves<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'R'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            x<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>moves<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'U'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            y<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>moves<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'D'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           y<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> x<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> y<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="551-学生出勤记录-I"><a href="#551-学生出勤记录-I" class="headerlink" title="551. 学生出勤记录 I"></a><a href="https://leetcode-cn.com/problems/student-attendance-record-i/" target="_blank" rel="noopener">551. 学生出勤记录 I</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串来代表一个学生的出勤记录，这个记录仅包含以下三个字符： </span><span class="token comment" spellcheck="true">// 'A' : Absent，缺勤 </span><span class="token comment" spellcheck="true">// 'L' : Late，迟到 </span><span class="token comment" spellcheck="true">// 'P' : Present，到场 </span><span class="token comment" spellcheck="true">// 如果一个学生的出勤记录中不超过一个'A'(缺勤)并且不超过两个连续的'L'(迟到),那么这个学生会被奖赏。 </span><span class="token comment" spellcheck="true">// 你需要根据这个学生的出勤记录判断他是否会被奖赏。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: "PPALLP"</span><span class="token comment" spellcheck="true">//输出: True</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: "PPALLL"</span><span class="token comment" spellcheck="true">//输出: False</span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 69 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkRecord</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token operator">==</span>null <span class="token operator">||</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'L'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'L'</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化时间复杂度</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkRecord</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> aCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> lCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            lCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            aCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>aCount<span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'L'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            lCount<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>lCount<span class="token operator">></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            lCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一行代码解决</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkRecord</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>s<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"LLL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="696-计数二进制子串"><a href="#696-计数二进制子串" class="headerlink" title="696. 计数二进制子串"></a><a href="https://leetcode-cn.com/problems/count-binary-substrings/" target="_blank" rel="noopener">696. 计数二进制子串</a></h4><pre><code>//给定一个字符串 s，计算具有相同数量 0 和 1 的非空（连续）子字符串的数量，并且这些子字符串中的所有 0 和所有 1 都是连续的。 // 重复出现的子串要计算它们出现的次数。 // 示例 1 : //输入: &quot;00110011&quot;//输出: 6//解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。//请注意，一些重复出现的子串要计算它们出现的次数。//另外，“00110011”不是有效的子串，因为所有的0（和1）没有组合在一起。// 示例 2 : //输入: &quot;10101&quot;//输出: 4//解释: 有4个子串：“10”，“01”，“10”，“01”，它们具有相同数量的连续1和0。// 提示： // s.length 在1到50,000之间。 // s 只包含“0”或“1”字符。 // Related Topics 字符串 // 👍 336 👎 0class Solution {    public int countBinarySubstrings(String s) {    }}</code></pre><h4 id="535-TinyURL-的加密与解密"><a href="#535-TinyURL-的加密与解密" class="headerlink" title="535. TinyURL 的加密与解密"></a><a href="https://leetcode-cn.com/problems/encode-and-decode-tinyurl/" target="_blank" rel="noopener">535. TinyURL 的加密与解密</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//TinyURL是一种URL简化服务， 比如：当你输入一个URL https://leetcode.com/problems/design-tinyurl 时</span><span class="token comment" spellcheck="true">//，它将返回一个简化的URL http://tinyurl.com/4e9iAk. </span><span class="token comment" spellcheck="true">// 要求：设计一个 TinyURL 的加密 encode 和解密 decode 的方法。你的加密和解密算法如何设计和运作是没有限制的，你只需要保证一个URL可</span><span class="token comment" spellcheck="true">//以被加密成一个TinyURL，并且这个TinyURL可以用解密方法恢复成原本的URL。 </span><span class="token comment" spellcheck="true">// Related Topics 哈希表 数学 </span><span class="token comment" spellcheck="true">// 👍 113 👎 0</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Codec</span> <span class="token punctuation">{</span>    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>String<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Encodes a URL to a shortened URL.</span>    <span class="token keyword">public</span> String <span class="token function">encode</span><span class="token punctuation">(</span>String longUrl<span class="token punctuation">)</span> <span class="token punctuation">{</span>      map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>longUrl<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>longUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>longUrl<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Decodes a shortened URL to its original URL.</span>    <span class="token keyword">public</span> String <span class="token function">decode</span><span class="token punctuation">(</span>String shortUrl<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>shortUrl<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="299-猜数字游戏"><a href="#299-猜数字游戏" class="headerlink" title="299. 猜数字游戏"></a><a href="https://leetcode-cn.com/problems/bulls-and-cows/" target="_blank" rel="noopener">299. 猜数字游戏</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//你在和朋友一起玩 猜数字（Bulls and Cows）游戏，该游戏规则如下： </span><span class="token comment" spellcheck="true">// 你写出一个秘密数字，并请朋友猜这个数字是多少。 </span><span class="token comment" spellcheck="true">// 朋友每猜测一次，你就会给他一个提示，告诉他的猜测数字中有多少位属于数字和确切位置都猜对了（称为“Bulls”, 公牛），有多少位属于数字猜对了但是位置不对</span><span class="token comment" spellcheck="true">//（称为“Cows”, 奶牛）。 </span><span class="token comment" spellcheck="true">// 朋友根据提示继续猜，直到猜出秘密数字。 </span><span class="token comment" spellcheck="true">// 请写出一个根据秘密数字和朋友的猜测数返回提示的函数，返回字符串的格式为 xAyB ，x 和 y 都是数字，A 表示公牛，用 B 表示奶牛。 </span><span class="token comment" spellcheck="true">// xA 表示有 x 位数字出现在秘密数字中，且位置都与秘密数字一致。 </span><span class="token comment" spellcheck="true">// yB 表示有 y 位数字出现在秘密数字中，但位置与秘密数字不一致。 </span><span class="token comment" spellcheck="true">// 请注意秘密数字和朋友的猜测数都可能含有重复数字，每位数字只能统计一次。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: secret = "1807", guess = "7810"</span><span class="token comment" spellcheck="true">//输出: "1A3B"</span><span class="token comment" spellcheck="true">//解释: 1 公牛和 3 奶牛。公牛是 8，奶牛是 0, 1 和 7。 </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: secret = "1123", guess = "0111"</span><span class="token comment" spellcheck="true">//输出: "1A1B"</span><span class="token comment" spellcheck="true">//解释: 朋友猜测数中的第一个 1 是公牛，第二个或第三个 1 可被视为奶牛。 </span><span class="token comment" spellcheck="true">// 说明: 你可以假设秘密数字和朋友的猜测数都只包含数字，并且它们的长度永远相等。 </span><span class="token comment" spellcheck="true">// Related Topics 哈希表 </span><span class="token comment" spellcheck="true">// 👍 119 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">getHint</span><span class="token punctuation">(</span>String secret<span class="token punctuation">,</span> String guess<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> countA <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> countB <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> secret<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>secret<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> guess<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> countA<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>guess<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">]</span><span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> countB<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>secret<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'0'</span><span class="token punctuation">]</span><span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> countB<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> countA <span class="token operator">+</span> <span class="token string">"A"</span> <span class="token operator">+</span> countB <span class="token operator">+</span> <span class="token string">"B"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="412-Fizz-Buzz"><a href="#412-Fizz-Buzz" class="headerlink" title="412. Fizz Buzz"></a><a href="https://leetcode-cn.com/problems/fizz-buzz/" target="_blank" rel="noopener">412. Fizz Buzz</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//写一个程序，输出从 1 到 n 数字的字符串表示。</span><span class="token comment" spellcheck="true">// 1. 如果 n 是3的倍数，输出“Fizz”；</span><span class="token comment" spellcheck="true">// 2. 如果 n 是5的倍数，输出“Buzz”；</span><span class="token comment" spellcheck="true">// 3.如果 n 同时是3和5的倍数，输出 “FizzBuzz”。</span><span class="token comment" spellcheck="true">// 示例：</span><span class="token comment" spellcheck="true">// n = 15,</span><span class="token comment" spellcheck="true">//返回:</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//    "1",</span><span class="token comment" spellcheck="true">//    "2",</span><span class="token comment" spellcheck="true">//    "Fizz",</span><span class="token comment" spellcheck="true">//    "4",</span><span class="token comment" spellcheck="true">//    "Buzz",</span><span class="token comment" spellcheck="true">//    "Fizz",</span><span class="token comment" spellcheck="true">//    "7",</span><span class="token comment" spellcheck="true">//    "8",</span><span class="token comment" spellcheck="true">//    "Fizz",</span><span class="token comment" spellcheck="true">//    "Buzz",</span><span class="token comment" spellcheck="true">//    "11",</span><span class="token comment" spellcheck="true">//    "Fizz",</span><span class="token comment" spellcheck="true">//    "13",</span><span class="token comment" spellcheck="true">//    "14",</span><span class="token comment" spellcheck="true">//    "FizzBuzz"</span><span class="token comment" spellcheck="true">//]</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 👍 85 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">fizzBuzz</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Fizz"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Buzz"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> i <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"FizzBuzz"</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="506-相对名次"><a href="#506-相对名次" class="headerlink" title="506. 相对名次"></a><a href="https://leetcode-cn.com/problems/relative-ranks/" target="_blank" rel="noopener">506. 相对名次</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给出 N 名运动员的成绩，找出他们的相对名次并授予前三名对应的奖牌。前三名运动员将会被分别授予 “金牌”，“银牌” 和“ 铜牌”（"Gold Medal",</span><span class="token comment" spellcheck="true">// "Silver Medal", "Bronze Medal"）。</span><span class="token comment" spellcheck="true">// (注：分数越高的选手，排名越靠前。)</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">//输入: [5, 4, 3, 2, 1]</span><span class="token comment" spellcheck="true">//输出: ["Gold Medal", "Silver Medal", "Bronze Medal", "4", "5"]</span><span class="token comment" spellcheck="true">//解释: 前三名运动员的成绩为前三高的，因此将会分别被授予 “金牌”，“银牌”和“铜牌” ("Gold Medal", "Silver Medal" and</span><span class="token comment" spellcheck="true">//"Bronze Medal").</span><span class="token comment" spellcheck="true">//余下的两名运动员，我们只需要通过他们的成绩计算将其相对名次即可。</span><span class="token comment" spellcheck="true">// 提示:</span><span class="token comment" spellcheck="true">// N 是一个正整数并且不会超过 10000。</span><span class="token comment" spellcheck="true">// 所有运动员的成绩都不相同。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 👍 70 👎 0</span><span class="token comment" spellcheck="true">//先拷贝原数组，再排序后使用HashMap记录对应的名次</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRelativeRanks</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> score<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> newScore <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>score<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>       String<span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>score<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>score<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           newScore<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> score<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>score<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>score<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>score<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>score<span class="token punctuation">.</span>length<span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>newScore<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         Integer count <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>newScore<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Gold Medal"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Silver Medal"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"Bronze Medal"</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="539-最小时间差"><a href="#539-最小时间差" class="headerlink" title="539. 最小时间差"></a><a href="https://leetcode-cn.com/problems/minimum-time-difference/" target="_blank" rel="noopener">539. 最小时间差</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个 24 小时制（小时:分钟 "HH:MM"）的时间列表，找出列表中任意两个时间的最小时间差并以分钟数表示。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：timePoints = ["23:59","00:00"]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：timePoints = ["00:00","23:59","00:00"]</span><span class="token comment" spellcheck="true">//输出：0</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 2 &lt;= timePoints &lt;= 2 * 104 </span><span class="token comment" spellcheck="true">// timePoints[i] 格式为 "HH:MM" </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 82 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findMinDifference</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> timePoints<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>timePoints<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1440</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> timeCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>timePoints<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> min <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>timePoints<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> timeStr <span class="token operator">=</span> timePoints<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">":"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            timeCount<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>timeStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">60</span><span class="token operator">+</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>timeStr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>timeCount<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//排序后相邻相减有最小值</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>timeCount<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           min <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span> timeCount<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> timeCount<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span>  Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>min<span class="token punctuation">,</span>timeCount<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1440</span><span class="token operator">-</span>timeCount<span class="token punctuation">[</span>timeCount<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="553-最优除法"><a href="#553-最优除法" class="headerlink" title="553. 最优除法"></a><a href="https://leetcode-cn.com/problems/optimal-division/" target="_blank" rel="noopener">553. 最优除法</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一组正整数，相邻的整数之间将会进行浮点除法操作。例如， [2,3,4] -> 2 / 3 / 4 。 </span><span class="token comment" spellcheck="true">// 但是，你可以在任意位置添加任意数目的括号，来改变算数的优先级。你需要找出怎么添加括号，才能得到最大的结果，并且返回相应的字符串格式的表达式。你的表达式不应</span><span class="token comment" spellcheck="true">//该含有冗余的括号。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">//输入: [1000,100,10,2]</span><span class="token comment" spellcheck="true">//输出: "1000/(100/10/2)"</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//1000/(100/10/2) = 1000/((100/10)/2) = 200</span><span class="token comment" spellcheck="true">//但是，以下加粗的括号 "1000/((100/10)/2)" 是冗余的，</span><span class="token comment" spellcheck="true">//因为他们并不影响操作的优先级，所以你需要返回 "1000/(100/10/2)"。</span><span class="token comment" spellcheck="true">//其他用例:</span><span class="token comment" spellcheck="true">//1000/(100/10)/2 = 50</span><span class="token comment" spellcheck="true">//1000/(100/(10/2)) = 50</span><span class="token comment" spellcheck="true">//1000/100/10/2 = 0.5</span><span class="token comment" spellcheck="true">//1000/100/(10/2) = 2</span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">// 输入数组的长度在 [1, 10] 之间。 </span><span class="token comment" spellcheck="true">// 数组中每个元素的大小都在 [2, 1000] 之间。 </span><span class="token comment" spellcheck="true">// 每个测试用例只有一个最优除法解。 </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 63 👎 0</span><span class="token comment" spellcheck="true">//除数最大，被除数最小得最大</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">optimalDivision</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"/"</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/("</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//特殊处理</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">optimalDivision</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">"/"</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"("</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="537-复数乘法"><a href="#537-复数乘法" class="headerlink" title="537. 复数乘法"></a><a href="https://leetcode-cn.com/problems/complex-number-multiplication/" target="_blank" rel="noopener">537. 复数乘法</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个表示复数的字符串。 </span><span class="token comment" spellcheck="true">// 返回表示它们乘积的字符串。注意，根据定义 i2 = -1 。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: "1+1i", "1+1i"</span><span class="token comment" spellcheck="true">//输出: "0+2i"</span><span class="token comment" spellcheck="true">//解释: (1 + i) * (1 + i) = 1 + i2 + 2 * i = 2i ，你需要将它转换为 0+2i 的形式。</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: "1+-1i", "1+-1i"</span><span class="token comment" spellcheck="true">//输出: "0+-2i"</span><span class="token comment" spellcheck="true">//解释: (1 - i) * (1 - i) = 1 + i2 - 2 * i = -2i ，你需要将它转换为 0+-2i 的形式。 </span><span class="token comment" spellcheck="true">// 注意: </span><span class="token comment" spellcheck="true">// 输入字符串不包含额外的空格。 </span><span class="token comment" spellcheck="true">// 输入字符串将以 a+bi 的形式给出，其中整数 a 和 b 的范围均在 [-100, 100] 之间。输出也应当符合这种形式。 </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 52 👎 0</span><span class="token comment" spellcheck="true">//复数乘法公式 (a+b*i)*(c+d*i) = (a*c-b*d)+(b*c+a*d)*i</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">complexNumberMultiply</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> aStr <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     String<span class="token punctuation">[</span><span class="token punctuation">]</span> bStr <span class="token operator">=</span> b<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\+"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Integer ans <span class="token operator">=</span>  <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>aStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>bStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">-</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>aStr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>bStr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   Integer ans1 <span class="token operator">=</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>aStr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">*</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>bStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>aStr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>bStr<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ans1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"i"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="592-分数加减运算"><a href="#592-分数加减运算" class="headerlink" title="592. 分数加减运算"></a><a href="https://leetcode-cn.com/problems/fraction-addition-and-subtraction/" target="_blank" rel="noopener">592. 分数加减运算</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个表示分数加减运算表达式的字符串，你需要返回一个字符串形式的计算结果。 这个结果应该是不可约分的分数，即最简分数。 如果最终结果是一个整数，例如 2，</span><span class="token comment" spellcheck="true">//你需要将它转换成分数形式，其分母为 1。所以在上述例子中, 2 应该被转换为 2/1。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入:"-1/2+1/2"</span><span class="token comment" spellcheck="true">//输出: "0/1"</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入:"-1/2+1/2+1/3"</span><span class="token comment" spellcheck="true">//输出: "1/3"</span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//输入:"1/3-1/2"</span><span class="token comment" spellcheck="true">//输出: "-1/6"</span><span class="token comment" spellcheck="true">// 示例 4: </span><span class="token comment" spellcheck="true">//输入:"5/3+1/3"</span><span class="token comment" spellcheck="true">//输出: "2/1"</span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">// 输入和输出字符串只包含 '0' 到 '9' 的数字，以及 '/', '+' 和 '-'。 </span><span class="token comment" spellcheck="true">// 输入和输出分数格式均为 ±分子/分母。如果输入的第一个分数或者输出的分数是正数，则 '+' 会被省略掉。 </span><span class="token comment" spellcheck="true">// 输入只包含合法的最简分数，每个分数的分子与分母的范围是 [1,10]。 如果分母是1，意味着这个分数实际上是一个整数。 </span><span class="token comment" spellcheck="true">// 输入的分数个数范围是 [1,10]。 </span><span class="token comment" spellcheck="true">// 最终结果的分子与分母保证是 32 位整数范围内的有效整数。 </span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 40 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">fractionAddition</span><span class="token punctuation">(</span>String expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="38-外观数列"><a href="#38-外观数列" class="headerlink" title="38. 外观数列"></a><a href="https://leetcode-cn.com/problems/count-and-say/" target="_blank" rel="noopener">38. 外观数列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个正整数 n ，输出外观数列的第 n 项。 </span><span class="token comment" spellcheck="true">// 「外观数列」是一个整数序列，从数字 1 开始，序列中的每一项都是对前一项的描述。 </span><span class="token comment" spellcheck="true">// 你可以将其视作是由递归公式定义的数字字符串序列： </span><span class="token comment" spellcheck="true">// countAndSay(1) = "1" </span><span class="token comment" spellcheck="true">// countAndSay(n) 是对 countAndSay(n-1) 的描述，然后转换成另一个数字字符串。 </span><span class="token comment" spellcheck="true">// 前五项如下： </span><span class="token comment" spellcheck="true">//1.     1</span><span class="token comment" spellcheck="true">//2.     11</span><span class="token comment" spellcheck="true">//3.     21</span><span class="token comment" spellcheck="true">//4.     1211</span><span class="token comment" spellcheck="true">//5.     111221</span><span class="token comment" spellcheck="true">//第一项是数字 1 </span><span class="token comment" spellcheck="true">//描述前一项，这个数是 1 即 “ 一 个 1 ”，记作 "11"</span><span class="token comment" spellcheck="true">//描述前一项，这个数是 11 即 “ 二 个 1 ” ，记作 "21"</span><span class="token comment" spellcheck="true">//描述前一项，这个数是 21 即 “ 一 个 2 + 一 个 1 ” ，记作 "1211"</span><span class="token comment" spellcheck="true">//描述前一项，这个数是 1211 即 “ 一 个 1 + 一 个 2 + 二 个 1 ” ，记作 "111221"</span><span class="token comment" spellcheck="true">// 要 描述 一个数字字符串，首先要将字符串分割为 最小 数量的组，每个组都由连续的最多 相同字符 组成。然后对于每个组，先描述字符的数量，然后描述字符，形成</span><span class="token comment" spellcheck="true">//一个描述组。要将描述转换为数字字符串，先将每组中的字符数量用数字替换，再将所有描述组连接起来。 </span><span class="token comment" spellcheck="true">// 例如，数字字符串 "3322251" 的描述如下图： </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：n = 1</span><span class="token comment" spellcheck="true">//输出："1"</span><span class="token comment" spellcheck="true">//解释：这是一个基本样例。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：n = 4</span><span class="token comment" spellcheck="true">//输出："1211"</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//countAndSay(1) = "1"</span><span class="token comment" spellcheck="true">//countAndSay(2) = 读 "1" = 一 个 1 = "11"</span><span class="token comment" spellcheck="true">//countAndSay(3) = 读 "11" = 二 个 1 = "21"</span><span class="token comment" spellcheck="true">//countAndSay(4) = 读 "21" = 一 个 2 + 一 个 1 = "12" + "11" = "1211"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= n &lt;= 30 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 644 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">countAndSay</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="443-压缩字符串"><a href="#443-压缩字符串" class="headerlink" title="443. 压缩字符串"></a><a href="https://leetcode-cn.com/problems/string-compression/" target="_blank" rel="noopener">443. 压缩字符串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一组字符，使用原地算法将其压缩。 </span><span class="token comment" spellcheck="true">// 压缩后的长度必须始终小于或等于原数组长度。 </span><span class="token comment" spellcheck="true">// 数组的每个元素应该是长度为1 的字符（不是 int 整数类型）。 </span><span class="token comment" spellcheck="true">// 在完成原地修改输入数组后，返回数组的新长度。 </span><span class="token comment" spellcheck="true">// 进阶： </span><span class="token comment" spellcheck="true">//你能否仅使用O(1) 空间解决问题？ </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：</span><span class="token comment" spellcheck="true">//["a","a","b","b","c","c","c"]</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//返回 6 ，输入数组的前 6 个字符应该是：["a","2","b","2","c","3"]</span><span class="token comment" spellcheck="true">//说明：</span><span class="token comment" spellcheck="true">//"aa" 被 "a2" 替代。"bb" 被 "b2" 替代。"ccc" 被 "c3" 替代。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：</span><span class="token comment" spellcheck="true">//["a"]</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//返回 1 ，输入数组的前 1 个字符应该是：["a"]</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//没有任何字符串被替代。</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：</span><span class="token comment" spellcheck="true">//["a","b","b","b","b","b","b","b","b","b","b","b","b"]</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//返回 4 ，输入数组的前4个字符应该是：["a","b","1","2"]。</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//由于字符 "a" 不重复，所以不会被压缩。"bbbbbbbbbbbb" 被 “b12” 替代。</span><span class="token comment" spellcheck="true">//注意每个数字在数组中都有它自己的位置。</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 所有字符都有一个ASCII值在[35, 126]区间内。 </span><span class="token comment" spellcheck="true">// 1 &lt;= len(chars) &lt;= 1000。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 165 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compress</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="8-字符串转换整数-atoi"><a href="#8-字符串转换整数-atoi" class="headerlink" title="8. 字符串转换整数 (atoi)"></a><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">8. 字符串转换整数 (atoi)</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</span><span class="token comment" spellcheck="true">// 函数 myAtoi(string s) 的算法如下：</span><span class="token comment" spellcheck="true">// 读入字符串并丢弃无用的前导空格</span><span class="token comment" spellcheck="true">// 检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。</span><span class="token comment" spellcheck="true">// 读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。</span><span class="token comment" spellcheck="true">// 将前面步骤读入的这些数字转换为整数（即，"123" -> 123， "0032" -> 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤</span><span class="token comment" spellcheck="true">//2 开始）。</span><span class="token comment" spellcheck="true">// 如果整数数超过 32 位有符号整数范围 [−231, 231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固</span><span class="token comment" spellcheck="true">//定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。</span><span class="token comment" spellcheck="true">// 返回整数作为最终结果。</span><span class="token comment" spellcheck="true">// 注意：</span><span class="token comment" spellcheck="true">//输入：s = "42"</span><span class="token comment" spellcheck="true">//输出：42</span><span class="token comment" spellcheck="true">//解释：加粗的字符串为已经读入的字符，插入符号是当前读取的字符。</span><span class="token comment" spellcheck="true">//第 1 步："42"（当前没有读入字符，因为没有前导空格）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 2 步："42"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 3 步："42"（读入 "42"）</span><span class="token comment" spellcheck="true">//           ^</span><span class="token comment" spellcheck="true">//解析得到整数 42 。</span><span class="token comment" spellcheck="true">//由于 "42" 在范围 [-231, 231 - 1] 内，最终结果为 42 。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "   -42"</span><span class="token comment" spellcheck="true">//输出：-42</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//第 1 步："   -42"（读入前导空格，但忽视掉）</span><span class="token comment" spellcheck="true">//            ^</span><span class="token comment" spellcheck="true">//第 2 步："   -42"（读入 '-' 字符，所以结果应该是负数）</span><span class="token comment" spellcheck="true">//             ^</span><span class="token comment" spellcheck="true">//第 3 步："   -42"（读入 "42"）</span><span class="token comment" spellcheck="true">//               ^</span><span class="token comment" spellcheck="true">//解析得到整数 -42 。</span><span class="token comment" spellcheck="true">//由于 "-42" 在范围 [-231, 231 - 1] 内，最终结果为 -42 。</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：s = "4193 with words"</span><span class="token comment" spellcheck="true">//输出：4193</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//第 1 步："4193 with words"（当前没有读入字符，因为没有前导空格）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 2 步："4193 with words"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 3 步："4193 with words"（读入 "4193"；由于下一个字符不是一个数字，所以读入停止）</span><span class="token comment" spellcheck="true">//             ^</span><span class="token comment" spellcheck="true">//解析得到整数 4193 。</span><span class="token comment" spellcheck="true">//由于 "4193" 在范围 [-231, 231 - 1] 内，最终结果为 4193 。</span><span class="token comment" spellcheck="true">// 示例 4：</span><span class="token comment" spellcheck="true">//输入：s = "words and 987"</span><span class="token comment" spellcheck="true">//输出：0</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//第 1 步："words and 987"（当前没有读入字符，因为没有前导空格）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 2 步："words and 987"（当前没有读入字符，因为这里不存在 '-' 或者 '+'）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 3 步："words and 987"（由于当前字符 'w' 不是一个数字，所以读入停止）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//解析得到整数 0 ，因为没有读入任何数字。</span><span class="token comment" spellcheck="true">//由于 0 在范围 [-231, 231 - 1] 内，最终结果为 0 。</span><span class="token comment" spellcheck="true">// 示例 5：</span><span class="token comment" spellcheck="true">//输入：s = "-91283472332"</span><span class="token comment" spellcheck="true">//输出：-2147483648</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//第 1 步："-91283472332"（当前没有读入字符，因为没有前导空格）</span><span class="token comment" spellcheck="true">//         ^</span><span class="token comment" spellcheck="true">//第 2 步："-91283472332"（读入 '-' 字符，所以结果应该是负数）</span><span class="token comment" spellcheck="true">//          ^</span><span class="token comment" spellcheck="true">//第 3 步："-91283472332"（读入 "91283472332"）</span><span class="token comment" spellcheck="true">//                     ^</span><span class="token comment" spellcheck="true">//解析得到整数 -91283472332 。</span><span class="token comment" spellcheck="true">//由于 -91283472332 小于范围 [-231, 231 - 1] 的下界，最终结果被截断为 -231 = -2147483648 。</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 200</span><span class="token comment" spellcheck="true">// s 由英文字母（大写和小写）、数字（0-9）、' '、'+'、'-' 和 '.' 组成</span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串</span><span class="token comment" spellcheck="true">// 👍 1006 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">myAtoi</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span><span class="token punctuation">{</span>            String sStr <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">trim</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> sStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">==</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span><span class="token punctuation">(</span>sStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span> <span class="token operator">||</span> sStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>sStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>sStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>sStr<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span> <span class="token operator">||</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">2147483647</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13. 罗马数字转整数"></a><a href="https://leetcode-cn.com/problems/roman-to-integer/" target="_blank" rel="noopener">13. 罗马数字转整数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//罗马数字包含以下七种字符: I， V， X， L，C，D 和 M。 </span><span class="token comment" spellcheck="true">//字符          数值</span><span class="token comment" spellcheck="true">//I             1</span><span class="token comment" spellcheck="true">//V             5</span><span class="token comment" spellcheck="true">//X             10</span><span class="token comment" spellcheck="true">//L             50</span><span class="token comment" spellcheck="true">//C             100</span><span class="token comment" spellcheck="true">//D             500</span><span class="token comment" spellcheck="true">//M             1000 </span><span class="token comment" spellcheck="true">// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + I</span><span class="token comment" spellcheck="true">//I 。 </span><span class="token comment" spellcheck="true">// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5</span><span class="token comment" spellcheck="true">// 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： </span><span class="token comment" spellcheck="true">// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 </span><span class="token comment" spellcheck="true">// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><span class="token comment" spellcheck="true">// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 </span><span class="token comment" spellcheck="true">// 给定一个罗马数字，将其转换成整数。输入确保在 1 到 3999 的范围内。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: "III"</span><span class="token comment" spellcheck="true">//输出: 3 </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: "IV"</span><span class="token comment" spellcheck="true">//输出: 4 </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//输入: "IX"</span><span class="token comment" spellcheck="true">//输出: 9 </span><span class="token comment" spellcheck="true">// 示例 4: </span><span class="token comment" spellcheck="true">//输入: "LVIII"</span><span class="token comment" spellcheck="true">//输出: 58</span><span class="token comment" spellcheck="true">//解释: L = 50, V= 5, III = 3.</span><span class="token comment" spellcheck="true">// 示例 5: </span><span class="token comment" spellcheck="true">//输入: "MCMXCIV"</span><span class="token comment" spellcheck="true">//输出: 1994</span><span class="token comment" spellcheck="true">//解释: M = 1000, CM = 900, XC = 90, IV = 4. </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 15 </span><span class="token comment" spellcheck="true">// s 仅含字符 ('I', 'V', 'X', 'L', 'C', 'D', 'M') </span><span class="token comment" spellcheck="true">// 题目数据保证 s 是一个有效的罗马数字，且表示整数在范围 [1, 3999] 内 </span><span class="token comment" spellcheck="true">// 题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。 </span><span class="token comment" spellcheck="true">// IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。 </span><span class="token comment" spellcheck="true">// 关于罗马数字的详尽书写规则，可以参考 罗马数字 - Mathematics 。 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 1215 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">romanToInt</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'I'</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'V'</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'X'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'L'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">'M'</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                count <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                count <span class="token operator">=</span> count <span class="token operator">+</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="12-整数转罗马数字"><a href="#12-整数转罗马数字" class="headerlink" title="12. 整数转罗马数字"></a><a href="https://leetcode-cn.com/problems/integer-to-roman/" target="_blank" rel="noopener">12. 整数转罗马数字</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//罗马数字包含以下七种字符： I， V， X， L，C，D 和 M。 </span><span class="token comment" spellcheck="true">//字符          数值</span><span class="token comment" spellcheck="true">//I             1</span><span class="token comment" spellcheck="true">//V             5</span><span class="token comment" spellcheck="true">//X             10</span><span class="token comment" spellcheck="true">//L             50</span><span class="token comment" spellcheck="true">//C             100</span><span class="token comment" spellcheck="true">//D             500</span><span class="token comment" spellcheck="true">//M             1000 </span><span class="token comment" spellcheck="true">// 例如， 罗马数字 2 写做 II ，即为两个并列的 1。12 写做 XII ，即为 X + II 。 27 写做 XXVII, 即为 XX + V + I</span><span class="token comment" spellcheck="true">//I 。 </span><span class="token comment" spellcheck="true">// 通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 IIII，而是 IV。数字 1 在数字 5 的左边，所表示的数等于大数 5</span><span class="token comment" spellcheck="true">// 减小数 1 得到的数值 4 。同样地，数字 9 表示为 IX。这个特殊的规则只适用于以下六种情况： </span><span class="token comment" spellcheck="true">// I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。 </span><span class="token comment" spellcheck="true">// X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。 </span><span class="token comment" spellcheck="true">// C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。 </span><span class="token comment" spellcheck="true">// 给定一个整数，将其转为罗马数字。输入确保在 1 到 3999 的范围内。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: 3</span><span class="token comment" spellcheck="true">//输出: "III" </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: 4</span><span class="token comment" spellcheck="true">//输出: "IV" </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//输入: 9</span><span class="token comment" spellcheck="true">//输出: "IX" </span><span class="token comment" spellcheck="true">// 示例 4: </span><span class="token comment" spellcheck="true">//输入: 58</span><span class="token comment" spellcheck="true">//输出: "LVIII"</span><span class="token comment" spellcheck="true">//解释: L = 50, V = 5, III = 3.</span><span class="token comment" spellcheck="true">// 示例 5: </span><span class="token comment" spellcheck="true">//输入: 1994</span><span class="token comment" spellcheck="true">//输出: "MCMXCIV"</span><span class="token comment" spellcheck="true">//解释: M = 1000, CM = 900, XC = 90, IV = 4. </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= num &lt;= 3999 </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 502 👎 0</span><span class="token comment" spellcheck="true">//穷举</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> mNum <span class="token operator">=</span>  num<span class="token operator">/</span><span class="token number">1000</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>mNum<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>mNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"M"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cmNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">900</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>cmNum<span class="token operator">*</span><span class="token number">900</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cmNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"CM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> dNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">500</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>dNum<span class="token operator">*</span><span class="token number">500</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>dNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cdNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">400</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>cdNum<span class="token operator">*</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cdNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"CD"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> cNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">100</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>cNum<span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>cNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> xcNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">90</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>xcNum<span class="token operator">*</span><span class="token number">90</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>xcNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"XC"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> lNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">50</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>lNum<span class="token operator">*</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>lNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"L"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> xlNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">40</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>xlNum<span class="token operator">*</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>xlNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"XL"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> xNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num<span class="token operator">-</span><span class="token punctuation">(</span>xNum<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>xNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> ixNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">9</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>ixNum<span class="token operator">*</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ixNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"IX"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">int</span> vNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>vNum<span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>vNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"V"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">int</span> ivNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>ivNum<span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ivNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"IV"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">int</span> iNum <span class="token operator">=</span> num<span class="token operator">/</span><span class="token number">1</span><span class="token punctuation">;</span>    num <span class="token operator">=</span> num <span class="token operator">-</span> <span class="token punctuation">(</span>ivNum<span class="token operator">*</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>iNum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"I"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>      <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">intToRoman</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">,</span><span class="token number">500</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">90</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"M"</span><span class="token punctuation">,</span><span class="token string">"CM"</span><span class="token punctuation">,</span><span class="token string">"D"</span><span class="token punctuation">,</span><span class="token string">"CD"</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">,</span><span class="token string">"XC"</span><span class="token punctuation">,</span><span class="token string">"L"</span><span class="token punctuation">,</span><span class="token string">"XL"</span><span class="token punctuation">,</span><span class="token string">"X"</span><span class="token punctuation">,</span><span class="token string">"IX"</span><span class="token punctuation">,</span><span class="token string">"V"</span><span class="token punctuation">,</span><span class="token string">"IV"</span><span class="token punctuation">,</span><span class="token string">"I"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">while</span><span class="token punctuation">(</span>num<span class="token operator">>=</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            num <span class="token operator">=</span> num <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="273-整数转换英文表示"><a href="#273-整数转换英文表示" class="headerlink" title="273. 整数转换英文表示"></a><a href="https://leetcode-cn.com/problems/integer-to-english-words/" target="_blank" rel="noopener">273. 整数转换英文表示</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将非负整数 num 转换为其对应的英文表示。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：num = 123</span><span class="token comment" spellcheck="true">//输出："One Hundred Twenty Three"</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：num = 12345</span><span class="token comment" spellcheck="true">//输出："Twelve Thousand Three Hundred Forty Five"</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：num = 1234567</span><span class="token comment" spellcheck="true">//输出："One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven"</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">//输入：num = 1234567891</span><span class="token comment" spellcheck="true">//输出："One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thous</span><span class="token comment" spellcheck="true">//and Eight Hundred Ninety One"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= num &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 134 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">numberToWords</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="165-比较版本号"><a href="#165-比较版本号" class="headerlink" title="165. 比较版本号"></a><a href="https://leetcode-cn.com/problems/compare-version-numbers/" target="_blank" rel="noopener">165. 比较版本号</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你两个版本号 version1 和 version2 ，请你比较它们。 </span><span class="token comment" spellcheck="true">// 版本号由一个或多个修订号组成，各修订号由一个 '.' 连接。每个修订号由 多位数字 组成，可能包含 前导零 。每个版本号至少包含一个字符。修订号从左到右编</span><span class="token comment" spellcheck="true">//号，下标从 0 开始，最左边的修订号下标为 0 ，下一个修订号下标为 1 ，以此类推。例如，2.5.33 和 0.1 都是有效的版本号。 </span><span class="token comment" spellcheck="true">// 比较版本号时，请按从左到右的顺序依次比较它们的修订号。比较修订号时，只需比较 忽略任何前导零后的整数值 。也就是说，修订号 1 和修订号 001 相等 。</span><span class="token comment" spellcheck="true">//如果版本号没有指定某个下标处的修订号，则该修订号视为 0 。例如，版本 1.0 小于版本 1.1 ，因为它们下标为 0 的修订号相同，而下标为 1 的修订号分别</span><span class="token comment" spellcheck="true">//为 0 和 1 ，0 &lt; 1 。 </span><span class="token comment" spellcheck="true">// 返回规则如下： </span><span class="token comment" spellcheck="true">// 如果 version1 > version2 返回 1， </span><span class="token comment" spellcheck="true">// 如果 version1 &lt; version2 返回 -1， </span><span class="token comment" spellcheck="true">// 除此之外返回 0。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：version1 = "1.01", version2 = "1.001"</span><span class="token comment" spellcheck="true">//输出：0</span><span class="token comment" spellcheck="true">//解释：忽略前导零，"01" 和 "001" 都表示相同的整数 "1"</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：version1 = "1.0", version2 = "1.0.0"</span><span class="token comment" spellcheck="true">//输出：0</span><span class="token comment" spellcheck="true">//解释：version1 没有指定下标为 2 的修订号，即视为 "0"</span><span class="token comment" spellcheck="true">// 示例 3：  </span><span class="token comment" spellcheck="true">//输入：version1 = "0.1", version2 = "1.1"</span><span class="token comment" spellcheck="true">//输出：-1</span><span class="token comment" spellcheck="true">//解释：version1 中下标为 0 的修订号是 "0"，version2 中下标为 0 的修订号是 "1" 。0 &lt; 1，所以 version1 &lt; ve</span><span class="token comment" spellcheck="true">//rsion2</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">//输入：version1 = "1.0.1", version2 = "1"</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 示例 5： </span><span class="token comment" spellcheck="true">//输入：version1 = "7.5.2.4", version2 = "7.5.3"</span><span class="token comment" spellcheck="true">//输出：-1</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= version1.length, version2.length &lt;= 500 </span><span class="token comment" spellcheck="true">// version1 和 version2 仅包含数字和 '.' </span><span class="token comment" spellcheck="true">// version1 和 version2 都是 有效版本号 </span><span class="token comment" spellcheck="true">// version1 和 version2 的所有修订号都可以存储在 32 位整数 中 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 139 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareVersion</span><span class="token punctuation">(</span>String version1<span class="token punctuation">,</span> String version2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span>  version1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans1<span class="token operator">=</span>  version2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span>  Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">,</span>ans1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans5 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans5<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans6 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans1<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans6<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans3 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>ans5<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans4 <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>ans6<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">></span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans4<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans4<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans3<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans4<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//精简版</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compareVersion</span><span class="token punctuation">(</span>String version1<span class="token punctuation">,</span> String version2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span>  version1<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans1<span class="token operator">=</span>  version2<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span>  Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">,</span>ans1<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>size<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token operator">?</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">&lt;</span>ans1<span class="token punctuation">.</span>length<span class="token operator">?</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ans1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">!=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> j<span class="token operator">></span>k<span class="token operator">?</span><span class="token number">1</span><span class="token operator">:</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="481-神奇字符串"><a href="#481-神奇字符串" class="headerlink" title="481. 神奇字符串"></a><a href="https://leetcode-cn.com/problems/magical-string/" target="_blank" rel="noopener">481. 神奇字符串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//神奇的字符串 S 只包含 '1' 和 '2'，并遵守以下规则： </span><span class="token comment" spellcheck="true">// 字符串 S 是神奇的，因为串联字符 '1' 和 '2' 的连续出现次数会生成字符串 S 本身。 </span><span class="token comment" spellcheck="true">// 字符串 S 的前几个元素如下：S = “1221121221221121122 ......” </span><span class="token comment" spellcheck="true">// 如果我们将 S 中连续的 1 和 2 进行分组，它将变成： </span><span class="token comment" spellcheck="true">// 1 22 11 2 1 22 1 22 11 2 11 22 ...... </span><span class="token comment" spellcheck="true">// 并且每个组中 '1' 或 '2' 的出现次数分别是： </span><span class="token comment" spellcheck="true">// 1 2 2 1 1 2 1 2 2 1 2 2 ...... </span><span class="token comment" spellcheck="true">// 你可以看到上面的出现次数就是 S 本身。 </span><span class="token comment" spellcheck="true">// 给定一个整数 N 作为输入，返回神奇字符串 S 中前 N 个数字中的 '1' 的数目。 </span><span class="token comment" spellcheck="true">// 注意：N 不会超过 100,000。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">// 输入：6</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">//解释：神奇字符串 S 的前 6 个元素是 “12211”，它包含三个 1，因此返回 3。</span><span class="token comment" spellcheck="true">// 👍 43 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">magicalString</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="子序列"><a href="#子序列" class="headerlink" title="子序列"></a>子序列</h3><h4 id="392-判断子序列"><a href="#392-判断子序列" class="headerlink" title="392. 判断子序列"></a><a href="https://leetcode-cn.com/problems/is-subsequence/" target="_blank" rel="noopener">392. 判断子序列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定字符串 s 和 t ，判断 s 是否为 t 的子序列。</span><span class="token comment" spellcheck="true">// 字符串的一个子序列是原始字符串删除一些（也可以不删除）字符而不改变剩余字符相对位置形成的新字符串。（例如，"ace"是"abcde"的一个子序列，而"ae</span><span class="token comment" spellcheck="true">//c"不是）。</span><span class="token comment" spellcheck="true">// 进阶：</span><span class="token comment" spellcheck="true">// 如果有大量输入的 S，称作 S1, S2, ... , Sk 其中 k >= 10亿，你需要依次检查它们是否为 T 的子序列。在这种情况下，你会怎样改变代</span><span class="token comment" spellcheck="true">//码？</span><span class="token comment" spellcheck="true">// 致谢：</span><span class="token comment" spellcheck="true">// 特别感谢 @pbrother 添加此问题并且创建所有测试用例。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：s = "abc", t = "ahbgdc"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "axc", t = "ahbgdc"</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 100</span><span class="token comment" spellcheck="true">// 0 &lt;= t.length &lt;= 10^4</span><span class="token comment" spellcheck="true">// 两个字符串都只由小写字符组成。</span><span class="token comment" spellcheck="true">// Related Topics 贪心算法 二分查找 动态规划</span><span class="token comment" spellcheck="true">// 👍 397 👎 0</span><span class="token comment" spellcheck="true">//直接查找拼接</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              j<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span></code></pre><h4 id="524-通过删除字母匹配到字典里最长单词"><a href="#524-通过删除字母匹配到字典里最长单词" class="headerlink" title="524. 通过删除字母匹配到字典里最长单词"></a><a href="https://leetcode-cn.com/problems/longest-word-in-dictionary-through-deleting/" target="_blank" rel="noopener">524. 通过删除字母匹配到字典里最长单词</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串和一个字符串字典，找到字典里面最长的字符串，该字符串可以通过删除给定字符串的某些字符来得到。如果答案不止一个，返回长度最长且字典顺序最小的字符</span><span class="token comment" spellcheck="true">//串。如果答案不存在，则返回空字符串。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//s = "abpcplea", d = ["ale","apple","monkey","plea"]</span><span class="token comment" spellcheck="true">//输出: </span><span class="token comment" spellcheck="true">//"apple"</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//s = "abpcplea", d = ["a","b","c"]</span><span class="token comment" spellcheck="true">//输出: </span><span class="token comment" spellcheck="true">//"a"</span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">// 所有输入的字符串只包含小写字母。 </span><span class="token comment" spellcheck="true">// 字典的大小不会超过 1000。 </span><span class="token comment" spellcheck="true">// 所有输入的字符串长度不会超过 1000。 </span><span class="token comment" spellcheck="true">// Related Topics 排序 双指针 </span><span class="token comment" spellcheck="true">// 👍 132 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>       <span class="token keyword">public</span> String <span class="token function">findLongestWord</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> dictionary<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        String result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> dictionary<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String ans <span class="token operator">=</span> dictionary<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">&lt;</span> ans<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> ans<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    k<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//子串排序按字典顺序最小排序</span>        res<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>String o1<span class="token punctuation">,</span> String o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>o2<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//找出长度最长的子串 </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> maxSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxSize <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//如果答案不止一个，且长度都相等，返回第一个字典顺序最小的</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>res <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxSize <span class="token operator">==</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="521-最长特殊序列-Ⅰ"><a href="#521-最长特殊序列-Ⅰ" class="headerlink" title="521. 最长特殊序列 Ⅰ"></a><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-i/" target="_blank" rel="noopener">521. 最长特殊序列 Ⅰ</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你两个字符串，请你从这两个字符串中找出最长的特殊序列。 </span><span class="token comment" spellcheck="true">// 「最长特殊序列」定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 </span><span class="token comment" spellcheck="true">// 子序列 可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 </span><span class="token comment" spellcheck="true">// 输入为两个字符串，输出最长特殊序列的长度。如果不存在，则返回 -1。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入: "aba", "cdc"</span><span class="token comment" spellcheck="true">//输出: 3</span><span class="token comment" spellcheck="true">//解释: 最长特殊序列可为 "aba" (或 "cdc")，两者均为自身的子序列且不是对方的子序列。 </span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：a = "aaa", b = "bbb"</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：a = "aaa", b = "aaa"</span><span class="token comment" spellcheck="true">//输出：-1</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 两个字符串长度均处于区间 [1 - 100] 。 </span><span class="token comment" spellcheck="true">// 字符串中的字符仅含有 'a'~'z' 。 </span><span class="token comment" spellcheck="true">// Related Topics 脑筋急转弯 字符串 </span><span class="token comment" spellcheck="true">// 👍 91 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLUSlength</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">boolean</span> res <span class="token operator">=</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">>=</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">,</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span> b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span>a<span class="token operator">:</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>res<span class="token operator">||</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token operator">-</span><span class="token number">1</span><span class="token operator">:</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> <span class="token function">isSubsequence</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>t<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//神™脑筋急转弯</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLUSlength</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="522-最长特殊序列-II"><a href="#522-最长特殊序列-II" class="headerlink" title="522. 最长特殊序列 II"></a><a href="https://leetcode-cn.com/problems/longest-uncommon-subsequence-ii/" target="_blank" rel="noopener">522. 最长特殊序列 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定字符串列表，你需要从它们中找出最长的特殊序列。最长特殊序列定义如下：该序列为某字符串独有的最长子序列（即不能是其他字符串的子序列）。 </span><span class="token comment" spellcheck="true">// 子序列可以通过删去字符串中的某些字符实现，但不能改变剩余字符的相对顺序。空序列为所有字符串的子序列，任何字符串为其自身的子序列。 </span><span class="token comment" spellcheck="true">// 输入将是一个字符串列表，输出是最长特殊序列的长度。如果最长特殊序列不存在，返回 -1 。 </span><span class="token comment" spellcheck="true">// 示例： </span><span class="token comment" spellcheck="true">// 输入: "aba", "cdc", "eae"</span><span class="token comment" spellcheck="true">//输出: 3</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 所有给定的字符串长度不会超过 10 。 </span><span class="token comment" spellcheck="true">// 给定字符串列表的长度将在 [2, 50 ] 之间。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 58 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLUSlength</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strs<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a><a href="https://leetcode-cn.com/problems/plus-one/" target="_blank" rel="noopener">66. 加一</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个由 整数 组成的 非空 数组所表示的非负整数，在该数的基础上加一。</span><span class="token comment" spellcheck="true">// 最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。</span><span class="token comment" spellcheck="true">// 你可以假设除了整数 0 之外，这个整数不会以零开头。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：digits = [1,2,3]</span><span class="token comment" spellcheck="true">//输出：[1,2,4]</span><span class="token comment" spellcheck="true">//解释：输入数组表示数字 123。</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：digits = [4,3,2,1]</span><span class="token comment" spellcheck="true">//输出：[4,3,2,2]</span><span class="token comment" spellcheck="true">//解释：输入数组表示数字 4321。</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：digits = [0]</span><span class="token comment" spellcheck="true">//输出：[1]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= digits.length &lt;= 100</span><span class="token comment" spellcheck="true">// 0 &lt;= digits[i] &lt;= 9</span><span class="token comment" spellcheck="true">// Related Topics 数组</span><span class="token comment" spellcheck="true">// 👍 637 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">plusOne</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> digits<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>digits<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>            digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>digits<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> digits<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        digits <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>digits<span class="token punctuation">.</span>length<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        digits<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> digits<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="67-二进制求和"><a href="#67-二进制求和" class="headerlink" title="67. 二进制求和"></a><a href="https://leetcode-cn.com/problems/add-binary/" target="_blank" rel="noopener">67. 二进制求和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你两个二进制字符串，返回它们的和（用二进制表示）。 </span><span class="token comment" spellcheck="true">// 输入为 非空 字符串且只包含数字 1 和 0。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: a = "11", b = "1"</span><span class="token comment" spellcheck="true">//输出: "100" </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: a = "1010", b = "1011"</span><span class="token comment" spellcheck="true">//输出: "10101" </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 每个字符串仅由字符 '0' 或 '1' 组成。 </span><span class="token comment" spellcheck="true">// 1 &lt;= a.length, b.length &lt;= 10^4 </span><span class="token comment" spellcheck="true">// 字符串如果不是 "0" ，就都不含前导零。 </span><span class="token comment" spellcheck="true">// Related Topics 数学 字符串 </span><span class="token comment" spellcheck="true">// 👍 568 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">addBinary</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="415-字符串相加"><a href="#415-字符串相加" class="headerlink" title="415. 字符串相加"></a><a href="https://leetcode-cn.com/problems/add-strings/" target="_blank" rel="noopener">415. 字符串相加</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// num1 和num2 的长度都小于 5100</span><span class="token comment" spellcheck="true">// num1 和num2 都只包含数字 0-9</span><span class="token comment" spellcheck="true">// num1 和num2 都不包含任何前导零</span><span class="token comment" spellcheck="true">// 你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 字符串</span><span class="token comment" spellcheck="true">// 👍 320 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">addStrings</span><span class="token punctuation">(</span>String num1<span class="token punctuation">,</span> String num2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> num1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> num2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> add <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        StringBuilder ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">||</span> j<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">||</span> add <span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> i<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">?</span>num1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> y <span class="token operator">=</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token operator">?</span>num2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token operator">-</span><span class="token string">'0'</span><span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> result <span class="token operator">=</span> x<span class="token operator">+</span>y<span class="token operator">+</span>add<span class="token punctuation">;</span>            ans<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>result<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            add <span class="token operator">=</span> result<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ans<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="482-密钥格式化"><a href="#482-密钥格式化" class="headerlink" title="482. 密钥格式化"></a><a href="https://leetcode-cn.com/problems/license-key-formatting/" target="_blank" rel="noopener">482. 密钥格式化</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//有一个密钥字符串 S ，只包含字母，数字以及 '-'（破折号）。其中， N 个 '-' 将字符串分成了 N+1 组。 </span><span class="token comment" spellcheck="true">// 给你一个数字 K，请你重新格式化字符串，使每个分组恰好包含 K 个字符。特别地，第一个分组包含的字符个数必须小于等于 K，但至少要包含 1 个字符。两个分</span><span class="token comment" spellcheck="true">//组之间需要用 '-'（破折号）隔开，并且将所有的小写字母转换为大写字母。 </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 给定非空字符串 S 和数字 K，按照上面描述的规则进行格式化。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入：S = "5F3Z-2e-9-w", K = 4</span><span class="token comment" spellcheck="true">//输出："5F3Z-2E9W"</span><span class="token comment" spellcheck="true">//解释：字符串 S 被分成了两个部分，每部分 4 个字符；</span><span class="token comment" spellcheck="true">//     注意，两个额外的破折号需要删掉。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入：S = "2-5g-3-J", K = 2</span><span class="token comment" spellcheck="true">//输出："2-5G-3J"</span><span class="token comment" spellcheck="true">//解释：字符串 S 被分成了 3 个部分，按照前面的规则描述，第一部分的字符可以少于给定的数量，其余部分皆为 2 个字符。</span><span class="token comment" spellcheck="true">// 提示: </span><span class="token comment" spellcheck="true">// S 的长度可能很长，请按需分配大小。K 为正整数。 </span><span class="token comment" spellcheck="true">// S 只包含字母数字（a-z，A-Z，0-9）以及破折号'-' </span><span class="token comment" spellcheck="true">// S 非空 </span><span class="token comment" spellcheck="true">// 👍 61 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">licenseKeyFormatting</span><span class="token punctuation">(</span>String S<span class="token punctuation">,</span> <span class="token keyword">int</span> K<span class="token punctuation">)</span> <span class="token punctuation">{</span>     StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     StringBuilder resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>S<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     String ans <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span>ans<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">!=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> j<span class="token operator">%</span>K <span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             resp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        resp<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         j<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token keyword">return</span> resp<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="6-Z-字形变换"><a href="#6-Z-字形变换" class="headerlink" title="6. Z 字形变换"></a><a href="https://leetcode-cn.com/problems/zigzag-conversion/" target="_blank" rel="noopener">6. Z 字形变换</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列。 </span><span class="token comment" spellcheck="true">// 比如输入字符串为 "PAYPALISHIRING" 行数为 3 时，排列如下： </span><span class="token comment" spellcheck="true">//P   A   H   N</span><span class="token comment" spellcheck="true">//A P L S I I G</span><span class="token comment" spellcheck="true">//Y   I   R </span><span class="token comment" spellcheck="true">// 之后，你的输出需要从左往右逐行读取，产生出一个新的字符串，比如："PAHNAPLSIIGYIR"。 </span><span class="token comment" spellcheck="true">// 请你实现这个将字符串进行指定行数变换的函数： </span><span class="token comment" spellcheck="true">//string convert(string s, int numRows); </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：s = "PAYPALISHIRING", numRows = 3</span><span class="token comment" spellcheck="true">//输出："PAHNAPLSIIGYIR"</span><span class="token comment" spellcheck="true">//示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "PAYPALISHIRING", numRows = 4</span><span class="token comment" spellcheck="true">//输出："PINALSIGYAHRPI"</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//P     I    N</span><span class="token comment" spellcheck="true">//A   L S  I G</span><span class="token comment" spellcheck="true">//Y A   H R</span><span class="token comment" spellcheck="true">//P     I</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：s = "A", numRows = 1</span><span class="token comment" spellcheck="true">//输出："A"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 1000 </span><span class="token comment" spellcheck="true">// s 由英文字母（小写和大写）、',' 和 '.' 组成 </span><span class="token comment" spellcheck="true">// 1 &lt;= numRows &lt;= 1000 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 1035 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">convert</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> <span class="token keyword">int</span> numRows<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>numRows <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>StringBuilder<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>numRows<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> rows <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> goingDown <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>rows<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>rows <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> rows <span class="token operator">==</span> numRows<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                goingDown <span class="token operator">=</span> <span class="token operator">!</span>goingDown<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>goingDown<span class="token punctuation">)</span><span class="token punctuation">{</span>                rows <span class="token operator">=</span> rows<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>goingDown<span class="token punctuation">)</span><span class="token punctuation">{</span>                rows <span class="token operator">=</span> rows<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        StringBuilder result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解题思路：</p><p>通过从左向右迭代字符串，我们可以轻松地确定字符位于 Z 字形图案中的哪一行。</p><p>我们可以使用 min(numRows,len(s)) 个列表来表示 Z 字形图案中的非空行。</p><p>从左到右迭代 ss，将每个字符添加到合适的行。可以使用当前行和当前方向这两个变量对合适的行进行跟踪。</p><p>只有当我们向上移动到最上面的行或向下移动到最下面的行时，当前方向才会发生改变。</p><h4 id="68-文本左右对齐"><a href="#68-文本左右对齐" class="headerlink" title="68. 文本左右对齐"></a><a href="https://leetcode-cn.com/problems/text-justification/" target="_blank" rel="noopener">68. 文本左右对齐</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个单词数组和一个长度 maxWidth，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本。 </span><span class="token comment" spellcheck="true">// 你应该使用“贪心算法”来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符。 </span><span class="token comment" spellcheck="true">// 要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数。 </span><span class="token comment" spellcheck="true">// 文本的最后一行应为左对齐，且单词之间不插入额外的空格。 </span><span class="token comment" spellcheck="true">// 说明: </span><span class="token comment" spellcheck="true">// 单词是指由非空格字符组成的字符序列。 </span><span class="token comment" spellcheck="true">// 每个单词的长度大于 0，小于等于 maxWidth。 </span><span class="token comment" spellcheck="true">// 输入单词数组 words 至少包含一个单词。 </span><span class="token comment" spellcheck="true">// 示例: </span><span class="token comment" spellcheck="true">// 输入:</span><span class="token comment" spellcheck="true">//words = ["This", "is", "an", "example", "of", "text", "justification."]</span><span class="token comment" spellcheck="true">//maxWidth = 16</span><span class="token comment" spellcheck="true">//输出:</span><span class="token punctuation">[</span><span class="token number">4</span> <span class="token number">2</span> <span class="token number">2</span> <span class="token number">6</span> <span class="token number">2</span> <span class="token number">4</span> <span class="token number">14</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//   "This    is    an",</span><span class="token comment" spellcheck="true">//   "example  of text",</span><span class="token comment" spellcheck="true">//   "justification.  "</span><span class="token comment" spellcheck="true">//]</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入:</span><span class="token comment" spellcheck="true">//words = ["What","must","be","acknowledgment","shall","be"]</span><span class="token comment" spellcheck="true">//maxWidth = 16</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//  "What   must   be",</span><span class="token comment" spellcheck="true">//  "acknowledgment  ",</span><span class="token comment" spellcheck="true">//  "shall be        "</span><span class="token comment" spellcheck="true">//]</span><span class="token comment" spellcheck="true">//解释: 注意最后一行的格式应为 "shall be    " 而不是 "shall     be",</span><span class="token comment" spellcheck="true">//     因为最后一行应为左对齐，而不是左右两端对齐。       </span><span class="token comment" spellcheck="true">//     第二行同样为左对齐，这是因为这行只包含一个单词。</span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">// 输入:</span><span class="token comment" spellcheck="true">//words = ["Science","is","what","we","understand","well","enough","to","explain</span><span class="token comment" spellcheck="true">//",</span><span class="token comment" spellcheck="true">//         "to","a","computer.","Art","is","everything","else","we","do"]</span><span class="token comment" spellcheck="true">//maxWidth = 20</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//[</span><span class="token comment" spellcheck="true">//  "Science  is  what we",</span><span class="token comment" spellcheck="true">//  "understand      well",</span><span class="token comment" spellcheck="true">//  "enough to explain to",</span><span class="token comment" spellcheck="true">//  "a  computer.  Art is",</span><span class="token comment" spellcheck="true">//  "everything  else  we",</span><span class="token comment" spellcheck="true">//  "do                  "</span><span class="token comment" spellcheck="true">//]</span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 126 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">fullJustify</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">,</span> <span class="token keyword">int</span> maxWidth<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="28-实现-strStr"><a href="#28-实现-strStr" class="headerlink" title="28. 实现 strStr()"></a><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank" rel="noopener">28. 实现 strStr()</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//实现 strStr() 函数。</span><span class="token comment" spellcheck="true">// 给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如</span><span class="token comment" spellcheck="true">//果不存在，则返回 -1。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">// 输入: haystack = "hello", needle = "ll"</span><span class="token comment" spellcheck="true">//输出: 2</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">// 输入: haystack = "aaaaa", needle = "bba"</span><span class="token comment" spellcheck="true">//输出: -1</span><span class="token comment" spellcheck="true">// 说明:</span><span class="token comment" spellcheck="true">// 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。</span><span class="token comment" spellcheck="true">// 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。</span><span class="token comment" spellcheck="true">// Related Topics 双指针 字符串</span><span class="token comment" spellcheck="true">// 👍 726 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">strStr</span><span class="token punctuation">(</span>String haystack<span class="token punctuation">,</span> String needle<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>needle<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span> <span class="token operator">||</span> haystack<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> split <span class="token operator">=</span> haystack<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>needle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>split<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>haystack<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> split<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="686-重复叠加字符串匹配"><a href="#686-重复叠加字符串匹配" class="headerlink" title="686. 重复叠加字符串匹配"></a><a href="https://leetcode-cn.com/problems/repeated-string-match/" target="_blank" rel="noopener">686. 重复叠加字符串匹配</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个字符串 a 和 b，寻找重复叠加字符串 a 的最小次数，使得字符串 b 成为叠加后的字符串 a 的子串，如果不存在则返回 -1。 </span><span class="token comment" spellcheck="true">// 注意：字符串 "abc" 重复叠加 0 次是 ""，重复叠加 1 次是 "abc"，重复叠加 2 次是 "abcabc"。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：a = "abcd", b = "cdabcdab"</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">//解释：a 重复叠加三遍后为 "abcdabcdabcd", 此时 b 是其子串。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：a = "a", b = "aa"</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：a = "a", b = "a"</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">// 输入：a = "abc", b = "wxyz"</span><span class="token comment" spellcheck="true">//输出：-1</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= a.length &lt;= 104 </span><span class="token comment" spellcheck="true">// 1 &lt;= b.length &lt;= 104 </span><span class="token comment" spellcheck="true">// a 和 b 由小写英文字母组成 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 129 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">repeatedStringMatch</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>      StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> ans<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             ans<span class="token operator">=</span> ans<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">+</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//解法二</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">repeatedStringMatch</span><span class="token punctuation">(</span>String a<span class="token punctuation">,</span> String b<span class="token punctuation">)</span> <span class="token punctuation">{</span>     StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> count <span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&lt;</span>b<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>         count<span class="token operator">++</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> count<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span> <span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="459-重复的子字符串"><a href="#459-重复的子字符串" class="headerlink" title="459. 重复的子字符串"></a><a href="https://leetcode-cn.com/problems/repeated-substring-pattern/" target="_blank" rel="noopener">459. 重复的子字符串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个非空的字符串，判断它是否可以由它的一个子串重复多次构成。给定的字符串只含有小写英文字母，并且长度不超过10000。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入: "abab"</span><span class="token comment" spellcheck="true">//输出: True</span><span class="token comment" spellcheck="true">//解释: 可由子字符串 "ab" 重复两次构成。</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">//输入: "aba"</span><span class="token comment" spellcheck="true">//输出: False</span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//输入: "abcabcabcabc"</span><span class="token comment" spellcheck="true">//输出: True</span><span class="token comment" spellcheck="true">//解释: 可由子字符串 "abc" 重复四次构成。 (或者子字符串 "abcabc" 重复两次构成。)</span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 463 👎 0</span><span class="token comment" spellcheck="true">//如果字符串 S 包含一个重复的子字符串，那么这意味着您可以多次 “移位和换行”`您的字符串，并使其与原始字符串匹配。</span><span class="token comment" spellcheck="true">//超时</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     String s1 <span class="token operator">=</span> s<span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">char</span> temp <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>temp<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         s <span class="token operator">=</span> ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//取巧</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">repeatedSubstringPattern</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     String str <span class="token operator">=</span> s<span class="token operator">+</span>s<span class="token punctuation">;</span>     <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>str<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="214-最短回文串"><a href="#214-最短回文串" class="headerlink" title="214. 最短回文串"></a><a href="https://leetcode-cn.com/problems/shortest-palindrome/" target="_blank" rel="noopener">214. 最短回文串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串 s，你可以通过在字符串前面添加字符将其转换为回文串。找到并返回可以用这种方式转换的最短回文串。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：s = "aacecaaa"</span><span class="token comment" spellcheck="true">//输出："aaacecaaa"</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：s = "abcd"</span><span class="token comment" spellcheck="true">//输出："dcbabcd"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 5 * 104 </span><span class="token comment" spellcheck="true">// s 仅由小写英文字母组成 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 </span><span class="token comment" spellcheck="true">// 👍 321 👎 0</span><span class="token comment" spellcheck="true">//暴力超时  abcd  , 每次添加一个字符，判断是否回文，循环判断</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span>  String <span class="token function">shortestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalid</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        String s1 <span class="token operator">=</span> s<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            StringBuilder str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            str<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String param <span class="token operator">=</span>  sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> res <span class="token operator">=</span>  <span class="token function">isPalid</span><span class="token punctuation">(</span>param<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> param<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> j<span class="token operator">=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            j<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">5. 最长回文子串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个字符串 s，找到 s 中最长的回文子串。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：s = "babad"</span><span class="token comment" spellcheck="true">//输出："bab"</span><span class="token comment" spellcheck="true">//解释："aba" 同样是符合题意的答案。</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：s = "cbbd"</span><span class="token comment" spellcheck="true">//输出："bb"</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：s = "a"</span><span class="token comment" spellcheck="true">//输出："a"</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">//输入：s = "ac"</span><span class="token comment" spellcheck="true">//输出："a"</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 1000 </span><span class="token comment" spellcheck="true">// s 仅由数字和英文字母（大写和/或小写）组成 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 动态规划 </span><span class="token comment" spellcheck="true">// 👍 3300 👎 0</span><span class="token comment" spellcheck="true">//暴力超时</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> s<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String resp <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxLength <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                String ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">-</span>i<span class="token operator">&lt;</span>maxLength<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalind</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   str<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                   maxLength <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>maxLength<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>str<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">if</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>resp<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    resp <span class="token operator">=</span> str<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalind</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">int</span> j <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       j<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//中心扩散法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     String res <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         String s1 <span class="token operator">=</span> <span class="token function">palindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         String s2 <span class="token operator">=</span> <span class="token function">palindrome</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         res <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>s1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span> res<span class="token operator">:</span>s1<span class="token punctuation">;</span>         res <span class="token operator">=</span> res<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span>s2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">?</span> res<span class="token operator">:</span>s2<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">palindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span><span class="token keyword">int</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">==</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             left<span class="token operator">--</span><span class="token punctuation">;</span>             right<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="647-回文子串"><a href="#647-回文子串" class="headerlink" title="647. 回文子串"></a><a href="https://leetcode-cn.com/problems/palindromic-substrings/" target="_blank" rel="noopener">647. 回文子串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。 </span><span class="token comment" spellcheck="true">// 具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入："abc"</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">//解释：三个回文子串: "a", "b", "c"</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入："aaa"</span><span class="token comment" spellcheck="true">//输出：6</span><span class="token comment" spellcheck="true">//解释：6个回文子串: "a", "a", "a", "aa", "aa", "aaa" </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 输入的字符串长度不会超过 1000 。 </span><span class="token comment" spellcheck="true">// Related Topics 字符串 动态规划 </span><span class="token comment" spellcheck="true">// 👍 504 👎 0</span><span class="token comment" spellcheck="true">//暴力通过</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countSubstrings</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             String ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token function">isPalind</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 count<span class="token operator">++</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalind</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> right <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>left<span class="token operator">&lt;</span>right<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           left<span class="token operator">++</span><span class="token punctuation">;</span>           right<span class="token operator">--</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//中心扩散法</span></code></pre><h3 id="数与位"><a href="#数与位" class="headerlink" title="数与位"></a>数与位</h3><h4 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9. 回文数"></a><a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。 </span><span class="token comment" spellcheck="true">// 回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。例如，121 是回文，而 123 不是。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：x = 121</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：x = -121</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">//解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><span class="token comment" spellcheck="true">// 示例 3：  </span><span class="token comment" spellcheck="true">//输入：x = 10</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">//解释：从右向左读, 为 01 。因此它不是一个回文数。</span><span class="token comment" spellcheck="true">// 示例 4：  </span><span class="token comment" spellcheck="true">//输入：x = -101</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// -231 &lt;= x &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// 进阶：你能不将整数转为字符串来解决这个问题吗？ </span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 1413 👎 0</span><span class="token comment" spellcheck="true">//反转后比较</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>       String ans <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span>  ans<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> y <span class="token operator">=</span> chars<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;</span>y<span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">char</span> temp <span class="token operator">=</span> chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>           chars<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> chars<span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>           chars<span class="token punctuation">[</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>           k<span class="token operator">++</span><span class="token punctuation">;</span>           y<span class="token operator">--</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       String res <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chars<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> ans<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//一一比较</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>     String ans <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> j <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">!=</span> ans<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         j<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="231-2的幂"><a href="#231-2的幂" class="headerlink" title="231. 2的幂"></a><a href="https://leetcode-cn.com/problems/power-of-two/" target="_blank" rel="noopener">231. 2的幂</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个整数，编写一个函数来判断它是否是 2 的幂次方。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: 1</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释: 20 = 1 </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: 16</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释: 24 = 16 </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">// 输入: 218</span><span class="token comment" spellcheck="true">//输出: false </span><span class="token comment" spellcheck="true">// Related Topics 位运算 数学 </span><span class="token comment" spellcheck="true">// 👍 290 👎 0</span><span class="token comment" spellcheck="true">//递归解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//位运算处理</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfTwo</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> n <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="342-4的幂"><a href="#342-4的幂" class="headerlink" title="342. 4的幂"></a><a href="https://leetcode-cn.com/problems/power-of-four/" target="_blank" rel="noopener">342. 4的幂</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。 </span><span class="token comment" spellcheck="true">// 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4x </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：n = 16</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：n = 5</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 示例 3：  </span><span class="token comment" spellcheck="true">//输入：n = 1</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 提示：  </span><span class="token comment" spellcheck="true">// -231 &lt;= n &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// 进阶： </span><span class="token comment" spellcheck="true">// 你能不使用循环或者递归来完成本题吗？ </span><span class="token comment" spellcheck="true">// Related Topics 位运算 </span><span class="token comment" spellcheck="true">// 👍 168 👎 0</span><span class="token comment" spellcheck="true">//递归解法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">4</span> <span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token function">isPowerOfFour</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="263-丑数"><a href="#263-丑数" class="headerlink" title="263. 丑数"></a><a href="https://leetcode-cn.com/problems/ugly-number/" target="_blank" rel="noopener">263. 丑数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//编写一个程序判断给定的数是否为丑数。</span><span class="token comment" spellcheck="true">// 丑数就是只包含质因数 2, 3, 5 的正整数。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">// 输入: 6</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释: 6 = 2 × 3</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">// 输入: 8</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//解释: 8 = 2 × 2 × 2</span><span class="token comment" spellcheck="true">// 示例 3:</span><span class="token comment" spellcheck="true">// 输入: 14</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">//解释: 14 不是丑数，因为它包含了另外一个质因数 7。</span><span class="token comment" spellcheck="true">// 说明：</span><span class="token comment" spellcheck="true">// 1 是丑数。</span><span class="token comment" spellcheck="true">// 输入不会超过 32 位有符号整数的范围: [−231, 231 − 1]。</span><span class="token comment" spellcheck="true">// Related Topics 数学</span><span class="token comment" spellcheck="true">// 👍 176 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isUgly</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">2</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">%</span><span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            n <span class="token operator">=</span> n<span class="token operator">/</span><span class="token number">5</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="190-颠倒二进制位"><a href="#190-颠倒二进制位" class="headerlink" title="190. 颠倒二进制位"></a><a href="https://leetcode-cn.com/problems/reverse-bits/" target="_blank" rel="noopener">190. 颠倒二进制位</a></h4><pre><code>//颠倒给定的 32 位无符号整数的二进制位。 // 示例 1： // 输入: 00000010100101000001111010011100//输出: 00111001011110000010100101000000//解释: 输入的二进制串 00000010100101000001111010011100 表示无符号整数 43261596，//     因此返回 964176192，其二进制表示形式为 00111001011110000010100101000000。 //// 示例 2： // 输入：11111111111111111111111111111101//输出：10111111111111111111111111111111//解释：输入的二进制串 11111111111111111111111111111101 表示无符号整数 4294967293，//     因此返回 3221225471 其二进制表示形式为 10111111111111111111111111111111 。 // 提示： // 请注意，在某些语言（如 Java）中，没有无符号整数类型。在这种情况下，输入和输出都将被指定为有符号整数类型，并且不应影响您的实现，因为无论整数是有符号的//还是无符号的，其内部的二进制表示形式都是相同的。 // 在 Java 中，编译器使用二进制补码记法来表示有符号整数。因此，在上面的 示例 2 中，输入表示有符号整数 -3，输出表示有符号整数 -10737418//25。 // 进阶: //如果多次调用这个函数，你将如何优化你的算法？ // Related Topics 位运算 // 👍 273 👎 0public class Solution {    // you need treat n as an unsigned value    public int reverseBits(int n) {    }}</code></pre><h4 id="492-构造矩形"><a href="#492-构造矩形" class="headerlink" title="492. 构造矩形"></a><a href="https://leetcode-cn.com/problems/construct-the-rectangle/" target="_blank" rel="noopener">492. 构造矩形</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//作为一位web开发者， 懂得怎样去规划一个页面的尺寸是很重要的。 现给定一个具体的矩形页面面积，你的任务是设计一个长度为 L 和宽度为 W 且满足以下要求的</span><span class="token comment" spellcheck="true">//矩形的页面。要求：</span><span class="token comment" spellcheck="true">//1. 你设计的矩形页面必须等于给定的目标面积。</span><span class="token comment" spellcheck="true">//2. 宽度 W 不应大于长度 L，换言之，要求 L >= W 。</span><span class="token comment" spellcheck="true">//3. 长度 L 和宽度 W 之间的差距应当尽可能小。</span><span class="token comment" spellcheck="true">// 你需要按顺序输出你设计的页面的长度 L 和宽度 W。</span><span class="token comment" spellcheck="true">// 示例：</span><span class="token comment" spellcheck="true">//输入: 4</span><span class="token comment" spellcheck="true">//输出: [2, 2]</span><span class="token comment" spellcheck="true">//解释: 目标面积是 4， 所有可能的构造方案有 [1,4], [2,2], [4,1]。</span><span class="token comment" spellcheck="true">//但是根据要求2，[1,4] 不符合要求; 根据要求3，[2,2] 比 [4,1] 更能符合要求. 所以输出长度 L 为 2， 宽度 W 为 2。</span><span class="token comment" spellcheck="true">// 说明:</span><span class="token comment" spellcheck="true">// 给定的面积不大于 10,000,000 且为正整数。</span><span class="token comment" spellcheck="true">// 你设计的页面的长度和宽度必须都是正整数。</span><span class="token comment" spellcheck="true">// Related Topics 数学</span><span class="token comment" spellcheck="true">// 👍 51 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">constructRectangle</span><span class="token punctuation">(</span><span class="token keyword">int</span> area<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>area<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>area<span class="token operator">%</span>i<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> area<span class="token operator">/</span>i<span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            i<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="29-两数相除"><a href="#29-两数相除" class="headerlink" title="29. 两数相除"></a><a href="https://leetcode-cn.com/problems/divide-two-integers/" target="_blank" rel="noopener">29. 两数相除</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个整数，被除数 dividend 和除数 divisor。将两数相除，要求不使用乘法、除法和 mod 运算符。 </span><span class="token comment" spellcheck="true">// 返回被除数 dividend 除以除数 divisor 得到的商。 </span><span class="token comment" spellcheck="true">// 整数除法的结果应当截去（truncate）其小数部分，例如：truncate(8.345) = 8 以及 truncate(-2.7335) = -2 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: dividend = 10, divisor = 3</span><span class="token comment" spellcheck="true">//输出: 3</span><span class="token comment" spellcheck="true">//解释: 10/3 = truncate(3.33333..) = truncate(3) = 3 </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: dividend = 7, divisor = -3</span><span class="token comment" spellcheck="true">//输出: -2</span><span class="token comment" spellcheck="true">//解释: 7/-3 = truncate(-2.33333..) = -2 </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 被除数和除数均为 32 位有符号整数。 </span><span class="token comment" spellcheck="true">// 除数不为 0。 </span><span class="token comment" spellcheck="true">// 假设我们的环境只能存储 32 位有符号整数，其数值范围是 [−231, 231 − 1]。本题中，如果除法结果溢出，则返回 231 − 1。 </span><span class="token comment" spellcheck="true">// Related Topics 数学 二分查找 </span><span class="token comment" spellcheck="true">// 👍 518 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">divide</span><span class="token punctuation">(</span><span class="token keyword">int</span> dividend<span class="token punctuation">,</span> <span class="token keyword">int</span> divisor<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="507-完美数"><a href="#507-完美数" class="headerlink" title="507. 完美数"></a><a href="https://leetcode-cn.com/problems/perfect-number/" target="_blank" rel="noopener">507. 完美数</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//对于一个 正整数，如果它和除了它自身以外的所有 正因子 之和相等，我们称它为 「完美数」。 </span><span class="token comment" spellcheck="true">// 给定一个 整数 n， 如果是完美数，返回 true，否则返回 false </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：28</span><span class="token comment" spellcheck="true">//输出：True</span><span class="token comment" spellcheck="true">//解释：28 = 1 + 2 + 4 + 7 + 14</span><span class="token comment" spellcheck="true">//1, 2, 4, 7, 和 14 是 28 的所有正因子。 </span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：num = 6</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：num = 496</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">// 输入：num = 8128</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 5： </span><span class="token comment" spellcheck="true">// 输入：num = 2</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= num &lt;= 108 </span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 82 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">checkPerfectNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="栈与递归"><a href="#栈与递归" class="headerlink" title="栈与递归"></a>栈与递归</h3><h4 id="682-棒球比赛"><a href="#682-棒球比赛" class="headerlink" title="682. 棒球比赛"></a><a href="https://leetcode-cn.com/problems/baseball-game/" target="_blank" rel="noopener">682. 棒球比赛</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//你现在是一场采用特殊赛制棒球比赛的记录员。这场比赛由若干回合组成，过去几回合的得分可能会影响以后几回合的得分。</span><span class="token comment" spellcheck="true">// 比赛开始时，记录是空白的。你会得到一个记录操作的字符串列表 ops，其中 ops[i] 是你需要记录的第 i 项操作，ops 遵循下述规则：</span><span class="token comment" spellcheck="true">// 整数 x - 表示本回合新获得分数 x</span><span class="token comment" spellcheck="true">// "+" - 表示本回合新获得的得分是前两次得分的总和。题目数据保证记录此操作时前面总是存在两个有效的分数。</span><span class="token comment" spellcheck="true">// "D" - 表示本回合新获得的得分是前一次得分的两倍。题目数据保证记录此操作时前面总是存在一个有效的分数。</span><span class="token comment" spellcheck="true">// "C" - 表示前一次得分无效，将其从记录中移除。题目数据保证记录此操作时前面总是存在一个有效的分数。</span><span class="token comment" spellcheck="true">// 请你返回记录中所有得分的总和。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：ops = ["5","2","C","D","+"]</span><span class="token comment" spellcheck="true">//输出：30</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//"5" - 记录加 5 ，记录现在是 [5]</span><span class="token comment" spellcheck="true">//"2" - 记录加 2 ，记录现在是 [5, 2]</span><span class="token comment" spellcheck="true">//"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5].</span><span class="token comment" spellcheck="true">//"D" - 记录加 2 * 5 = 10 ，记录现在是 [5, 10].</span><span class="token comment" spellcheck="true">//"+" - 记录加 5 + 10 = 15 ，记录现在是 [5, 10, 15].</span><span class="token comment" spellcheck="true">//所有得分的总和 5 + 10 + 15 = 30</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：ops = ["5","-2","4","C","D","9","+","+"]</span><span class="token comment" spellcheck="true">//输出：27</span><span class="token comment" spellcheck="true">//解释：</span><span class="token comment" spellcheck="true">//"5" - 记录加 5 ，记录现在是 [5]</span><span class="token comment" spellcheck="true">//"-2" - 记录加 -2 ，记录现在是 [5, -2]</span><span class="token comment" spellcheck="true">//"4" - 记录加 4 ，记录现在是 [5, -2, 4]</span><span class="token comment" spellcheck="true">//"C" - 使前一次得分的记录无效并将其移除，记录现在是 [5, -2]</span><span class="token comment" spellcheck="true">//"D" - 记录加 2 * -2 = -4 ，记录现在是 [5, -2, -4]</span><span class="token comment" spellcheck="true">//"9" - 记录加 9 ，记录现在是 [5, -2, -4, 9]</span><span class="token comment" spellcheck="true">//"+" - 记录加 -4 + 9 = 5 ，记录现在是 [5, -2, -4, 9, 5]</span><span class="token comment" spellcheck="true">//"+" - 记录加 9 + 5 = 14 ，记录现在是 [5, -2, -4, 9, 5, 14]</span><span class="token comment" spellcheck="true">//所有得分的总和 5 + -2 + -4 + 9 + 5 + 14 = 27</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：ops = ["1"]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= ops.length &lt;= 1000</span><span class="token comment" spellcheck="true">// ops[i] 为 "C"、"D"、"+"，或者一个表示整数的字符串。整数范围是 [-3 * 104, 3 * 104]</span><span class="token comment" spellcheck="true">// 对于 "+" 操作，题目数据保证记录此操作时前面总是存在两个有效的分数</span><span class="token comment" spellcheck="true">// 对于 "C" 和 "D" 操作，题目数据保证记录此操作时前面总是存在一个有效的分数</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 栈</span><span class="token comment" spellcheck="true">// 👍 168 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calPoints</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> ops<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ops<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> index <span class="token operator">=</span>  <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ops<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            index<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">continue</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> res<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> res<span class="token punctuation">[</span>index<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        index<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>res<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        sum <span class="token operator">=</span> sum <span class="token operator">+</span> res<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token keyword">return</span> sum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//栈的方式解决</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calPoints</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> ops<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ops<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//先弹出栈顶元素，再记录最后一个，最后把弹出的元素加回去</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">int</span> top <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> top1 <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> addNum <span class="token operator">=</span> top <span class="token operator">+</span> top1<span class="token punctuation">;</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>top<span class="token punctuation">)</span><span class="token punctuation">;</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>addNum<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>ops<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Integer i<span class="token operator">:</span>deque<span class="token punctuation">)</span> <span class="token punctuation">{</span>           res <span class="token operator">=</span>res <span class="token operator">+</span> i<span class="token punctuation">;</span>         <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="150-逆波兰表达式求值"><a href="#150-逆波兰表达式求值" class="headerlink" title="150. 逆波兰表达式求值"></a><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">150. 逆波兰表达式求值</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//根据 逆波兰表示法，求表达式的值。</span><span class="token comment" spellcheck="true">// 有效的运算符包括 +, -, *, / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。</span><span class="token comment" spellcheck="true">// 说明：</span><span class="token comment" spellcheck="true">// 整数除法只保留整数部分。</span><span class="token comment" spellcheck="true">// 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">// 输入: ["4", "13", "5", "/", "+"]</span><span class="token comment" spellcheck="true">//输出: 6</span><span class="token comment" spellcheck="true">//解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">// 输入: ["10", "6", "9", "3", "+", "-11", "*", "/", "*", "17", "+", "5", "+"]</span><span class="token comment" spellcheck="true">//输出: 22</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//该算式转化为常见的中缀算术表达式为：</span><span class="token comment" spellcheck="true">//  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5</span><span class="token comment" spellcheck="true">//= ((10 * (6 / (12 * -11))) + 17) + 5</span><span class="token comment" spellcheck="true">//= ((10 * (6 / -132)) + 17) + 5</span><span class="token comment" spellcheck="true">//= ((10 * 0) + 17) + 5</span><span class="token comment" spellcheck="true">//= (0 + 17) + 5</span><span class="token comment" spellcheck="true">//= 17 + 5</span><span class="token comment" spellcheck="true">//= 22</span><span class="token comment" spellcheck="true">// 逆波兰表达式：</span><span class="token comment" spellcheck="true">// 逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。</span><span class="token comment" spellcheck="true">// 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。</span><span class="token comment" spellcheck="true">// 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。</span><span class="token comment" spellcheck="true">// 逆波兰表达式主要有以下两个优点：</span><span class="token comment" spellcheck="true">// 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。</span><span class="token comment" spellcheck="true">// 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。</span><span class="token comment" spellcheck="true">// Related Topics 栈</span><span class="token comment" spellcheck="true">// 👍 263 👎 0</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayDeque<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">evalRPN</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> tokens<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>tokens<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token operator">-</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">int</span> top <span class="token operator">=</span>  deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token keyword">int</span> top1 <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>top1 <span class="token operator">/</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>tokens<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>     <span class="token keyword">return</span> deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="227-基本计算器-II"><a href="#227-基本计算器-II" class="headerlink" title="227. 基本计算器 II"></a><a href="https://leetcode-cn.com/problems/basic-calculator-ii/" target="_blank" rel="noopener">227. 基本计算器 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//实现一个基本的计算器来计算一个简单的字符串表达式的值。 </span><span class="token comment" spellcheck="true">// 字符串表达式仅包含非负整数，+， - ，*，/ 四种运算符和空格 。 整数除法仅保留整数部分。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: "3+2*2"</span><span class="token comment" spellcheck="true">//输出: 7</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: " 3/2 "</span><span class="token comment" spellcheck="true">//输出: 1 </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">// 输入: " 3+5 / 2 "</span><span class="token comment" spellcheck="true">//输出: 5</span><span class="token comment" spellcheck="true">// 说明： </span><span class="token comment" spellcheck="true">// 你可以假设所给定的表达式都是有效的。 </span><span class="token comment" spellcheck="true">// 请不要使用内置的库函数 eval。 </span><span class="token comment" spellcheck="true">// Related Topics 栈 字符串 </span><span class="token comment" spellcheck="true">// 👍 269 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//中缀转后缀</span>        <span class="token comment" spellcheck="true">//优先级高 入栈  来的元素优先级&lt;= 栈内元素优先级，弹出</span>        Deque<span class="token operator">&lt;</span>Character<span class="token operator">></span> chars <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果是符号类型，栈为空，入栈</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> chars<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                chars<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//如果当前符号优先级&lt;= 栈顶符号 ，将栈内元素弹出直到栈为空，将当前符号入栈</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'+'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>chars<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                chars<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">///如果当前符号优先级&lt;= 栈顶符号 ，将栈内元素弹出直到栈为空，将当前符号入栈,</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               Character k <span class="token operator">=</span> chars<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">//当前符号优先级大于栈顶元素，符号入栈</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">==</span><span class="token string">'+'</span> <span class="token operator">||</span> k<span class="token operator">==</span><span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   chars<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">else</span><span class="token punctuation">{</span>                   <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                       <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> chars<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token string">'+'</span> <span class="token operator">||</span> chars<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'-'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                           <span class="token keyword">break</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span>                       <span class="token keyword">if</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'*'</span> <span class="token operator">||</span> chars<span class="token punctuation">.</span><span class="token function">peekLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                           res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                       <span class="token punctuation">}</span>                   <span class="token punctuation">}</span>                   chars<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//数字，多位数截取</span>                <span class="token keyword">int</span> k <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">while</span><span class="token punctuation">(</span>k<span class="token operator">&lt;=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> Character<span class="token punctuation">.</span><span class="token function">isDigit</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  k<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                i <span class="token operator">=</span> k<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>       <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span>chars<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>chars<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//逆波兰表达式求值，后缀表达式转中缀表达式</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"+"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"-"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span><span class="token operator">-</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> top <span class="token operator">=</span>  deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> top1 <span class="token operator">=</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>top1 <span class="token operator">/</span> top<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span><span class="token string">"*"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>Integer<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>res<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> deque<span class="token punctuation">.</span><span class="token function">peekFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="224-基本计算器"><a href="#224-基本计算器" class="headerlink" title="224. 基本计算器"></a><a href="https://leetcode-cn.com/problems/basic-calculator/" target="_blank" rel="noopener">224. 基本计算器</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个字符串表达式 s ，请你实现一个基本计算器来计算并返回它的值。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：s = "1 + 1"</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">// 示例 2：  </span><span class="token comment" spellcheck="true">//输入：s = " 2-1 + 2 "</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">//输入：s = "(1+(4+5+2)-3)+(6+8)"</span><span class="token comment" spellcheck="true">//输出：23</span><span class="token comment" spellcheck="true">// 提示：  </span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 3 * 105 </span><span class="token comment" spellcheck="true">// s 由数字、'+'、'-'、'('、')'、和 ' ' 组成 </span><span class="token comment" spellcheck="true">// s 表示一个有效的表达式 </span><span class="token comment" spellcheck="true">// Related Topics 栈 数学 </span><span class="token comment" spellcheck="true">// 👍 494 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">calculate</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode-cn.com/problems/valid-parentheses/" target="_blank" rel="noopener">20. 有效的括号</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。</span><span class="token comment" spellcheck="true">// 有效字符串需满足：</span><span class="token comment" spellcheck="true">// 左括号必须用相同类型的右括号闭合。</span><span class="token comment" spellcheck="true">// 左括号必须以正确的顺序闭合。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：s = "()"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "()[]{}"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：s = "(]"</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 示例 4：</span><span class="token comment" spellcheck="true">//输入：s = "([)]"</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 示例 5：</span><span class="token comment" spellcheck="true">//输入：s = "{[]}"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= s.length &lt;= 104</span><span class="token comment" spellcheck="true">// s 仅由括号 '()[]{}' 组成</span><span class="token comment" spellcheck="true">// Related Topics 栈 字符串</span><span class="token comment" spellcheck="true">// 👍 2225 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Deque<span class="token operator">&lt;</span>Character<span class="token operator">></span> deque <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayDeque</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">']'</span> <span class="token operator">||</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span><span class="token string">'}'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">']'</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token string">'['</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">')'</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token string">'('</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'}'</span> <span class="token operator">&amp;&amp;</span> deque<span class="token punctuation">.</span><span class="token function">pollLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token string">'{'</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                deque<span class="token punctuation">.</span><span class="token function">offerLast</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>deque<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><h4 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs/" target="_blank" rel="noopener">24. 两两交换链表中的节点</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。</span><span class="token comment" spellcheck="true">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：head = [1,2,3,4]</span><span class="token comment" spellcheck="true">//输出：[2,1,4,3]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：head = []</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：head = [1]</span><span class="token comment" spellcheck="true">//输出：[1]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 链表中节点的数目在范围 [0, 100] 内</span><span class="token comment" spellcheck="true">// 0 &lt;= Node.val &lt;= 100</span><span class="token comment" spellcheck="true">// 进阶：你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）</span><span class="token comment" spellcheck="true">// Related Topics 递归 链表</span><span class="token comment" spellcheck="true">// 👍 869 👎 0</span><span class="token comment" spellcheck="true">/**迭代法 * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">swapPairs</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>head<span class="token punctuation">)</span><span class="token punctuation">;</span>        ListNode temp <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>temp<span class="token punctuation">.</span>next <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            ListNode node1 <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            ListNode node2 <span class="token operator">=</span> temp<span class="token punctuation">.</span>next<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            temp<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">;</span>            node1<span class="token punctuation">.</span>next <span class="token operator">=</span> node2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            node2<span class="token punctuation">.</span>next <span class="token operator">=</span> node1<span class="token punctuation">;</span>            temp <span class="token operator">=</span> node1<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/" target="_blank" rel="noopener">206. 反转链表</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//反转一个单链表。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: 1->2->3->4->5->NULL</span><span class="token comment" spellcheck="true">//输出: 5->4->3->2->1->NULL</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 进阶:</span><span class="token comment" spellcheck="true">//你可以迭代或递归地反转链表。你能否用两种方法解决这道题？</span><span class="token comment" spellcheck="true">// Related Topics 链表</span><span class="token comment" spellcheck="true">// 👍 1637 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>      ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>      ListNode temp <span class="token operator">=</span> null<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          temp <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>          prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>          curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">92. 反转链表 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链</span><span class="token comment" spellcheck="true">//表节点，返回 反转后的链表 。</span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：head = [1,2,3,4,5], left = 2, right = 4</span><span class="token comment" spellcheck="true">//输出：[1,4,3,2,5]</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：head = [5], left = 1, right = 1</span><span class="token comment" spellcheck="true">//输出：[5]</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 链表中节点数目为 n </span><span class="token comment" spellcheck="true">// 1 &lt;= n &lt;= 500 </span><span class="token comment" spellcheck="true">// -500 &lt;= Node.val &lt;= 500 </span><span class="token comment" spellcheck="true">// 1 &lt;= left &lt;= right &lt;= n </span><span class="token comment" spellcheck="true">// 进阶： 你可以使用一趟扫描完成反转吗？ </span><span class="token comment" spellcheck="true">// Related Topics 链表 </span><span class="token comment" spellcheck="true">// 👍 839 👎 0</span><span class="token comment" spellcheck="true">/**穿针引线 * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseBetween</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        dummy<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode prev <span class="token operator">=</span> dummy<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode rightNode <span class="token operator">=</span> prev<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>right<span class="token operator">-</span>left<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            rightNode <span class="token operator">=</span> rightNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode curr <span class="token operator">=</span> rightNode<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        ListNode leftNode <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//切断链表</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        rightNode<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token function">reverseNode</span><span class="token punctuation">(</span>leftNode<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//接链表</span>        prev<span class="token punctuation">.</span>next <span class="token operator">=</span> rightNode<span class="token punctuation">;</span>        leftNode<span class="token punctuation">.</span>next <span class="token operator">=</span> curr<span class="token punctuation">;</span>        <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reverseNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode temp <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            temp <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>            curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode-cn.com/problems/add-two-numbers/" target="_blank" rel="noopener">2. 两数相加</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。</span><span class="token comment" spellcheck="true">// 请你将两个数相加，并以相同形式返回一个表示和的链表。</span><span class="token comment" spellcheck="true">// 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：l1 = [2,4,3], l2 = [5,6,4]</span><span class="token comment" spellcheck="true">//输出：[7,0,8]</span><span class="token comment" spellcheck="true">//解释：342 + 465 = 807.</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：l1 = [0], l2 = [0]</span><span class="token comment" spellcheck="true">//输出：[0]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]</span><span class="token comment" spellcheck="true">//输出：[8,9,9,9,0,0,0,1]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 每个链表中的节点数在范围 [1, 100] 内</span><span class="token comment" spellcheck="true">// 0 &lt;= Node.val &lt;= 9</span><span class="token comment" spellcheck="true">// 题目数据保证列表表示的数字不含前导零</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 递归 链表 数学</span><span class="token comment" spellcheck="true">// 👍 5910 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null <span class="token operator">||</span> carry <span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> l1Val <span class="token operator">=</span> l1 <span class="token operator">!=</span>null <span class="token operator">?</span> l1<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l2Val <span class="token operator">=</span> l2 <span class="token operator">!=</span>null <span class="token operator">?</span> l2<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sumVal <span class="token operator">=</span> l1Val<span class="token operator">+</span>l2Val<span class="token operator">+</span>carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sumVal<span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">;</span>            <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span>sumVal<span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="445-两数相加-II"><a href="#445-两数相加-II" class="headerlink" title="445. 两数相加 II"></a><a href="https://leetcode-cn.com/problems/add-two-numbers-ii/" target="_blank" rel="noopener">445. 两数相加 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你两个 非空 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。</span><span class="token comment" spellcheck="true">// 你可以假设除了数字 0 之外，这两个数字都不会以零开头。</span><span class="token comment" spellcheck="true">// 进阶：</span><span class="token comment" spellcheck="true">// 如果输入链表不能修改该如何处理？换句话说，你不能对列表中的节点进行翻转。</span><span class="token comment" spellcheck="true">// 示例：</span><span class="token comment" spellcheck="true">// 输入：(7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)</span><span class="token comment" spellcheck="true">//输出：7 -> 8 -> 0 -> 7</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 链表</span><span class="token comment" spellcheck="true">// 👍 359 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { val = x; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">addTwoNumbers</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        l1 <span class="token operator">=</span> <span class="token function">reverseNode</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        l2 <span class="token operator">=</span> <span class="token function">reverseNode</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> carry <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        ListNode result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null <span class="token operator">||</span> carry <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> l1Val <span class="token operator">=</span> l1 <span class="token operator">!=</span> null <span class="token operator">?</span> l1<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> l2Val <span class="token operator">=</span> l2 <span class="token operator">!=</span> null <span class="token operator">?</span> l2<span class="token punctuation">.</span>val <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> sumVal <span class="token operator">=</span> l1Val <span class="token operator">+</span> l2Val <span class="token operator">+</span> carry<span class="token punctuation">;</span>            carry <span class="token operator">=</span> sumVal <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>            <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> sumVal <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">reverseNode</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ListNode <span class="token function">reverseNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        ListNode temp <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            curr<span class="token punctuation">.</span>next <span class="token operator">=</span> prev<span class="token punctuation">;</span>            prev <span class="token operator">=</span> curr<span class="token punctuation">;</span>            curr <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span> <span class="token keyword">int</span> val<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode node <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists/" target="_blank" rel="noopener">21. 合并两个有序链表</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：l1 = [1,2,4], l2 = [1,3,4]</span><span class="token comment" spellcheck="true">//输出：[1,1,2,3,4,4]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：l1 = [], l2 = []</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：l1 = [], l2 = [0]</span><span class="token comment" spellcheck="true">//输出：[0]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 两个链表的节点数目范围是 [0, 50]</span><span class="token comment" spellcheck="true">// -100 &lt;= Node.val &lt;= 100</span><span class="token comment" spellcheck="true">// l1 和 l2 均按 非递减顺序 排列</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 递归 链表</span><span class="token comment" spellcheck="true">// 👍 1632 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">||</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val <span class="token operator">>=</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                    l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>l1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> l2 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">addNode</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> l1<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>                l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addNode</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">,</span><span class="token keyword">int</span> val<span class="token punctuation">)</span><span class="token punctuation">{</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>curr<span class="token punctuation">.</span>next <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>            curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        ListNode node <span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>        curr<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/**迭代优化 * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">mergeTwoLists</span><span class="token punctuation">(</span>ListNode l1<span class="token punctuation">,</span> ListNode l2<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ListNode dummy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ListNode</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      ListNode prev <span class="token operator">=</span> dummy<span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>l1 <span class="token operator">!=</span>null <span class="token operator">&amp;&amp;</span> l2<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">.</span>val<span class="token operator">>=</span>l2<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>             prev<span class="token punctuation">.</span>next <span class="token operator">=</span> l2<span class="token punctuation">;</span>             l2 <span class="token operator">=</span> l2<span class="token punctuation">.</span>next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             prev<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token punctuation">;</span>             l1 <span class="token operator">=</span> l1<span class="token punctuation">.</span>next<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         prev <span class="token operator">=</span> prev<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      prev<span class="token punctuation">.</span>next <span class="token operator">=</span> l1<span class="token operator">==</span>null<span class="token operator">?</span>l2<span class="token operator">:</span>l1<span class="token punctuation">;</span>      <span class="token keyword">return</span> dummy<span class="token punctuation">.</span>next<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><h4 id="217-存在重复元素"><a href="#217-存在重复元素" class="headerlink" title="217. 存在重复元素"></a><a href="https://leetcode-cn.com/problems/contains-duplicate/" target="_blank" rel="noopener">217. 存在重复元素</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个整数数组，判断是否存在重复元素。</span><span class="token comment" spellcheck="true">// 如果存在一值在数组中出现至少两次，函数返回 true 。如果数组中每个元素都不相同，则返回 false 。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">//输入: [1,2,3,1]</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">//输入: [1,2,3,4]</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">// 示例 3:</span><span class="token comment" spellcheck="true">//输入: [1,1,1,3,3,4,3,2,4,2]</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">// Related Topics 数组 哈希表</span><span class="token comment" spellcheck="true">// 👍 376 👎 0</span><span class="token comment" spellcheck="true">//数组排序</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>           Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">int</span> length <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>           <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//哈希表</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="633-平方数之和"><a href="#633-平方数之和" class="headerlink" title="633. 平方数之和"></a><a href="https://leetcode-cn.com/problems/sum-of-square-numbers/" target="_blank" rel="noopener">633. 平方数之和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个非负整数 c ，你要判断是否存在两个整数 a 和 b，使得 a2 + b2 = c 。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：c = 5</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">//解释：1 * 1 + 2 * 2 = 5</span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">// 输入：c = 3</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 示例 3： </span><span class="token comment" spellcheck="true">// 输入：c = 4</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 4： </span><span class="token comment" spellcheck="true">// 输入：c = 2</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 5： </span><span class="token comment" spellcheck="true">// 输入：c = 1</span><span class="token comment" spellcheck="true">//输出：true </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= c &lt;= 231 - 1 </span><span class="token comment" spellcheck="true">// Related Topics 数学 </span><span class="token comment" spellcheck="true">// 👍 170 👎 0</span><span class="token comment" spellcheck="true">//双指针法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">judgeSquareSum</span><span class="token punctuation">(</span><span class="token keyword">int</span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">sqrt</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;=</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token operator">*</span>j<span class="token operator">></span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">*</span>i<span class="token operator">+</span>j<span class="token operator">*</span>j<span class="token operator">&lt;</span>c<span class="token punctuation">)</span><span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="349-两个数组的交集"><a href="#349-两个数组的交集" class="headerlink" title="349. 两个数组的交集"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays/" target="_blank" rel="noopener">349. 两个数组的交集</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个数组，编写一个函数来计算它们的交集。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">// 输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><span class="token comment" spellcheck="true">//输出：[2]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">// 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><span class="token comment" spellcheck="true">//输出：[9,4]</span><span class="token comment" spellcheck="true">// 说明：</span><span class="token comment" spellcheck="true">// 输出结果中的每个元素一定是唯一的。</span><span class="token comment" spellcheck="true">// 我们可以不考虑输出结果的顺序。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 排序 哈希表 双指针 二分查找</span><span class="token comment" spellcheck="true">// 👍 345 👎 0</span><span class="token comment" spellcheck="true">//HashSet处理</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>     <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersection</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums1Set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        HashSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums2Set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            nums1Set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums1Set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                nums2Set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>nums2Set<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Integer item<span class="token operator">:</span> nums2Set<span class="token punctuation">)</span><span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>            i<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence/" target="_blank" rel="noopener">128. 最长连续序列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。 </span><span class="token comment" spellcheck="true">// 进阶：你可以设计并实现时间复杂度为 O(n) 的解决方案吗？ </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [100,4,200,1,3,2]</span><span class="token comment" spellcheck="true">//输出：4</span><span class="token comment" spellcheck="true">//解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。 </span><span class="token comment" spellcheck="true">// 示例 2： </span><span class="token comment" spellcheck="true">//输入：nums = [0,3,7,2,5,8,4,6,0,1]</span><span class="token comment" spellcheck="true">//输出：9</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 104 </span><span class="token comment" spellcheck="true">// -109 &lt;= nums[i] &lt;= 109 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 并查集 数组 </span><span class="token comment" spellcheck="true">// 👍 728 👎 0</span><span class="token comment" spellcheck="true">//去重->排序处理</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestConsecutive</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>       Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> sets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          sets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>sets<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span>Integer item<span class="token operator">:</span>sets<span class="token punctuation">)</span><span class="token punctuation">{</span>           ans<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>           i<span class="token operator">++</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>      Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>      <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>ans<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">==</span> ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               count<span class="token operator">++</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">else</span><span class="token punctuation">{</span>              count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>count<span class="token punctuation">,</span>max<span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="500-键盘行"><a href="#500-键盘行" class="headerlink" title="500. 键盘行"></a><a href="https://leetcode-cn.com/problems/keyboard-row/" target="_blank" rel="noopener">500. 键盘行</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个字符串数组 words ，只返回可以使用在 美式键盘 同一行的字母打印出来的单词。键盘如下图所示。</span><span class="token comment" spellcheck="true">// 美式键盘 中：</span><span class="token comment" spellcheck="true">// 第一行由字符 "qwertyuiop" 组成。</span><span class="token comment" spellcheck="true">// 第二行由字符 "asdfghjkl" 组成。</span><span class="token comment" spellcheck="true">// 第三行由字符 "zxcvbnm" 组成。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：words = ["Hello","Alaska","Dad","Peace"]</span><span class="token comment" spellcheck="true">//输出：["Alaska","Dad"]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：words = ["omk"]</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：words = ["adsdf","sfd"]</span><span class="token comment" spellcheck="true">//输出：["adsdf","sfd"]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= words.length &lt;= 20</span><span class="token comment" spellcheck="true">// 1 &lt;= words[i].length &lt;= 100</span><span class="token comment" spellcheck="true">// words[i] 由英文字母（小写和大写字母）组成</span><span class="token comment" spellcheck="true">// Related Topics 哈希表</span><span class="token comment" spellcheck="true">// 👍 127 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findWords</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> first <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> second <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> third <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String firstKey <span class="token operator">=</span> <span class="token string">"qwertyuiop"</span><span class="token punctuation">;</span>        String secondKey <span class="token operator">=</span> <span class="token string">"asdfghjkl"</span><span class="token punctuation">;</span>        String thirdKey <span class="token operator">=</span> <span class="token string">"zxcvbnm"</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>firstKey<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            first<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>secondKey<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            second<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>secondKey<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>thirdKey<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            third<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>thirdKey<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> words<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            String message <span class="token operator">=</span> words<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">boolean</span> flagA <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> message<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>first<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    flagA <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flagA<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">boolean</span> flagB <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> message<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>second<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    flagB <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flagB<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">boolean</span> flagC <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> l <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> l <span class="token operator">&lt;</span> message<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> l<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>third<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span>message<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    flagC <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flagC<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>res<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String item<span class="token operator">:</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>            resp<span class="token punctuation">[</span>m<span class="token punctuation">]</span> <span class="token operator">=</span> item<span class="token punctuation">;</span>            m<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="290-单词规律"><a href="#290-单词规律" class="headerlink" title="290. 单词规律"></a><a href="https://leetcode-cn.com/problems/word-pattern/" target="_blank" rel="noopener">290. 单词规律</a></h4><pre><code>//给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。 //// 这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。 //// 示例1: //// 输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;//输出: true //// 示例 2: //// 输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;//输出: false //// 示例 3: //// 输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;//输出: false //// 示例 4: //// 输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;//输出: false //// 说明: //你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母。 // Related Topics 哈希表 // 👍 319 👎 0//leetcode submit region begin(Prohibit modification and deletion)class Solution {    public boolean wordPattern(String pattern, String s) {    }}//leetcode submit region end(Prohibit modification and deletion)</code></pre><h4 id="205-同构字符串"><a href="#205-同构字符串" class="headerlink" title="205. 同构字符串"></a><a href="https://leetcode-cn.com/problems/isomorphic-strings/" target="_blank" rel="noopener">205. 同构字符串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个字符串 s 和 t，判断它们是否是同构的。</span><span class="token comment" spellcheck="true">// 如果 s 中的字符可以按某种映射关系替换得到 t ，那么这两个字符串是同构的。</span><span class="token comment" spellcheck="true">// 每个出现的字符都应当映射到另一个字符，同时不改变字符的顺序。不同字符不能映射到同一个字符上，相同字符只能映射到同一个字符上，字符可以映射到自己本身。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">//输入：s = "egg", t = "add"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "foo", t = "bar"</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：s = "paper", t = "title"</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 可以假设 s 和 t 长度相同。</span><span class="token comment" spellcheck="true">// Related Topics 哈希表</span><span class="token comment" spellcheck="true">// 👍 345 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isIsomorphic</span><span class="token punctuation">(</span>String s<span class="token punctuation">,</span> String t<span class="token punctuation">)</span> <span class="token punctuation">{</span>     Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Character<span class="token operator">></span> sMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Character<span class="token operator">></span> tMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">char</span> x <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> sMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">!=</span>y<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>tMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> tMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span> <span class="token operator">!=</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         sMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>         tMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="167. 两数之和 II - 输入有序数组"></a><a href="https://leetcode-cn.com/problems/two-sum-ii-input-array-is-sorted/" target="_blank" rel="noopener">167. 两数之和 II - 输入有序数组</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个已按照 升序排列 的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。</span><span class="token comment" spellcheck="true">// 函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 1 开始计数 ，所以答案数组应当满足 1 &lt;= answer[0]</span><span class="token comment" spellcheck="true">// &lt; answer[1] &lt;= numbers.length 。</span><span class="token comment" spellcheck="true">// 你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：numbers = [2,7,11,15], target = 9</span><span class="token comment" spellcheck="true">//输出：[1,2]</span><span class="token comment" spellcheck="true">//解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：numbers = [2,3,4], target = 6</span><span class="token comment" spellcheck="true">//输出：[1,3]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：numbers = [-1,0], target = -1</span><span class="token comment" spellcheck="true">//输出：[1,2]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 2 &lt;= numbers.length &lt;= 3 * 104</span><span class="token comment" spellcheck="true">// -1000 &lt;= numbers[i] &lt;= 1000</span><span class="token comment" spellcheck="true">// numbers 按 递增顺序 排列</span><span class="token comment" spellcheck="true">// -1000 &lt;= target &lt;= 1000</span><span class="token comment" spellcheck="true">// 仅存在一个有效答案</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组 双指针 二分查找</span><span class="token comment" spellcheck="true">// 👍 491 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> numbers<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                res<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                res<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="599-两个列表的最小索引总和"><a href="#599-两个列表的最小索引总和" class="headerlink" title="599. 两个列表的最小索引总和"></a><a href="https://leetcode-cn.com/problems/minimum-index-sum-of-two-lists/" target="_blank" rel="noopener">599. 两个列表的最小索引总和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//假设Andy和Doris想在晚餐时选择一家餐厅，并且他们都有一个表示最喜爱餐厅的列表，每个餐厅的名字用字符串表示。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 你需要帮助他们用最少的索引和找出他们共同喜爱的餐厅。 如果答案不止一个，则输出所有答案并且不考虑顺序。 你可以假设总是存在一个答案。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">// 输入:</span><span class="token comment" spellcheck="true">//["Shogun", "Tapioca Express", "Burger King", "KFC"]</span><span class="token comment" spellcheck="true">//["Piatti", "The Grill at Torrey Pines", "Hungry Hunter Steakhouse", "Shogun"]</span><span class="token comment" spellcheck="true">//输出: ["Shogun"]</span><span class="token comment" spellcheck="true">//解释: 他们唯一共同喜爱的餐厅是“Shogun”。</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">// 输入:</span><span class="token comment" spellcheck="true">//["Shogun", "Tapioca Express", "Burger King", "KFC"]</span><span class="token comment" spellcheck="true">//["KFC", "Shogun", "Burger King"]</span><span class="token comment" spellcheck="true">//输出: ["Shogun"]</span><span class="token comment" spellcheck="true">//解释: 他们共同喜爱且具有最小索引和的餐厅是“Shogun”，它有最小的索引和1(0+1)。</span><span class="token comment" spellcheck="true">// 提示:</span><span class="token comment" spellcheck="true">// 两个列表的长度范围都在 [1, 1000]内。</span><span class="token comment" spellcheck="true">// 两个列表中的字符串的长度将在[1，30]的范围内。</span><span class="token comment" spellcheck="true">// 下标从0开始，到列表的长度减1。</span><span class="token comment" spellcheck="true">// 两个列表都没有重复的元素。</span><span class="token comment" spellcheck="true">// Related Topics 哈希表</span><span class="token comment" spellcheck="true">// 👍 102 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">findRestaurant</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> list1<span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> list2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> sMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> tMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> list1<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>list1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sMap<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>list2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             minIndex <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">,</span>sMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>             tMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>list2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>sMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>list2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">+</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> entry <span class="token operator">:</span> tMap<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>minIndex<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            resp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="219-存在重复元素-II"><a href="#219-存在重复元素-II" class="headerlink" title="219. 存在重复元素 II"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-ii/" target="_blank" rel="noopener">219. 存在重复元素 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值</span><span class="token comment" spellcheck="true">// 至多为 k。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,2,3,1], k = 3</span><span class="token comment" spellcheck="true">//输出: true </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,0,1,1], k = 1</span><span class="token comment" spellcheck="true">//输出: true </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,2,3,1,2,3], k = 2</span><span class="token comment" spellcheck="true">//输出: false </span><span class="token comment" spellcheck="true">// Related Topics 数组 哈希表 </span><span class="token comment" spellcheck="true">// 👍 252 👎 0</span><span class="token comment" spellcheck="true">//给定一个整数数组和一个整数 k，判断数组中是否存在两个不同的索引 i 和 j，使得 nums [i] = nums [j]，并且 i 和 j 的差的 绝对值</span><span class="token comment" spellcheck="true">// 至多为 k。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: nums = [1,2,3,1], k = 3</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: nums = [1,0,1,1], k = 1</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 3:</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: nums = [1,2,3,1,2,3], k = 2</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">// Related Topics 数组 哈希表</span><span class="token comment" spellcheck="true">// 👍 252 👎 0</span><span class="token comment" spellcheck="true">//暴力</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token operator">&lt;=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//hashMap解决</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">containsNearbyDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>       HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>i<span class="token operator">-</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                 <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="220-存在重复元素-III"><a href="#220-存在重复元素-III" class="headerlink" title="220. 存在重复元素 III"></a><a href="https://leetcode-cn.com/problems/contains-duplicate-iii/" target="_blank" rel="noopener">220. 存在重复元素 III</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//在整数数组 nums 中，是否存在两个下标 i 和 j，使得 nums [i] 和 nums [j] 的差的绝对值小于等于 t ，且满足 i 和 j 的差的</span><span class="token comment" spellcheck="true">//绝对值也小于等于 ķ 。 </span><span class="token comment" spellcheck="true">// 如果存在则返回 true，不存在返回 false。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,2,3,1], k = 3, t = 0</span><span class="token comment" spellcheck="true">//输出: true </span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,0,1,1], k = 1, t = 2</span><span class="token comment" spellcheck="true">//输出: true </span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">// 输入: nums = [1,5,9,1,5,9], k = 2, t = 3</span><span class="token comment" spellcheck="true">//输出: false </span><span class="token comment" spellcheck="true">// Related Topics 排序 Ordered Map </span><span class="token comment" spellcheck="true">// 👍 308 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">boolean</span> <span class="token function">containsNearbyAlmostDuplicate</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>k<span class="token operator">==</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span>t <span class="token operator">&amp;&amp;</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Double</span><span class="token punctuation">(</span>i<span class="token operator">-</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">&lt;=</span>k<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="594-最长和谐子序列"><a href="#594-最长和谐子序列" class="headerlink" title="594. 最长和谐子序列"></a><a href="https://leetcode-cn.com/problems/longest-harmonious-subsequence/" target="_blank" rel="noopener">594. 最长和谐子序列</a></h4><h4 id="350-两个数组的交集-II"><a href="#350-两个数组的交集-II" class="headerlink" title="350. 两个数组的交集 II"></a><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii/" target="_blank" rel="noopener">350. 两个数组的交集 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定两个数组，编写一个函数来计算它们的交集。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">// 输入：nums1 = [1,2,2,1], nums2 = [2,2]</span><span class="token comment" spellcheck="true">//输出：[2,2]</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]</span><span class="token comment" spellcheck="true">//输出：[4,9] </span><span class="token comment" spellcheck="true">// 说明： </span><span class="token comment" spellcheck="true">// 输出结果中每个元素出现的次数，应与元素在两个数组中出现次数的最小值一致。 </span><span class="token comment" spellcheck="true">// 我们可以不考虑输出结果的顺序。 </span><span class="token comment" spellcheck="true">// 进阶：  </span><span class="token comment" spellcheck="true">// 如果给定的数组已经排好序呢？你将如何优化你的算法？ </span><span class="token comment" spellcheck="true">// 如果 nums1 的大小比 nums2 小很多，哪种方法更优？ </span><span class="token comment" spellcheck="true">// 如果 nums2 的元素存储在磁盘上，内存是有限的，并且你不能一次加载所有的元素到内存中，你该怎么办？  </span><span class="token comment" spellcheck="true">// Related Topics 排序 哈希表 双指针 二分查找 </span><span class="token comment" spellcheck="true">// 👍 469 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>nums2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          res<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//排序+双指针</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">intersect</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums2<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums1<span class="token punctuation">)</span><span class="token punctuation">;</span>       Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums2<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> nums1Length <span class="token operator">=</span> nums1<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> nums2Length <span class="token operator">=</span> nums2<span class="token punctuation">.</span>length<span class="token punctuation">;</span>       <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>       List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>nums1Length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>nums2Length<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           i<span class="token operator">++</span><span class="token punctuation">;</span>           j<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>nums1<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>nums2<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             i<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token keyword">else</span><span class="token punctuation">{</span>             j<span class="token operator">++</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          res<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="609-在系统中查找重复文件"><a href="#609-在系统中查找重复文件" class="headerlink" title="609. 在系统中查找重复文件"></a><a href="https://leetcode-cn.com/problems/find-duplicate-file-in-system/" target="_blank" rel="noopener">609. 在系统中查找重复文件</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个目录信息列表，包括目录路径，以及该目录中的所有包含内容的文件，您需要找到文件系统中的所有重复文件组的路径。一组重复的文件至少包括二个具有完全相同内容</span><span class="token comment" spellcheck="true">//的文件。</span><span class="token comment" spellcheck="true">// 输入列表中的单个目录信息字符串的格式如下：</span><span class="token comment" spellcheck="true">// "root/d1/d2/.../dm f1.txt(f1_content) f2.txt(f2_content) ... fn.txt(fn_conten</span><span class="token comment" spellcheck="true">//t)"</span><span class="token comment" spellcheck="true">// 这意味着有 n 个文件（f1.txt, f2.txt ... fn.txt 的内容分别是 f1_content, f2_content ... fn_co</span><span class="token comment" spellcheck="true">//ntent）在目录 root/d1/d2/.../dm 下。注意：n>=1 且 m>=0。如果 m=0，则表示该目录是根目录。</span><span class="token comment" spellcheck="true">// 该输出是重复文件路径组的列表。对于每个组，它包含具有相同内容的文件的所有文件路径。文件路径是具有下列格式的字符串：</span><span class="token comment" spellcheck="true">// "directory_path/file_name.txt"</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">// 输入：</span><span class="token comment" spellcheck="true">//["root/a 1.txt(abcd) 2.txt(efgh)", "root/c 3.txt(abcd)", "root/c/d 4.txt(efgh)</span><span class="token comment" spellcheck="true">//", "root 4.txt(efgh)"]</span><span class="token comment" spellcheck="true">//输出：</span><span class="token comment" spellcheck="true">//[["root/a/2.txt","root/c/d/4.txt","root/4.txt"],["root/a/1.txt","root/c/3.txt"</span><span class="token comment" spellcheck="true">//]]</span><span class="token comment" spellcheck="true">// 注：</span><span class="token comment" spellcheck="true">// 最终输出不需要顺序。</span><span class="token comment" spellcheck="true">// 您可以假设目录名、文件名和文件内容只有字母和数字，并且文件内容的长度在 [1，50] 的范围内。</span><span class="token comment" spellcheck="true">// 给定的文件数量在 [1，20000] 个范围内。</span><span class="token comment" spellcheck="true">// 您可以假设在同一目录中没有任何文件或目录共享相同的名称。</span><span class="token comment" spellcheck="true">// 您可以假设每个给定的目录信息代表一个唯一的目录。目录路径和文件信息用一个空格分隔。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 超越竞赛的后续行动：</span><span class="token comment" spellcheck="true">// 假设您有一个真正的文件系统，您将如何搜索文件？广度搜索还是宽度搜索？</span><span class="token comment" spellcheck="true">// 如果文件内容非常大（GB级别），您将如何修改您的解决方案？</span><span class="token comment" spellcheck="true">// 如果每次只能读取 1 kb 的文件，您将如何修改解决方案？</span><span class="token comment" spellcheck="true">// 修改后的解决方案的时间复杂度是多少？其中最耗时的部分和消耗内存的部分是什么？如何优化？</span><span class="token comment" spellcheck="true">// 如何确保您发现的重复文件不是误报？</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 哈希表 字符串</span><span class="token comment" spellcheck="true">// 👍 62 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> <span class="token function">findDuplicate</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> paths<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>paths<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String path <span class="token operator">=</span> paths<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            String<span class="token punctuation">[</span><span class="token punctuation">]</span> ans<span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>ans<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                String root <span class="token operator">=</span> ans<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                String file <span class="token operator">=</span> ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\("</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                String content <span class="token operator">=</span> ans<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\("</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\\)"</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                String rootFile <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"/"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                List<span class="token operator">&lt;</span>String<span class="token operator">></span> mapValue <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                mapValue<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>rootFile<span class="token punctuation">)</span><span class="token punctuation">;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span>mapValue<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>List<span class="token operator">&lt;</span>String<span class="token operator">>></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="454-四数相加-II"><a href="#454-四数相加-II" class="headerlink" title="454. 四数相加 II"></a><a href="https://leetcode-cn.com/problems/4sum-ii/" target="_blank" rel="noopener">454. 四数相加 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定四个包含整数的数组列表 A , B , C , D ,计算有多少个元组 (i, j, k, l) ，使得 A[i] + B[j] + C[k] + D[</span><span class="token comment" spellcheck="true">//l] = 0。 </span><span class="token comment" spellcheck="true">// 为了使问题简单化，所有的 A, B, C, D 具有相同的长度 N，且 0 ≤ N ≤ 500 。所有整数的范围在 -228 到 228 - 1 之间，最</span><span class="token comment" spellcheck="true">//终结果不会超过 231 - 1 。 </span><span class="token comment" spellcheck="true">// 例如: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//A = [ 1, 2]</span><span class="token comment" spellcheck="true">//B = [-2,-1]</span><span class="token comment" spellcheck="true">//C = [-1, 2]</span><span class="token comment" spellcheck="true">//D = [ 0, 2]</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//2</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//两个元组如下:</span><span class="token comment" spellcheck="true">//1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0</span><span class="token comment" spellcheck="true">//2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0</span><span class="token comment" spellcheck="true">// Related Topics 哈希表 二分查找 </span><span class="token comment" spellcheck="true">// 👍 348 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">fourSumCount</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> A<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> B<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> C<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> D<span class="token punctuation">)</span> <span class="token punctuation">{</span>       Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>A<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>B<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>A<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>B<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>       <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>C<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>D<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>               <span class="token keyword">if</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">(</span>C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                 res <span class="token operator">=</span> res<span class="token operator">+</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">(</span>C<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>D<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="18-四数之和"><a href="#18-四数之和" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c +</span><span class="token comment" spellcheck="true">// d 的值与 target 相等？找出所有满足条件且不重复的四元组。</span><span class="token comment" spellcheck="true">// 注意：答案中不可以包含重复的四元组。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：nums = [1,0,-1,0,-2,2], target = 0</span><span class="token comment" spellcheck="true">//输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：nums = [], target = 0</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 200</span><span class="token comment" spellcheck="true">// -109 &lt;= nums[i] &lt;= 109</span><span class="token comment" spellcheck="true">// -109 &lt;= target &lt;= 109</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组 哈希表 双指针</span><span class="token comment" spellcheck="true">// 👍 800 👎 0</span><span class="token comment" spellcheck="true">//暴力，离谱</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token operator">=</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>l<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>resp<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                                resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><h4 id="605-种花问题"><a href="#605-种花问题" class="headerlink" title="605. 种花问题"></a><a href="https://leetcode-cn.com/problems/can-place-flowers/" target="_blank" rel="noopener">605. 种花问题</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//假设有一个很长的花坛，一部分地块种植了花，另一部分却没有。可是，花不能种植在相邻的地块上，它们会争夺水源，两者都会死去。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 给你一个整数数组 flowerbed 表示花坛，由若干 0 和 1 组成，其中 0 表示没种植花，1 表示种植了花。另有一个数 n ，能否在不打破种植规则</span><span class="token comment" spellcheck="true">//的情况下种入 n 朵花？能则返回 true ，不能则返回 false。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//输入：flowerbed = [1,0,0,0,1], n = 1</span><span class="token comment" spellcheck="true">//输出：true</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//输入：flowerbed = [1,0,0,0,1], n = 2</span><span class="token comment" spellcheck="true">//输出：false</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 1 &lt;= flowerbed.length &lt;= 2 * 104</span><span class="token comment" spellcheck="true">// flowerbed[i] 为 0 或 1</span><span class="token comment" spellcheck="true">// flowerbed 中不存在相邻的两朵花</span><span class="token comment" spellcheck="true">// 0 &lt;= n &lt;= flowerbed.length</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 贪心算法 数组</span><span class="token comment" spellcheck="true">// 👍 334 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span>  <span class="token keyword">boolean</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> flowerbed<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        HashMap<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flowerbed<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">.</span>length<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> flowerbed<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                n<span class="token operator">--</span><span class="token punctuation">;</span>                map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>n<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> n<span class="token operator">&lt;=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//贪心算法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canPlaceFlowers</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> flowerbed<span class="token punctuation">,</span> <span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>flowerbed<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token number">0</span> <span class="token operator">||</span> flowerbed<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token operator">>=</span>flowerbed<span class="token punctuation">.</span>length <span class="token operator">||</span> flowerbed<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            sum<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>sum <span class="token operator">>=</span>n<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            flowerbed<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sum<span class="token operator">>=</span>n<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">121. 买卖股票的最佳时机</a></h4><pre><code>//给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。// 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。// 返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。// 示例 1：//输入：[7,1,5,3,6,4]//输出：5//解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。//     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。// 示例 2：//输入：prices = [7,6,4,3,1]//输出：0//解释：在这种情况下, 没有交易完成, 所以最大利润为 0。// 提示：// 1 &lt;= prices.length &lt;= 105// 0 &lt;= prices[i] &lt;= 104// Related Topics 数组 动态规划// 👍 1548 👎 0class Solution {    public int maxProfit(int[] prices) {     Integer minPrice = Integer.MAX_VALUE;     int res = 0;     for(int i=0;i&lt;prices.length;i++){       minPrice = Math.min(minPrice,prices[i]);       res = Math.max(res,prices[i]-minPrice);     }     return res;    }}</code></pre><h4 id="122-买卖股票的最佳时机-II"><a href="#122-买卖股票的最佳时机-II" class="headerlink" title="122. 买卖股票的最佳时机 II"></a><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/" target="_blank" rel="noopener">122. 买卖股票的最佳时机 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。 </span><span class="token comment" spellcheck="true">// 设计一个算法来计算你所能获取的最大利润。你可以尽可能地完成更多的交易（多次买卖一支股票）。 </span><span class="token comment" spellcheck="true">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">// 输入: [7,1,5,3,6,4]</span><span class="token comment" spellcheck="true">//输出: 7</span><span class="token comment" spellcheck="true">//解释: 在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="token comment" spellcheck="true">//     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6-3 = 3 。</span><span class="token comment" spellcheck="true">// 示例 2: </span><span class="token comment" spellcheck="true">// 输入: [1,2,3,4,5]</span><span class="token comment" spellcheck="true">//输出: 4</span><span class="token comment" spellcheck="true">//解释: 在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5-1 = 4 。</span><span class="token comment" spellcheck="true">//     注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。</span><span class="token comment" spellcheck="true">//     因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。</span><span class="token comment" spellcheck="true">// 示例 3: </span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// 输入: [7,6,4,3,1]</span><span class="token comment" spellcheck="true">//输出: 0</span><span class="token comment" spellcheck="true">//解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。 </span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 1 &lt;= prices.length &lt;= 3 * 10 ^ 4 </span><span class="token comment" spellcheck="true">// 0 &lt;= prices[i] &lt;= 10 ^ 4 </span><span class="token comment" spellcheck="true">// </span><span class="token comment" spellcheck="true">// Related Topics 贪心算法 数组 </span><span class="token comment" spellcheck="true">// 👍 1176 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">maxProfit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> prices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>prices<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">></span>prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans <span class="token operator">=</span> ans <span class="token operator">+</span> prices<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">-</span> prices<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span>       <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="455-分发饼干"><a href="#455-分发饼干" class="headerlink" title="455. 分发饼干"></a><a href="https://leetcode-cn.com/problems/assign-cookies/" target="_blank" rel="noopener">455. 分发饼干</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。</span><span class="token comment" spellcheck="true">// 对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 j，都有一个尺寸 s[j] 。如果 s[j] >= g[i</span><span class="token comment" spellcheck="true">//]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">//输入: g = [1,2,3], s = [1,1]</span><span class="token comment" spellcheck="true">//输出: 1</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。</span><span class="token comment" spellcheck="true">//虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。</span><span class="token comment" spellcheck="true">//所以你应该输出1。</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">//输入: g = [1,2], s = [1,2,3]</span><span class="token comment" spellcheck="true">//输出: 2</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。</span><span class="token comment" spellcheck="true">//你拥有的饼干数量和尺寸都足以让所有孩子满足。</span><span class="token comment" spellcheck="true">//所以你应该输出2.</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= g.length &lt;= 3 * 104</span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 3 * 104</span><span class="token comment" spellcheck="true">// 1 &lt;= g[i], s[j] &lt;= 231 - 1</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 贪心算法</span><span class="token comment" spellcheck="true">// 👍 316 👎 0</span><span class="token comment" spellcheck="true">//双指针 贪心算法</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findContentChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> g<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> j<span class="token operator">&lt;</span>s<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">>=</span>g<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token operator">++</span><span class="token punctuation">;</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="409-最长回文串"><a href="#409-最长回文串" class="headerlink" title="409. 最长回文串"></a><a href="https://leetcode-cn.com/problems/longest-palindrome/" target="_blank" rel="noopener">409. 最长回文串</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个包含大写字母和小写字母的字符串，找到通过这些字母构造成的最长的回文串。 </span><span class="token comment" spellcheck="true">// 在构造过程中，请注意区分大小写。比如 "Aa" 不能当做一个回文字符串。 </span><span class="token comment" spellcheck="true">// 注意: </span><span class="token comment" spellcheck="true">//假设字符串的长度不会超过 1010。 </span><span class="token comment" spellcheck="true">// 示例 1: </span><span class="token comment" spellcheck="true">//输入:</span><span class="token comment" spellcheck="true">//"abccccdd"</span><span class="token comment" spellcheck="true">//输出:</span><span class="token comment" spellcheck="true">//7</span><span class="token comment" spellcheck="true">//解释:</span><span class="token comment" spellcheck="true">//我们可以构造的最长的回文串是"dccaccd", 它的长度是 7。</span><span class="token comment" spellcheck="true">// Related Topics 哈希表 </span><span class="token comment" spellcheck="true">// 👍 283 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestPalindrome</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span>map<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span>Integer<span class="token operator">></span> entry <span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                count <span class="token operator">=</span> count<span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                count <span class="token operator">=</span> count <span class="token operator">+</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>count<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            count <span class="token operator">=</span> count<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h3><h4 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode-cn.com/problems/3sum/" target="_blank" rel="noopener">15. 三数之和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重</span><span class="token comment" spellcheck="true">//复的三元组。</span><span class="token comment" spellcheck="true">// 注意：答案中不可以包含重复的三元组。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：nums = [-1,0,1,2,-1,-4]</span><span class="token comment" spellcheck="true">//输出：[[-1,-1,2],[-1,0,1]]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：nums = []</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：nums = [0]</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 3000</span><span class="token comment" spellcheck="true">// -105 &lt;= nums[i] &lt;= 105</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组 双指针</span><span class="token comment" spellcheck="true">// 👍 3239 👎 0</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">threeSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>k <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>                List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    ans <span class="token operator">=</span> ans<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>compareTo<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>resp<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                    j<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token operator">-</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    j<span class="token operator">--</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token operator">-</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="16-最接近的三数之和"><a href="#16-最接近的三数之和" class="headerlink" title="16. 最接近的三数之和"></a><a href="https://leetcode-cn.com/problems/3sum-closest/" target="_blank" rel="noopener">16. 最接近的三数之和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和</span><span class="token comment" spellcheck="true">//。假定每组输入只存在唯一答案。</span><span class="token comment" spellcheck="true">// 示例：</span><span class="token comment" spellcheck="true">// 输入：nums = [-1,2,1,-4], target = 1</span><span class="token comment" spellcheck="true">//输出：2</span><span class="token comment" spellcheck="true">//解释：与 target 最接近的和是 2 (-1 + 2 + 1 = 2) 。</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 3 &lt;= nums.length &lt;= 10^3</span><span class="token comment" spellcheck="true">// -10^3 &lt;= nums[i] &lt;= 10^3</span><span class="token comment" spellcheck="true">// -10^4 &lt;= target &lt;= 10^4</span><span class="token comment" spellcheck="true">// Related Topics 数组 双指针</span><span class="token comment" spellcheck="true">// 👍 752 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">threeSumClosest</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>         Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> closestNum <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> l<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> r<span class="token operator">=</span>nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> threeNum <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>threeNum<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token operator">&lt;</span>Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>closestNum<span class="token operator">-</span>target<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                closestNum <span class="token operator">=</span> threeNum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>threeNum<span class="token operator">></span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>                r<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>threeNum <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                l<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> threeNum<span class="token punctuation">;</span>            <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> closestNum<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="18-四数之和-1"><a href="#18-四数之和-1" class="headerlink" title="18. 四数之和"></a><a href="https://leetcode-cn.com/problems/4sum/" target="_blank" rel="noopener">18. 四数之和</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个包含 n 个整数的数组 nums 和一个目标值 target，判断 nums 中是否存在四个元素 a，b，c 和 d ，使得 a + b + c +</span><span class="token comment" spellcheck="true">// d 的值与 target 相等？找出所有满足条件且不重复的四元组。 </span><span class="token comment" spellcheck="true">// 注意：答案中不可以包含重复的四元组。 </span><span class="token comment" spellcheck="true">// 示例 1： </span><span class="token comment" spellcheck="true">//输入：nums = [1,0,-1,0,-2,2], target = 0</span><span class="token comment" spellcheck="true">//输出：[[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]</span><span class="token comment" spellcheck="true">// 示例 2：  </span><span class="token comment" spellcheck="true">//输入：nums = [], target = 0</span><span class="token comment" spellcheck="true">//输出：[]</span><span class="token comment" spellcheck="true">// 提示： </span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 200 </span><span class="token comment" spellcheck="true">// -109 &lt;= nums[i] &lt;= 109 </span><span class="token comment" spellcheck="true">// -109 &lt;= target &lt;= 109 </span><span class="token comment" spellcheck="true">// Related Topics 数组 哈希表 双指针 </span><span class="token comment" spellcheck="true">// 👍 821 👎 0</span><span class="token comment" spellcheck="true">//暴力</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> k<span class="token operator">=</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token operator">=</span>k<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>l<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>l<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                            List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                            Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>resp<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                               resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token punctuation">}</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//双指针</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> <span class="token function">fourSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> resp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">int</span> l <span class="token operator">=</span> j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>              <span class="token keyword">int</span> r <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>              <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token operator">&lt;</span>r<span class="token punctuation">)</span><span class="token punctuation">{</span>                  List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">==</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                     ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     ans<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>resp<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                          resp<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token punctuation">}</span>                    l<span class="token operator">++</span><span class="token punctuation">;</span>                    r<span class="token operator">--</span><span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">></span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                      r<span class="token operator">--</span><span class="token punctuation">;</span>                      <span class="token keyword">continue</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>                  <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token operator">+</span>nums<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">&lt;</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>                      l<span class="token operator">++</span><span class="token punctuation">;</span>                      <span class="token keyword">continue</span><span class="token punctuation">;</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> resp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="187-重复的DNA序列"><a href="#187-重复的DNA序列" class="headerlink" title="187. 重复的DNA序列"></a><a href="https://leetcode-cn.com/problems/repeated-dna-sequences/" target="_blank" rel="noopener">187. 重复的DNA序列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//所有 DNA 都由一系列缩写为 'A'，'C'，'G' 和 'T' 的核苷酸组成，例如："ACGAATTCCG"。在研究 DNA 时，识别 DNA 中的重复</span><span class="token comment" spellcheck="true">//序列有时会对研究非常有帮助。</span><span class="token comment" spellcheck="true">// 编写一个函数来找出所有目标子串，目标子串的长度为 10，且在 DNA 字符串 s 中出现次数超过一次。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：s = "AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT"</span><span class="token comment" spellcheck="true">//输出：["AAAAACCCCC","CCCCCAAAAA"]</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：s = "AAAAAAAAAAAAA"</span><span class="token comment" spellcheck="true">//输出：["AAAAAAAAAA"]</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= s.length &lt;= 105</span><span class="token comment" spellcheck="true">// s[i] 为 'A'、'C'、'G' 或 'T'</span><span class="token comment" spellcheck="true">// Related Topics 位运算 哈希表</span><span class="token comment" spellcheck="true">// 👍 158 👎 0</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashSet<span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">findRepeatedDnaSequences</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>      Set<span class="token operator">&lt;</span>String<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">+</span><span class="token number">10</span><span class="token operator">&lt;=</span>s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String ans <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>res<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="643-子数组最大平均数-I"><a href="#643-子数组最大平均数-I" class="headerlink" title="643. 子数组最大平均数 I"></a><a href="https://leetcode-cn.com/problems/maximum-average-subarray-i/" target="_blank" rel="noopener">643. 子数组最大平均数 I</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定 n 个整数，找出平均数最大且长度为 k 的连续子数组，并输出该最大平均数。</span><span class="token comment" spellcheck="true">// 示例：</span><span class="token comment" spellcheck="true">//输入：[1,12,-5,-6,50,3], k = 4</span><span class="token comment" spellcheck="true">//输出：12.75</span><span class="token comment" spellcheck="true">//解释：最大平均数 (12-5-6+50)/4 = 51/4 = 12.75</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 1 &lt;= k &lt;= n &lt;= 30,000。</span><span class="token comment" spellcheck="true">// 所给数据范围 [-10,000，10,000]。</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组</span><span class="token comment" spellcheck="true">// 👍 182 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">findMaxAverage</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> k<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">=</span> sum <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> sum<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> k<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sum <span class="token operator">=</span> sum <span class="token operator">+</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> nums<span class="token punctuation">[</span>i <span class="token operator">-</span> k<span class="token punctuation">]</span><span class="token punctuation">;</span>            maxValue <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">,</span> sum<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxValue <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token number">1.0</span> <span class="token operator">*</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="674-最长连续递增序列"><a href="#674-最长连续递增序列" class="headerlink" title="674. 最长连续递增序列"></a><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence/" target="_blank" rel="noopener">674. 最长连续递增序列</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个未经排序的整数数组，找到最长且 连续递增的子序列，并返回该序列的长度。</span><span class="token comment" spellcheck="true">// 连续递增的子序列 可以由两个下标 l 和 r（l &lt; r）确定，如果对于每个 l &lt;= i &lt; r，都有 nums[i] &lt; nums[i + 1] ，那</span><span class="token comment" spellcheck="true">//么子序列 [nums[l], nums[l + 1], ..., nums[r - 1], nums[r]] 就是连续递增子序列。</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：nums = [1,3,5,4,7]</span><span class="token comment" spellcheck="true">//输出：3</span><span class="token comment" spellcheck="true">//解释：最长连续递增序列是 [1,3,5], 长度为3。</span><span class="token comment" spellcheck="true">//尽管 [1,3,5,7] 也是升序的子序列, 但它不是连续的，因为 5 和 7 在原数组里被 4 隔开。</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：nums = [2,2,2,2,2]</span><span class="token comment" spellcheck="true">//输出：1</span><span class="token comment" spellcheck="true">//解释：最长连续递增序列是 [2], 长度为1。</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 0 &lt;= nums.length &lt;= 104</span><span class="token comment" spellcheck="true">// -109 &lt;= nums[i] &lt;= 109</span><span class="token comment" spellcheck="true">//</span><span class="token comment" spellcheck="true">// Related Topics 数组</span><span class="token comment" spellcheck="true">// 👍 178 👎 0</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>null <span class="token operator">==</span> nums <span class="token operator">||</span> nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> max <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MIN_VALUE<span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">></span>nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                ans<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span><span class="token punctuation">{</span>                ans <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span>ans<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> max<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//优化</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findLengthOfLCIS</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">></span><span class="token number">0</span> <span class="token operator">&amp;&amp;</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> nums<span class="token punctuation">[</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              start <span class="token operator">=</span> i<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span>i<span class="token operator">-</span>start<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">142. 环形链表 II</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个链表，返回链表开始入环的第一个节点。 如果链表无环，则返回 null。</span><span class="token comment" spellcheck="true">// 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意，po</span><span class="token comment" spellcheck="true">//s 仅仅是用于标识环的情况，并不会作为参数传递到函数中。</span><span class="token comment" spellcheck="true">// 说明：不允许修改给定的链表。</span><span class="token comment" spellcheck="true">// 进阶：</span><span class="token comment" spellcheck="true">// 你是否可以使用 O(1) 空间解决此题？</span><span class="token comment" spellcheck="true">// 示例 1：</span><span class="token comment" spellcheck="true">//输入：head = [3,2,0,-4], pos = 1</span><span class="token comment" spellcheck="true">//输出：返回索引为 1 的链表节点</span><span class="token comment" spellcheck="true">//解释：链表中有一个环，其尾部连接到第二个节点。</span><span class="token comment" spellcheck="true">// 示例 2：</span><span class="token comment" spellcheck="true">//输入：head = [1,2], pos = 0</span><span class="token comment" spellcheck="true">//输出：返回索引为 0 的链表节点</span><span class="token comment" spellcheck="true">//解释：链表中有一个环，其尾部连接到第一个节点。</span><span class="token comment" spellcheck="true">// 示例 3：</span><span class="token comment" spellcheck="true">//输入：head = [1], pos = -1</span><span class="token comment" spellcheck="true">//输出：返回 null</span><span class="token comment" spellcheck="true">//解释：链表中没有环。</span><span class="token comment" spellcheck="true">// 提示：</span><span class="token comment" spellcheck="true">// 链表中节点的数目范围在范围 [0, 104] 内</span><span class="token comment" spellcheck="true">// -105 &lt;= Node.val &lt;= 105</span><span class="token comment" spellcheck="true">// pos 的值为 -1 或者链表中的一个有效索引</span><span class="token comment" spellcheck="true">// Related Topics 链表 双指针</span><span class="token comment" spellcheck="true">// 👍 976 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * class ListNode { *     int val; *     ListNode next; *     ListNode(int x) { *         val = x; *         next = null; *     } * } */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> ListNode <span class="token function">detectCycle</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>        Set<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> curr<span class="token punctuation">.</span>next <span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>set<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> curr<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         set<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>         curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="143-重排链表"><a href="#143-重排链表" class="headerlink" title="143. 重排链表"></a><a href="https://leetcode-cn.com/problems/reorder-list/" target="_blank" rel="noopener">143. 重排链表</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//给定一个单链表 L：L0→L1→…→Ln-1→Ln ，</span><span class="token comment" spellcheck="true">//将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</span><span class="token comment" spellcheck="true">// 你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">// 给定链表 1->2->3->4, 重新排列为 1->4->2->3.</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">// 给定链表 1->2->3->4->5, 重新排列为 1->5->2->4->3.</span><span class="token comment" spellcheck="true">// Related Topics 链表</span><span class="token comment" spellcheck="true">// 👍 572 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reorderList</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>head <span class="token operator">==</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      List<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>          list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>          curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> j<span class="token operator">=</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>         list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span>         i<span class="token operator">++</span><span class="token punctuation">;</span>         list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>         j<span class="token operator">--</span><span class="token punctuation">;</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>i<span class="token operator">==</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode-cn.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">234. 回文链表</a></h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//请判断一个链表是否为回文链表。</span><span class="token comment" spellcheck="true">// 示例 1:</span><span class="token comment" spellcheck="true">// 输入: 1->2</span><span class="token comment" spellcheck="true">//输出: false</span><span class="token comment" spellcheck="true">// 示例 2:</span><span class="token comment" spellcheck="true">// 输入: 1->2->2->1</span><span class="token comment" spellcheck="true">//输出: true</span><span class="token comment" spellcheck="true">// 进阶：</span><span class="token comment" spellcheck="true">//你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？</span><span class="token comment" spellcheck="true">// Related Topics 链表 双指针</span><span class="token comment" spellcheck="true">// 👍 956 👎 0</span><span class="token comment" spellcheck="true">/** * Definition for singly-linked list. * public class ListNode { *     int val; *     ListNode next; *     ListNode() {} *     ListNode(int val) { this.val = val; } *     ListNode(int val, ListNode next) { this.val = val; this.next = next; } * } */</span><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isPalindrome</span><span class="token punctuation">(</span>ListNode head<span class="token punctuation">)</span> <span class="token punctuation">{</span>     List<span class="token operator">&lt;</span>ListNode<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     ListNode curr <span class="token operator">=</span> head<span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>curr <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">{</span>         list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>curr<span class="token punctuation">)</span><span class="token punctuation">;</span>         curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>next<span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>     <span class="token keyword">int</span> j <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>     <span class="token keyword">while</span><span class="token punctuation">(</span>i<span class="token operator">&lt;</span>j<span class="token punctuation">)</span><span class="token punctuation">{</span>         <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>val <span class="token operator">!=</span> list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">{</span>             <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         i<span class="token operator">++</span><span class="token punctuation">;</span>         j<span class="token operator">--</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode-cn.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">287. 寻找重复数</a></h4>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode刷题指南</title>
      <link href="/2021/01/31/LeetCode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/"/>
      <url>/2021/01/31/LeetCode%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h4 id="一-数组"><a href="#一-数组" class="headerlink" title="一. 数组"></a>一. 数组</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组的遍历</td><td>485✔、495✔、414✔、628✔</td></tr><tr><td>统计数组中的元素</td><td>645✔、697✔、448✔、442✔、41✔、274✔</td></tr><tr><td>数组的改变、移动</td><td>453✔、665✔、283✔</td></tr><tr><td>二维数组及滚动数组</td><td>118✔、119✔、661、598、419</td></tr><tr><td>数组的旋转</td><td>189✔、396</td></tr><tr><td>特定顺序遍历二维数组</td><td>54、59、498</td></tr><tr><td>二维数组变换</td><td>566、48、73、289</td></tr><tr><td>前缀和数组</td><td>303、304、238</td></tr><tr><td>题解</td><td><a href="https://leetcode-cn.com/circle/article/oalBEI/" target="_blank" rel="noopener">数组篇</a></td></tr></tbody></table><h4 id="二-字符串"><a href="#二-字符串" class="headerlink" title="二. 字符串"></a>二. 字符串</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>字符</td><td>520✔</td></tr><tr><td>回文串的定义</td><td>125✔</td></tr><tr><td>公共前缀</td><td>14✔</td></tr><tr><td>单词</td><td>434✔、58✔</td></tr><tr><td>字符串的反转</td><td>344✔、541✔、557✔、151✔</td></tr><tr><td>字符的统计</td><td>387✔、389✔、383✔、<a href="https://leetcode-cn.com/problems/valid-anagram/" target="_blank" rel="noopener">242.</a>✔、<a href="https://leetcode-cn.com/problems/group-anagrams/" target="_blank" rel="noopener">49</a>✔、451✔、423、657✔、551✔、696、467、535✔</td></tr><tr><td>数字与字符串间转换</td><td>299✔、412✔、506✔、539✔、553✔、537✔、592✔、640、38、443、8、13、12、273、165、481</td></tr><tr><td>子序列</td><td>392✔、524✔、521、522</td></tr><tr><td>高精度运算</td><td>66、67、415、43、306</td></tr><tr><td>字符串变换</td><td>482、6、68</td></tr><tr><td>字符串匹配</td><td>28、686、459、214</td></tr><tr><td>中心拓展法</td><td>5、647</td></tr></tbody></table><h4 id="三-数与位"><a href="#三-数与位" class="headerlink" title="三. 数与位"></a>三. 数与位</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数字的位操作</td><td><a href="https://leetcode-cn.com/problems/reverse-integer/" target="_blank" rel="noopener">7. 整数反转</a>✔、<a href="https://leetcode-cn.com/problems/palindrome-number/" target="_blank" rel="noopener">9. 回文数</a>✔、479、564、231、342、326、504、263、190、191、476、461、477、693、393、172、458、258、319、405、171、168、670、233、357、400</td></tr><tr><td>简单数学题</td><td>492、29、507</td></tr><tr><td>快速幂</td><td>50、372</td></tr></tbody></table><h4 id="四-栈与递归"><a href="#四-栈与递归" class="headerlink" title="四. 栈与递归"></a>四. 栈与递归</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>用栈访问最后若干元素</td><td>682、71、388</td></tr><tr><td>栈与计算器</td><td>150、227、224</td></tr><tr><td>栈与括号匹配</td><td>20、636、591、32</td></tr><tr><td>递归</td><td>385、341、394</td></tr></tbody></table><h4 id="五-链表"><a href="#五-链表" class="headerlink" title="五. 链表"></a>五. 链表</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>链表的删除</td><td>203、237、19</td></tr><tr><td>链表的遍历</td><td>430</td></tr><tr><td>链表的旋转与反转</td><td>61、24、206、92、25</td></tr><tr><td>链表高精度加法</td><td>2、445</td></tr><tr><td>链表的合并</td><td>21、23</td></tr></tbody></table><h4 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六. 哈希表"></a>六. 哈希表</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>哈希表的查找、插入及删除</td><td>217、633、349、128、202、500、290、532、205、166、466、138</td></tr><tr><td>哈希表与索引</td><td>1、167、599、219、220</td></tr><tr><td>哈希表与统计</td><td>594、350、554、609、454、18</td></tr><tr><td>哈希表与前缀和</td><td>560、523、525</td></tr></tbody></table><h4 id="七-贪心算法"><a href="#七-贪心算法" class="headerlink" title="七. 贪心算法"></a>七. 贪心算法</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组与贪心算法</td><td>605、121、122、561、455、575、135、409、621、179、56、57、228、452、435、646、406、48、169、215、75、324、517、649、678、420</td></tr><tr><td>子数组与贪心算法</td><td>53、134、581、152</td></tr><tr><td>子序列与贪心算法</td><td>334、376、659</td></tr><tr><td>数字与贪心</td><td>343</td></tr><tr><td>单调栈法</td><td>496、503、456、316、402、321、84、85</td></tr></tbody></table><h4 id="八-双指针法"><a href="#八-双指针法" class="headerlink" title="八. 双指针法"></a>八. 双指针法</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>头尾指针</td><td>345、680、167、15、16、18、11、42</td></tr><tr><td>同向双指针、滑动窗口</td><td>27、26、80、83、82、611、187、643、674、209、3、438、567、424、76、30</td></tr><tr><td>分段双指针</td><td>86、328、160、88、475</td></tr><tr><td>快慢指针</td><td>141、142、143、234、457、287</td></tr></tbody></table><h4 id="九-树"><a href="#九-树" class="headerlink" title="九. 树"></a>九. 树</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>树与递归</td><td>100、222、101、226、437、563、617、508、572、543、654、687、87</td></tr><tr><td>树的层次遍历</td><td>102、429、690、559、662、671、513、515、637、103、107、257、623、653、104、111、112、113、129、404、199、655、116、117</td></tr><tr><td>树的前序遍历</td><td>144、589</td></tr><tr><td>树的前序序列化</td><td>606、331、652、297、449</td></tr><tr><td>树的后序遍历</td><td>145、590</td></tr><tr><td>树的中序遍历与二叉搜索树</td><td>94、700、530、538、230、98、173、669、450、110、95、108、109</td></tr><tr><td>重构二叉树</td><td>105、106</td></tr><tr><td>二叉树的展开</td><td>114</td></tr><tr><td>最近公共祖先</td><td>235、236</td></tr><tr><td>Morris中序遍历</td><td>501、99</td></tr><tr><td>四叉树</td><td>558、427</td></tr></tbody></table><h4 id="十-图与搜索"><a href="#十-图与搜索" class="headerlink" title="十. 图与搜索"></a>十. 图与搜索</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>图的建立与应用</td><td>565</td></tr><tr><td>深度优先搜索</td><td>17、397</td></tr><tr><td>回溯法</td><td>526、401、36、37、51、52、77、39、216、40、46、47、31、556、60、491、78、90、79、93、332</td></tr><tr><td>回溯法与表达式</td><td>241、282、679</td></tr><tr><td>回溯法与括号</td><td>22、301</td></tr><tr><td>回溯法与贪心</td><td>488</td></tr><tr><td>广度优先搜索</td><td>133、200、695、463、542、130、417、529、127、126、433、675</td></tr><tr><td>并查集</td><td>547、684、685</td></tr><tr><td>拓扑排序</td><td>399、207、210</td></tr><tr><td>有限状态自动机</td><td>65、468</td></tr></tbody></table><h4 id="十一-二分查找"><a href="#十一-二分查找" class="headerlink" title="十一. 二分查找"></a>十一. 二分查找</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>二分查找应用(简单)</td><td>374、35、278、367、69、441</td></tr><tr><td>二分查找应用(中等)</td><td>34、540、275、436、300、354、658、162、4</td></tr><tr><td>二分查找与旋转数组</td><td>153、154、33、81</td></tr><tr><td>二分查找与矩阵</td><td>74、240</td></tr><tr><td>二分答案法</td><td>378、668、410、483</td></tr></tbody></table><h4 id="十二-二进制运算的应用"><a href="#十二-二进制运算的应用" class="headerlink" title="十二. 二进制运算的应用"></a>十二. 二进制运算的应用</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>异或的应用</td><td>89、136、137、260、268</td></tr><tr><td>与或非的应用</td><td>371、318、201</td></tr></tbody></table><h4 id="十三-动态规划"><a href="#十三-动态规划" class="headerlink" title="十三. 动态规划"></a>十三. 动态规划</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数组中的动态规划</td><td>509、70、338、45、55、198、213、650、91、639、552、123、188、309、32、264、313、403</td></tr><tr><td>子数组、子序列中的动态规划</td><td>689、413、446、368、416、279</td></tr><tr><td>背包问题</td><td>322、518、474、494、377</td></tr><tr><td>矩阵中的动态规划</td><td>62、63、64、120、576、688、221、629、174、96、329</td></tr><tr><td>动态规划与字符串匹配</td><td>583、72、97、115、516、132、131、139、140、514、10、44</td></tr><tr><td>状态压缩动态规划</td><td>464、691、698、638、473</td></tr><tr><td>区间中的动态规划</td><td>486、664、375、312、546</td></tr><tr><td>树形dp</td><td>337、124</td></tr><tr><td>数位dp</td><td>233、600</td></tr></tbody></table><h4 id="十四-数据结构"><a href="#十四-数据结构" class="headerlink" title="十四. 数据结构"></a>十四. 数据结构</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>数据结构设计——栈与队列</td><td>225、232、284、622、641、155</td></tr><tr><td>数据结构设计——哈希表</td><td>676、355、380、381</td></tr><tr><td>数据结构设计——哈希与双向链表</td><td>432、146、460</td></tr><tr><td>前缀树</td><td>208、211、648、386、677、472、421、212、336、440</td></tr><tr><td>堆</td><td>23、373、378、632、347、692、502、630、407、295、480</td></tr><tr><td>树状数组</td><td>307、315、493、327、673</td></tr><tr><td>线段树</td><td>699</td></tr><tr><td>平衡树(set/map)</td><td>352、218、363</td></tr></tbody></table><h4 id="十五-采样"><a href="#十五-采样" class="headerlink" title="十五. 采样"></a>十五. 采样</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>按权值采样</td><td>528、497</td></tr><tr><td>蓄水池抽样</td><td>382、398</td></tr><tr><td>拒绝采样</td><td>470、478、519</td></tr></tbody></table><h4 id="十六-计算几何"><a href="#十六-计算几何" class="headerlink" title="十六. 计算几何"></a>十六. 计算几何</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>计算几何基础</td><td>593、447、223、149</td></tr><tr><td>分类讨论法</td><td>335</td></tr><tr><td>凸包</td><td>587</td></tr><tr><td>覆盖问题</td><td>391</td></tr></tbody></table><h4 id="十七-常用技巧与算法"><a href="#十七-常用技巧与算法" class="headerlink" title="十七. 常用技巧与算法"></a>十七. 常用技巧与算法</h4><table><thead><tr><th>题目分类</th><th>题目编号</th></tr></thead><tbody><tr><td>博弈论</td><td>292</td></tr><tr><td>分块</td><td>239、164</td></tr><tr><td>倍增法</td><td>330</td></tr><tr><td>拓展欧几里得算法</td><td>365</td></tr><tr><td>洗牌算法</td><td>384</td></tr><tr><td>找规律</td><td>390、672</td></tr><tr><td>分治法</td><td>395、667</td></tr><tr><td>排序算法</td><td>147、148</td></tr><tr><td>线性筛</td><td>204</td></tr><tr><td>摩尔投票法</td><td>229</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池</title>
      <link href="/2020/08/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
      <url>/2020/08/17/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
      
        <content type="html"><![CDATA[<p><strong>摘要 ：</strong></p><blockquote><p>线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的<a href="https://baike.baidu.com/item/堆栈/1682032" target="_blank" rel="noopener">堆栈</a>大小，以默认的优先级运行，并处于多线程单元中</p></blockquote><h5 id="手动声明线程池"><a href="#手动声明线程池" class="headerlink" title="手动声明线程池"></a>手动声明线程池</h5><p>《Java阿里巴巴开发手册》中有提到：<font face="黑体" color="red">线程资源必须通过线程池提供</font>，不允许在应用中自行显式创建线程。使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。<font face="黑体" color="red">线程池不允许使用 Executors去创建</font> ，而是通过 去创建，而是通过 ThreadPoolExecutor的方式，避资源耗尽风险。</p><p> Executors返回的线程池对象 的弊端 如下 ：</p><ul><li><p>FixedThreadPool和 SingleThreadPoolPool : 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</p></li><li><p>CachedThreadPool和ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM</p></li></ul><p>不建议使用Executors提供的快捷线程池原因：</p><ul><li>需要根据自己的业务场景，并发情况来评估线程池的几个核心参数，包括核心线程数、最大线程数、线程回收策略、工作队列的类型、拒绝策略，确保线程池的工作符合需求，需要设置有界的工作队列和可控的线程数。</li><li>自定义线程池指定有意义的名称，以方便排查问题，当线程池出现暴增、线程死锁、线程占用大量cpu、线程执行出现异常问题等，我们往往会抓取线程栈，这个时候有意义的线程名称可以帮助我们快速定位问题。</li></ul><h5 id="创建线程池示例："><a href="#创建线程池示例：" class="headerlink" title="创建线程池示例："></a><strong>创建线程池示例：</strong></h5><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> lombok<span class="token punctuation">.</span>extern<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Slf4j<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>lucene<span class="token punctuation">.</span>util<span class="token punctuation">.</span>NamedThreadFactory<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ArrayBlockingQueue<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ExecutorService<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadPoolExecutor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>TimeUnit<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * 线程池添加task时的执行过程： * 1. 如果池中线程数小于核心线程数，直接创建一个线程入池并执行此task * 2. 如果池中线程数大于或等于核心线程数，则判断队列中task数量： * &lt;1>如果队列中task数量未达到队列容量，则task直接进队列（不创建新线程，因为线程是很重的资源，能不新建就不新建，例外情况是 * 如果核心线程数是0，则新建一个线程） * &lt;2>如果队列中task数量达到队列最大容量，且池中线程数量未达到最大线程数，则创建一个线程入池，并用此线程执行 * 此task（注意，是直接执行本次要添加的task，而不是从队列里拿task） * &lt;3>如果队列中task数量达到队列最大容量，且池中线程数量达到最大线程数，则根据指定的RejectPolicy来决定： * CallerRunsPolicy: 用提交task的线程来执行此task，不扔RejectedExecutionException * AbortPolicy: 直接丢弃此task，扔RejectedExecutionException; 此策略为未指定RejectedExecutionHandler时的默认策略 * DiscardPolicy: 直接丢弃此task，不扔RejectedExecutionException * DiscardOldestPolicy: 丢弃队列中最老的task，并将此task放入队尾，不扔RejectedExecutionException * 线程池构造函数： * int corePoolSize,                  核心线程数 * int maximumPoolSize,               最大线程数 * long keepAliveTime,                线程闲置时保持存活的时间数量 * TimeUnit unit,                     线程闲置时保持存活的时间单位 * BlockingQueue&lt;Runnable> workQueue, 线程任务队列 * ThreadFactory threadFactory,       线程池用于创建线程的工厂类 * RejectedExecutionHandler handler   线程池满且队列满时的任务提交策略 * * @author gaohu08299 * @create $ ID: ThreadPools, 2020-10-15 10:51 gaohu08299 Exp $ * @since 1.0.0 */</span><span class="token annotation punctuation">@Slf4j</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPools</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ExecutorService logPools<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">ThreadPools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>      logPools <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span> TimeUnit<span class="token punctuation">.</span>MINUTES<span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">ArrayBlockingQueue</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1024</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token keyword">new</span> <span class="token class-name">NamedThreadFactory</span><span class="token punctuation">(</span><span class="token string">"LOGGER"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadPools <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> ThreadPoolManagerHolder<span class="token punctuation">.</span>instance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolManagerHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> ThreadPools instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadPools</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">void</span> <span class="token function">submitLoggerTask</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            logPools<span class="token punctuation">.</span><span class="token function">submit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"submitLoggerTask exception{}"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="使用线程池"><a href="#使用线程池" class="headerlink" title="使用线程池"></a>使用线程池</h5><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">asyncCacheCityDetailPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        ThreadPools<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">submitLoggerTask</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token operator">></span> <span class="token function">submitLogger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="线程池默认的工作行为"><a href="#线程池默认的工作行为" class="headerlink" title="线程池默认的工作行为"></a>线程池默认的工作行为</h5><ul><li>不会初始化corePoolSize 个线程，有任务来了才创建工作线程。</li><li>当核心线程满了之后不会立即扩容线程池，而是把任务堆积到工作队列中。</li><li>当工作队列满了之后扩容线程池，一直到线程个数达到maximumPoolSize为止。</li><li>如果队列已满且达到最大线程后还有任务进来，按照拒绝策略处理。</li><li>当线程数大于核心线程数时，线程等待keepAliveTime后还是没有任务需要处理的话，收缩线程到核心线程数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>/2020/04/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>数据库事务( transaction)是访问并可能操作各种<a href="https://baike.baidu.com/item/数据项/3227309" target="_blank" rel="noopener">数据项</a>的一个数据库操作<a href="https://baike.baidu.com/item/序列/1302588" target="_blank" rel="noopener">序列</a>，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。<a id="more"></a></p><h1 id="事务的特性：ACID"><a href="#事务的特性：ACID" class="headerlink" title="事务的特性：ACID"></a>事务的特性：ACID</h1><ol><li><strong>A，也就是原子性（Atomicity）</strong>。原子的概念就是不可分割，你可以把它理解为组成物质的基本单位，也是我们进行数据处理操作的基本单位。</li><li><strong>C，就是一致性（Consistency</strong>）。一致性指的就是数据库在进行事务操作后，会由原来的一致状态，变成另一种一致的状态。也就是说当事务提交后，或者当事务发生回滚后，数据库的完整性约束不能被破坏。</li><li><strong>I，就是隔离性（Isolation）</strong>。它指的是每个事务都是彼此独立的，不会受到其他事务的执行影响。也就是说一个事务在提交之前，对其他事务都是不可见的。</li><li><strong>D，指的是持久性（Durability）</strong>。事务提交之后对数据的修改是持久性的，即使在系统出故障的情况下，比如系统崩溃或者存储介质发生故障，数据的修改依然是有效的。因为当事务完成，数据库的日志就会被更新，这时可以通过日志，让系统恢复到最后一次成功的更新状态。</li></ol><h2 id="数据库隔离级别"><a href="#数据库隔离级别" class="headerlink" title="数据库隔离级别"></a>数据库隔离级别</h2><h4 id="事务并发可能存在的异常有哪些？"><a href="#事务并发可能存在的异常有哪些？" class="headerlink" title="事务并发可能存在的异常有哪些？"></a><strong>事务并发可能存在的异常有哪些？</strong></h4><p><strong>1、脏读</strong>: 读到了其他事务还没有提交的数据。</p><p>例子：A事务读取B事务尚未提交的数据，此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据。就好像原本的数据比较干净、纯粹，此时由于B事务更改了它，这个数据变得不再纯粹。这个时候A事务立即读取了这个脏数据，但事务B良心发现，又用回滚把数据恢复成原来干净、纯粹的样子，而事务A却什么都不知道，最终结果就是事务A读取了此次的脏数据，称为脏读。</p><p><strong>2、丢失修改</strong>（Lost to modify）指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p><p><strong>3、不可重复读</strong>：前后多次读取，数据内容不一致</p><p>例子：事务A在执行读取操作，由整个事务A比较大，前后读取同一条数据需要经历很长的时间 。而在事务A第一次读取数据，比如此时读取了小明的年龄为20岁，事务B执行更改操作，将小明的年龄更改为30岁，此时事务A第二次读取到小明的年龄时，发现其年龄是30岁，和之前的数据不一样了，也就是数据不重复了，系统不可以读取到重复的数据，成为不可重复读。</p><p><strong>4：幻读</strong>：前后多次读取，数据总量不一致</p><p>事务A在执行读取操作，需要两次统计数据的总量，前一次查询数据总量后，此时事务B执行了新增数据的操作并提交后，这个时候事务A读取的数据总量和之前统计的不一样，就像产生了幻觉一样，平白无故的多了几条数据，成为幻读。</p><p><strong>不可重复度和幻读区别：</strong> 不可重复读针对的是修改操作，幻读针对的于新增或者删除操作。</p><h4 id="事务的四种隔离级别"><a href="#事务的四种隔离级别" class="headerlink" title="事务的四种隔离级别"></a><strong>事务的四种隔离级别</strong></h4><p><strong>1、读未提交（READ-UNCOMMITTED）</strong>：也就是允许读到未提交的内容，这种情况下查询是不会使用锁的，可能会产生脏读、不可重复读、幻读等情况。</p><p><strong>2、读已提交（READ-COMMITTED）</strong>：读已提交就是只能读到已经提交的内容，可以避免脏读的产生，属于RDBMS中常见的默认隔离级别（比如说Oracle和SQL Server），但如果想要避免不可重复读或者幻读，就需要我们在SQL查询的时候编写带加锁的SQL语句。</p><p><strong>3、可重复读（REPEATABLE-READ）</strong>，保证一个事务在相同查询条件下两次查询得到的数据结果是一致的，可以避免不可重复读和脏读，但无法避免幻读。MySQL默认的隔离级别就是可重复读。</p><p><strong>4、可串行化（SERIALIZABLE）</strong>，将事务进行串行化，也就是在一个队列中按照顺序执行，可串行化是最高级别的隔离等级，可以解决事务读取中所有可能出现的异常情况，但是它牺牲了系统的并发性。</p><p><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/%E6%88%AA%E5%B1%8F2021-04-26%2023.53.34.png" alt></p><h3 id="事物隔离的实现"><a href="#事物隔离的实现" class="headerlink" title="事物隔离的实现"></a>事物隔离的实现</h3><p>在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><p>假设一个值从 1 被按顺序改成了 2、3、4，在回滚日志里面就会有类似下面的记录。</p><p><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/d9c313809e5ac148fc39feff532f0fee.png" alt></p><p>事务隔离的实现：每条记录在更新的时候都会同时记录一条回滚操作。同一条记录在系统中可以存在多个版本，这就是数据库的多版本并发控制（MVCC）</p><p>事务启动方式：一、显式启动事务语句，begin或者start transaction,提交commit，回滚rollback；二、set autocommit=0，该命令会把这个线程的自动提交关掉。这样只要执行一个select语句，事务就启动，并不会自动提交，直到主动执行commit或rollback或断开连接。</p><h3 id="常见数据库事物面试题"><a href="#常见数据库事物面试题" class="headerlink" title="常见数据库事物面试题"></a>常见数据库事物面试题</h3><ul><li>介绍一下数据库的事务</li><li>Mysql 有哪些隔离级别</li><li>Mysql 什么情况会造成脏读、可重复读、幻读？如何解决。</li><li>Mysql 在可重复读的隔离级别下会不会有幻读的情况，为什么？</li><li>Mysql 事务是如何实现的。</li></ul><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css"><p><script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script></p><p><div id="gitalk-container"></div><br>var gitalk = new Gitalk({<br>  “clientID”: “clientId”,<br>  “clientSecret”: “clientSecret”,<br>  “repo”: “GitHub repo”,<br>  “owner”: “GitHub repo owner”,<br>  “admin”: [“GitHub repo admin”],<br>  “id”: location.pathname,<br>  “distractionFreeMode”: false<br>});<br>gitalk.render(“gitalk-container”);</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法专栏</title>
      <link href="/2019/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F/"/>
      <url>/2019/11/17/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B8%93%E6%A0%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><p><strong>总的时间复杂度就等于量级最大的那段代码的时间复杂度</strong></p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/3723793cc5c810e9d5b06bc95325bf0a.jpg" alt></p><ul><li>O(1)只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)。或者说，<strong>一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)</strong>。</li></ul><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p><strong>数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。</strong></p><p>第一是<strong>线性表</strong>（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。而与它相对立的概念是<strong>非线性表</strong>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。</p><p><strong>连续的内存空间和相同类型的数</strong></p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构与算法分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java类加载机制详解</title>
      <link href="/2019/02/15/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/"/>
      <url>/2019/02/15/Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-了解-class"><a href="#1-了解-class" class="headerlink" title="1. 了解 .class"></a>1. 了解 .class</h3><h4 id="1-1-字节码-class-来源"><a href="#1-1-字节码-class-来源" class="headerlink" title="1.1 字节码 .class 来源"></a>1.1 字节码 .class 来源</h4><p>我们都知道 Java 是跨平台的，一次编写可以在各个操作系统上运行。而其中的一次编写，就是指：</p><p>通过 Java 语法编写 <code>*.java</code> 文件，由编译器产生 <code>*.class</code>。而 <code>*.class</code> 可以发布到各种操作系统上，由各个系统上 JVM 的 Java 运行环境来加载进行运行。</p><p>随着开源生态的发展，Java 虚拟机规范《Java Virtual Machine Specification》的制定，<code>*.class</code> 不一定只有 Java 语言和 Java 编译器可以生成，目前市场比较有名的还有 JRuby、Groovy、Jython 等。</p><table><thead><tr><th>语言</th><th>其源文件</th><th>编译器</th><th>字节码</th><th>JVM</th></tr></thead><tbody><tr><td>Java 语言</td><td>*.java</td><td>javac 编译器</td><td>字节码 .class</td><td>Java 虚拟机</td></tr><tr><td>JRuby 语言</td><td>*.rb</td><td>jrubyc 编译器</td><td>字节码 .class</td><td>Java 虚拟机</td></tr><tr><td>Groovy 语言</td><td>*.groovy</td><td>groovyc 编译器</td><td>字节码 .class</td><td>Java 虚拟机</td></tr><tr><td>其它符合标准的语言</td><td><em>.</em></td><td>对应的编译器</td><td>字节码 .class</td><td>Java 虚拟机</td></tr></tbody></table><h4 id="1-2-class-文件结构和内容"><a href="#1-2-class-文件结构和内容" class="headerlink" title="1.2 .class 文件结构和内容"></a>1.2 .class 文件结构和内容</h4><p>.class 文件是一个 8 位字节的二进制流文件。</p><p>简单来说，就是一个字节占用 8 位，即一个字节用 8 位的 0、1 二进制流表示。也就是说，Java 世界里面的二进制流，不管是 16-bit、32-bit、64-bit， 都将会被分别转成 2、3、8 个 8 位的字节。</p><p>可以用 <code>java.io.DataInput</code> 和 <code>java.io.DataOutput</code> 来处理 8 位字节的二进制流，读、存 classes 文件可以用 <code>java.io.DataInputStream</code> 和 <code>java.io.DataOutputStream</code>。</p><p>.class 文件中的每个字节都是紧凑地拼接在一起，中间没有任何分割符号，因此每一个字节都有其一定意义。就像一张表一样具有详细的分割，.class 文件可以看做一个由具有固定排版的 0、1 组成、每个位置都不能错的二进制流文件。所以加载完成后会有验证机制。</p><p><strong>严格的类结构如下：</strong></p><p><img src="http://images.gitbook.cn/472a8fe0-4d0f-11e8-b4a2-6db258d7e131" alt="enter image description here"></p><p>根据 Java 虚拟机的规定，class 文件采用的这种类似 C 语言的伪结构来储存，而其中包含了两种数据类型：无符号和表。</p><p>u1、u2、u3、u4 等就是无符号数据类型，分别代表了 1 个字节、2 个字节、3 个字节、4 个字节等等以此类推。而其中的 ***_info 就代表了一种表的数据类型，其后的结构详情是个表结构。非常细的表结构我们知道就行了，最重要的是上面的 class 结构。</p><p>我们来分别看下每个结构代表什么意思，如下表：</p><table><thead><tr><th>结构体</th><th>名字</th><th>字节数</th><th>描述</th></tr></thead><tbody><tr><td>magic</td><td>魔数</td><td>u4 四个字节</td><td>其实懂计算机储存原理的都知道，这是用来识别二进制的文件属于什么文件类型。而 .class 文件的魔数用 16 进制来表示正是 CAFEBABE（咖啡宝贝)</td></tr><tr><td>minor<em>version, major</em>version</td><td>次版本号，主版本号</td><td>u2 分别 2 个字节</td><td>支持的最低大版本号，小版本号</td></tr><tr><td>constant<em>pool</em>count</td><td>常量池数量</td><td>u2 2 个字节长度</td><td></td></tr><tr><td>constant_pool</td><td>常量池</td><td>cp_info 常量池表结构</td><td>里面包含 String 常量、Class 、 interface 名称、 字段名、常量的引用等</td></tr><tr><td>access_flags</td><td>访问表示</td><td>u2 2 个字节长度</td><td>表示这个 class 是 class 还是接口；是否定义了 public 类型；是否定义了 abstract 类型；是否被声明了 final 等</td></tr><tr><td>this<em>class、super</em>class</td><td>当前类、父类</td><td>u2 2 个字节长度</td><td>在 constant<em>pool 里面符合 CONSTANT</em>Class_info 结构的索引的位置</td></tr><tr><td>interfaces_count</td><td>接口索引数量</td><td>u2 2 个字节长度</td><td>接口在 constant<em>pool 里面符合 CONSTANT</em>Class_info 结构的索引的数量</td></tr><tr><td>interfaces[]</td><td>接口索引数组</td><td>u2 2 个字节长度</td><td>接口在 constant<em>pool 里面符合 CONSTANT</em>Class_info 结构的索引的位置</td></tr><tr><td>fields_count</td><td>字段数量</td><td>u2 2 个字节长度</td><td></td></tr><tr><td>fields[]</td><td>字段的表结构数组</td><td>field_info 表结构</td><td>符合field_info结构的字段value table</td></tr><tr><td>methods_count</td><td>方法数量</td><td>u2 2 个字节长度</td><td></td></tr><tr><td>methods[]</td><td>方法对应的表的结构的数组</td><td>method_info 表结构</td><td>符合 method_info 结构的字段 value table</td></tr><tr><td>attributes_count</td><td>属性数量</td><td>u2 2 个字节长度</td><td></td></tr><tr><td>attributes[]</td><td>属性表结构的数组</td><td>attribute_info 表结构</td><td>符合 attribute_info 结构的字段 value table</td></tr></tbody></table><p>感兴趣的同学可以详细看一下<a href="https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-4.html" target="_blank" rel="noopener">《JVM 规范》</a></p><h4 id="1-3-查看-class-文件里面的二进制"><a href="#1-3-查看-class-文件里面的二进制" class="headerlink" title="1.3 查看 .class 文件里面的二进制"></a>1.3 查看 .class 文件里面的二进制</h4><p>MAC 情况下，我们可以直接通过 Sublime 打开 .class 文件，此工具默认会以 16 进制的格式来显示字节流。<br><img src="http://images.gitbook.cn/c470b8d0-4d0f-11e8-b4a2-6db258d7e131" alt="enter image description here"></p><p>MAC 中使用 vi 修改二进制文件</p><ol><li>首先以二进制方式编辑这个文件 <code>vi -b datafile</code></li><li>使用 xxd 转换为 16 进制 <code>:%!xxd</code>：</li></ol><p><img src="http://images.gitbook.cn/ca7d7d30-4d0f-11e8-856b-c3783bde05e6" alt="enter image description here"></p><h4 id="1-4-class-java"><a href="#1-4-class-java" class="headerlink" title="1.4 class.java"></a>1.4 class.java</h4><p>当我们大致了解了 .class 文件里面的字节流，接下去来了解一下<code>java.lang.class</code>类。</p><p>认识 class 对象之前，先来了解一个概念，RTTI（Run-Time Type Identification）——运行时类型识别。</p><p>这个词一直是 C++ 的概念，Java 中出现 RTTI 的说法是源于《Thinking in Java》一书。其作用是在运行时识别一个对象的类型和类的信息，这里分两种：</p><ul><li><strong>传统的“RTTI”</strong>，它假定我们在编译期已知道了所有类型（在没有反射机制创建和使用类对象时，一般都是编译期已确定其类型，如 new 对象时该类必须已定义好）</li><li>另外一种是<strong>反射机制</strong>，它允许我们在运行时发现和使用类型的信息。在 Java 中用来表示运行时类型信息的对应类就是 class 类，class 类也是一个实实在在的类，存在于 JDK 的 java.lang 包中。部分源码内容如下：</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Class</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span><span class="token punctuation">,</span>                              GenericDeclaration<span class="token punctuation">,</span>                              Type<span class="token punctuation">,</span>                              AnnotatedElement <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ANNOTATION<span class="token operator">=</span> <span class="token number">0x00002000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ENUM      <span class="token operator">=</span> <span class="token number">0x00004000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SYNTHETIC <span class="token operator">=</span> <span class="token number">0x00001000</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/*     * Private constructor. Only the Java Virtual Machine creates Class objects.     * This constructor is not used and prevents the default constructor being     * generated.     */</span>    <span class="token keyword">private</span> <span class="token function">Class</span><span class="token punctuation">(</span>ClassLoader loader<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Initialize final field for classLoader.  The initialization value of non-null</span>        <span class="token comment" spellcheck="true">// prevents future JIT optimizations from assuming this final field is null.</span>        classLoader <span class="token operator">=</span> loader<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>作为 Java 工程师不一定要知道 .class 里面的文件字节流详细到每个内容是什么意思，但是 class.java 里面的方法都是我们必须要掌握的。因为“反射”在实际开发中会经常被用到。</p></blockquote><p>class 类被创建后的对象就是 class 对象，注意，class 对象表示的是自己手动编写类的类型信息。比如创建一个 Shapes 类，那么JVM 就会创建一个 Shapes 对应 class 类的 class 对象，该 class 对象保存了 Shapes 类相关的类型信息。</p><p>实际上在 Java 中每个类都有一个 class 对象，每当我们编写编译一个新创建的类，就会产生一个对应 class 对象并且这个 class 对象会被保存在同名 .class 文件里（编译后的字节码文件保存的就是 class 对象）。</p><p>那为什么需要这样一个 class 对象呢？</p><p>当我们 new 一个新对象或者引用静态成员变量时，Java 虚拟机中的类加载器子系统会将对应 class 对象加载到 JVM 中，然后 JVM 再根据这个类型信息相关的 class 对象创建我们需要的实例对象或者提供静态变量的引用值。</p><p><strong>需要特别注意的是，手动编写的每个 class 类，无论创建多少个实例对象，在 JVM 中都只有一个 class 对象，即在内存中每个类有且只有一个相对应的 class 对象（即也就是所谓的 meta，Java 元数据）。</strong></p><ul><li>class 类只存私有构造函数，因此对应 class 对象只能由 JVM 创建和加载</li><li>class 类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要。</li></ul><p>class 的 UML 图：<img src="http://images.gitbook.cn/0c4e1760-4d10-11e8-8fbb-d5dabcf6ef11" alt="enter image description here"></p><p>我们通过此图可以发现：</p><ol><li>Java 里面的反射，涉及到的任何东西都是字节。</li><li>而每个反射回来的对象不一定是 class，还有 ParameterizedTypeImpl。</li></ol><h3 id="2-class-在-JVM-中"><a href="#2-class-在-JVM-中" class="headerlink" title="2. class 在 JVM 中"></a>2. class 在 JVM 中</h3><p>在整个 JVM 的架构设计中，Class Loader 作为一个子系统，是 JVM 运行之前必须执行的一个过程，即在任何 class 初始化之前必须先进行加载，加载完然后放到 MethodArea 里面，整个过程如下图所示：<img src="http://images.gitbook.cn/7eb3d3d0-4d10-11e8-856b-c3783bde05e6" alt="enter image description here"></p><p>而其中的 Method Area 就是用于存储所得 class 结构的字节流。在运行时会通过 class ref 建立联系如下图：</p><p><img src="http://images.gitbook.cn/967e1160-4d10-11e8-9d85-bdd8a53e41f6" alt="enter image description here"></p><h4 id="2-1-class-类加载时机与过程"><a href="#2-1-class-类加载时机与过程" class="headerlink" title="2.1 class 类加载时机与过程"></a>2.1 class 类加载时机与过程</h4><p>当我们有了 .class 之后，接下去就是 JVM 通过规范进行 .class 的内存加载。类从加载到虚拟机内存中开始，直到卸载为止，它的整个生命周期包括了：加载、验证、准备、解析、初始化、使用和卸载这 7 个阶段。其中，验证、准备和解析这三个部分统称为连接（linking）。正如下图所示：<img src="http://images.gitbook.cn/adacf950-4d10-11e8-856b-c3783bde05e6" alt="enter image description here"><br>其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的“开始”（仅仅指的是开始，而非执行或者结束，因为这些阶段通常都是互相交叉的混合进行，通常会在一个阶段执行的过程中调用或者激活另一个阶段），而解析阶段则不一定（它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 语言的运行时绑定）。</p><h4 id="2-2-何时开始类的初始化"><a href="#2-2-何时开始类的初始化" class="headerlink" title="2.2 何时开始类的初始化"></a>2.2 何时开始类的初始化</h4><p>什么情况下需要开始类加载过程的第一个阶段：”加载”。</p><p>虚拟机规范中并没强行约束在什么时候开始类加载过程，可以交给虚拟机的的具体实现自由把握。但加载一定发生在初始化之前。对于初始化时机，虚拟机严格规定了如下几种情况：</p><ol><li>创建类的实例</li><li>访问类的静态变量（被 final 修辞的静态变量除外）</li></ol><blockquote><p>被 final 修辞的静态变量除外原因：常量一种特殊的变量，因为编译器把他们当作值 (value) 而不是域 (field) 来对待。如果你的代码中用到了常变量 (constant variable)，编译器并不会生成字节码，而是直接把这个值插入到字节码中。这是一种很有用的优化，但是如果你需要改变 final 域的值那么每一块用到那个域的代码都需要重新编译。</p><ol><li>访问类的静态方法</li><li>反射如 (Class.forName(“my.xyz.Test”))</li><li>当初始化一个类时，发现其父类还未初始化，则先出发父类的初始化</li><li>虚拟机启动时，定义了 main() 方法的那个类先初始化</li></ol></blockquote><p>以上情况称为对一个类进行“主动引用”，除此之外均不会触发类的初始化，称为“被动引用”。</p><p>接口的加载过程与类的加载过程稍有不同。接口中不能使用 static{} 块。当一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有真正在使用到父接口时（例如引用接口中定义的常量）才会初始化。也就是说：</p><ol><li>子类调用父类的静态变量，子类不会被初始化。只有父类被初始化。对于静态字段，只有直接定义这个字段的类才会被初始化。</li><li>通过数组定义来引用类，不会触发类的初始化</li><li>访问类的常量，不会初始化类</li></ol><h4 id="2-3-初始化-5-步走"><a href="#2-3-初始化-5-步走" class="headerlink" title="2.3 初始化 5 步走"></a>2.3 初始化 5 步走</h4><h5 id="2-3-1-加载"><a href="#2-3-1-加载" class="headerlink" title="2.3.1 加载"></a><strong>2.3.1 加载</strong></h5><p>“加载” (Loading) 是“类加载” (Class Loading) 的第一个阶段，在此阶段，虚拟机需要完成以下三件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的二进制字节流。</li><li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li><li>在 Java 堆中生成一个代表这个类的 java.lang.class 对象，作为方法区这些数据的访问入口。</li></ol><p>加载阶段既可以使用系统提供的类加载器完成，也可以由用户自定义的类加载器来完成。加载阶段与连接阶段的部分内容（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始。</p><h5 id="2-3-2-验证"><a href="#2-3-2-验证" class="headerlink" title="2.3.2 验证"></a><strong>2.3.2 验证</strong></h5><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</p><p>Java 语言本身是相对安全的语言，使用 Java 编码无法做到如访问数组边界以外的数据、将一个对象转型为它并未实现的类型等，如果这样做，编译器将拒绝编译。但是，class 文件并不一定是由 Java 源码编译而来，可以使用任何途径，包括用十六进制编辑器（如 UltraEdit）直接编写。如果直接编写了有害的“代码”，而虚拟机在加载该 class 时不进行检查的话，就有可能危害到虚拟机或程序的安全。</p><p>不同的虚拟机，对类验证的实现可能有所不同，但大致都会完成下面四个阶段的验证：文件格式验证、元数据验证、字节码验证和符号引用验证。</p><ol><li>文件格式验证，是要验证字节流是否符合 class 文件格式规范，且能被当前版本的虚拟机处理。如验证魔数是否 0xCAFEBABE；主、次版本号是否正在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型……该验证阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区中，经过这个阶段的验证后，字节流才会进入内存的方法区中存储，所以后面的三个验证阶段都是基于方法区的存储结构进行的。</li><li>元数据验证，是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求。可能包括的验证如：这个类是否有父类；这个类的父类是否继承了不被允许继承的类；如果这个类不是抽象类，是否实现了其父类或接口中要求实现的所有方法……</li><li>字节码验证，主要工作是进行数据流和控制流分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为。如果一个类方法体的字节码没有通过字节码验证，那肯定是有问题的；但如果一个方法体通过了字节码验证，也不能说明其一定就是安全的。</li><li>符号引用验证，发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在“解析阶段”中发生。验证符号引用中通过字符串描述的权限定名是否能找到对应的类；在指定类中是否存在符合方法字段的描述符及简单名称所描述的方法和字段；符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问</li></ol><p>验证阶段对于虚拟机的类加载机制来说，不一定是必要的阶段。如果所运行的全部代码确认是安全的，可以使用 <code>-Xverify：none</code> 参数来关闭大部分的类验证措施，以缩短虚拟机类加载时间。</p><h5 id="2-3-3-准备"><a href="#2-3-3-准备" class="headerlink" title="2.3.3 准备"></a><strong>2.3.3 准备</strong></h5><p>准备阶段为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> value<span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//在准备阶段value初始值为0 。在初始化阶段才会变为123 。</span></code></pre><h5 id="2-3-4-解析"><a href="#2-3-4-解析" class="headerlink" title="2.3.4 解析"></a><strong>2.3.4 解析</strong></h5><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</p><ol><li>符号引用（Symbolic Reference）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</li><li>直接引用（Direct Reference）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，如果有了直接引用，那么引用的目标必定已经在内存中存在。</li></ol><h5 id="2-3-5-初始化"><a href="#2-3-5-初始化" class="headerlink" title="2.3.5 初始化"></a><strong>2.3.5 初始化</strong></h5><p>类初始化是类加载过程的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。</p><p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。 <code>&lt;clinit&gt;()</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。</p><h3 id="3-ClassLoader-详解："><a href="#3-ClassLoader-详解：" class="headerlink" title="3. ClassLoader 详解："></a>3. ClassLoader 详解：</h3><p>Java 默认提供的三个 ClassLoader，分别是：BootStrap ClassLoader、Extension ClassLoader、App ClassLoader。我们执行一个新建的 test.java，打印出来所有的 ClassLoader 来看看加载器都有哪些？</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      ClassLoader loader <span class="token operator">=</span> Test<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得加载ClassLoaderTest.class这个类的类加载器</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>loader <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>loader<span class="token punctuation">)</span><span class="token punctuation">;</span>         loader <span class="token operator">=</span> loader<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//获得父类加载器的引用</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上面例子，执行结果如下：</p><pre class=" language-java"><code class="language-java">sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$AppClassLoader<span class="token annotation punctuation">@14dad5dc</span>sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>Launcher$ExtClassLoader<span class="token annotation punctuation">@1d81eb93</span>null</code></pre><ul><li>第一行结果说明：ClassLoaderTest 的类加载器是 AppClassLoader。</li><li>第二行结果说明：AppClassLoader 的类加器是 ExtClassLoader，即 parent=ExtClassLoader。</li><li>第三行结果说明：ExtClassLoader 的类加器是 Bootstrap ClassLoader，因为 Bootstrap ClassLoader 不是一个普通的 Java 类，所以 ExtClassLoader 的 parent=null，所以第三行的打印结果为 null 就是这个原因。</li></ul><h4 id="3-1-ClassLoader-的体系架构及其加载原理"><a href="#3-1-ClassLoader-的体系架构及其加载原理" class="headerlink" title="3.1 ClassLoader 的体系架构及其加载原理"></a>3.1 ClassLoader 的体系架构及其加载原理</h4><p>ClassLoader 是个抽象父类，看一下它的关键代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token function">registerNatives</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token keyword">protected</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">boolean</span> resolve<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException<span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token function">getClassLoadingLock</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// First, check if the class has already been loaded</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> <span class="token function">findLoadedClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">long</span> t0 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> parent<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    c <span class="token operator">=</span> <span class="token function">findBootstrapClassOrNull</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// ClassNotFoundException thrown if class not found</span>                <span class="token comment" spellcheck="true">// from the non-null parent class loader</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>c <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// If still not found, then invoke findClass in order</span>                <span class="token comment" spellcheck="true">// to find the class.</span>                <span class="token keyword">long</span> t1 <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                c <span class="token operator">=</span> <span class="token function">findClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// this is the defining class loader; record the stats</span>sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getParentDelegationTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addTime</span><span class="token punctuation">(</span>t1 <span class="token operator">-</span> t0<span class="token punctuation">)</span><span class="token punctuation">;</span>            sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClassTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">addElapsedTimeFrom</span><span class="token punctuation">(</span>t1<span class="token punctuation">)</span><span class="token punctuation">;</span>                sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>PerfCounter<span class="token punctuation">.</span><span class="token function">getFindClasses</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">resolveClass</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> c<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>通过源码和 JDK 里面的 classload 注释，这方法的目的是使用指定的二进制名称来加载类，默认实现按照以下顺序查找类：</p><ol><li>调用 <code>findLoadedClass(String)</code> 方法检查这个类是否被加载过</li><li>使用父加载器调用 <code>loadClass(String)</code> 方法</li><li>如果父加载器为 Null，类加载器装载虚拟机内置的加载器调用 <code>findClass(String)</code>方法装载类</li></ol><p>如果按照以上的步骤成功的找到对应的类，并且该方法接收的 resolve 参数的值为 true，那么就调用 <code>resolveClass(Class)</code> 方法来处理类。</p><p>ClassLoader 的子类最好覆盖 <code>findClass(String)</code>，除非被重写，这个方法默认在整个装载过程中都是同步的（线程安全的）。</p><p>也就是如下规则：<img src="http://images.gitbook.cn/0b057fe0-4d12-11e8-8fbb-d5dabcf6ef11" alt="enter image description here"></p><p><strong>双亲委托模型：</strong></p><p>其实这个规则概括起来就是我们常说的“双亲委托模型”。每个 ClassLoader 实例都有一个父类加载器的引用（不是继承的关系，是一个包含的关系），虚拟机内置的类加载器（Bootstrap ClassLoader）本身没有父类加载器，但可以用作其它 ClassLoader 实例的的父类加载器。当一个 ClassLoader 实例需要加载某个类时，它会试图亲自搜索某个类，先把这个任务委托给它的父类加载器，这个过程是由上至下依次检查的，首先由最顶层的类加载器 Bootstrap ClassLoader 试图加载，如果没加载到，则把任务转交给 Extension ClassLoader 试图加载，如果也没加载到，则转交给 App ClassLoader 进行加载，如果它也没有加载得到的话，则返回给委托的发起者，由它到指定的文件系统或网络等 URL 中加载该类。如果它们都没有加载到这个类时，则抛出 ClassNotFoundException 异常。否则将这个找到的类生成一个类的定义，并将它加载到内存当中，最后返回这个类在内存中的 Class 实例对象。正如下图所示：</p><p><img src="http://images.gitbook.cn/ec502be0-4d11-11e8-856b-c3783bde05e6" alt="enter image description here"></p><p><strong>为什么要使用双亲委托这种模型？</strong></p><p>因为这样可以避免重复加载，当父类已经加载了该类的时候，就没有必要子 ClassLoader 再加载一次。考虑到安全因素，我们试想一下，如果不使用这种委托模式，那我们就可以随时使用自定义的 string 来动态替代 Java 核心 API 中定义的类型，这样会存在非常大的安全隐患；而双亲委托的方式，就可以避免这种情况，因为 string 已经在启动时就被引导类加载器（Bootstrcp ClassLoader）加载，所以用户自定义的 ClassLoader 永远也无法加载一个自己写的 string，除非你改变 JDK 中 ClassLoader 搜索类的默认算法。</p><p><strong>JVM 在搜索类的时候，如何判定两个 Class 是相同的？</strong></p><p>JVM 在判定两个 Class 是否相同时，不仅要判断两个类名是否相同，而且要判断是否由同一个类加载器实例加载的。只有两者同时满足的情况下，JVM 才认为这两个 Class 是相同的。</p><h4 id="3-2-Spring-的-ClassLoader"><a href="#3-2-Spring-的-ClassLoader" class="headerlink" title="3.2 Spring 的 ClassLoader"></a>3.2 Spring 的 ClassLoader</h4><p>而当我们使用 Spring Boot 的时候，会用到 <code>spring-boot-devtools</code> 来帮我们实现热部署。而其中热部署的原理就是使用了自定义 class loader 来实现类的重新加载，如下图，我们设置一个断点：<img src="http://images.gitbook.cn/67fc6900-4d14-11e8-8fbb-d5dabcf6ef11" alt="enter image description here"></p><h3 id="4-Java-初始化顺序"><a href="#4-Java-初始化顺序" class="headerlink" title="4. Java 初始化顺序"></a>4. Java 初始化顺序</h3><p>正如下图所示的 Java 单个对象的初始化顺序：<img src="http://images.gitbook.cn/b865e3d0-4d14-11e8-8fbb-d5dabcf6ef11" alt="enter image description here"></p><p>非继承加载顺序验证 1：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ExecuteDemo</span> <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span> <span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        DemonstrateOrder DO <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DemonstrateOrder</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">DemonstrateOrder</span><span class="token punctuation">{</span>        <span class="token keyword">static</span> String vstatic <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">" 1a - Static class variable vstatic initialized first."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        String vnonstatic <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">" 2  - Non-static class variable vnonstatic initialized."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">static</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 1b - Static initialization block ran."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">static</span> String <span class="token function">verify</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> s<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token function">DemonstrateOrder</span> <span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">" 3  - Constructor ran."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们执行一下打印结果如下：</p><pre class=" language-java"><code class="language-java">1a <span class="token operator">-</span> Static <span class="token keyword">class</span> <span class="token class-name">variable</span> vstatic initialized first<span class="token punctuation">.</span>1b <span class="token operator">-</span> Static initialization block ran<span class="token punctuation">.</span><span class="token number">2</span>  <span class="token operator">-</span> Non<span class="token operator">-</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">variable</span> vnonstatic initialized<span class="token punctuation">.</span><span class="token number">3</span>  <span class="token operator">-</span> Constructor ran<span class="token punctuation">.</span></code></pre><p>继承加载顺序验证 2：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span>String p <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">"4  - Parent's non-static class variable p initialized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> String pstatic <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">"1a - Parent's static class variable pstatic initialized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"1b - Parent's static initialization block ran."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">static</span> String <span class="token function">verify</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> s<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Parent</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"5  - Parent constructor ran."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Child</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span> <span class="token punctuation">{</span><span class="token keyword">static</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"2a - Child's static initialization block ran."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>String c <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">"6  - Child's non-static class variable c initialized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> String cstatic <span class="token operator">=</span> <span class="token function">verify</span><span class="token punctuation">(</span><span class="token string">"2b - Child's static class variable cstatic initialized."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">Child</span><span class="token punctuation">(</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//super( );   //调不调用super执行结果一样</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span> <span class="token punctuation">(</span><span class="token string">"7  - Child constructor ran."</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span> <span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"3  - Child's main(..) method ran. Invoking Child with new."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                                 Child C <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>  System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"8  - The rest of main(..) was run."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>执行结果如下：</p><pre class=" language-java"><code class="language-java">1a <span class="token operator">-</span> Parent's <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">variable</span> pstatic initialized<span class="token punctuation">.</span>1b <span class="token operator">-</span> Parent's <span class="token keyword">static</span> initialization block ran<span class="token punctuation">.</span>2a <span class="token operator">-</span> Child's <span class="token keyword">static</span> initialization block ran<span class="token punctuation">.</span>2b <span class="token operator">-</span> Child's <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">variable</span> cstatic initialized<span class="token punctuation">.</span><span class="token number">3</span>  <span class="token operator">-</span> Child's <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> method ran<span class="token punctuation">.</span> Invoking Child with <span class="token keyword">new</span><span class="token punctuation">.</span><span class="token number">4</span>  <span class="token operator">-</span> Parent's non<span class="token operator">-</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">variable</span> p initialized<span class="token punctuation">.</span><span class="token number">5</span>  <span class="token operator">-</span> Parent constructor ran<span class="token punctuation">.</span><span class="token number">6</span>  <span class="token operator">-</span> Child's non<span class="token operator">-</span><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">variable</span> c initialized<span class="token punctuation">.</span><span class="token number">7</span>  <span class="token operator">-</span> Child constructor ran<span class="token punctuation">.</span><span class="token number">8</span>  <span class="token operator">-</span> The rest of <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> was run<span class="token punctuation">.</span></code></pre><p><strong>static 关键字</strong></p><p>而其中 static 修饰的变量，初始化实际上分成两步：</p><ol><li>静态变量随着类加载完成初始化和默认值</li><li>当 loading 完，在 initialization 这步完成了初始化</li></ol><h3 id="5-Spring-Bean-加载原理"><a href="#5-Spring-Bean-加载原理" class="headerlink" title="5. Spring Bean 加载原理"></a>5. Spring Bean 加载原理</h3><p>我们提到了 JVM 的 Class 的加载原理，那我们也顺便看一下 Spring Bean 的加载原理：一个是应用级别的，一个是 JVM 级别的。我们来简单了解一下：<img src="http://images.gitbook.cn/e6dbcf90-4d14-11e8-856b-c3783bde05e6" alt="enter image description here"></p><ol><li><p>ResourceLoader 从存储介质中加载 Spring 配置信息，并使用 Resource 表示这个配置文件的资源；</p></li><li><p>BeanDefinitionReader 读取 Resource 所指向的配置文件资源，然后解析配置文件。配置文件中每一个解析成一个 BeanDefinition 对象，并保存到 BeanDefinitionRegistry 中；</p></li><li><p>容器扫描 BeanDefinitionRegistry 中的 BeanDefinition，使用 Java 的反射机制自动识别出 Bean 工厂后处理后器（实现 BeanFactoryPostProcessor 接口）的 Bean，然后调用这些 Bean 工厂后处理器对 BeanDefinitionRegistry 中的 BeanDefinition 进行加工处理。主要完成以下两项工作：<br>1）对使用到占位符的元素标签进行解析，得到最终的配置值，这意味对一些半成品式的 BeanDefinition 对象进行加工处理并得到成品的 BeanDefinition 对象；<br>2）对 BeanDefinitionRegistry 中的 BeanDefinition 进行扫描，通过 Java 反射机制找出所有属性编辑器的 Bean（实现java.beans.PropertyEditor接口的Bean），并自动将它们注册到 Spring 容器的属性编辑器注册表中（PropertyEditorRegistry）；</p></li><li><p>Spring 容器从 BeanDefinitionRegistry 中取出加工后的 BeanDefinition，并调用 InstantiationStrategy 着手进行 Bean 实例化的工作；</p></li><li><p>在实例化 Bean 时，Spring容器使用 BeanWrapper 对 Bean 进行封装，BeanWrapper 提供了很多以 Java 反射机制操作 Bean 的方法，它将结合该 Bean 的 BeanDefinition 以及容器中属性编辑器，完成 Bean 属性的设置工作；</p></li><li><p>利用容器中注册的 Bean 后处理器（实现 BeanPostProcessor 接口的 Bean）对已经完成属性设置工作的 Bean 进行后续加工，直接装配出一个准备就绪的 Bean。</p><p>总之一句话：Spring Bean 的 loader 是基于 bean 的实例化配置，然后加载 Bean 进行初始化，然后根据 scope 在适当的实际分配实例化对象。</p></li></ol><h3 id="6-相关问题"><a href="#6-相关问题" class="headerlink" title="6. 相关问题"></a>6. 相关问题</h3><ol><li>final static 怎么理解？</li><li>如何利用 byte 二进制流来加载 Class？</li><li>看下这段代码的最终执行结果是什么？</li></ol><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SingleTon</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingleTon singleTon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count1<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count1<span class="token operator">++</span><span class="token punctuation">;</span>        count2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingleTon <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleTon<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SingleTon singleTon <span class="token operator">=</span> SingleTon<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count1="</span> <span class="token operator">+</span> singleTon<span class="token punctuation">.</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count2="</span> <span class="token operator">+</span> singleTon<span class="token punctuation">.</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p><strong>问：在实际开发的工程中，有用 ClassLoader 来处理什么吗？什么场景？干什么用？</strong></p><p><strong>答：</strong>看过文章的同学其实可以发现，ClassLoader 肯定是来加载我们的类的对吗？最常见的第一种场景：热部署。</p><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>dependency<span class="token operator">></span>            <span class="token operator">&lt;</span>groupId<span class="token operator">></span>org<span class="token punctuation">.</span>springframework<span class="token punctuation">.</span>boot<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">></span>            <span class="token operator">&lt;</span>artifactId<span class="token operator">></span>spring<span class="token operator">-</span>boot<span class="token operator">-</span>devtools<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">></span></code></pre><p>Spring Boot 我们会经常用到这个 Devtools，它就是通过自定义 ClassLoad 来实现类的卸载和重新加载。</p><p>第二种场景：当我们做插件开发的时候，有的时候上传一个 Jar 就可以实现某些功能，这个时候也需要自定 ClassLoad（这种做法目前很少用了。）实际生产，由于微服务的盛行，现在很少自定 ClassLoad 了。文章里面有方法查看上下文的 ClassLoad 的方法。</p><hr><p><strong>问：预留一个面试题的执行结果是什么？</strong></p><p><strong>答：</strong>我们先看一下程序：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">SingleTon</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> SingleTon singleTon <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count1<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> count2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">SingleTon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        count1<span class="token operator">++</span><span class="token punctuation">;</span>        count2<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SingleTon <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> singleTon<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        SingleTon singleTon <span class="token operator">=</span> SingleTon<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count1="</span> <span class="token operator">+</span> SingleTon<span class="token punctuation">.</span>count1<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"count2="</span> <span class="token operator">+</span> SingleTon<span class="token punctuation">.</span>count2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Count1 和 Cout2 分别是什么？</p><p><img src="http://images.gitbook.cn/57c65ca0-52c6-11e8-a8df-c3f787da37d0" alt="enter image description here"></p><p>这个题很多人都很容易犯错的，刚开始我也以为是1，2。详细了解 Class 字节码的初始化顺序，好好想想才明白。首先 Static 的准备和初始化阶段是分开的。我们文章里面讲过 Class 的初始化，一共经历了5个步骤。</p><p>当在准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中。</p><pre><code>         public static int count1;; //在准备阶段初始化0 public static int count2 = 0; //在准备阶段初始化0</code></pre><p>而在完成准备阶段，连接，和初始化阶段，静态变量又进行了赋值。什么时间算是完成初始化？就是在构造方法执行完。调用类的构造方法后 count=1;count2=1。而构造方法执行完，Static 开始赋值，既继续为 Count1 与 Count2 赋值，此时 Count1 没有赋值操作，所有 Count1 为1，但是 Count2 执行赋值操作就变为0。</p><p>Static 的内存溢出模拟方法如下：</p><p><img src="http://images.gitbook.cn/afe93950-5395-11e8-9dec-133e323ed087" alt="enter image description here"></p><p>由此可以看出 Static 在1.8之中是在 Heap 中的。</p><hr><p><strong>问：如何通过 Byte 二进制流来加载 Class？</strong></p><p><strong>答：</strong>首先先说基本原理，就 Class 文件找到，IO 字节流读进来，然后找到 ClassLoader 的 API 进行加载。其次那我们就查一下方法了，</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>example2<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token keyword">extends</span> <span class="token class-name">ClassLoader</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BUFFER_SIZE <span class="token operator">=</span> <span class="token number">1024</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">c</span> <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"/Users/jack/git_hub/spring-data-jpa-guide/2.0.0/example2/target/classes/com/example/example2/StringTest.class"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">loadClass</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token string">"StringTest"</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> classBytes <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//            InputStream in = new FileInputStream(new File(name));</span><span class="token comment" spellcheck="true">//            InputStream in = getResourceAsStream(new File(name));</span>            BufferedInputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span>BUFFER_SIZE<span class="token punctuation">]</span><span class="token punctuation">;</span>            ByteArrayOutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>n <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> BUFFER_SIZE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>buffer<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            classBytes <span class="token operator">=</span> out<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            in<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            out<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">defineClass</span><span class="token punctuation">(</span><span class="token string">"com.example.example2.StringTest"</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> classBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><img src="http://images.gitbook.cn/92d7d150-5395-11e8-9dec-133e323ed087" alt="enter image description here"></p><p>关键的就是 URLClassLoader 把二进制流加载进来。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cLassBytes  <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">readAllBytes</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span><span class="token punctuation">;</span> Class <span class="token class-name">cLass</span> <span class="token operator">=</span> <span class="token function">defineClass</span><span class="token punctuation">(</span>cLassBytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> cLassBytes<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>直接文件 IO 也可以，找到 Class 剩下就是 Class 里面的具体 API 方法了，初始化，反射都可以玩了。</p><hr><p><strong>问：什么是 Java Bytecode（Java字节码）？</strong></p><p><strong>答：</strong> Class 是以8位 Byte 的二进来储存 Java 字节码的，定义如下：字节码（英语：Bytecode）通常指的是已经经过编译，但与特定机器码无关，需要解释器转译后才能成为机器码的中间代码。前面我们讲了.class 里面的二进制流的内容，但是.class 里面的内容又叫字节码。而对于 Java 来说就是编译器生成.class 文件，而虚拟机加载.class 进行运行，而实现平台无关，Java 虚拟机将.class 的字节码转化成汇编指令进行运行。</p><p>Byte 二进制我们文章里面都讲过如何看了，但是怎么转换成 Java 认识的字节码？那么我们怎么分析字节码？因为它只有 JVM 识别，所以只能从 JDK 里面找工具。Java/Bin/Javap 可以帮我们分析字节码：Javap 是 JDK 自带的反汇编器，可以查看 Java 编译器为我们生成的字节码。通过它，我们可以对照源代码和字节码，从而了解很多编译器内部的工作。我们先介绍一下语法，</p><p>语法：</p><ul><li>javap [ 命令选项 ] class. . .</li><li>javap 命令用于解析类文件。其输出取决于所用的选项。若没有使用选项，javap 将输出传递给它的类的 public 域及方法。javap 将其输出到标准输出设备上。</li></ul><p>命令选项：</p><ul><li>-help 输出 javap 的帮助信息。</li><li>-l 输出行及局部变量表。</li><li>-b 确保与 JDK 1.1 javap 的向后兼容性。</li><li>-public 只显示 public 类及成员。</li><li>-protected 只显示 protected 和 public 类及成员。</li><li>-package 只显示包、protected 和 public 类及成员。这是缺省设置。</li><li>-private 显示所有类和成员。</li><li>-J[flag] 直接将 flag 传给运行时系统。</li><li>-s 输出内部类型签名。</li><li>-c 输出类中各方法的未解析的代码，即构成 Java 字节码的指令。</li><li>-verbose 输出堆栈大小、各方法的 locals 及 args 数,以及class文件的编译版本</li><li>-classpath[路径] 指定 javap 用来查找类的路径。如果设置了该选项，则它将覆盖缺省值或 CLASSPATH 环境变量。目录用冒号分隔。</li><li>- bootclasspath[路径] 指定加载自举类所用的路径。缺省情况下，自举类是实现核心 Java 平台的类，位于 jrelib</li><li>t.jar 和 jrelibi18n.jar 中。</li><li>-extdirs[dirs] 覆盖搜索安装方式扩展的位置。扩展的缺省位置是 jrelibext。</li></ul><p><img src="http://images.gitbook.cn/7e1be640-52c6-11e8-a8df-c3f787da37d0" alt="enter image description here"></p><p>我们看下实例：</p><pre><code>package com.example.example2;public class StringTest {   public static void main(String[] args) {      String str = &quot;Hello &quot;;      str += &quot;world&quot;;      System.out.println(str);   }}</code></pre><p>它的字节码是什么样的？有没有发现非常奇怪 String 变StringBuilder？这是 -c 的用法。</p><p><img src="http://images.gitbook.cn/84ff82a0-52c6-11e8-a8df-c3f787da37d0" alt="enter image description here"></p><p>这是 -v 的用法。此时会发现，我们之前了解的 Class 文件二进制结构都图形化的给我们展示出来了。所以其实作者想表达一点，就是当我们大方向没有错的时候，剩下的就是找细节的方法了。</p><p>我们什么时间需要分析字节码？因为 JVM 随着不断的升级和优化，编译器会帮我们做很多事情，有很多代码是帮我们优化掉的，这个时候我们就要用到 Javap 看一下编译器帮我们干了一些什么，不至于我们去查资料半天看不明白。直接使用+拼接 VS StringBuilder 的问题 一直以来是一个不断争论的问题。所以当我们不清楚的时候就看一下 Javap 的字节码。</p><p>其实 String 字符串的拼接，帮我们转成 StringBuilder 了在某些场景下面。所有某些场景下面是等价的，=+的情况大家可以自己 Javap 一下。</p><hr><p><strong>问：元数据 Metaspace 和.class 的关系？</strong></p><p><strong>答：</strong>首先在j JVM 中.class 的字节码就是元数据，而元数据就是类信息，而类信息就是存储在Metaspace 上的。</p><p><img src="http://images.gitbook.cn/9752d330-52c6-11e8-a8df-c3f787da37d0" alt="enter image description here"></p><p>其实就是图上的这个位置。</p><hr><p><strong>问：利用字节码分析一下 Enum 的原理吗？Enum 和 Class 是什么关系？</strong></p><p><strong>答：</strong>这个时候又得用到我们前面提到的 Javap 了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>example2<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">enum</span> EnumTest <span class="token punctuation">{</span>    ONE<span class="token punctuation">,</span>TWO<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>我们先新建一个 Enum 类。</p><p><img src="http://images.gitbook.cn/a32540d0-52c6-11e8-a8df-c3f787da37d0" alt="enter image description here"></p><p>通过这个我们可以发现如下几件事情：</p><ol><li>有一个 java.lang.Enum 抽象类，我们这个时候其实可以查看其源码发现很多 Enum 的边界用法。</li><li>我们也可以看得出来，Values() 方法和 valueOf(String name)方法是编译器生成的 Static 方法，因此从前面的分析中，在 Enum 类中并没出现 Values() 方法，但 ValueOf() 方法还是有出现的，只不过编译器生成的 ValueOf() 方法需传递一个 Name 参数，而 Enum 自带的静态方法 ValueOf() 则需要传递两个方法，从前面反编译后的代码可以看出，编译器生成的 ValueOf 方法最终还是调用了 Enum 类的 ValueOf 方法。</li><li>所有的 Enum 变量都被解析成了 Static 的 Final 的实例对象，通过 Static{} 进行初始化。</li></ol><p>总结一下：实际上在使用关键字 Enum 创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了 Java API 中的 java.lang.Enum 类，也就是说通过关键字 Enum 创建枚举类型在编译后事实上也是一个类类型而且该类继承自 java.lang.Enum 类。所以我们查看 java.lang.Enum 就可以知道哪些方法可以被覆盖，哪些方法不可以被覆盖。</p><hr><p><strong>问：Final Static 怎么理解？</strong></p><p><strong>答：</strong>其实当我们看过 Enum 的 Javap 之后，其实这个问题也不难理解。Static 是全局的共享一份内存地址变量，放在方法区，不需要对象实例化也可以直接使用。而经过 Final 修饰，就变成了不可更改的全局独立的共享内存地址区域了。</p><p>利：对对象的共享数据进行单独空间的存储，节省空间，没有必要每一格对象中都存储一份。可以直接被类名调用。Static Final 用来修饰成员变量和成员方法，可简单理解为”全局常量”。</p><hr><p><strong>问：可以不可以自己写个 String 类？</strong></p><p><strong>答：</strong>其实遇到这样的问题就是考你双亲委派模型的，双亲委派模型卡卡讲一下，文章里面又提了，不多说了。那么答案是可定不能的。因为根据类加载的双亲委派机制，会去加载父类，父类发现冲突了 String 就不再加载了；但是我们自定 String 进行继承扩展。</p><hr><p><strong>问：怎么样降低 Fullgc 执行次数？</strong></p><p><strong>答：</strong> Fullgc 什么时机触发的这个要搞清楚一下。如果明白这个我们就明白，降低 Fullgc 的唯一办法就是加内存，调整年轻代和和老年代的大小和比例。</p><hr><p><strong>问：用ClassLaod，Tomcat 应用隔离能讲下吗？</strong></p><p><strong>答：</strong>通过此图我们可以发现 Tomcat 有自定义的 Commonloader和 Catalina ClassLoader。而各个 WebApp 加载的时候又有自己独立的 WebAppClassLoad，而不同的 ClassLoader 加载出来的对象是相互隔离的，如果没有向上查找的话。该 ClassLoader 有意违背了委托原则。它首先看 WEB-INF/Classes 中是否有请求的类，而不是委托 Parent ClassLoader去处理，但是 Jre 和 Servlet API 不会被覆盖。所以简单的实现了模块隔离。但是目前我们大多数都是用的 Spring Boot，而 Spring Boot的原理是直接使用 Tomcat Servlet。而没有采用 Tomcat 的 Loader 机制。说以 Spring Boot Start 的时候其实是没有自己的 ClassLoader 的直接用的 Java 里面自带的三个。</p><p><img src="http://images.gitbook.cn/762427e0-5320-11e8-9dec-133e323ed087" alt="enter image description here"></p><p>参考链接： <a href="https://www.cnblogs.com/xdouby/p/5829423.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdouby/p/5829423.html</a><br>          <a href="https://blog.csdn.net/u010126792/article/details/65940064" target="_blank" rel="noopener">https://blog.csdn.net/u010126792/article/details/65940064</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>新一代流式计算引擎 Flink</title>
      <link href="/2019/01/16/%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E-Flink/"/>
      <url>/2019/01/16/%E6%96%B0%E4%B8%80%E4%BB%A3%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97%E5%BC%95%E6%93%8E-Flink/</url>
      
        <content type="html"><![CDATA[<h3 id="初探Flink"><a href="#初探Flink" class="headerlink" title="初探Flink"></a>初探Flink</h3><p>Apache Flink 是为分布式、高性能、随时可用以及准确的流处理应用程序打造的开源流处理框架。”Flink不仅能提供同时支持高吞吐和exactly-once 语义的实时计算，还能提供批量数据处理.</p><h3 id><a href="#" class="headerlink" title></a><a id="more"></a></h3><p><strong>批处理与流处理</strong></p><p>Flink 是如何同时实现批处理与流处理的呢？答案是，Flink 将批处理（即处<br>理有限的静态数据）视作一种特殊的流处理。Flink 的核心计算构造是图1-4 中的Flink Runtime 执行引擎，它是一个分布式系统，能够接受数据流程序并在一台或多台机器上以容错方式执行。Flink Runtime 执行引擎可以作为YARN（Yet Another Resource Negotiator）的应用程序在集群上运行，也可以在Mesos 集群上运行，还可以在单机上运行（这对于调试Flink 应用程序来说非常有用）。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/flink2.png" alt></p><p>Flink 技术栈的核心组成部分。值得一提的是，Flink 分别提供了面向流处理的接口（DataStream API）和面向批处理的接口（DataSet API）。因此，Flink 既可以完成流处理，也可以完成批处理。Flink 支持的拓展库涉及机器学习（FlinkML）、复杂事件处理（CEP），以及图计算（Gelly），还有分别针对流处理和批处理的Table API.</p><p><strong>消息传输层和流处理层</strong></p><ul><li>消息传输层从各种数据源（生产者）采集连续事件产生的数据，并传输给订阅了这些数据的应用程序和服务（消费者）。</li><li>处理层有3 个用途：①持续地将数据在应用程序和系统间移动；②聚合并处理事件；③在本地维持应用程序的状态。</li></ul><p><img src="https://github.com/gaohueric/blogpicture/raw/master/flink3.png" alt></p><p>Flink 项目的架构有两个主要组成部分：消息传输层和由Flink 提供的流处理层。消息传输层负责传输连续事件产生的消息，能够提供消息传输的系统包括Kafka 和MapR Streams。MapR Streams 是MapR 融合数据平台的一个主要组成部分，它兼容Kafka API.</p><h4 id="Flink中的时间概念"><a href="#Flink中的时间概念" class="headerlink" title="Flink中的时间概念"></a>Flink中的时间概念</h4><p>在流处理中，主要有两个时间概念<br>• 事件时间，即事件实际发生的时间。更准确地说，每一个事件都有一个与它相关的时间戳，并且时间戳是数据记录的一部分（比如手机或者服务器的记录）。事件时间其实就是时间戳。<br>• 处理时间，即事件被处理的时间。处理时间其实就是处理事件的机器所测量的时间。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/flink5.png" alt></p><p>以《星球大战》系列电影为例。首先上映的3 部电影是该系列中的第4、5、6 部（这是事件时间），它们的上映年份分别是1977 年、1980 年和1983 年（这是处理时间）。之后按事件时间上映的第1、2、3、7 部，对应的处理时间分别是1999 年、2002 年、2005 年和2015 年。由此可见，事件流的顺序可能是乱的（尽管年份顺序一般不会乱）。</p><p>通常还有第3 个时间概念，即摄取时间，也叫作进入时间。它指的是事件进入流处理框架的时间。缺乏真实事件时间的数据会被流处理器附上时间戳，即流处理器第一次看到它的时间（这个操作由source 函数完成，它是程序的第一个处理节点）。</p><h4 id="Flink中的窗口机制"><a href="#Flink中的窗口机制" class="headerlink" title="Flink中的窗口机制"></a>Flink中的窗口机制</h4><p>窗口是一种机制，它用于将许多事件按照时间或者其他特征分组，从而将每一组作为整体进行分析（比如求和）。</p><h5 id="时间窗口"><a href="#时间窗口" class="headerlink" title="时间窗口"></a><strong>时间窗口</strong></h5><p>是最简单和最有用的一种窗口。它支持滚动和滑动。举一个例子，假设要对传感器输出的数值求和。</p><p>一分钟滚动窗口收集最近一分钟的数值，并在一分钟结束时输出总和</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/flink6.png" alt></p><p>一分钟滑动窗口计算最近一分钟的数值总和，但每半分钟滑动一次并输出结果</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/flink7.png" alt></p><p>第一个滑动窗口对9、6、8 和4 求和，得到27。半分钟后，窗口滑动，然后对8、4、7 和3 求和，得到22，照此类推。</p><p>在Flink 中，一分钟滚动窗口的定义如下。</p><pre class=" language-java"><code class="language-java">stream<span class="token punctuation">.</span><span class="token function">timeWindow</span><span class="token punctuation">(</span>Time<span class="token punctuation">.</span><span class="token function">minutes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>每半分钟（即30 秒）滑动一次的一分钟滑动窗口如下所示</p><pre class=" language-java"><code class="language-java">stream<span class="token punctuation">.</span><span class="token function">timeWindow</span><span class="token punctuation">(</span>Time<span class="token punctuation">.</span><span class="token function">minutes</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Time<span class="token punctuation">.</span><span class="token function">seconds</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token number">4.4</span><span class="token punctuation">.</span><span class="token number">2</span></code></pre><h5 id="计数窗口"><a href="#计数窗口" class="headerlink" title="计数窗口"></a>计数窗口</h5><p>Flink 支持的另一种常见窗口叫作计数窗口。采用计数窗口时，分组依据不再是时间戳，而是元素的数量。例如，图4-6 中的滑动窗口也可以解释为由4 个元素组成的计数窗口，并且每两个元素滑动一次。滚动和滑动的计数窗口分别定义如下。</p><pre class=" language-java"><code class="language-java">stream<span class="token punctuation">.</span><span class="token function">countWindow</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>stream<span class="token punctuation">.</span><span class="token function">countWindow</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span></code></pre><p>虽然计数窗口有用，但是其定义不如时间窗口严谨，因此要谨慎使用。时间不会停止，而且时间窗口总会“关闭”。但就计数窗口而言，假设其定义的元素数量为100，而某个key 对应的元素永远达不到100 个，那么窗口就永远不会关闭，被该窗口占用的内存也就浪费了。一种解决办法是用时间窗口来触发超时.</p><h5 id="会话窗口"><a href="#会话窗口" class="headerlink" title="会话窗口"></a>会话窗口</h5><p>Flink 支持的另一种很有用的窗口是会话窗口。第3 章提到过这个概念。会话指的是活动阶段，其前后都是非活动阶段，例如用户与网站进行一系列交互（活动阶段）之后，关闭浏览器或者不再交互（非活动阶段）。会话需要有自己的处理机制，因为它们通常没有固定的持续时间（有些30 秒就结束了，有些则长达一小时），或者没有固定的交互次数（有些可能是3 次点<br>击后购买，另一些可能是40 次点击却没有购买）。</p><h4 id="Flink中的水印机制"><a href="#Flink中的水印机制" class="headerlink" title="Flink中的水印机制"></a>Flink中的水印机制</h4><p>支持事件时间对于流处理架构而言至关重要，因为事件时间能保证结果正确，并使流处理架构拥有重新处理数据的能力。当计算基于事件时间时，如何判断所有事件是否都到达，以及何时计算和输出窗口的结果呢？换言之，如何追踪事件时间，并知晓输入数据已经流到某个事件时间了呢？为了追踪事件时间，需要依靠由数据驱动的时钟，而不是系统时钟。以图4-5 中的一分钟滚动窗口为例。假设第一个窗口从10:00:00 开始（即从10 时0 分0 秒开始），需要计算从10:00:00 到10:01:00 的数值总和。当时间就是记录的一部分时，我们怎么知道10:01:00 已到呢？换句话说，我们怎么知道盖有时间戳10:00:59 的元素还没到呢？</p><p>Flink 通过水印来推进事件时间。水印是嵌在流中的常规记录，计算程序通过水印获知某个时间点已到。对于上述一分钟滚动窗口，假设水印标记时间为10:01:00（或者其他时间，如10:03:43），那么收到水印的窗口就知道不会再有早于该时间的记录出现，因为所有时间戳小于或等于该时间的事件都已经到达。这时，窗口可以安全地计算并给出结果（总和）。水印使事件时间与处理时间完全无关。迟到的水印（“迟到”是从处理时间的角度而言）并不会影响结果的正确性，而只会影响收到结果的速度。</p><h5 id="水印是如何生成的"><a href="#水印是如何生成的" class="headerlink" title="水印是如何生成的"></a>水印是如何生成的</h5><p>在Flink 中，水印由应用程序开发人员生成，这通常需要对相应的领域有一定的了解。完美的水印永远不会错：时间戳小于水印标记时间的事件不会再出现。在特殊情况下（例如非乱序事件流），最近一次事件的时间戳就可能是完美的水印。启发式水印则相反，它只估计时间，因此有可能出错，即迟到的事件（其时间戳小于水印标记时间）晚于水印出现。针对启发式<br>水印，Flink 提供了处理迟到元素的机制。设定水印通常需要用到领域知识。举例来说，如果知道事件的迟到时间不会超过5 秒，就可以将水印标记时间设为收到的最大时间戳减去5 秒。另<br>一种做法是，采用一个Flink 作业监控事件流，学习事件的迟到规律，并以此构建水印生成模型。</p><p>如果水印迟到得太久，收到结果的速度可能就会很慢，解决办法是在水印到达之前输出近似结果（Flink 可以实现）。如果水印到达得太早，则可能收到错误结果，不过Flink 处理迟到数据的机制可以解决这个问题。上述问题看起来很复杂，但是恰恰符合现实世界的规律——大部分真实的事件流都是乱序的，并且通常无法了解它们的乱序程度（因为理论上不能预见未来）。水印是唯一让我们直面乱序事件流并保证正确性的机制；否则只能选择忽视事实，假装错误的结果是正确的。</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> Flink </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HashMap完全解读</title>
      <link href="/2019/01/10/HashMap%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/01/10/HashMap%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<!-- toc --><h4 id="HashMap解读"><a href="#HashMap解读" class="headerlink" title="HashMap解读"></a>HashMap解读</h4><h5 id="概念：-什么是HashMap"><a href="#概念：-什么是HashMap" class="headerlink" title="概念： 什么是HashMap"></a>概念： 什么是HashMap</h5><blockquote><p>基于哈希表的Map接口实现.此实现提供所有可选的映射操作,并允许使用null值和null键.除了非同步和允许使用null外,HashMap 类与HashTable 大致相同,此类不保证映射的顺序,特别是它不保证该顺序亘久不变,此实现假定哈希函数将元素适当地分布在各桶之间,可为基本操作（get 和 put）提供稳定的性能.迭代 collection 视图所需的时间与 HashMap 实例的“容量”（桶的数量）及其大小（键-值映射关系数）成比例.所以,如果迭代性能很重要,则不要将初始容量设置得太高（或将加载因子设置得太低）.</p></blockquote><a id="more"></a><h5 id="HashMap和HashTable的区别"><a href="#HashMap和HashTable的区别" class="headerlink" title="HashMap和HashTable的区别"></a>HashMap和HashTable的区别</h5><blockquote><ul><li><strong>HashTable的方法是同步的</strong>，在方法的前面都有synchronized来同步，<strong>HashMap未经同步</strong>，所以在多线程场合要手动同步</li><li><strong>HashTable不允许null值</strong>(key和value都不可以) ,<strong>HashMap允许null值</strong>(key和value都可以)。</li><li>HashTable有一个contains(Object value)功能和containsValue(Object value)功能一样。</li><li>HashTable使用Enumeration进行遍历，HashMap使用Iterator进行遍历。</li><li>HashTable中hash数组默认大小是11，增加的方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数。</li><li>哈希值的使用不同，HashTable直接使用对象的hashCode，代码是这样的：</li></ul></blockquote><pre class=" language-java"><code class="language-java"><span class="token keyword">int</span> hash <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span>hash <span class="token operator">&amp;</span> <span class="token number">0x7FFFFFFF</span><span class="token punctuation">)</span> <span class="token operator">%</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">;</span></code></pre><p>而 HashMap 重新计算hash值，而且用与代替求模</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> h<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h5 id="HashMap-和HashSet-的关系"><a href="#HashMap-和HashSet-的关系" class="headerlink" title="HashMap 和HashSet 的关系"></a>HashMap 和HashSet 的关系</h5><blockquote><ul><li><p>HashSet底层采用HashMap实现的</p></li><li><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token function">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><pre><code></code></pre></li><li><p>调用HashSet的add方法时，实际上是向HashMap中增加了一行(key-value对)，该行的key就是向HashSet增加的那个对象，该行的value就是一个Object类型的常量</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Object PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span>E e<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span>null<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token operator">==</span>PRESENT<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre></li></ul></blockquote><h5 id="HashMap-和ConcurrentHashMap的关系"><a href="#HashMap-和ConcurrentHashMap的关系" class="headerlink" title="HashMap 和ConcurrentHashMap的关系"></a>HashMap 和ConcurrentHashMap的关系</h5><blockquote><p><code>ConcurrentHashMap</code> 也是一种线程安全的集合类，他和<code>HashTable</code>也是有区别的，主要区别就是加锁的粒度以及如何加锁，<code>ConcurrentHashMap</code>的加锁粒度要比<code>HashTable</code>更细一点。将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问, 下面篇幅介绍。</p></blockquote><h4 id="HashMap实现原理分析"><a href="#HashMap实现原理分析" class="headerlink" title="HashMap实现原理分析"></a>HashMap实现原理分析</h4><h5 id="底层原理分析"><a href="#底层原理分析" class="headerlink" title="底层原理分析"></a>底层原理分析</h5><blockquote><p>底层实现的一种数据结构——Hash 表</p></blockquote><p>Hash表，是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。存放记录的数组叫做哈希表。</p><p>在HashMap中，就是将所给的“键”通过哈希函数得到“索引”，然后把内容存在数组中，这样就形成了“键”和内容的映射关系。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map6.png" alt></p><p>“键”转为“索引”的过程就是哈希函数，为了尽可能保证每一个“键”通过哈希函数的转换对应不同的“索引”，就需要对哈希函数进行选择了，使其得到的“索引”分布越均匀越好。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map7.png" alt></p><p>通过研究加上实践表明，当把哈希函数得到hashcode值对素数取模时，这样得到的索引是最为均匀的。但是，在HashMap源码中，并不是取模素数的，而是一种等效取模2的n次方的位运算，hash&amp;(length-1)。hash%length==hash&amp;(length-1)的前提是length是2的n次方；之所以使用位运算替代取模，是因为位运算的效率更高，所以也就要求数组的长度必须是2的n次方（索引的分布也是很均匀的）。</p><p>哈希函数的设计：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map8.png" alt></p><p>哈希函数的一致性原则是：当两个对象的equals相等，那么他们的hashcode一定相等。</p><p>这就要求我们在重写了equals方法时，必须重写hashcode方法。如果不重写hashcode，则会使用Object的hashcode方法，该方法是以我们创建的对象的地址作为参数求hash的。所以，如果不重写hashcode，两个equals相等的对象会导致hashcode不同（因为不同的对象），这个是不允许的，因为违背了hash函数的一致性原则。</p><p><strong>哈希冲突：</strong></p><p>当两个不同的元素，通过哈希函数得到了同一个hashcode，则会产生哈希冲突。HashMap的处理方式是，JDK8之前，每一个位置对应一个链表，链式的存放哈希冲突的元素；JDK8开始，当哈希冲突达到一定程度（8个），每一个位置从链表转换成红黑树。因为红黑树的时间复杂度是O(log n)的，效率优于链表。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map9.png" alt></p><p><strong>哈希表小结：</strong></p><p>哈希表，均摊复杂度是O(1)，因为第一步通过数组索引找到数组位置是O(1)，然后到链表中查找元素的均摊复杂度是O(size/length)，size为元素个数，length为数组长度。由于Hash表的容量是动态扩容的，也就是说随着size和length成正比的，即size/length是一个常数，于是也是O(1)的复杂度，即总的来说，均摊复杂度是O(1)。但是哈希表是没有顺序性的，即无法对元素进行排序。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map10.png" alt></p><h5 id="底层数据结构分析"><a href="#底层数据结构分析" class="headerlink" title="底层数据结构分析"></a>底层数据结构分析</h5><blockquote><p>基于JDK1.7分析HashMap</p></blockquote><p>JDk1.8之前HashMap底层是数据和链表结合在一起使用，也就是链表散列。HashMap 通过 key的hashCode经过扰动函数处理过后得到hash值，然后通过(n-1) &amp; hash 判断当前元素存放的位置(n指数组的长度) 如果当前位置存在元素的话，就判断该元素和要插入的元素的hash值已经key是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p><strong>JDK 1.8 HashMap 的 hash 方法源码:</strong></p><p>JDK 1.8 的 hash方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> h<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// key.hashCode()：返回散列值也就是hashcode</span>      <span class="token comment" spellcheck="true">// ^ ：按位异或</span>      <span class="token comment" spellcheck="true">// >>>:无符号右移，忽略符号位，空位都以0补齐</span>      <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span></code></pre><p>对比一下 JDK1.7的 HashMap 的 hash 方法源码.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// This function ensures that hashCodes that differ only by</span>    <span class="token comment" spellcheck="true">// constant multiples at each bit position have a bounded</span>    <span class="token comment" spellcheck="true">// number of collisions (approximately 8 at default load factor).</span>    h <span class="token operator">^=</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> h <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">>>></span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能会稍差一点点，因为毕竟扰动了 4 次。</p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map3.png" alt></p><blockquote><p>基于JDK1.7分析HashMap</p></blockquote><p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/map11.png" alt></p><p>源码解读</p><p>类属性</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractMap</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">,</span> Cloneable<span class="token punctuation">,</span> Serializable <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 序列号</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 362498820763181265L<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 默认的初始容量是16</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 最大容量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 默认的填充因子</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数大于这个值时会转成红黑树</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 当桶(bucket)上的结点数小于这个值时树转链表</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中结构转化为红黑树对应的table的最小大小</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存储元素的数组，总是2的幂次倍</span>    <span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 存放具体元素的集</span>    <span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>map<span class="token punctuation">.</span>entry<span class="token operator">&lt;</span>k<span class="token punctuation">,</span>v<span class="token operator">>></span> entrySet<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 存放元素的个数，注意这个不等于数组的长度。</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 每次扩容和更改map结构的计数器</span>    <span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 临界值 当实际大小(容量*填充因子)超过临界值时，会进行扩容</span>    <span class="token keyword">int</span> threshold<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 填充因子</span>    <span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li><strong>loadFactor加载因子</strong></li></ul><p>loadFactor 加载因子是控制数组存放数据的疏密程度，loadFactor越趋近于1，那么数组中存放的数据(entry) 也就越多，也就越密集，也就是会让链表的长度增加，loadFactor 越小，也就是越趋近于0</p><p>loadFactor 太大导致查找元素效率低，太小导致数组利用率低，存放的数据会很分散。loadFactor的默认值为0.75是官方给出的一个比较好的临近值。</p><ul><li><strong>threshold</strong></li></ul><p>threshold  = capacity * loadFactor,当Size&gt;threshold 的时候，那么就要考虑对数组的扩容了，也就是说，这个是衡量数组是否需要扩容的一个标准。</p><p>Node节点源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>       <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span>       <span class="token keyword">final</span> K key<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//键</span>       V value<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//值</span>       <span class="token comment" spellcheck="true">// 指向下一个节点</span>       Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>       <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span> <span class="token keyword">return</span> key<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">{</span> <span class="token keyword">return</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span> <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写hashCode()方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重写 equals() 方法</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span>o<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>树节点源码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 父</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> left<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 左</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> right<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 右</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>        <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 判断颜色</span>        <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回根节点</span>        <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token keyword">return</span> r<span class="token punctuation">;</span>                r <span class="token operator">=</span> p<span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//默认构造函数</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// all other fields defaulted</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//包含另外一个map</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">;</span>        <span class="token function">putMapEntries</span><span class="token punctuation">(</span>m<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//指定容量大小</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">,</span> DEFAULT_LOAD_FACTOR<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>   <span class="token comment" spellcheck="true">// 指定“容量大小”和“加载因子”的构造函数</span><span class="token keyword">public</span> <span class="token function">HashMap</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">,</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal initial capacity: "</span> <span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> MAXIMUM_CAPACITY<span class="token punctuation">)</span>            initialCapacity <span class="token operator">=</span> MAXIMUM_CAPACITY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>loadFactor <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span> Float<span class="token punctuation">.</span><span class="token function">isNaN</span><span class="token punctuation">(</span>loadFactor<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal load factor: "</span> <span class="token operator">+</span>                                               loadFactor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>loadFactor <span class="token operator">=</span> loadFactor<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//putMapEntries 方法</span>  <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">putMapEntries</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> m<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> s <span class="token operator">=</span> m<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// pre-size</span>                <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>s <span class="token operator">/</span> loadFactor<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1.0F</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> t <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token operator">?</span>                         <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>t <span class="token operator">></span> threshold<span class="token punctuation">)</span>                    threshold <span class="token operator">=</span> <span class="token function">tableSizeFor</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">></span> threshold<span class="token punctuation">)</span>                <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span> e <span class="token operator">:</span> m<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                K key <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                V value <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> evict<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><p>HashMap只提供了put用于添加元素，putVal方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><p>源码:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>                   <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 桶中已经存在元素</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 将第一个元素赋值给e，用e来记录</span>                e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// hash值不相等，即key不相等；为红黑树结点</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 放入树中</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 为链表结点</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在链表最末插入结点</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 结点数量达到阈值，转化为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 相等，跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">//用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 实际大小大于阈值则扩容</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><p><strong>对putVal方法添加元素的分析如下：</strong></p><p>HashMap 只提供了put用于添加元素，putVal 方法只是给put方法调用的一个方法，并没有提供给用户使用。</p><ul><li>如果定位的数组位置没有元素，则直接插入。</li><li>如果定位到的数组位置有元素就要和要插入的key比较，如果key相同就直接覆盖，如果key不相同，就判断p是否是一个树节点，如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加,如果不是就遍历链表插入。</li></ul><p><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/map1.png" alt></p><p>对比JDK1.7 put方法源码</p><p>分析源码</p><ul><li>如果定位到的数组位置没有元素就直接插入</li><li>如果定位到的数组位置有元素，遍历以这个元素为头节点的链表，依次和插入的key比较，如果key相同就直接覆盖，不同就采用头插入法插入元素。</li></ul><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>table <span class="token operator">==</span> EMPTY_TABLE<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">inflateTable</span><span class="token punctuation">(</span>threshold<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 先遍历</span>        Object k<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 再插入</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">;</span> K k<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>        <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 数组元素相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>            <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 桶中不止一个节点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 在树中get</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在链表中get</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h5><p>进行扩容，会伴随着一次重新hash分配，并且会遍历hash表中所有的元素，是非常耗时的。在编写程序中，要尽量避免resize。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 没超过最大值，就扩充为原来的2倍</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>         signifies using defaults        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 计算新的resize上限</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span><span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 把每个bucket都移动到新的buckets中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span>                     Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 原索引</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token comment" spellcheck="true">// 原索引+oldCap</span>                        <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 原索引放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 原索引+oldCap放到bucket里</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h4><h5 id="Java7-ConcurrentHashMap"><a href="#Java7-ConcurrentHashMap" class="headerlink" title="Java7 ConcurrentHashMap"></a><strong>Java7 ConcurrentHashMap</strong></h5>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多线程特性解读</title>
      <link href="/2019/01/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/"/>
      <url>/2019/01/07/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%89%B9%E6%80%A7%E8%A7%A3%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>java的原子性就和数据库事物的原子性差不多,线程的一个或者多个操作要么全部执行,而且执行过程不会被打断,要么全部都不执行.</p></blockquote><a id="more"></a><p>JMM只是保证了基本的原子性，但类似i++ 之类的操作，看似是原子操作，其实里面涉及到</p><ul><li>获取i的值</li><li>自增</li><li>再赋值给i</li></ul><p>这三步操作，所以想要实现i++ 这样的原子操作就需要用到synchronize 或者lock进行加锁处理</p><p>example ： </p><pre><code>i = 0;       //1j = i ;      //2i++;         //3i = j + 1;   //4</code></pre><p>什么四个操作，哪些是原子性操作，哪些不是。</p><pre><code>1在Java中，对基本数据类型的变量和赋值操作都是原子性操作； 2中包含了两个操作：读取i，将i值赋值给j 3中包含了三个操作：读取i值、i + 1 、将+1结果赋值给i； 4中同三一样</code></pre><p>在单线程环境下我们可以认为整个步骤都是原子性操作，但是在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的</p><p>要想在多线程环境下保证原子性，则可以通过锁、synchronized来确保。volatile是无法保证复合操作的原子性。</p><p>所谓原子性操作是指当执行一系列操作时候，这些操作那么全部被执行，那么全部不被执行，不存在只执行其中一部分的情况。</p><p>在设计计数器时候一般都是先读取当前值，然后+1，然后更新，这个过程是读 -&gt; 改 -&gt; 写的过程，如果不能保证这个过程是原子性，那么就会出现线程安全问题。如下代码是线程不安全的，因为不能保证 <code>++value</code> 是原子性操作。</p><pre><code>    public class ThreadNotSafeCount {        private  Long value;        public Long getCount() {            return value;        }        public void inc() {            ++value;        }    }</code></pre><p>通过使用 <code>Javap -c</code> 查看汇编代码如下：</p><pre><code> public void inc();    Code:       0: aload_0              1: dup                  2: getfield      #2                  // Field value:J       5: lconst_1             6: ladd                 7: putfield      #2                  // Field value:J      10: return        </code></pre><p>可知简单的 <code>++value</code>有 2，5，6，7 组成，其中2是获取当前 value 的值并放入栈顶，5是把常量1放入栈顶，6是把当前栈顶中2个值相加并把结果放入栈顶，7则是把栈顶结果赋值会 value 变量，可知 Java 中简单的一句 ++value 转换为汇编后就不具有原子性了。</p><p>那么如何才能保证多个操作完成原子性呢，最简单的是使用 Synchronized 进行同步，修改代码如下：</p><pre><code>    public class ThreadSafeCount {        private  Long value;        public synchronized Long getCount() {            return value;        }        public synchronized void inc() {            ++value;        }    }</code></pre><p>使用 Synchronized 的确可以实现线程安全，即实现内存可见性和同步，但是 Synchronized 是独占锁，同时只有一个线程可以调用 getCount 方法，其他没有获取内部锁的线程会被阻塞掉；而这里 getCount 方法只是读操作，多个线程同时调用不会存在线程安全问题，但是加了关键字 Synchronized 后同时就只能有一个线程可以调用了，这显然大大降低了并发性。</p><p>也许你会问既然是只读操作那么为何不去掉 getCount 方法上的 Synchronized 关键字呢？其实是不能去掉的，别忘了这里要靠 Synchronized 的内存语义来实现 value 的内存可见性。</p><p>那么有没有更好的实现呢？答案是肯定的，下面会讲到的内部使用非阻塞 CAS 算法实现的原子性操作类 AtomicLong 就是不错选择。</p><p>如果是基础类的自增操作可以使用AtomicInteger 这样的原子类来实现(其本质是利用了CPU级别的CAS指令来完成的)</p><p>其中用的最多的方法就是 incrementAndGet() 以原子的方式自增</p><pre><code>  public final int incrementAndGet() {        return unsafe.getAndAddInt(this, valueOffset, 1) + 1;    }</code></pre><pre><code>    public final int getAndAddInt(Object var1, long var2, int var4) {        int var5;        do {            var5 = this.getIntVolatile(var1, var2);        } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));        return var5;    }</code></pre><p>通过源码分析可知，incrementAndGet（）和 getAndIncrement （）都调用了 Unsafe 类中的 getAndAddInt（） 方法，区别是：</p><p>① 前者，先+1，再返回</p><p>② 后者，先返回，再 +1</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>现代计算机中，由于 <code>CPU</code> 直接从主内存中读取数据的效率不高，所以都会对应的 <code>CPU</code> 高速缓存，先将主内存中的数据读取到缓存中，线程修改数据之后首先更新到缓存，之后才会更新到主内存。如果此时还没有将数据更新到主内存其他的线程此时来读取就是修改之前的数据。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/006tKfTcly1fmouu3fpokj31ae0osjt1.jpg" alt></p><p><code>volatile</code> 关键字就是用于保证内存可见性，当线程A更新了 volatile 修饰的变量时，它会立即刷新到主线程，并且将其余缓存中该变量的值清空，导致其余线程只能去主内存读取最新值。</p><p>使用 <code>volatile</code> 关键词修饰的变量每次读取都会得到最新的数据，不管哪个线程对这个变量的修改都会立即刷新到主内存。</p><p><code>synchronized</code>和加锁也能能保证可见性，实现原理就是在释放锁之前其余线程是访问不到这个共享变量的。但是和 <code>volatile</code> 相比开销较大。</p><p>volatile保证可见性</p><p>上面介绍了使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太重，因为它会引起线程上下文的切换开销，对于解决内存可见性问题，Java 还提供了一种弱形式的同步，也就是使用了 volatile 关键字。</p><p>一旦一个变量被 volatile 修饰了，当线程获取这个变量值的时候会首先清空线程工作内存中该变量的值，然后从主内存获取该变量的值；当线程写入被 volatile 修饰的变量的值的时候，首先会把修改后的值写入工作内存，然后会刷新到主内存。这就保证了对一个变量的更新对其它线程马上可见。</p><p>下面看一个使用 volatile 关键字解决内存不可见性的一个例子，如下代码的共享变量 value 是线程不安全的，因为它没有进行适当同步措施。</p><pre><code>    public class ThreadNotSafeInteger {        private int value;        public int get() {            return value;        }        public void set(int value) {            this.value = value;        }    }</code></pre><p>首先看下使用 synchronized 关键字进行同步方式如下：</p><pre><code>    public class ThreadSafeInteger {        private int value;        public synchronized int get() {            return value;        }        public synchronized  void set(int value) {            this.value = value;        }    }</code></pre><p>然后看下使用 volatile 进行同步如下：</p><pre><code>    public class ThreadSafeInteger {        private volatile int value;        public int get() {            return value;        }        public void set(int value) {            this.value = value;        }    }</code></pre><p>这里使用 synchronized 和使用 volatile 是等价的，都解决了共享变量 value 的内存不可见性问题；但是前者是独占锁，同时只能有一个线程调用 get() 方法，其它调用线程会被阻塞；并且会存在线程上下文切换和线程重新调度的开销；而后者是非阻塞算法，不会造成线程上下文切换的开销。</p><p>这里使用 synchronized 和使用 volatile 是等价的，但是并不是所有情况下都是等价的，这是因为 volatile 虽然提供了可见性保证，但是并没有保证操作的原子性。</p><p>那么一般什么时候才使用 volatile 关键字修饰变量呢？</p><ul><li>当写入变量值时候不依赖变量的当前值。因为如果依赖当前值则是获取 -&gt; 计算 -&gt; 写入操作，而这三步操作不是原子性的，而 volatile 不保证原子性。</li><li>读写变量值时候没有进行加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为 volatile。</li></ul><p>另外变量被声明为 volatile 还可以避免重排序的发生，这个后面会讲到。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>以下这段代码:</p><pre><code>int a = 100 ; //1int b = 200 ; //2int c = a + b ; //3</code></pre><p>正常情况下的执行顺序应该是 <code>1&gt;&gt;2&gt;&gt;3</code>。但是有时 <code>JVM</code> 为了提高整体的效率会进行指令重排导致执行的顺序可能是 <code>2&gt;&gt;1&gt;&gt;3</code>。但是 <code>JVM</code> 也不能是什么都进行重排，是在保证最终结果和代码顺序执行结果一致的情况下才可能进行重排。</p><p>重排在单线程中不会出现问题，但在多线程中会出现数据不一致的问题。</p><p>Java 中可以使用 <code>volatile</code> 来保证顺序性，<code>synchronized 和 lock</code> 也可以来保证有序性，和保证原子性的方式一样，通过同一段时间只能一个线程访问来实现的。</p><p>除了通过 <code>volatile</code> 关键字显式的保证顺序之外， <code>JVM</code> 还通过 <code>happen-before</code> 原则来隐式的保证顺序性。</p><p>其中有一条就是适用于 <code>volatile</code> 关键字的，针对于 <code>volatile</code> 关键字的写操作肯定是在读操作之前，也就是说读取的值肯定是最新的。</p><h3 id="扩展：-深入理解Volatile关键字"><a href="#扩展：-深入理解Volatile关键字" class="headerlink" title="扩展： 深入理解Volatile关键字"></a>扩展： 深入理解Volatile关键字</h3><p>上面介绍了使用锁的方式可以解决共享变量内存可见性问题，但是使用锁太重，因为它会引起线程上下文的切换开销，对于解决内存可见性问题，Java 还提供了一种弱形式的同步，也就是使用了 volatile 关键字。</p><p>一旦一个变量被 volatile 修饰了，当线程获取这个变量值的时候会首先清空线程工作内存中该变量的值，然后从主内存获取该变量的值；当线程写入被 volatile 修饰的变量的值的时候，首先会把修改后的值写入工作内存，然后会刷新到主内存。这就保证了对一个变量的更新对其它线程马上可见。</p><p>下面看一个使用 volatile 关键字解决内存不可见性的一个例子，如下代码的共享变量 value 是线程不安全的，因为它没有进行适当同步措施。</p><pre><code>    public class ThreadNotSafeInteger {        private int value;        public int get() {            return value;        }        public void set(int value) {            this.value = value;        }    }</code></pre><p>首先看下使用 synchronized 关键字进行同步方式如下：</p><pre><code>    public class ThreadSafeInteger {        private int value;        public synchronized int get() {            return value;        }        public synchronized  void set(int value) {            this.value = value;        }    }</code></pre><p>然后看下使用 volatile 进行同步如下：</p><pre><code>    public class ThreadSafeInteger {        private volatile int value;        public int get() {            return value;        }        public void set(int value) {            this.value = value;        }    }</code></pre><p>这里使用 synchronized 和使用 volatile 是等价的，都解决了共享变量 value 的内存不可见性问题；但是前者是独占锁，同时只能有一个线程调用 get() 方法，其它调用线程会被阻塞；并且会存在线程上下文切换和线程重新调度的开销；而后者是非阻塞算法，不会造成线程上下文切换的开销。</p><p>这里使用 synchronized 和使用 volatile 是等价的，但是并不是所有情况下都是等价的，这是因为 volatile 虽然提供了可见性保证，但是并没有保证操作的原子性。</p><p>那么一般什么时候才使用 volatile 关键字修饰变量呢？</p><ul><li>当写入变量值时候不依赖变量的当前值。因为如果依赖当前值则是获取 -&gt; 计算 -&gt; 写入操作，而这三步操作不是原子性的，而 volatile 不保证原子性。</li><li>读写变量值时候没有进行加锁。因为加锁本身已经保证了内存可见性，这时候不需要把变量声明为 volatile。</li></ul><p>另外变量被声明为 volatile 还可以避免重排序的发生，这个后面会讲到。</p><p>volatile通常被比喻成轻量级的synchronized ,也是Java并发编程中比较重要的一个关键字。和<code>synchronized</code>不同，<code>volatile</code>是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><h4 id="volatile-的应用"><a href="#volatile-的应用" class="headerlink" title="volatile 的应用"></a>volatile 的应用</h4><h5 id="双重检查锁的单例模式"><a href="#双重检查锁的单例模式" class="headerlink" title="双重检查锁的单例模式"></a>双重检查锁的单例模式</h5><p>可以用 <code>volatile</code> 实现一个双重检查锁的单例模式：</p><pre><code>    public class Singleton {        private static volatile Singleton singleton;        private Singleton() {        }        public static Singleton getInstance() {            if (singleton == null) {                synchronized (Singleton.class) {                    if (singleton == null) {                        singleton = new Singleton();                    }                }            }            return singleton;        }    }</code></pre><p>这里的 <code>volatile</code> 关键字主要是为了防止指令重排。 如果不用 <code>volatile</code> ，<code>singleton = new Singleton();</code>，这段代码其实是分为三步：</p><ul><li>分配内存空间。(1)</li><li>初始化对象。(2)</li><li>将 <code>singleton</code> 对象指向分配的内存地址。(3)</li></ul><p>加上 <code>volatile</code> 是为了让以上的三步操作顺序执行，反之有可能第三步在第二步之前被执行就有可能导致某个线程拿到的单例对象还没有初始化，以致于使用报错。</p><h5 id="控制停止线程的标记"><a href="#控制停止线程的标记" class="headerlink" title="控制停止线程的标记"></a>控制停止线程的标记</h5><pre><code>    private volatile boolean flag ;    private void run(){        new Thread(new Runnable() {            @Override            public void run() {                while (flag) {                    doSomeThing();                }            }        });    }    private void stop(){        flag = false ;    }</code></pre><p>这里如果没有用 volatile 来修饰 flag ，就有可能其中一个线程调用了 <code>stop()</code>方法修改了 flag 的值并不会立即刷新到主内存中，导致这个循环并不会立即停止。</p><p>这里主要利用的是 <code>volatile</code> 的内存可见性。</p><p>总结一下:</p><ul><li><h5 id="volatile-关键字只能保证可见性，顺序性-禁止指令重排序-，不能保证原子性。"><a href="#volatile-关键字只能保证可见性，顺序性-禁止指令重排序-，不能保证原子性。" class="headerlink" title="volatile 关键字只能保证可见性，顺序性(禁止指令重排序)，不能保证原子性。"></a><code>volatile</code> 关键字只能保证可见性，顺序性(禁止指令重排序)，<strong>不能保证原子性</strong>。</h5></li></ul><hr><p>在以下两个场景中可以使用<code>volatile</code>来代替<code>synchronized</code>：</p><blockquote><p>1、运算结果并不依赖变量的当前值，或者能够确保只有单一的线程会修改变量的值。</p><p>2、变量不需要与其他状态变量共同参与不变约束。</p></blockquote><p>除以上场景外，都需要使用其他方式来保证原子性，如<code>synchronized</code>或者<code>concurrent包</code>。</p><p>我们来看一下volatile和原子性的例子：</p><pre><code>public class Test {    public volatile int inc = 0;    public void increase() {        inc++;    }    public static void main(String[] args) {        final Test test = new Test();        for(int i=0;i&lt;10;i++){            new Thread(){                public void run() {                    for(int j=0;j&lt;1000;j++)                        test.increase();                };            }.start();        }        while(Thread.activeCount()&gt;1)  //保证前面的线程都执行完            Thread.yield();        System.out.println(test.inc);    }}</code></pre><p>以上代码比较简单，就是创建10个线程，然后分别执行1000次<code>i++</code>操作。正常情况下，程序的输出结果应该是10000，但是，多次执行的结果都小于10000。这其实就是<code>volatile</code>无法满足原子性的原因。</p><p>为什么会出现这种情况呢，那就是因为虽然volatile可以保证<code>inc</code>在多个线程之间的可见性。但是无法<code>inc++</code>的原子性。</p><h5 id="volatile-原理解析"><a href="#volatile-原理解析" class="headerlink" title="volatile 原理解析"></a>volatile 原理解析</h5><p>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p><p>但是，对于<code>volatile</code>变量，当对<code>volatile</code>变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<code>缓存一致性协议</code></p><p><strong>缓存一致性协议</strong>：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被<code>volatile</code>所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个<code>volatile</code>在并发编程中，其值在多个缓存中是可见的。</p><h3 id="总结与思考"><a href="#总结与思考" class="headerlink" title="总结与思考"></a>总结与思考</h3><p>我们介绍过了<code>volatile</code>关键字和<code>synchronized</code>关键字。现在我们知道，<code>synchronized</code>可以保证原子性、有序性和可见性。而<code>volatile</code>却只能保证有序性和可见性。</p><p>思考题： 双重校验锁实现的单例，已经使用了<code>synchronized</code>，为什么还需要<code>volatile</code>？</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Synchronized深度解析</title>
      <link href="/2019/01/06/Synchronized%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/"/>
      <url>/2019/01/06/Synchronized%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p><img src="http://pkwj22qv0.bkt.clouddn.com/006tNbRwgy1fvyf0zkwadj31g80teqh0.jpg" alt></p><h3 id="Synchronized-的两种用法"><a href="#Synchronized-的两种用法" class="headerlink" title="Synchronized 的两种用法"></a>Synchronized 的两种用法</h3><ol><li>对象锁 (包括方法锁，默认锁对象为this当前实例对象)和同步代码块锁(自己指定锁对象)</li><li>类锁(指synchronizd修饰静态的方法或指定锁为Class对象)<a id="more"></a></li></ol><h4 id="第一种用法：-对象锁"><a href="#第一种用法：-对象锁" class="headerlink" title="第一种用法： 对象锁"></a>第一种用法： 对象锁</h4><p>代码块形式：手动指定锁对象</p><p>方法锁形式： synchronized 修饰普通方法，锁对象默认为this.</p><pre><code>public class SynchronizedObjectCodeBlock implements Runnable {    static SynchronizedObjectCodeBlock instance = new SynchronizedObjectCodeBlock();    Object lock = new Object(); //手动指定对象    Object lock2 = new Object();    public static void main(String[] args) {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }    @Override    public void run() {        synchronized (lock) {            System.out.println(&quot;我是对象锁的代码块形式，我叫&quot; + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;运行结束&quot;);        }        synchronized (lock2) {            System.out.println(&quot;我是对象锁的代码块形式，我叫&quot; + Thread.currentThread().getName());            try {                Thread.sleep(3000);            } catch (InterruptedException e) {                e.printStackTrace();            }            System.out.println(Thread.currentThread().getName() + &quot;运行结束&quot;);        }    }}</code></pre><p>普通方法锁</p><pre><code>public class SynchronizedObjectMethod implements Runnable {    static SynchronizedObjectMethod instance = new SynchronizedObjectMethod();    public static void main(String[] args) {        Thread t1 = new Thread(instance);        Thread t2 = new Thread(instance);        t1.start();        t2.start();        while (t1.isAlive() || t2.isAlive()) {        }        System.out.println(&quot;finished&quot;);    }    @Override    public void run() {        method();    }    public synchronized void method() {        System.out.println(&quot;我的对象锁的方法修饰符形式，我叫&quot; + Thread.currentThread().getName());        try {            Thread.sleep(3000);        } catch (InterruptedException e) {            e.printStackTrace();        }        System.out.println(Thread.currentThread().getName() + &quot;finish&quot;);    }}</code></pre><h4 id="第二种用法：-类锁"><a href="#第二种用法：-类锁" class="headerlink" title="第二种用法： 类锁"></a>第二种用法： 类锁</h4><p>概念(重要)： Java类可能有很多个对象，但只有一个Class对象</p><p>形式2： synchronized (*.class) 代码块</p><p>本质： 所以所谓的类锁，不过是Class对象的锁而已。</p><p>用法和效果： 类锁只能在 同一时刻被一个对象拥有。</p><p>形式1： synchronized 加在 static方法上</p><h3 id="synchronized-关键字原理"><a href="#synchronized-关键字原理" class="headerlink" title="synchronized 关键字原理"></a>synchronized 关键字原理</h3><p>众所周知 <code>synchronized</code> 关键字是解决并发问题常用解决方案，有以下三种使用方式:</p><ul><li>同步普通方法，锁的是当前对象。</li><li>同步静态方法，锁的是当前 <code>Class</code> 对象。</li><li>同步块，锁的是 <code>()</code> 中的对象。</li></ul><p>实现原理： <code>JVM</code> 是通过进入、退出对象监视器( <code>Monitor</code> )来实现对方法、同步块的同步的。</p><p>具体实现是在编译之后在同步方法调用前加入一个 <code>monitor.enter</code> 指令，在退出方法和异常处插入 <code>monitor.exit</code> 的指令。</p><p>其本质就是对一个对象监视器( <code>Monitor</code> )进行获取，而这个获取过程具有排他性从而达到了同一时刻只能一个线程访问的目的。</p><p>而对于没有获取到锁的线程将会阻塞到方法入口处，直到获取锁的线程 <code>monitor.exit</code> 之后才能尝试继续获取锁。</p><p>流程图如下:</p><p><img src="https://ws2.sinaimg.cn/large/006tNc79ly1fn27fkl07jj31e80hyn0n.jpg" alt="img"></p><p>通过一段代码来演示:</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Synchronize<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Synchronize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>使用 <code>javap -c Synchronize</code> 可以查看编译之后的具体信息。</p><pre><code>public class com.crossoverjie.synchronize.Synchronize {  public com.crossoverjie.synchronize.Synchronize();    Code:       0: aload_0       1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V       4: return  public static void main(java.lang.String[]);    Code:       0: ldc           #2                  // class com/crossoverjie/synchronize/Synchronize       2: dup       3: astore_1       **4: monitorenter**       5: getstatic     #3                  // Field java/lang/System.out:Ljava/io/PrintStream;       8: ldc           #4                  // String Synchronize      10: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/String;)V      13: aload_1      **14: monitorexit**      15: goto          23      18: astore_2      19: aload_1      20: monitorexit      21: aload_2      22: athrow      23: return    Exception table:       from    to  target type           5    15    18   any          18    21    18   any}</code></pre><p>可以看到在同步块的入口和出口分别有 <code>monitorenter,monitorexit</code> 指令。</p><h4 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h4><p><code>synchronized</code> 很多都称之为重量锁，<code>JDK1.6</code> 中对 <code>synchronized</code> 进行了各种优化，为了能减少获取和释放锁带来的消耗引入了<code>偏向锁</code>和<code>轻量锁</code>。</p><h4 id="轻量锁"><a href="#轻量锁" class="headerlink" title="轻量锁"></a>轻量锁</h4><p>当代码进入同步块时，如果同步对象为无锁状态时，当前线程会在栈帧中创建一个锁记录(<code>Lock Record</code>)区域，同时将锁对象的对象头中 <code>Mark Word</code> 拷贝到锁记录中，再尝试使用 <code>CAS</code> 将 <code>Mark Word</code> 更新为指向锁记录的指针。</p><p>如果更新<strong>成功</strong>，当前线程就获得了锁。</p><p>如果更新<strong>失败</strong> <code>JVM</code> 会先检查锁对象的 <code>Mark Word</code> 是否指向当前线程的锁记录。</p><p>如果是则说明当前线程拥有锁对象的锁，可以直接进入同步块。</p><p>不是则说明有其他线程抢占了锁，如果存在多个线程同时竞争一把锁，<strong>轻量锁就会膨胀为重量锁</strong>。</p><h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>轻量锁的解锁过程也是利用 <code>CAS</code> 来实现的，会尝试锁记录替换回锁对象的 <code>Mark Word</code> 。如果替换成功则说明整个同步操作完成，失败则说明有其他线程尝试获取锁，这时就会唤醒被挂起的线程(此时已经膨胀为<code>重量锁</code>)</p><p>轻量锁能提升性能的原因是：</p><p>认为大多数锁在整个同步周期都不存在竞争，所以使用 <code>CAS</code> 比使用互斥开销更少。但如果锁竞争激烈，轻量锁就不但有互斥的开销，还有 <code>CAS</code> 的开销，甚至比重量锁更慢。</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>为了进一步的降低获取锁的代价，<code>JDK1.6</code> 之后还引入了偏向锁。</p><p>偏向锁的特征是:锁不存在多线程竞争，并且应由一个线程多次获得锁。</p><p>当线程访问同步块时，会使用 <code>CAS</code> 将线程 ID 更新到锁对象的 <code>Mark Word</code> 中，如果更新成功则获得偏向锁，并且之后每次进入这个对象锁相关的同步块时都不需要再次获取锁了。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><p>当有另外一个线程获取这个锁时，持有偏向锁的线程就会释放锁，释放时会等待全局安全点(这一时刻没有字节码运行)，接着会暂停拥有偏向锁的线程，根据锁对象目前是否被锁来判定将对象头中的 <code>Mark Word</code> 设置为无锁或者是轻量锁状态。</p><p>偏向锁可以提高带有同步却没有竞争的程序性能，但如果程序中大多数锁都存在竞争时，那偏向锁就起不到太大作用。可以使用 <code>-XX:-userBiasedLocking=false</code> 来关闭偏向锁，并默认进入轻量锁。</p><h4 id="适应性自旋"><a href="#适应性自旋" class="headerlink" title="适应性自旋"></a>适应性自旋</h4><p>在使用 <code>CAS</code> 时，如果操作失败，<code>CAS</code> 会自旋再次尝试。由于自旋是需要消耗 <code>CPU</code> 资源的，所以如果长期自旋就白白浪费了 <code>CPU</code>。<code>JDK1.6</code>加入了适应性自旋:</p><blockquote><p>如果某个锁自旋很少成功获得，那么下一次就会减少自旋。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HDFS简介及其功能</title>
      <link href="/2019/01/02/HDFS%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD/"/>
      <url>/2019/01/02/HDFS%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%85%B6%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<h4 id="HDFS简介"><a href="#HDFS简介" class="headerlink" title="HDFS简介"></a>HDFS简介</h4><p>Hadoop分布式文件系统HDFS的设计目标是管理数以千计的服务器、数以万计的磁盘，将这么大规模的服务器计算资源当做一个单一的存储系统进行管理,对应用程序提供数以PB计的存储容量，让应用程序像使用普通文件系统一样存储大规模的文件数据。</p><h5 id="如何设计一个分布式文件系统？"><a href="#如何设计一个分布式文件系统？" class="headerlink" title="如何设计一个分布式文件系统？"></a>如何设计一个分布式文件系统？</h5><p>HDFS 是在一个大规模分布式服务器集群上，对数据分片后进行并行读写及冗余存储。因为 HDFS 可以部署在一个比较大的服务器集群上，集群中所有服务器的磁盘都可供 HDFS 使用，所以整个 HDFS 的存储空间可以达到 PB 级容量。</p><p>HDFS的架构图如下：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/HDFS2jpg.jpg" alt></p><p>从图中可以看到HDFS的关键组件有两个，一个是DataNode ,一个是NameNode.</p><p><strong>DataNode 负责文件数据的存储和读写操作，HDFS将文件数据分割成若干数据块(Block),每个DataNode 存储一部分数据块，这样文件就分布存储在整个HDFS服务器集群中</strong>，应用程序客户端（Client）可以并行对这些数据块进行访问，从而使得 HDFS 可以在服务器集群规模上实现数据并行访问，极大地提高了访问速度。</p><p>在实践中，HDFS 集群的 DataNode 服务器会有很多台，一般在几百台到几千台这样的规模，每台服务器配有数块磁盘，整个集群的存储容量大概在几 PB 到数百 PB。</p><p><strong>NameNode 负责整个分布式文件系统的元数据（MetaData）管理，也就是文件路径名、数据块的 ID 以及存储位置等信息，相当于操作系统中文件分配表（FAT）的角色</strong>。HDFS 为了保证数据的高可用，会将一个数据块复制为多份（缺省情况为 3 份），并将多份相同的数据块存储在不同的服务器上，甚至不同的机架上。这样当有磁盘损坏，或者某个 DataNode 服务器宕机，甚至某个交换机宕机，导致其存储的数据块不能访问的时候，客户端会查找其备份的数据块进行访问。</p><p>下面这张图是数据块多份复制存储的示意，图中对于文件 /users/sameerp/data/part-0，其复制备份数设置为 2，存储的 BlockID 分别为 1、3。Block1 的两个备份存储在 DataNode0 和 DataNode2 两个服务器上，Block3 的两个备份存储 DataNode4 和 DataNode6 两个服务器上，上述任何一台服务器宕机后，每个数据块都至少还有一个备份存在，不会影响对文件 /users/sameerp/data/part-0 的访问。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/hdfs3.jpg" alt></p><p>和 RAID 一样，数据分成若干数据块后存储到不同服务器上，可以实现数据大容量存储，并且不同分片的数据可以并行进行读 / 写操作，进而实现数据的高速访问。你可以看到，HDFS 的大容量存储和高速访问相对比较容易实现，但是 HDFS 是如何保证存储的高可用性呢？</p><h5 id="HDFS-的高可用设计"><a href="#HDFS-的高可用设计" class="headerlink" title="HDFS 的高可用设计"></a>HDFS 的高可用设计</h5><ol><li>数据存储故障容错</li></ol><p>磁盘介质在存储过程中受环境或者老化影响，其存储的数据可能会出现错乱。HDFS 的应对措施是，对于存储在 DataNode 上的数据块，计算并存储校验和（CheckSum）。在读取数据的时候，重新计算读取出来的数据的校验和，如果校验不正确就抛出异常，应用程序捕获异常后就到其他 DataNode 上读取备份数据。</p><ol start="2"><li>磁盘故障容错</li></ol><p>如果 DataNode 监测到本机的某块磁盘损坏，就将该块磁盘上存储的所有 BlockID 报告给 NameNode，NameNode 检查这些数据块还在哪些 DataNode 上有备份，通知相应的 DataNode 服务器将对应的数据块复制到其他服务器上，以保证数据块的备份数满足要求。</p><ol start="3"><li>DataNode 故障容错</li></ol><p>DataNode 会通过心跳和 NameNode 保持通信，如果 DataNode 超时未发送心跳，NameNode 就会认为这个 DataNode 已经宕机失效，立即查找这个 DataNode 上存储的数据块有哪些，以及这些数据块还存储在哪些服务器上，随后通知这些服务器再复制一份数据块到其他服务器上，保证 HDFS 存储的数据块备份数符合用户设置的数目，即使再出现服务器宕机，也不会丢失数据。</p><ol start="4"><li>NameNode 故障容错</li></ol><p>NameNode 是整个 HDFS 的核心，记录着 HDFS 文件分配表信息，所有的文件路径和数据块存储信息都保存在 NameNode，如果 NameNode 故障，整个 HDFS 系统集群都无法使用；如果 NameNode 上记录的数据丢失，整个集群所有 DataNode 存储的数据也就没用了。</p><p>所以，NameNode 高可用容错能力非常重要。NameNode 采用主从热备的方式提供高可用服务,如下图。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/hdfs5.png" alt></p><p>集群部署两台 NameNode 服务器，一台作为主服务器提供服务，一台作为从服务器进行热备，两台服务器通过 ZooKeeper 选举，主要是通过争夺 znode 锁资源，决定谁是主服务器。而 DataNode 则会向两个 NameNode 同时发送心跳数据，但是只有主 NameNode 才能向 DataNode 返回控制信息。</p><p>正常运行期间，主从 NameNode 之间通过一个共享存储系统 shared edits 来同步文件系统的元数据信息。当主 NameNode 服务器宕机，从 NameNode 会通过 ZooKeeper 升级成为主服务器，并保证 HDFS 集群的元数据信息，也就是文件分配表信息完整一致。</p><p>对于一个软件系统而言，性能差一点，用户也许可以接受；使用体验差，也许也能忍受。但是如果可用性差，经常出故障导致不可用，那就比较麻烦了；如果出现重要数据丢失，那开发工程师绝对是摊上大事了。</p><p>而分布式系统可能出故障地方又非常多，内存、CPU、主板、磁盘会损坏，服务器会宕机，网络会中断，机房会停电，所有这些都可能会引起软件系统的不可用，甚至数据永久丢失。</p><p>所以在设计分布式系统的时候，软件工程师一定要绷紧可用性这根弦，思考在各种可能的故障情况下，如何保证整个软件系统依然是可用的。</p><h5 id="常用的保证系统可用性的策略"><a href="#常用的保证系统可用性的策略" class="headerlink" title="常用的保证系统可用性的策略"></a>常用的保证系统可用性的策略</h5><ul><li>比如<strong>冗余备份</strong>，任何程序、任何数据，都至少要有一个备份，也就是说程序至少要部署到两台服务器，数据至少要备份到另一台服务器上。此外，稍有规模的互联网企业都会建设多个数据中心，数据中心之间互相进行备份，用户请求可能会被分发到任何一个数据中心，即所谓的异地多活，在遭遇地域性的重大故障和自然灾害的时候，依然保证应用的高可用。</li><li>当要访问的程序或者数据无法访问时，需要将访问请求转移到备份的程序或者数据所在的服务器上，这也就是<strong>失效转移</strong>。失效转移你应该注意的是失效的鉴定，像 NameNode 这样主从服务器管理同一份数据的场景，如果从服务器错误地以为主服务器宕机而接管集群管理，会出现主从服务器一起对 DataNode 发送指令，进而导致集群混乱，也就是所谓的“脑裂”。这也是这类场景选举主服务器时，引入 ZooKeeper 的原因。ZooKeeper 的工作原理，我将会在后面专门分析。</li><li>当大量的用户请求或者数据处理请求到达的时候，由于计算资源有限，可能无法处理如此大量的请求，进而导致资源耗尽，系统崩溃。这种情况下，可以拒绝部分请求，即进行<strong>限流</strong>；也可以关闭部分功能，降低资源消耗，即进行<strong>降级</strong>。限流是互联网应用的常备功能，因为超出负载能力的访问流量在何时会突然到来，你根本无法预料，所以必须提前做好准备，当遇到突发高峰流量时，就可以立即启动限流。而降级通常是为可预知的场景准备的，比如电商的“双十一”促销，为了保障促销活动期间应用的核心功能能够正常运行，比如下单功能，可以对系统进行降级处理，关闭部分非重要功能，比如商品评价功能。</li></ul><h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><ol><li>文件数据以数据块的方式进行切分，数据块可以存储在集群任意 DataNode 服务器上，所以 HDFS 存储的文件可以非常大，一个文件理论上可以占据整个 HDFS 服务器集群上的所有磁盘，实现了大容量存储。</li><li>HDFS 一般的访问模式是通过 MapReduce 程序在计算时读取，MapReduce 对输入数据进行分片读取，通常一个分片就是一个数据块，每个数据块分配一个计算进程，这样就可以同时启动很多进程对一个 HDFS 文件的多个数据块进行并发访问，从而实现数据的高速访问。关于 MapReduce 的具体处理过程，我们会在专栏后面详细讨论。</li><li>DataNode 存储的数据块会进行复制，使每个数据块在集群里有多个备份，保证了数据的可靠性，并通过一系列的故障容错手段实现 HDFS 系统中主要组件的高可用，进而保证数据和整个系统的高可用。</li></ol><h4 id="HDFS功能实践"><a href="#HDFS功能实践" class="headerlink" title="HDFS功能实践"></a>HDFS功能实践</h4><h5 id="HDFS的命令行操作"><a href="#HDFS的命令行操作" class="headerlink" title="HDFS的命令行操作"></a>HDFS的命令行操作</h5><p>HDFS是存取数据的分布式文件系统，对HDFS的操作，就是文件系统的基本操作，如文件的创建、修改、删除、修改权限等。对HDFS的操作命令类似于Linux的shell对文件的操作，如ls、mkdir、rm等。总的来说，HDFS的命令行操作可以分为两类，一类为基本操作命令：hdfs dfs；另一类为管理命令：hdfs dfsadmin。HDFS常用基本操作命令列举如下：</p><h5 id="使用Java操作HDFS"><a href="#使用Java操作HDFS" class="headerlink" title="使用Java操作HDFS"></a>使用Java操作HDFS</h5>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
            <tag> HDFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>synchronized和ReentrantLock区别</title>
      <link href="/2019/01/01/synchronized%E5%92%8CReentrantLock%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/01/01/synchronized%E5%92%8CReentrantLock%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h4 id="synchronized-和-ReentrantLock-区别"><a href="#synchronized-和-ReentrantLock-区别" class="headerlink" title="synchronized 和 ReentrantLock 区别"></a>synchronized 和 ReentrantLock 区别</h4><p>synchronized 是 Java 内建的同步机制,所以也有人称其为 Intrinsic Locking,它提供了互斥的语义和可见性,当一个线程已经获取当前锁时，其他试图获取的线程只能等待或者阻塞在那里.<br><a id="more"></a></p><p>在 Java 5 以前，synchronized 是仅有的同步手段，在代码中， synchronized 可以用来修饰方法，也可以使用在特定的代码块儿上，本质上 synchronized 方法等同于把方法全部语句用 synchronized 块包起来。</p><p>ReentrantLock，通常翻译为再入锁，是 Java 5 提供的锁实现，它的语义和 synchronized 基本相同。再入锁通过代码直接调用 lock() 方法获取，代码书写也更加灵活。与此同时，ReentrantLock 提供了很多实用的方法，能够实现很多 synchronized 无法做到的细节控制，比如可以控制 fairness，也就是公平性，或者利用定义条件等。但是，编码中也需要注意，必须要明确调用 unlock() 方法释放，不然就会一直持有该锁。</p><p>synchronized 和 ReentrantLock 的性能不能一概而论，早期版本 synchronized 在很多场景下性能相差较大，在后续版本进行了较多改进，在低竞争场景中表现可能优于 ReentrantLock。</p><p>我认为，锁作为并发的基础工具之一，你至少需要掌握：</p><ul><li>理解什么是线程安全。</li><li>synchronized、ReentrantLock 等机制的基本使用与案例。</li></ul><p>更近一步，你还需要：</p><ul><li>掌握 synchronized、ReentrantLock 底层实现；理解锁膨胀、降级；理解偏斜锁、自旋锁、轻量级锁、重量级锁等概念。</li><li>掌握并发包中 java.util.concurrent.lock 各种不同实现和案例分析。</li></ul><h4 id="知识扩展"><a href="#知识扩展" class="headerlink" title="知识扩展"></a>知识扩展</h4><p>首先，我们需要理解什么是线程安全。</p><p>线程安全是一个多线程环境下正确性的概念，也就是保证多线程环境下<strong>共享的</strong>、<strong>可修改的</strong>状态的正确性，这里的状态反映在程序中其实可以看作是数据。</p><p>换个角度来看，如果状态不是共享的，或者不是可修改的，也就不存在线程安全问题，进而可以推理出保证线程安全的两个办法：</p><ul><li>封装：通过封装，我们可以将对象内部状态隐藏、保护起来。</li><li>不可变：Java 语言目前还没有真正意义上的原生不可变，但是未来也许会引入。</li></ul><p>线程安全需要保证几个基本特性：</p><ul><li><strong>原子性</strong>，简单说就是相关操作不会中途被其他线程干扰，一般通过同步机制实现。</li><li><strong>可见性</strong>，是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，volatile 就是负责保证可见性的。</li><li><strong>有序性</strong>，是保证线程内串行语义，避免指令重排等。</li></ul><p>分析一下原子性需求体现在哪里。这个例子通过取两次数值然后进行对比，来模拟两次对共享状态的操作。</p><p>你可以编译并执行，可以看到，仅仅是两个线程的低度并发，就非常容易碰到 former 和 latter 不相等的情况。这是因为，在两次取值的过程中，其他线程可能已经修改了 sharedState。</p><pre><code>public class ThreadSafeSample {    public int sharedState;    public void nonSafeAction() {        while (sharedState &lt; 100000) {            int former = sharedState++;            int latter = sharedState;            if (former != latter - 1) {                System.out.printf(&quot;Observed data race, former is &quot; +                        former + &quot;, &quot; + &quot;latter is &quot; + latter);            }        }    }    public static void main(String[] args) throws InterruptedException {        ThreadSafeSample sample = new ThreadSafeSample();        Thread threadA = new Thread(){            public void run(){                sample.nonSafeAction();            }        };        Thread threadB = new Thread(){            public void run(){                sample.nonSafeAction();            }        };        threadA.start();        threadB.start();        threadA.join();        threadB.join();    }}</code></pre><p>下面是在我的电脑上的运行结果：</p><pre><code>C:\&gt;c:\jdk-9\bin\java ThreadSafeSampleObserved data race, former is 13097, latter is 13099</code></pre><p>将两次赋值过程用 synchronized 保护起来，使用 this 作为互斥单元，就可以避免别的线程并发的去修改 sharedState。</p><pre><code>synchronized (this) {    int former = sharedState ++;    int latter = sharedState;    // …}</code></pre><p>如果用 javap 反编译，可以看到类似片段，利用 monitorenter/monitorexit 对实现了同步的语义：</p><pre><code>11: astore_112: monitorenter13: aload_014: dup15: getfield      #2                  // Field sharedState:I18: dup_x1…56: monitorexit</code></pre><p>代码中使用 synchronized 非常便利，如果用来修饰静态方法，其等同于利用下面代码将方法体囊括进来：</p><pre><code>synchronized (ClassName.class) {}</code></pre><p>再来看看 ReentrantLock。你可能好奇什么是再入？它是表示当一个线程试图获取一个它已经获取的锁时，这个获取动作就自动成功，这是对锁获取粒度的一个概念，也就是锁的持有是以线程为单位而不是基于调用次数。Java 锁实现强调再入性是为了和 pthread 的行为进行区分。</p><p>再入锁可以设置公平性（fairness），我们可在创建再入锁时选择是否是公平的。</p><pre><code>ReentrantLock fairLock = new ReentrantLock(true);</code></pre><p>这里所谓的公平性是指在竞争场景中，当公平性为真时，会倾向于将锁赋予等待时间最久的线程。公平性是减少线程“饥饿”（个别线程长期等待锁，但始终无法获取）情况发生的一个办法。</p><p>如果使用 synchronized，我们根本<strong>无法进行</strong>公平性的选择，其永远是不公平的，这也是主流操作系统线程调度的选择。通用场景中，公平性未必有想象中的那么重要，Java 默认的调度策略很少会导致 “饥饿”发生。与此同时，若要保证公平性则会引入额外开销，自然会导致一定的吞吐量下降。所以，我建议<strong>只有</strong>当你的程序确实有公平性需要的时候，才有必要指定它。</p><p>我们再从日常编码的角度学习下再入锁。为保证锁释放，每一个 lock() 动作，我建议都立即对应一个 try-catch-finally，典型的代码结构如下，这是个良好的习惯。</p><pre><code>ReentrantLock fairLock = new ReentrantLock(true);// 这里是演示创建公平锁，一般情况不需要。try {    // do something} finally {     fairLock.unlock();}</code></pre><p>ReentrantLock 相比 synchronized，因为可以像普通对象一样使用，所以可以利用其提供的各种便利方法，进行精细的同步操作，甚至是实现 synchronized 难以表达的用例，如：</p><ul><li>带超时的获取锁尝试。</li><li>可以判断是否有线程，或者某个特定线程，在排队等待获取锁。</li><li>可以响应中断请求。</li><li>…</li></ul><p>这里我特别想强调<strong>条件变量</strong>（java.util.concurrent.Condition），如果说 ReentrantLock 是 synchronized 的替代选择，Condition 则是将 wait、notify、notifyAll 等操作转化为相应的对象，将复杂而晦涩的同步操作转变为直观可控的对象行为。</p><p>条件变量最为典型的应用场景就是标准类库中的 ArrayBlockingQueue 等。</p><p>参考下面的源码，首先，通过再入锁获取条件变量：</p><pre><code>/** Condition for waiting takes */private final Condition notEmpty;/** Condition for waiting puts */private final Condition notFull;public ArrayBlockingQueue(int capacity, boolean fair) {    if (capacity &lt;= 0)        throw new IllegalArgumentException();    this.items = new Object[capacity];    lock = new ReentrantLock(fair);    notEmpty = lock.newCondition();    notFull =  lock.newCondition();}</code></pre><p>两个条件变量是从<strong>同一再入锁</strong>创建出来，然后使用在特定操作中，如下面的 take 方法，判断和等待条件满足：</p><pre><code>public E take() throws InterruptedException {    final ReentrantLock lock = this.lock;    lock.lockInterruptibly();    try {        while (count == 0)            notEmpty.await();        return dequeue();    } finally {        lock.unlock();    }}</code></pre><p>当队列为空时，试图 take 的线程的正确行为应该是等待入队发生，而不是直接返回，这是 BlockingQueue 的语义，使用条件 notEmpty 就可以优雅地实现这一逻辑。</p><p>那么，怎么保证入队触发后续 take 操作呢？请看 enqueue 实现：</p><pre><code>private void enqueue(E e) {    // assert lock.isHeldByCurrentThread();    // assert lock.getHoldCount() == 1;    // assert items[putIndex] == null;    final Object[] items = this.items;    items[putIndex] = e;    if (++putIndex == items.length) putIndex = 0;    count++;    notEmpty.signal(); // 通知等待的线程，非空条件已经满足}</code></pre><p>通过 signal/await 的组合，完成了条件判断和通知等待线程，非常顺畅就完成了状态流转。注意，signal 和 await 成对调用非常重要，不然假设只有 await 动作，线程会一直等待直到被打断（interrupt）。</p><p>从性能角度，synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大。但是在 Java 6 中对其进行了非常多的改进，可以参考性能<a href="https://dzone.com/articles/synchronized-vs-lock" target="_blank" rel="noopener">对比</a>，在高竞争情况下，ReentrantLock 仍然有一定优势。我在下一讲进行详细分析，会更有助于理解性能差异产生的内在原因。在大多数情况下，无需纠结于性能，还是考虑代码书写结构的便利性、可维护性等。</p><h4 id="ReentrantLock-实现原理"><a href="#ReentrantLock-实现原理" class="headerlink" title="ReentrantLock 实现原理"></a>ReentrantLock 实现原理</h4><h5 id="AbstractQueuedSynchronized（AQS）"><a href="#AbstractQueuedSynchronized（AQS）" class="headerlink" title="AbstractQueuedSynchronized（AQS）"></a>AbstractQueuedSynchronized（AQS）</h5><p>谈到并发，不得不谈ReentrantLock；而谈到ReentrantLock，不得不谈AbstractQueuedSynchronized（AQS）！<br>独占锁：锁在一个时间点只能被一个线程占有。根据锁的获取机制，又分为“公平锁”和“非公平锁”。等待队列中按照FIFO的原则获取锁，等待时间越长的线程越先获取到锁，这就是公平的获取锁，即公平锁。而非公平锁，线程获取的锁的时候，无视等待队列直接获取锁。ReentrantLock和ReentrantReadWriteLock.Writelock是独占锁。<br>共享锁：同一个时候能够被多个线程获取的锁，能被共享的锁。JUC包中ReentrantReadWriteLock.ReadLock，CyclicBarrier，CountDownLatch和Semaphore都是共享锁。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka消息中间件</title>
      <link href="/2018/11/22/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
      <url>/2018/11/22/Kafka%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在大数据中,使用了大量的数据.关于数据,我们有两个主要挑战.第一个挑战是如何收集大量的数据,第二个挑战是分析收集的数据.为了克服这些挑战,您必须需要一个消息系统.</p><p>Kafka专为分布式高吞吐量系统而设计。 Kafka往往工作得很好，作为一个更传统的消息代理的替代品。 与其他消息传递系统相比，Kafka具有更好的吞吐量，内置分区，复制和固有的容错能力，这使得它非常适合大规模消息处理应用程序。</p><h4 id="什么是消息系统"><a href="#什么是消息系统" class="headerlink" title="什么是消息系统"></a>什么是消息系统</h4><p>消息系统负责将数据从一个应用程序传输到另一个应用程序，因此应用程序可以专注于数据，但不担心如何共享它，分布式消息传递基于可靠消息队列的概念，消息再客户端应用程序和消息传递系统之间异步排队，有两种类型的消息模式可用，一种是点对点，另外一种是发布-订阅消息系统，大多数消息系统遵循pub-sub</p><p><strong>点对点消息系统：</strong></p><p>在点对点系统中，消息被保留在队列中，一个或多个消费者可以消耗队列中的消息，但是特定消息只能由最多一个消费者消费，一旦消费者读取队列中的消息，它就从该队列中消失，概系统的典型示例就是订单处理系统，其中每个订单将由一个订单处理器处理，但多个订单处理器可以同时工作，如下图所示：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/kafka1.jpg" alt></p><p><strong>发布-订阅消息系统</strong></p><p>在发布-订阅系统中，消息被保留在主题中，与点对点系统不同，消费组可以订阅一个或多个主题并使用该主题中的所有消息，在发布-订阅系统中，消息生产者称为发布者，消息使用者称为订阅者，一个现实生活的例子就是Dish电视，它发布不同的渠道，如运动，电影，音乐等，任何人都可以订阅自己的频道集，并获的他们订阅的频道时可用。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/kafka2.jpg" alt></p><h4 id="什么是Kafka"><a href="#什么是Kafka" class="headerlink" title="什么是Kafka?"></a>什么是Kafka?</h4><p>Apache Kafka是一个分布式发布 - 订阅消息系统和一个强大的队列，可以处理大量的数据，并使您能够将消息从一个端点传递到另一个端点。 Kafka适合离线和在线消息消费。 Kafka消息保留在磁盘上，并在群集内复制以防止数据丢失。 Kafka构建在ZooKeeper同步服务之上。 它与Apache Storm和Spark非常好地集成，用于实时流式数据分析。</p><p><strong>好处</strong></p><ul><li>可靠性 ： Kafak是分布式，分区，复制和容错的</li><li>可扩展性: Kafka消息系统轻松缩放，无需停机。</li><li>耐用性： Kafka使用分布式提交日志，这意味着消息会尽可能地保留在磁盘上，因此它是持久的。</li><li>性能： Kafka对于发布和订阅消息都具有高吞吐量，即使存储了许多TB的消息，它也能保持稳定的性能。</li></ul><p><strong>使用案例</strong></p><ul><li>指标： Kafka通常用于操作监控数据，这涉及聚合来自分布式应用程序的统计信息，以产生操作数据的集中馈送。</li><li>日志聚合解决方案： Kafka可跨组织从多个服务收集日志，并使它们以标准格式提供给多个服务器。</li><li>流处理： 流行的框架(如Storm、SparkStreaming、Flink)从主题中读取数据，对其进行处理，并将处理后的数据写入新的主题，供用户和应用程序使用，Kafka的强耐久性在流处理的上下文中也非常有用</li></ul><h4 id="Kafka集群架构"><a href="#Kafka集群架构" class="headerlink" title="Kafka集群架构"></a>Kafka集群架构</h4><p><img src="https://github.com/gaohueric/blogpicture/raw/master/kafka3.jpg" alt></p><table><thead><tr><th>组件</th><th><strong>Broker（代理）</strong></th><th><strong>ZooKeeper</strong></th><th><strong>Producers（生产者）</strong></th><th><strong>Consumers（消费者）</strong></th></tr></thead><tbody><tr><td>说明</td><td>Kafka集群通常由多个代理组成以保持负载平衡。 Kafka代理是无状态的，所以他们使用ZooKeeper来维护它们的集群状态。 一个Kafka代理实例可以每秒处理数十万次读取和写入，每个Broker可以处理TB的消息，而没有性能影响。Kafka经纪人领导选举可以由ZooKeeper完成。</td><td>ZooKeeper用于管理和协调Kafka代理。 ZooKeeper服务主要用于通知生产者和消费者Kafka系统中存在任何新代理或Kafka系统中代理失败。 根据Zookeeper接收到关于代理的存在或失败的通知，然后产品和消费者采取决定并开始与某些其他代理协调他们的任务。</td><td>生产者将数据推送给经纪人。 当新代理启动时，所有生产者搜索它并自动向该新代理发送消息。 Kafka生产者不等待来自代理的确认，并且发送消息的速度与代理可以处理的一样快。</td><td>因为Kafka代理是无状态的，这意味着消费者必须通过使用分区偏移来维护已经消耗了多少消息。 如果消费者确认特定的消息偏移，则意味着消费者已经消费了所有先前的消息。 消费者向代理发出异步拉取请求，以具有准备好消耗的字节缓冲区。 消费者可以简单地通过提供偏移值来快退或跳到分区中的任何点。 消费者偏移值由ZooKeeper通知。</td></tr></tbody></table><h4 id="Kafka工作流程"><a href="#Kafka工作流程" class="headerlink" title="Kafka工作流程"></a>Kafka工作流程</h4><p>Kafka只是分为一个或多个分区的主题的集合。 Kafka分区是消息的线性有序序列，其中每个消息由它们的索引(称为偏移)来标识。 Kafka集群中的所有数据都是不相连的分区联合。 传入消息写在分区的末尾，消息由消费者顺序读取。 通过将消息复制到不同的代理提供持久性。</p><p>Kafka以快速，可靠，持久，容错和零停机的方式提供基于pub-sub和队列的消息系统。 在这两种情况下，生产者只需将消息发送到主题，消费者可以根据自己的需要选择任何一种类型的消息传递系统。 让我们按照下一节中的步骤来了解消费者如何选择他们选择的消息系统。</p><p><strong>发布 - 订阅消息的工作流程</strong></p><p>以下是Pub-Sub消息的逐步工作流程 -</p><ul><li>生产者定期向主题发送消息。</li><li>Kafka代理存储为该特定主题配置的分区中的所有消息。 它确保消息在分区之间平等共享。 如果生产者发送两个消息并且有两个分区，Kafka将在第一分区中存储一个消息，在第二分区中存储第二消息。</li><li>消费者订阅特定主题。</li><li>一旦消费者订阅主题，Kafka将向消费者提供主题的当前偏移，并且还将偏移保存在Zookeeper系综中。</li><li>消费者将定期请求Kafka(如100 Ms)新消息。</li><li>一旦Kafka收到来自生产者的消息，它将这些消息转发给消费者。</li><li>消费者将收到消息并进行处理。</li><li>一旦消息被处理，消费者将向Kafka代理发送确认。</li><li>一旦Kafka收到确认，它将偏移更改为新值，并在Zookeeper中更新它。 由于偏移在Zookeeper中维护，消费者可以正确地读取下一封邮件，即使在服务器暴力期间。</li><li>以上流程将重复，直到消费者停止请求。</li><li>消费者可以随时回退/跳到所需的主题偏移量，并阅读所有后续消息</li></ul><p><strong>队列消息/用户组的工作流</strong></p><p>在队列消息传递系统而不是单个消费者中，具有相同组ID 的一组消费者将订阅主题。 简单来说，订阅具有相同 Group ID 的主题的消费者被认为是单个组，并且消息在它们之间共享。 让我们检查这个系统的实际工作流程。</p><ul><li>生产者以固定间隔向某个主题发送消息。</li><li>Kafka存储在为该特定主题配置的分区中的所有消息，类似于前面的方案。</li><li>单个消费者订阅特定主题，假设 Topic-01 为 Group ID 为 Group-1 。</li><li>Kafka以与发布 - 订阅消息相同的方式与消费者交互，直到新消费者以相同的组ID 订阅相同主题 Topic-01  1 。</li><li>一旦新消费者到达，Kafka将其操作切换到共享模式，并在两个消费者之间共享数据。 此共享将继续，直到用户数达到为该特定主题配置的分区数。</li><li>一旦消费者的数量超过分区的数量，新消费者将不会接收任何进一步的消息，直到现有消费者取消订阅任何一个消费者。 出现这种情况是因为Kafka中的每个消费者将被分配至少一个分区，并且一旦所有分区被分配给现有消费者，新消费者将必须等待。</li><li>此功能也称为使用者组。 同样，Kafka将以非常简单和高效的方式提供两个系统中最好的。</li></ul><p><strong>ZooKeeper的作用</strong></p><p>Apache Kafka的一个关键依赖是Apache Zookeeper，它是一个分布式配置和同步服务。 Zookeeper是Kafka代理和消费者之间的协调接口。 Kafka服务器通过Zookeeper集群共享信息。 Kafka在Zookeeper中存储基本元数据，例如关于主题，代理，消费者偏移(队列读取器)等的信息。</p><p>由于所有关键信息存储在Zookeeper中，并且它通常在其整体上复制此数据，因此Kafka代理/ Zookeeper的故障不会影响Kafka集群的状态。 Kafka将恢复状态，一旦Zookeeper重新启动。 这为Kafka带来了零停机时间。 Kafka代理之间的领导者选举也通过使用Zookeeper在领导者失败的情况下完成。</p><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><h4 id="KafkaProducer-API"><a href="#KafkaProducer-API" class="headerlink" title="KafkaProducer API"></a><strong>KafkaProducer API</strong></h4><p>生产者示例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Properties<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>Producer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>KafkaProducer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>producer<span class="token punctuation">.</span>ProducerRecord<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SimpleProducer</span> <span class="token punctuation">{</span>   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>args<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Enter topic name"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      String topicName <span class="token operator">=</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> “localhost<span class="token operator">:</span><span class="token number">9092</span>"<span class="token punctuation">)</span><span class="token punctuation">;</span>          props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"acks"</span><span class="token punctuation">,</span> “all"<span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"retries"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"batch.size"</span><span class="token punctuation">,</span> <span class="token number">16384</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"linger.ms"</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"buffer.memory"</span><span class="token punctuation">,</span> <span class="token number">33554432</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.serializer"</span><span class="token punctuation">,</span>          <span class="token string">"org.apache.kafka.common.serializa-tion.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.serializer"</span><span class="token punctuation">,</span>          <span class="token string">"org.apache.kafka.common.serializa-tion.StringSerializer"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      Producer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> producer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">KafkaProducer</span>         <span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>         producer<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ProducerRecord</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span>topicName<span class="token punctuation">,</span>             Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“Message sent successfully"<span class="token punctuation">)</span><span class="token punctuation">;</span>               producer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>参数说明</strong></p><table><thead><tr><th>S.No</th><th>配置设置和说明</th></tr></thead><tbody><tr><td>client.id</td><td>标识生产者应用程序</td></tr><tr><td>producer.type</td><td>同步或异步</td></tr><tr><td>acks</td><td>acks配置控制生产者请求下的标准是完全的。</td></tr><tr><td><strong>重试</strong></td><td>如果生产者请求失败，则使用特定值自动重试。</td></tr><tr><td>bootstrapping</td><td>代理列表。</td></tr><tr><td>linger.ms</td><td>如果你想减少请求的数量，你可以将linger.ms设置为大于某个值的东西。</td></tr><tr><td>key.serializer</td><td>序列化器接口的键。</td></tr><tr><td>value.serializer</td><td>值。</td></tr><tr><td>batch.siz</td><td>缓冲区大小。</td></tr><tr><td>buffer.memory</td><td>控制生产者可用于缓冲的存储器的总量。</td></tr></tbody></table><h4 id="Kafka-消费者组示例"><a href="#Kafka-消费者组示例" class="headerlink" title="Kafka 消费者组示例"></a>Kafka 消费者组示例</h4><p><strong>消费者群体</strong></p><ul><li>消费者可以使用相同的 group.id 加入群组</li><li>一个组的最大并行度是组中的消费者数量←不是分区。</li><li>Kafka将主题的分区分配给组中的使用者，以便每个分区仅由组中的一个使用者使用。</li><li>Kafka保证消息只能被组中的一个消费者读取。</li><li>消费者可以按照消息存储在日志中的顺序查看消息。</li></ul><p><strong>重新平衡消费者</strong></p><p>添加更多进程/线程将导致Kafka重新平衡。 如果任何消费者或代理无法向ZooKeeper发送心跳，则可以通过Kafka集群重新配置。 在此重新平衡期间，Kafka将分配可用分区到可用线程，可能将分区移动到另一个进程。</p><p><strong>消费者示例代码</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecord<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>ConsumerRecords<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>common<span class="token punctuation">.</span>serialization<span class="token punctuation">.</span>StringDeserializer<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>*<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KafkaConsumer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Properties props <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> UUID<span class="token punctuation">.</span><span class="token function">randomUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"key.deserializer"</span><span class="token punctuation">,</span> StringDeserializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"value.deserializer"</span><span class="token punctuation">,</span> StringDeserializer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        props<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"auto.offset.reset"</span><span class="token punctuation">,</span> <span class="token string">"earliest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>KafkaConsumer<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>kafka<span class="token punctuation">.</span>clients<span class="token punctuation">.</span>consumer<span class="token punctuation">.</span>KafkaConsumer</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">;</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> topics <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        consumer<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span>topics<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ConsumerRecords<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> records <span class="token operator">=</span> consumer<span class="token punctuation">.</span><span class="token function">poll</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>ConsumerRecord<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> record <span class="token operator">:</span> records<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"offset = %s, key = %s, value = %s"</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">offset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">key</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> record<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="Kafka-与SparkStreaming集成"><a href="#Kafka-与SparkStreaming集成" class="headerlink" title="Kafka 与SparkStreaming集成"></a>Kafka 与SparkStreaming集成</h4><p><strong>Spark streaming接收Kafka数据</strong></p><p>用spark streaming流式处理kafka中的数据，第一步当然是先把数据接收过来，转换为spark streaming中的数据结构Dstream。接收数据的方式有两种：</p><ul><li>利用Receiver接收数据</li><li>直接从kafka读取数据。</li></ul><p><strong>基于Receiver的方式</strong></p><p>这种方式利用接收器（Receiver）来接收kafka中的数据，其最基本是使用Kafka高阶用户API接口。对于所有的接收器，从kafka接收来的数据会存储在spark的executor中，之后spark streaming提交的job会处理这些数据。如下图：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/kafka5png.png" alt></p><p>注意的点：</p><ul><li>在Receiver的方式中，Spark中的partition和kafka中的partition并不是相关的，所以如果我们加大每个topic的partition数量，仅仅是增加线程来处理由单一Receiver消费的主题。但是这并没有增加Spark在处理数据上的并行度。</li><li>对于不同的Group和topic我们可以使用<strong>多个Receiver</strong>创建不同的Dstream来并行接收数据，之后可以利用<strong>union来统一</strong>成一个Dstream。</li><li>如果我们启用了Write Ahead Logs复制到文件系统如HDFS，那么storage level需要设置成 StorageLevel.MEMORY_AND_DISK_SER，也就是<code>KafkaUtils.createStream(..., StorageLevel.MEMORY_AND_DISK_SER)</code></li></ul><p>遇到的坑，kafka数据量一天150亿左右，生产者每秒生产250万条数据，采用高阶api消费，消费速率提不上去，遇到了消费瓶颈。采用低阶api提供并行拉取速度，解决了消费瓶颈问题。</p><p><strong>接读取方式</strong></p><p>在spark1.3之后，引入了Direct方式。不同于Receiver的方式，Direct方式没有receiver这一层，其会周期性的获取Kafka中每个topic的每个partition中的最新offsets，之后根据设定的maxRatePerPartition来处理每个batch。其形式如下图：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/kafka6.png" alt></p><p>这种方法相较于Receiver方式的优势在于：</p><ul><li><strong>简化的并行</strong>：在Receiver的方式中我们提到创建多个Receiver之后利用union来合并成一个Dstream的方式提高数据传输并行度。而在Direct方式中，<strong>Kafka中的partition与RDD中的partition是一一对应</strong>的并行读取Kafka数据，这种映射关系也更利于理解和优化。</li><li><strong>高效</strong>：在Receiver的方式中，为了达到0数据丢失需要将数据存入Write Ahead Log中，这样在Kafka和日志中就保存了两份数据，浪费！而第二种方式不存在这个问题，只要我们Kafka的数据保留时间足够长，我们都能够从Kafka进行数据恢复。</li><li><strong>精确一次</strong>：在Receiver的方式中，使用的是Kafka的高阶API接口从Zookeeper中获取offset值，这也是传统的从Kafka中读取数据的方式，但由于Spark Streaming消费的数据和Zookeeper中记录的offset不同步，这种方式偶尔会造成数据重复消费。而第二种方式，直接使用了简单的低阶Kafka API，Offsets则利用Spark Streaming的checkpoints进行记录，消除了这种不一致性。</li></ul><p>不同于Receiver的方式，是从Zookeeper中读取offset值，那么自然zookeeper就保存了当前消费的offset值，那么如果重新启动开始消费就会接着上一次offset值继续消费。而在Direct的方式中，我们是直接从kafka来读数据，那么offset需要自己记录，可以利用checkpoint、数据库或文件记录或者回写到zookeeper中进行记录。这里我们给出利用Kafka底层API接口，将offset及时同步到zookeeper中的通用类</p><p>SparkStreaming 低阶API消费Kafka</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createInputDStream</span><span class="token punctuation">(</span>JavaStreamingContext jsc<span class="token punctuation">,</span> String topics<span class="token punctuation">)</span> <span class="token keyword">throws</span> SparkException <span class="token punctuation">{</span>        HashSet<span class="token operator">&lt;</span>String<span class="token operator">></span> topicSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        topicSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>topics<span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> kafkaParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"metadata.broker.list"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"zookeeper.connection.timeout.ms"</span><span class="token punctuation">,</span> <span class="token string">"10000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"auto.offset.reset"</span><span class="token punctuation">,</span> <span class="token string">"largest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        JavaKafkaManager javaKafkaManager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JavaKafkaManager</span><span class="token punctuation">(</span>kafkaParams<span class="token punctuation">)</span><span class="token punctuation">;</span>        JavaInputDStream<span class="token operator">&lt;</span>String<span class="token operator">></span> records <span class="token operator">=</span> javaKafkaManager<span class="token punctuation">.</span><span class="token function">createDirectStream</span><span class="token punctuation">(</span>jsc<span class="token punctuation">,</span>kafkaParams<span class="token punctuation">,</span>topicSet<span class="token punctuation">)</span><span class="token punctuation">;</span>        records<span class="token punctuation">.</span><span class="token function">transform</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span>JavaRDD<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">,</span> JavaRDD<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">)</span> v1 <span class="token operator">-</span><span class="token operator">></span> v1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">foreachRDD</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VoidFunction<span class="token operator">&lt;</span>JavaRDD<span class="token operator">&lt;</span>String<span class="token operator">>></span><span class="token punctuation">)</span> rdd <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>rdd<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                rdd<span class="token punctuation">.</span><span class="token function">foreach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>VoidFunction<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> r <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                javaKafkaManager<span class="token punctuation">.</span><span class="token function">updateZKOffsets</span><span class="token punctuation">(</span>rdd<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p><strong>使用高阶API消费Kafka</strong>代码示例</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">createInputDStream</span><span class="token punctuation">(</span>JavaStreamingContext jsc<span class="token punctuation">,</span> String topics<span class="token punctuation">)</span> <span class="token keyword">throws</span> SparkException<span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> topicMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        topicMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>topics<span class="token punctuation">,</span> ConfigUtil<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"kafka.numThreads"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> kafkaParams <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"zookeeper.connect"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"zookeeper.connection.timeout.ms"</span><span class="token punctuation">,</span> <span class="token string">"10000"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        kafkaParams<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"auto.offset.reset"</span><span class="token punctuation">,</span> <span class="token string">"largest"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//消费kafka消息</span>        JavaPairReceiverInputDStream<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> records <span class="token operator">=</span> KafkaUtils<span class="token punctuation">.</span><span class="token function">createStream</span><span class="token punctuation">(</span>jsc<span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> StringDecoder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> StringDecoder<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> kafkaParams<span class="token punctuation">,</span> topicMap<span class="token punctuation">,</span> StorageLevel<span class="token punctuation">.</span><span class="token function">MEMORY_AND_DISK_SER_2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="Kafka-与Flink集成"><a href="#Kafka-与Flink集成" class="headerlink" title="Kafka 与Flink集成"></a>Kafka 与Flink集成</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StreamDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>StreamDemo<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">final</span> StreamExecutionEnvironment env <span class="token operator">=</span> StreamExecutionEnvironment<span class="token punctuation">.</span><span class="token function">getExecutionEnvironment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Properties properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"bootstrap.servers"</span><span class="token punctuation">,</span> PropertiesUtil<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"kafka.bootstrap.servers"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"group.id"</span><span class="token punctuation">,</span> PropertiesUtil<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"kafka.group.id"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"auto.offset.reset"</span><span class="token punctuation">,</span> PropertiesUtil<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"kafka.auto.offset.reset"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 序列化方式</span>        DeserializationSchema<span class="token operator">&lt;</span>SkynetLogVO<span class="token operator">></span> deserializer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LogDeserializationSchema</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FlinkKafkaConsumer010<span class="token operator">&lt;</span>String<span class="token operator">></span> consumer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlinkKafkaConsumer010</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>Constant<span class="token punctuation">.</span>KAFKA_TOPIC<span class="token punctuation">,</span> deserializer<span class="token punctuation">,</span> properties<span class="token punctuation">)</span><span class="token punctuation">;</span>        escountConsumer<span class="token punctuation">.</span><span class="token function">setStartFromGroupOffsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        DataStream<span class="token operator">&lt;</span>String<span class="token operator">></span> esCountStream <span class="token operator">=</span> env<span class="token punctuation">.</span><span class="token function">addSource</span><span class="token punctuation">(</span>escountConsumer<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>#### </p>]]></content>
      
      
      <categories>
          
          <category> 基础组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里巴巴Java开发手册</title>
      <link href="/2018/08/17/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
      <url>/2018/08/17/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<h4 id="一、编程规约"><a href="#一、编程规约" class="headerlink" title="一、编程规约"></a>一、编程规约</h4><h5 id="一-命名风格"><a href="#一-命名风格" class="headerlink" title="(一) 命名风格"></a>(一) 命名风格</h5><ol><li><p>代码中的命名严禁使用拼音与英文混合的方式,更不允许直接使用中文的方式.</p><a id="more"></a><p>说明:正确的英文拼写和语法可以让阅读者易于理解,避免歧义.注意,即使纯拼音命名方式也要避免采用.<br>正例：alibaba / taobao / youku / hangzhou 等国际通用的名称,可视同英文.</p><p>反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</p></li><li><p>【强制】类名使用UpperCamelCase风格，但以下情形例外：DO / BO / DTO / VO / AO / PO / UID等。 </p><p>正例：MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion </p><p>反例：macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</p></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用lowerCamelCase风格，必须遵从驼峰形式。 正例： localValue / getHttpMessage() / inputUserId</p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。 </p><p>正例：MAX_STOCK_COUNT 反例：MAX_COUNT</p></li><li><p>【强制】抽象类命名使用Abstract或Base开头；异常类命名使用Exception结尾；测试类命名以它要测试的类的名称开始，以Test结尾。 </p></li><li><p>【强制】类型与中括号紧挨相连来 表示 数组。 </p><p>正例： 定义整形数组 int[] arrayDemo; </p><p>反例： 在 main 参数中，使用  String args[] 来定义。</p></li><li><p>【强制】POJO类中布尔类型的变量，都不要加is前缀，否则部分框架解析会引起序列化错误。 反例：定义为基本数据类型Boolean isDeleted的属性，它的方法也是isDeleted()，RPC框架在反向解析的时候，“误以为”对应的属性名称是deleted，导致属性获取不到，进而抛出异常。</p></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p><p>正例：应用工具类包名为com.alibaba.ai.util、类名为MessageUtils（此规则参考spring的框架结构）</p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。 </p><p>反例：AbstractClass“缩写”命名成AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 </p></li><li><p>【推荐】为了达到代码自解释的目标，任何定义编程元素在命名时使用尽量完整单词 组合来表达其意。 正例： 在 JDK 中， 表达 原子更新的类名为： AtomicReferenceFieldUpdater </p><p>反例： 变量 int a int a 的随意命名</p></li><li><p>【推荐】如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。 </p><p>说明：将设计模式体现在名字中，有利于阅读者快速理解架构设计理念。 </p><p>正例：public class OrderFactory; </p><p>​            public class LoginProxy; </p><p>​            public class ResourceObserver;</p></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的Javadoc注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。 </p><p>正例：接口方法签名void commit(); 接口基础常量String COMPANY = “alibaba”; </p><p>反例：接口方法定义public abstract void f(); </p><p>说明：JDK8中接口允许有默认实现，那么这个default方法，是对所有实现类都有价值的默认实现。</p></li><li><p>接口和实现类的命名有两套规则：</p><p>1）【强制】对于Service和DAO类，基于SOA的理念，暴露出来的服务一定是接口，内部的实现类用Impl的后缀与接口区别。 正例：CacheServiceImpl实现CacheService接口。 </p><p>2） 【推荐】 如果是形容能力的接口名称，取对应的形容词为接口名（通常是–able的形式）。 </p><p>正例：AbstractTranslator实现 Translatable接口。<br>​</p></li><li><p>【参考】枚举类名建议带上Enum后缀，枚举成员名称需要全大写，单词间用下划线隔开。 </p><p>说明：枚举其实就是特殊的类，域成员均为常量，且构造方法被默认强制是私有。 </p><p>正例：枚举名字为ProcessStatusEnum的成员名称：SUCCESS / UNKNOWN_REASON。</p></li><li><p>【参考】各层命名规约： </p><p>A) Service/DAO层方法命名规约 </p><p>​    1） 获取单个对象的方法用get做前缀。</p><p>​    2） 获取多个对象的方法用list做前缀，复数形式结尾如：listObjects。 </p><p>   3） 获取统计值的方法用count做前缀。 </p><p>   4） 插入的方法用save/insert做前缀。  </p><p>   5） 删除的方法用remove/delete做前缀。</p><p>   6） 修改的方法用update做前缀。  </p><p>B) 领域模型命名规约 </p><p>  1） 数据对象：xxxDO，xxx即为数据表名。 </p><p>  2） 数据传输对象：xxxDTO，xxx为业务领域相关的名称。 </p><p> 3） 展示对象：xxxVO，xxx一般为网页名称。 </p><p> 4） POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</p></li></ol><h5 id="二-常量定义"><a href="#二-常量定义" class="headerlink" title="(二) 常量定义"></a>(二) 常量定义</h5><ol><li><p>【强制】不允许任何魔法值（即未经预先定义的常量）直接出现在代码中。 </p><p>反例：String key = “Id#taobao_” + tradeId; cache.put(key, value);</p></li><li><p>【强制】在long或者Long赋值时，数值后使用大写的L，不能是小写的l，小写容易跟数字1混淆，造成误解。</p><p> 说明：Long a = 2l; 写的是数字的21，还是Long型的2?</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。</p><p>说明：大而全的常量类，杂乱无章，使用查找功能才能定位到修改的常量，不利于理解和维护。<br>正例：缓存相关常量放在类CacheConsts下；系统配置相关常量放在类ConfigConsts下。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。 </p><p>1） 跨应用共享常量：放置在二方库中，通常是client.jar中的constant目录下。 </p><p>2） 应用内共享常量：放置在一方库中，通常是子模块中的constant目录下。</p><p>反例：易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：            类A中：public static final String YES = “yes”;<br>类B中：public static final String YES = “y”; A.YES.equals(B.YES)，预期是true，但实际返回为false，导致线上问题。<br>3） 子工程内部共享常量：即在当前子工程的constant目录下。 </p><p>4） 包内共享常量：即在当前包下单独的constant目录下。</p><p>5） 类内共享常量：直接在类内部private static final定义。</p></li><li><p>【推荐】如果变量值仅在一个固定范围内变化用enum类型来定义。 说明：如果存在名称之外的延伸属性应使用enum类型，下面正例中的数字就是延伸信息，表示一年中的第几个季节。 </p><p>正例： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> SeasonEnum <span class="token punctuation">{</span>   <span class="token function">SPRING</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">SUMMER</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">AUTUMN</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">WINTER</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">private</span> <span class="token keyword">int</span> seq<span class="token punctuation">;</span>   <span class="token function">SeasonEnum</span><span class="token punctuation">(</span><span class="token keyword">int</span> seq<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>seq <span class="token operator">=</span> seq<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li></ol><h5 id="三-代码格式"><a href="#三-代码格式" class="headerlink" title="(三) 代码格式"></a>(三) 代码格式</h5><ol><li><p>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：</p><p> 1） 左大括号前不换行。 </p><p> 2） 左大括号后换行。</p><p> 3） 右大括号前换行。 </p><p> 4） 右大括号后还有else等代码则不换行；表示终止的右大括号后必须换行。</p></li><li><p>【强制】左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格；而左大括号前需要空格。详见第5条下方正例提示。 反例：if (空格a == b空格)</p></li><li><p>【强制】if/for/while/switch/do等保留字与括号之间都必须加空格。</p></li><li><p>【强制】任何二目、三目运算符的左右两边都需要加一个空格。 说明：运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p>【强制】采用4个空格缩进，禁止使用tab字符。<br>说明： 如果使用 tab 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 缩进，必须设置 1个 tab 为 4个空格。 IDEA 设置 tab 为 4个空格时， 请勿勾选 Use tab character ；而在 eclipse 中，必须勾选 insert spaces for tabs 。<br>正例： （涉及1-5点）</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 缩进4个空格</span>        String say <span class="token operator">=</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 运算符的左右必须有一个空格</span>        <span class="token keyword">int</span> flag <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 关键词if与括号之间必须有一个空格，括号内的f与左括号，0与右括号不需要空格</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>say<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 左大括号前加空格且不换行；左大括号后换行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"world"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 右大括号前换行，右大括号后有else，不用换行</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ok"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 在右大括号后直接结束，则必须换行</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><ol><li><p>【强制】注释的双斜线与内容之间有且仅一个空格。 </p><p>正例： // 这是示例注释，请注意在双斜线之后有一个空格 String ygb = new String(); </p></li><li><p>【强制】单行字符数限不超过 120 个，超出需要换行时 个，超出需要换行时 遵循如下原则：</p><p> 1） 第二行相对一缩进 4个空格，从第三行开始不再继续缩进参考示例。 </p><p> 2） 运算符与下文一起换行。 </p><p> 3） 方法调用的点符号与下文一起换行。</p><p> 4） 方法调用中的多个参数需要换行时，在逗号后进行。 </p><p> 5） 在括号前不要换行，见反例。 </p><p>正例：</p></li></ol><pre class=" language-java"><code class="language-java">StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 超过120个字符的情况下，换行缩进4个空格，点号和方法名称一起换行</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"zi"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"xin"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"huang"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"huang"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>  <span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"huang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>   反例：</p><pre class=" language-java"><code class="language-java">StringBuffer sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 超过120个字符的情况下，不要在括号前换行</span>sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"zi"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"xin"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"huang"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 参数很多的方法调用可能超过120个字符，不要在逗号前换行</span><span class="token function">method</span><span class="token punctuation">(</span>args1<span class="token punctuation">,</span> args2<span class="token punctuation">,</span> args3<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> argsX<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ol><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。 </p><p>正例：下例中实参的args1，后边必须要有一个空格。method(args1, args2, args3);</p></li><li><p>【强制】IDE的text file encoding设置为UTF-8; IDE中文件的换行符使用Unix格式，不要使用Windows格式。</p></li><li><p>【推荐】单个方法的总行数不超过 80 行。 </p><p>说明： 包括方法签名、结束右大号内代码注释空行回车及任何不可见字符的总行数不超过 80 行。<br>正例：代码逻辑分清红花和绿叶，个性和共性，绿叶逻辑单独出来成为额外方法，使主干代码更加清晰；共性逻辑抽取成为共性方法，便于复用和维护。</p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。 </p><p>正例：<br>int one = 1;<br>long two = 2L;<br>float three = 3F;<br>StringBuffer sb = new StringBuffer();<br>说明：增加sb这个变量，如果需要对齐，则给a、b、c都要增加几个空格，在变量比较多的情况下，是非常累赘的事情。</p></li><li><p>【推荐】不同逻辑、不同语义、不同业务的代码之间插入</p></li></ol></li></ol><h5 id="四-OOP规约"><a href="#四-OOP规约" class="headerlink" title="(四) OOP规约"></a>(四) OOP规约</h5><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加@Override注解。 </p><p>说明：getObject()与get0bject()的问题。一个是字母的O，一个是数字的0，加@Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用Java的可变参数，避免使用Object。</p><p> 说明：可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程） 正例：public List<user> listUsers(String type, Long… ids) {…}</user></p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加@Deprecated注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。 </p><p>说明：java.net.URLDecoder 中的方法decode(String encodeStr) 这个方法已经过时，应该使用双参数decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li><li><p>【强制】Object的equals方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。 </p><p>正例：”test”.equals(object); 反例：object.equals(“test”); </p><p>说明：推荐使用java.util.Objects#equals（JDK7引入的工具类）</p></li><li><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用equals方法比较。 说明：对于Integer var = ? 在-128至127范围内的赋值，Integer对象是在IntegerCache.cache产生，会复用已有对象，这个区间内的Integer值可以直接使用==进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用equals方法进行判断。</p></li><li><p>关于基本数据类型与包装数据类型的使用标准如下： </p><p>1） 【强制】所有的POJO类属性必须使用包装数据类型。</p><p>2） 【强制】RPC方法的返回值和参数必须使用包装数据类型 </p><p>3） 【推荐】所有的局部变量使用基本数据类型。 </p><p>说明：POJO类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE问题，或者入库检查，都由使用者来保证。 </p><p>正例：数据库的查询结果可能是null，因为自动拆箱，用基本数据类型接收有NPE风险。 </p><p>反例：比如显示成交总额涨跌情况，即正负x%，x为基本数据类型，调用的RPC服务，调用不成功时，返回的是默认值，页面显示为0%，这是不合理的，应该显示成中划线。所以包装数据类型的null值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p>【强制】定义DO/DTO/VO等POJO类时，不要设定任何属性默认值。</p><p> 反例：POJO类的gmtCreate默认值为new Date()，但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p>【强制】序列化类新增属性时，请不要修改serialVersionUID字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改serialVersionUID值。 </p><p>说明：注意serialVersionUID不一致会抛出序列化运行时异常。</p></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在init方法中。</p></li><li><p>【强制】POJO类必须写toString方法。使用IDE中的工具：source&gt; generate toString时，如果继承了另一个POJO类，注意在前面加一下super.toString。 说明：在方法执行抛出异常时，可以直接调用POJO的toString()方法打印其属性值，便于排查问题。</p></li><li><p>【强制】禁止在 POJO类中，同时存在对应属性 xxx的 isXxx()和 getXxx()方法。 </p><p>说明： 框架在调用属性 xxx 的提取方法时，并不能确定哪个一是被优先调用到。</p></li><li><p>【推荐】使用索引访问用String的split方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛IndexOutOfBoundsException的风险。<br>说明：<br>String str = “a,b,c,,”;<br>String[] ary = str.split(“,”);<br>// 预期大于3，结果是3<br>System.out.println(ary.length);</p></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读，此条规则优先于第16条规则。</p></li><li><p>【推荐】 类内方法定义的顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter方法。</p><p> 说明：公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为承载的信息价值较低，所有Service和DAO的getter/setter方法放在类体最后。</p></li><li><p>【推荐】setter方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在getter/setter方法中，不要增加业务逻辑，增加排查问题的难度。 </p><p>反例：</p><pre class=" language-java"><code class="language-java">   <span class="token keyword">public</span> Integer <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">-</span> <span class="token number">100</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span>   <span class="token punctuation">}</span></code></pre></li><li><p>【推荐】循环体内，字符串的连接方式，使用StringBuilder的append方法进行扩展。 说明：下例中，反编译出的字节码文件显示每次循环都会new出一个StringBuilder对象，然后进行append操作，最后通过toString方法返回String对象，造成内存资源浪费。<br>反例：</p><pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"start"</span><span class="token punctuation">;</span>       <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           str <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">"hello"</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre></li><li><p>【推荐】final可以声明类、成员变量、方法、以及本地变量，下列情况使用final关键字：</p><p>1） 不允许被继承的类，如：String类。</p><p>2） 不允许修改引用的域对象。 </p><p>3） 不允许被重写的方法，如：POJO类的setter方法。<br>4） 不允许运行过程中重新赋值的局部变量。</p><p>5） 避免上下文重复使用一个变量，使用final描述可以强制重新定义一个变量，方便更好地进行重构。</p></li><li><p>【推荐】慎用Object的clone方法来拷贝对象。</p><p> 说明：对象的clone方法默认是浅拷贝，若想实现深拷贝需要重写clone方法实现域对象的深度遍历式拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严： </p><p>1） 如果不允许外部直接通过new来创建对象，那么构造方法必须是private。</p><p>2） 工具类不允许有public或default构造方法。 </p><p>3） 类非static成员变量并且与子类共享，必须是protected。</p><p>4） 类非static成员变量并且仅在本类使用，必须是private。 </p><p>5） 类static成员变量如果仅在本类使用，必须是private。 </p><p>6） 若是static成员变量，考虑是否为final。 </p><p>7） 类成员方法只供类内部调用，必须是private。 </p><p>8） 类成员方法只对继承类公开，那么限制为protected。 说明：任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个private的方法，想删除就删除，可是一个public的service成员方法或成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，无限制的到处跑，那么你会担心的。</p></li></ol><h5 id="五-集合处理"><a href="#五-集合处理" class="headerlink" title="(五) 集合处理"></a>(五) 集合处理</h5><ol><li><p>【强制】关于hashCode和equals的处理，遵循如下规则：</p><p> 1） 只要重写equals，就必须重写hashCode。</p><p> 2） 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对象必须重写这两个方法。 </p><p>3） 如果自定义对象作为Map的键，那么必须重写hashCode和equals。 </p><p>说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。</p></li><li><p>【强制】 ArrayList的subList结果不可强转成ArrayList，否则会抛出ClassCastException异常，即java.util.RandomAccessSubList cannot be cast to java.util.ArrayList。 </p><p>说明：subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList而是ArrayList 的一个视图，对于SubList子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】在subList场景中，高度注意对原集合元素的增加或删除，均会导致子列表的遍历、增加、删除产生ConcurrentModificationException 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的toArray(T[] array)，传入的是类型完全一样的数组，大小就是list.size()。<br>说明：使用toArray带参方法，入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为[ list.size() ]的数组元素将被置为null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 正例：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"guan"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"bao"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>array <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>反例：直接使用toArray无参方法存在问题，此方法返回值只能是Object[]类，若强转其它类型数组将出现ClassCastException错误。</p></li><li><p>【强制】使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportedOperationException异常。 说明：asList的返回对象是一个Arrays内部类，并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { “you”, “wu” }; List list = Arrays.asList(str); 第一种情况：list.add(“yangguanbao”); 运行时异常。 第二种情况：str[0] = “gujin”; 那么list.get(0)也会随之修改。</p></li><li><p>【强制】泛型通配符&lt;? extends T&gt;来接收返回的数据，此写法的泛型集合不能使用add方法，而&lt;? super T&gt;不能使用get方法，作为接口调用赋值时易出错。</p><p> 说明：扩展说一下PECS(Producer Extends Consumer Super)原则：第一、频繁往外读取内容的，适合用&lt;? extends T&gt;。第二、经常往里插入的，适合用&lt;? super T&gt;。</p></li><li><p>【强制】不要在foreach循环里进行元素的remove/add操作。remove元素请使用Iterator方式，如果并发操作，需要对Iterator对象加锁。<br>正例：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator<span class="token operator">&lt;</span>String<span class="token operator">></span> iterator <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   String item <span class="token operator">=</span> iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>删除元素的条件<span class="token punctuation">)</span> <span class="token punctuation">{</span>   iterator<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>反例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span> <span class="token punctuation">(</span>String item <span class="token operator">:</span> list<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   list<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>说明：以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p>【强制】 在JDK7版本及以上，Comparator实现类要满足如下三个条件，不然Arrays.sort，Collections.sort会报IllegalArgumentException异常。 说明：三个条件如下 </p><p>1） x，y的比较结果和y，x的比较结果相反。</p><p>2） x&gt;y，y&gt;z，则x&gt;z。 </p><p>3） x=y，则x，z比较结果和y，z比较结果相同。 </p><p>反例：下例中没有处理相等的情况，实际使用中可能会出现异常：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token operator">&lt;</span>Student<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token annotation punctuation">@Override</span>           <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Student o1<span class="token punctuation">,</span> Student o2<span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">return</span> o1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> o2<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre></li><li><p>【推荐】集合泛型定义时，在JDK7及以上，使用diamond语法或全省略。<br>说明：菱形泛型，即diamond，直接使用&lt;&gt;来指代前边已经指定的类型。<br>正例：<br>// &lt;&gt; diamond方式<br>HashMap&lt;String, String&gt; userCache = new HashMap&lt;&gt;(16);<br>// 全省略方式<br>ArrayList<user> users = new ArrayList(10);</user></p></li><li><p>【推荐】集合初始化时，指定集合初始值大小。 </p><p>说明：HashMap使用HashMap(int initialCapacity) 初始化。 正例：initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意 负载因子（即loader factor）默认为 0.75，如果 暂时无法 确定 初始值大小，请设置为 16（即默认值）。 </p><p>反例： HashMap需要 放置 1024个元素， 由于 没有设置容量 初始大小，随着元素不断增加容 量 7次被迫扩大， resize需要重建 hash表，严重影响性能。 表，严重影响性能。</p></li><li><p>【推荐】使用entrySet遍历Map类集合KV，而不是keySet方式进行遍历。</p><p>说明：keySet其实是遍历了2次，一次是转为Iterator对象，另一次是从hashMap中取出key所对应的value。而entrySet只是遍历了一次就把key和value都放到了entry中，效率更高。如果是JDK8，使用Map.foreach方法。 </p><p>正例：values()返回的是V值集合，是一个list集合对象；keySet()返回的是K值集合，是一个Set集合对象；entrySet()返回的是K-V值组合集合。</p></li><li><p>【推荐】高度注意Map类集合K/V能不能存储null值的情况，如下表格：</p><p>| 集合类               | Key      | Value    | Super       | 说明              |<br>| —————– | ——– | ——– | ———– | ————— |<br>| Hashtable         | 不允许为null | 不允许为null | Dictionary  | 线程安全            |<br>| ConcurrentHashMap | 不允许为null | 不允许为null | AbstractMap | 锁分段技术（JDK8:CAS） |<br>| TreeMap           | 不允许为null | 允许为null  | AbstractMap | 线程不安全           |<br>| HashMap           | 允许为null  | 允许为null  | AbstractMap | 线程不安全           |</p></li><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。 </p><p>说明：有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如：ArrayList是order/unsort；HashMap是unorder/unsort；TreeSet是order/sort。</p></li><li><p>【参考】利用Set元素唯一的特性，可以快速对一个集合进行去重操作，避免使用List的contains方法进行遍历、对比、去重操作。</p></li></ol><h5 id="六-并发处理"><a href="#六-并发处理" class="headerlink" title="(六) 并发处理"></a>(六) 并发处理</h5><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。 说明：资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。 </p><p>正例：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TimerTaskThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>           <span class="token keyword">public</span> <span class="token function">TimerTaskThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"TimerTaskThread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span></code></pre></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。 </p><p>说明：使用线程池的好处是减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></li><li><p>【强制】线程池不允许使用 Executors去创建，而是通过 去创建，而是通过 去创建，而是通过 ThreadPoolExecutor的方式，这样 的方式，这样 的处理方式让写同学更加明确线程池运行规则，避资源耗尽风险。 </p><p>说明： Executors返回的线程池对象 的弊端 如下 ： </p><p> 1）FixedThreadPool和 SingleThreadPoolPool : 允许的请求队列长度为 Integer.MAX_VALUE，可 能会堆积大量的请求，从而导致 OOM。</p><p> 2）CachedThreadPool和ScheduledThreadPool : 允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。</p></li><li><p>【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为static变量，如果定义为static，必须加锁，或者使用DateUtils工具类。</p><p>正例：注意线程安全，使用DateUtils。亦推荐如下处理：</p><pre class=" language-java"><code class="language-java">  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>DateFormat<span class="token operator">></span> df <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>DateFormat<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token annotation punctuation">@Override</span>           <span class="token keyword">protected</span> DateFormat <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SimpleDateFormat</span><span class="token punctuation">(</span><span class="token string">"yyyy-MM-dd"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>说明：如果是JDK8的应用，可以使用Instant代替Date，LocalDateTime代替Calendar，DateTimeFormatter代替SimpleDateFormat，官方给出的解释：simple beautiful strong immutable thread-safe。</p></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。</p><p> 说明：尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用RPC方法。</p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。 </p><p>说明：线程一需要对表A、B、C依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是A、B、C，否则可能出现死锁。</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用version作为更新依据。 说明：如果每次访问冲突概率小于20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于3次。</p></li><li><p>【强制】多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用ScheduledExecutorService则没有这个问题。</p></li><li><p>【推荐】使用CountDownLatch进行异步转同步操作，每个线程退出前必须调用countDown方法，线程执行代码注意catch异常，确保countDown方法被执行到，避免主线程无法执行至await方法，直到超时才返回结果。 说明：注意，子线程抛出异常堆栈，不能在主线程try-catch到。</p></li><li><p>【推荐】避免Random实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一seed 导致的性能下降。<br>说明：Random实例包括java.util.Random 的实例或者 Math.random()的方式。 正例：在JDK7之后，可以直接使用API ThreadLocalRandom，而在 JDK7之前，需要编码保证每个线程持有一个实例。</p></li><li><p>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐解决方案中较为简单一种（适用于JDK5及以上版本），将目标属性声明为 volatile型。</p><p>反例：</p><pre class=" language-java"><code class="language-java">     <span class="token keyword">class</span> <span class="token class-name">LazyInitDemo</span> <span class="token punctuation">{</span>           <span class="token keyword">private</span> Helper helper <span class="token operator">=</span> null<span class="token punctuation">;</span>           <span class="token keyword">public</span> Helper <span class="token function">getHelper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token punctuation">(</span>helper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                   <span class="token keyword">if</span> <span class="token punctuation">(</span>helper <span class="token operator">==</span> null<span class="token punctuation">)</span>                       helper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Helper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token punctuation">}</span>               <span class="token keyword">return</span> helper<span class="token punctuation">;</span>           <span class="token punctuation">}</span>       <span class="token comment" spellcheck="true">// other methods and fields...</span>       <span class="token punctuation">}</span></code></pre></li><li><p>【参考】volatile解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是JDK8，推荐使用LongAdder对象，比AtomicLong性能更好（减少乐观锁的重试次数）。</p></li><li><p>【参考】 HashMap在容量不够进行resize时由于高并发可能出现死链，导致CPU飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</p></li><li><p>【参考】ThreadLocal无法解决共享对象的更新问题，ThreadLocal对象建议使用static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量 ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p></li></ol><h5 id="七-控制语句"><a href="#七-控制语句" class="headerlink" title="(七) 控制语句"></a>(七) 控制语句</h5><ol><li><p>【强制】在一个switch块内，每个case要么通过break/return等来终止，要么注释说明程序将继续执行到哪一个case为止；在一个switch块内，都必须包含一个default语句并且放在最后，即使空代码。</p></li><li><p>【强制】在if/else/for/while/do语句中必须使用大括号。即使只有一行代码，避免采用单行的编码方式：if (condition) statements;</p></li><li><p>【强制】在高并发场景中，避免使用 ”等于 ”判断作为中或退出的条件。 判断作为中或退出的条件。 </p><p>说明： 如果并发控制没有处理好，容易产生等值判断被 如果并发控制没有处理好，容易产生等值判断被 “击穿 ”的情况，使用大于或小区间 的情况，使用大于或小区间 的情况，使用大于或小区间 的情况，使用大于或小区间 判断条件来代替。 反例： 判断剩余奖品数量等于 0时，终止发放奖品但因为并处理错误导致数量瞬间变 时，终止发放奖品但因为并处理错误导致数量瞬间变 时，终止发放奖品但因为并处理错误导致数量瞬间变 成了负数， 这样的话，活动无法终止。</p></li><li><p>【推荐】表达异常的分支时，少用if-else方式，这种方式可以改写成：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>condition<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 接着写else的业务逻辑代码;</span></code></pre><p>说明：如果非得使用if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过3层。<br>正例：超过3层的 if-else 的逻辑判断代码可以使用卫语句、策略模式、状态模式等来实现，其中卫语句示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">today</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isBusy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“change time<span class="token punctuation">.</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">return</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isFree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“go to travel<span class="token punctuation">.</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>               <span class="token keyword">return</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>           System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>“stay at home to learn Alibaba Java Coding Guidelines<span class="token punctuation">.</span>”<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">return</span><span class="token punctuation">;</span>       <span class="token punctuation">}</span></code></pre></li><li><p>【推荐】除常用方法（如getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。 说明：很多if语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 正例：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 伪代码如下</span><span class="token keyword">final</span> <span class="token keyword">boolean</span> existed <span class="token operator">=</span> <span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>existed<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><p>反例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>file<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token string">"w"</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的try-catch操作（这个try-catch是否可以移至循环体外）。 7. 【推荐】避免采用取反逻辑运算符。 说明： 取反逻辑不利于快速理解，并且写法必然存在对应的正向。</p></li><li><p>正例： 使用 if (x &lt; 628) if (x &lt; 628) if (x &lt; 628) 来表达 x 小于 628 。</p><p>反例： 使用 if (!(x &gt;= 628)) if (!(x &gt;= 628)) if (!(x &gt;= 628)) 来表达 x 小于 628 。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用作批量操作的接口。</p></li><li><p>【参考】下列情形，需要进行参数校验： </p><p>1） 调用频次低的方法。 </p><p>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。 </p><p>3） 需要极高稳定性和可用性的方法。 </p><p>4） 对外提供的开放接口，不管是RPC/API/HTTP接口。<br>5） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验： </p><p>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。 </p><p>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般DAO层与Service层都在同一个应用中，部署在同一台服务器中，所以DAO的参数校验，可以省略。 </p><p>3） 被声明成private只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h5 id="八-注释规约"><a href="#八-注释规约" class="headerlink" title="(八) 注释规约"></a>(八) 注释规约</h5><ol><li><p>【强制】类、类属性、类方法的注释必须使用Javadoc规范，使用/*<em>内容</em>/格式，不得使用// xxx方式。 </p><p>说明：在IDE编辑窗口中，Javadoc方式会提示相关注释，生成Javadoc可以正确输出相应注释；在IDE中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。</p></li><li><p>【强制】所有的抽象方法（包括接口中的方法）必须要用Javadoc注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。 </p><p>说明：对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用//注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。 反例：“TCP连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。 </p><p>说明：代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。</p></li><li><p>【参考】谨慎注释掉代码。在上方详细说明，而不是简单地注释掉。如果无用，则删除。</p><p> 说明：代码被注释掉有两种可能性：</p><p>1）后续会恢复此段代码逻辑。</p><p>2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。</p><p>反例：<br>// put elephant into fridge<br>put(elephant, fridge);<br>方法名put，加上两个有意义的变量名elephant和fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。 </p><p>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]） 表示需要实现，但目前还未实现的功能。这实际上是一个Javadoc的标签，目前的Javadoc还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个Javadoc标签）。</p><p>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]） 在注释中用FIXME标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol><h5 id="九-其它"><a href="#九-其它" class="headerlink" title="(九) 其它"></a>(九) 其它</h5><ol><li><p>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。 </p><p>说明：不要在方法体内定义：Pattern pattern = Pattern.compile(“规则”);</p></li><li><p>【强制】velocity调用POJO类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用POJO的getXxx()，如果是boolean基本数据类型变量（boolean命名不需要加is前缀），会自动调用isXxx()方法。 说明：注意如果是Boolean包装类对象，优先调用getXxx()的方法。</p></li><li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。 说明：如果var等于null或者不存在，那么${var}会直接显示在页面上。</p></li><li><p>【强制】注意 Math.random() 这个方法返回是double类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将x放大10的若干倍然后取整，直接使用Random对象的nextInt或者nextLong方法。</p></li><li><p>【强制】获取当前毫秒数System.currentTimeMillis(); 而不是new Date().getTime(); </p><p>说明：如果想获取更加精确的纳秒级时间值，使用System.nanoTime()的方式。在JDK8中，针对统计时间等场景，推荐使用Instant类。</p></li><li><p>【推荐】不要在视图模板中加入任何复杂的逻辑。 </p><p>说明：根据MVC理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p>【推荐】及时清理不再使用的代码段或配置信息。<br>说明：对于垃圾代码或过时配置，坚决清理干净，避免程序过度臃肿，代码冗余。<br>正例：对于暂时被注释掉，后续可能恢复使用的代码片断，在注释代码上方，统一规定使用三个斜杠(///)来说明注释掉代码的理由。</p></li></ol><h4 id="二、异常日志"><a href="#二、异常日志" class="headerlink" title="二、异常日志"></a>二、异常日志</h4><h5 id="一-异常处理"><a href="#一-异常处理" class="headerlink" title="(一) 异常处理"></a>(一) 异常处理</h5><ol><li><p>【强制】Java 类库中定义的可以通过预检查方式规避的RuntimeException异常不应该通过catch 的方式来处理，比如：NullPointerException，IndexOutOfBoundsException等等。 </p><p>说明：无法通过预检查的异常除外，比如，在解析字符串形式的数字时，不得不通过catch NumberFormatException来实现。 </p><p>正例：if (obj != null) {…} </p><p>反例：try { obj.method(); } catch (NullPointerException e) {…} </p></li><li><p>【强制】异常不要用来做流程控制，条件控制。</p><p> 说明：异常设计的初衷是解决程序运行中的各种意外情况，且异常的处理效率比条件判断方式要低很多</p></li><li><p>【强制】catch时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的catch尽可能进行区分异常类型，再做对应的异常处理。 </p><p>说明：对大段代码进行try-catch，使程序无法根据不同的异常做出正确的应激反应，也不利于定位问题，这是一种不负责任的表现。</p><p> 正例：用户注册的场景中，如果用户输入非法字符，或用户名称已存在，或用户输入密码过于简单，在程序上作出分门别类的判断，并提示给用户</p></li><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>【强制】有try块放到了事务代码中，catch异常后，如果需要回滚事务，一定要注意手动回滚事务。</p></li><li><p>【强制】finally块必须对资源对象、流对象进行关闭，有异常也要做try-catch。 说明：如果JDK7及以上，可以使用try-with-resources方式。</p></li><li><p>【强制】不要在 finally块中使用 return。 说明： finally块中的 return返回后方法结束执行 ，不会再返回后方法结束执行 ，不会再try块中的 return语句。 语句。</p></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。 说明：如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【推荐】方法的返回值可以为null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回null值。 说明：本手册明确防止NPE是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回null的情况。</p></li><li><p>【推荐】防止NPE，是程序员的基本修养，注意NPE产生的场景： </p><p>1）返回类型为基本数据类型，return包装数据类型的对象时，自动拆箱有可能产生NPE。 反例：public int f() { return Integer对象}， 如果为null，自动解箱抛NPE。 </p><p>2） 数据库的查询结果可能为null。 </p><p>3） 集合里的元素即使isNotEmpty，取出的数据元素也可能为null。 </p><p>4） 远程调用返回对象时，一律要求进行空指针判断，防止NPE。 </p><p>5） 对于Session中获取的数据，建议NPE检查，避免空指针。 </p><p>6） 级联调用obj.getA().getB().getC()；一连串调用，易产生NPE。</p><p>正例：使用JDK8的Optional类来防止NPE问题</p></li><li><p>【推荐】定义时区分unchecked / checked 异常，避免直接抛出new RuntimeException()，更不允许抛出Exception或者Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException等。</p></li><li><p>【参考】对于公司外的http/api开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间RPC调用优先考虑使用Result方式，封装isSuccess()方法、“错误码”、“错误简短信息”。 </p><p>说明：关于RPC方法返回方式使用Result方式的理由：</p><p> 1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。 </p><p> 2）如果不加栈信息，只是new自定义异常，加入自己的理解的error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即DRY原则。 说明：随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是组件化。 正例：一个类中有多个public方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br>private boolean checkParam(DTO dto) {…}</p></li></ol><h5 id="二-日志规约"><a href="#二-日志规约" class="headerlink" title="(二) 日志规约"></a>(二) 日志规约</h5><ol><li><p>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>Logger<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>slf4j<span class="token punctuation">.</span>LoggerFactory<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Abc<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><ol start="2"><li><p>【强制】日志文件至少保存15天，因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式appName_logType_logName.log。<br>logType:日志类型，如stats/monitor/access等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。 </p><p>正例：mppserver应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log 说明：推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。</p></li><li><p>【强制】对trace/debug/info级别的日志输出，必须使用条件输出形式或者使用占位符的方式。</p><p> 说明：logger.debug(“Processing trade with id: “ + id + “ and symbol: “ + symbol); 如果日志级别是warn，上述日志不会打印，但是会执行字符串拼接操作，如果symbol是对象，会执行toString()方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 </p><p>正例：（条件）建设采用如下方式</p><pre class=" language-java"><code class="language-java"><span class="token keyword">if</span> <span class="token punctuation">(</span>logger<span class="token punctuation">.</span><span class="token function">isDebugEnabled</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>logger<span class="token punctuation">.</span><span class="token function">debug</span><span class="token punctuation">(</span><span class="token string">"Processing trade with id: "</span> <span class="token operator">+</span> id <span class="token operator">+</span> <span class="token string">" and symbol: "</span> <span class="token operator">+</span> symbol<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>正例：（占位符）<br>logger.debug(“Processing trade with id: {} and symbol : {} “, id, symbol);</p></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml中设置additivity=false。 </p><p>正例：<logger name="com.taobao.dubbo.config" additivity="false"></logger></p></li><li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字throws往上抛出。 正例：logger.error(各类参数或者对象toString() + “_” + e.getMessage(), e);</p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出debug日志；有选择地输出info日志；如果使用warn来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。 </p><p>说明：大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></li><li><p>【推荐】可以使用 warnwarn warn日志级别来记录用户输入参数错误的情况，避免投诉时无所适 从。如非必要，请不在此场景打出 errorerror errorerror级别，避免频繁报警。 级别，避免频繁报警。 说明： 注意日志输出的级别， errorerror errorerror级别只记录系统逻辑出错、异常 级别只记录系统逻辑出错、异常 或者重要的错误信息。 </p></li><li><p>【推荐】尽量用 英文来描述日志错误信息，如果中的不清楚话使【推荐】尽量用 英文来描述日志错误信息，如果中的不清楚话使【推荐】尽量用 英文来描述日志错误信息，如果中的不清楚话使中文描述即可，否则容易产生歧义 中文描述即可，否则容易产生歧义 中文描述即可，否则容易产生歧义 。国际化团队或海外部署的服务器由于字符集问题，【强制】 国际化团队或海外部署的服务器由于字符集问题，【强制】 国际化团队或海外部署的服务器由于字符集问题，【强制】 国际化团队或海外部署的服务器由于字符集问题，【强制】使用全英文来注释和描叙日志错误信息。</p></li></ol><h4 id="三、单元测试"><a href="#三、单元测试" class="headerlink" title="三、单元测试"></a>三、单元测试</h4><ol><li><p>【强制】好的单元测试必须遵守AIR原则。 </p><p>说明：单元测试在线上运行时，感觉像空气（AIR）一样并不存在，但在测试质量的保障上，却是非常关键的。好的单元测试宏观上来说，具有自动化、独立性、可重复执行的特点。 </p><ul><li>A：Automatic AutomaticAutomatic Automatic Automatic （自动化） （自动化） </li><li>I：Independent IndependentIndependent Independent Independent Independent （独立性） （独立性） </li><li>R：Repeatable RepeatableRepeatable Repeatable Repeatable Repeatable（可重复） （可重复）</li></ul></li><li><p>【强制】单元测试应该是全自动执行的，并且非交互式的。测试用例通常是被定期执行的，执行过程必须完全自动化才有意义。输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用System.out来进行人肉验证，必须使用assert来验证。</p></li><li><p>【强制】保持单元测试的独立性。为了保证单元测试稳定可靠且便于维护，单元测试用例之间决不能互相调用，也不能依赖执行的先后次序。 </p><p>反例：method2需要依赖method1的执行，将执行结果作为method2的输入。</p></li><li><p>【强制】单元测试是可以重复执行的，不能受到外界环境的影响。 说明：单元测试通常会被放到持续集成中，每次有代码check in时单元测试都会被执行。如果单测对外部环境（网络、服务、中间件等）有依赖，容易导致持续集成机制的不可用。</p><p>正例：为了不受外界环境影响，要求设计代码时就把SUT的依赖改成注入，在测试时用spring 这样的DI框架注入一个本地（内存）实现或者Mock实现。</p></li><li><p>【强制】对于单元测试，要保证测试粒度足够小，有助于精确定位问题。单测粒度至多是类级别，一般是方法级别。 </p><p>说明：只有测试粒度小才能在出错时尽快定位到出错位置。单测不负责检查跨类或者跨系统的交互逻辑，那是集成测试的领域。</p></li><li><p>【强制】核心业务、核心应用、核心模块的增量代码确保单元测试通过。 </p><p>说明：新增代码及时补充单元测试，如果新增代码影响了原有单元测试，请及时修正。</p></li><li><p>【强制】单元测试代码必须写在如下工程目录：src/test/java，不允许写在业务代码目录下。 </p><p>说明：源码构建时会跳过此目录，而单元测试框架默认是扫描此目录。</p></li><li><p>【推荐】单元测试的基本目标：语句覆盖率达到70%；核心模块的语句覆盖率和分支覆盖率都要达到100% </p><p>说明：在工程规约的应用分层中提到的DAO层，Manager层，可重用度高的Service，都应该进行单元测试。</p></li><li><p>【推荐】编写单元测试代码遵守BCDE原则，以保证被测试模块的交付质量。 </p><ul><li>B：Border，边界值测试，包括循环、特殊取时间点数据顺序等。 ，边界值测试包括循环、特殊取时间点数据顺序等。 </li><li>C：Correct，正确的输入，并得到预期结果。 ，正确的输入并得到预期结果。 </li><li>D：Design，与设计文档相结合，来编写单元测试。 ，与设计文档相结合来编写单元测试。 </li><li>E：Error，强制错误信息输入（如：非法数据、异常流程业务允许等），并得 到预期的结果。 </li></ul></li><li><p>【推荐】对于数据库相关的查询，更新，删除等操作，不能假设数据库里的数据是存在的，或者直接操作数据库把数据插入进去，请使用程序插入或者导入数据的方式来准备数据。 </p><p>反例：删除某一行数据的单元测试，在数据库中，先直接手动增加一行作为删除目标，但是这一行新增数据并不符合业务插入规则，导致测试结果异常。</p></li><li><p>【推荐】和数据库相关的单元测试，可以设定自动回滚机制，不给数据库造成脏数据。或者对单元测试产生的数据有明确的前后缀标识。 </p><p>正例：在RDC内部单元测试中，使用RDC_UNIT_TEST_的前缀标识数据。 </p></li><li><p>【推荐】对于不可测的代码建议做必要的重构，使代码变得可测，避免为了达到测试要求而书写不规范测试代码。 </p></li><li><p>【推荐】在设计评审阶段，开发人员需要和测试人员一起确定单元测试范围，单元测试最好覆盖所有测试用例。 </p></li><li><p>【推荐】单元测试作为一种质量保障手段，不建议项目发布后补充单元测试用例，建议在项目提测前完成单元测试。 </p></li><li><p>【参考】为了更方便地进行单元测试，业务代码应避免以下情况： </p><ul><li><p>构造方法中做的事情过多。 </p></li><li><p>存在过多的全局 变量 和静态方法。  </p></li><li><p>存在过多的外部依赖。 </p></li><li><p>存在过多的条件语句。 </p><p>说明： 多层条件语句建议使用卫、策略模式状态等方重构。 </p></li></ul></li><li><p>【参考】不要对单元测试存在如下误解： </p><ul><li>那是测试同学干的事情。本文开发 手册 ，凡是本文内容都与开发同学强相关的。 </li><li>单元测试代码是多余的。 系统 的整体功能 与各单元部件的测试正常否是强相关。 </li><li>单元测试代码不需要维护。 一年半载后，那么几乎处于废弃状态</li><li>单元测试与线上故障没有辩证关系，好的单元测试能够最大限度地规避线上故障。</li></ul></li></ol><h4 id="四、安全规约"><a href="#四、安全规约" class="headerlink" title="四、安全规约"></a>四、安全规约</h4><ol><li><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。 </p><p>说明：防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。</p></li><li><p>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。</p><p> 说明：中国大陆个人手机号码显示为:1589119，隐藏中间4位，防止隐私泄露。</p></li><li><p>【强制】用户输入的SQL参数严格使用参数绑定或者METADATA字段值限定，防止SQL注入，禁止字符串拼接SQL访问数据库。</p></li><li><p>【强制】用户请求传入的任何参数必须做有效性验证。 说明：忽略参数校验可能导致：</p><ul><li><p>page size过大导致内存溢出</p></li><li><p>恶意order by导致数据库慢查询</p></li><li><p>任意重定向</p></li><li><p>SQL注入</p></li><li><p>反序列化注入</p></li><li><p>正则输入源串拒绝服务ReDoS </p><p>说明： Java JavaJava代码用 代码用 正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的 结果。</p></li></ul></li><li><p>【强制】禁止向HTML页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>【强制】表单、AJAX提交必须执行CSRF安全验证。 </p><p>说明：CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF漏洞的应用/网站，攻击者可以事先构造好URL，只要受害者用户一访问，后台便在用户不知情的情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。 说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。</p></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。</p></li></ol><h4 id="五、MySQL数据库"><a href="#五、MySQL数据库" class="headerlink" title="五、MySQL数据库"></a>五、MySQL数据库</h4><h5 id="一-建表规约"><a href="#一-建表规约" class="headerlink" title="(一) 建表规约"></a>(一) 建表规约</h5><ol><li><p>【强制】表达是与否概念的字段，必须使用 【强制】表达是与否概念的字段，必须使用 【强制】表达是与否概念的字段，必须使用 is_xxx的方式命名，数据类型是 的方式命名，数据类型是 的方式命名，数据类型是 unsigned tinyint（1表示是， 0表示否）。 表示否）。</p><p> 说明： 任何字段如果为非负数，必须是 unsigned。 </p><p> 注意： POJO类中的任何布尔型变量，都不要加 类中的任何布尔型变量，都不要加 类中的任何布尔型变量，都不要加 is前缀，所以需要在 前缀，所以需要在 前缀，所以需要在 前缀，所以需要在 <resultmap>设置 从 is_xxx到 Xxx的映射关系。数据库表示是与否值，使用 的映射关系。数据库表示是与否值，使用 tinyint类型，坚持 is_xxx的 命名方式是为了明确其取值含义与范围。 </resultmap></p><p>正例： 表达逻辑删除的字段名 is_deleted，1表示删除， 0表示未删除。</p></li><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。 </p><p>说明： MySQL在 Windows下不区分大小写，但在 下不区分大小写，但在 下不区分大小写，但在 LinuxLinux Linux下默认是区分大小写。因此，数据库名、 下默认是区分大小写。因此，数据库名、 下默认是区分大小写。因此，数据库名、 表名、字段，都不允许出现任何大写母避免节外生枝。 </p><p>正例：aliyun_admin，rdc_config，level3_name </p><p>反例：AliyunAdmin，rdcConfig，level_3_name</p></li><li><p>【强制】表名不使用复数名词。 说明：表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于DO类名也是单数形式，符合表达习惯。</p></li><li><p>【强制】禁用保留字，如desc、range、match、delayed等，请参考MySQL官方保留字。</p></li><li><p>【强制】主键索引名为pk_字段名；唯一索引名为uk_字段名；普通索引名则为idx_字段名。 说明：pk_ 即primary key；uk_ 即 unique key；idx_ 即index的简称。</p></li><li><p>【强制】小数类型为decimal，禁止使用float和double。 </p><p>说明：float和double在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过decimal的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用char定长字符串类型。</p></li><li><p>【强制】varchar是可变长字符串，不预先分配存储空间，长度不要超过5000，如果存储长度大于此值，定义字段类型为text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。</p><p>说明： 其中 id必为 主键，类型必为 主键，类型bigint unsigned、单表时自增步长为 、单表时自增步长为 1。gmt_create, gmt_modified的类型均为 的类型均为 datetime类型，前者现在时表示主动创建后过去分词被 类型，前者现在时表示主动创建后过去分词被 动更新。</p></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。 正例：alipay_task / force_project / trade_config</p></li><li><p>【推荐】库名与应用名称尽量一致。</p></li><li><p>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：</p><p> 1）不是频繁修改的字段。 </p><p> 2）不是varchar超长字段，更不能是text字段。</p><p> 正例：商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。</p></li><li><p>【推荐】单表行数超过500万行或者单表容量超过2GB，才推荐进行分库分表。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。</p><p>正例：如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p></li></ol><table><thead><tr><th>对象</th><th>年龄区间</th><th>类型</th><th>字节</th><th>表示范围</th></tr></thead><tbody><tr><td>人</td><td>150岁之内</td><td>tinyint unsigned</td><td>1</td><td>无符号值：0到255</td></tr><tr><td>龟</td><td>数百岁</td><td>smallint unsigned</td><td>2</td><td>无符号值：0到65535</td></tr><tr><td>恐龙化石</td><td>数千万年</td><td>int unsigned</td><td>4</td><td>无符号值：0到约42.9亿</td></tr><tr><td>太阳</td><td>约50亿年</td><td>bigint unsigned</td><td>8</td><td>无符号值：0到约10的19次方</td></tr></tbody></table><h5 id="二-索引规约"><a href="#二-索引规约" class="headerlink" title="(二) 索引规约"></a>(二) 索引规约</h5><ol><li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。 </p><p>说明：不要以为唯一索引影响了insert速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p>【强制】超过三个表禁止join。需要join的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。 说明：即使双表join也要注意表索引、SQL性能。</p></li><li><p>【强制】在varchar字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。</p><p>说明：索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为20的索引，区分度会高达90%以上，可以使用count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p></li><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。 </p><p>说明：索引文件具有B-Tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>【推荐】如果有order by的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现file_sort的情况，影响查询性能。 </p><p>正例：where a=? and b=? order by c; 索引：a_b_c 反例：索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引a_b无法排序。</p></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。 </p><p>说明：如果一本书需要知道第11章是什么标题，会翻开第11章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。 </p><p>正例：能够建立索引的种类分为主键索引、唯一索引、普通索引三种，而覆盖索引只是一种查询的一种效果，用explain的结果，extra列会出现：using index。</p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。 </p><p>说明：MySQL并不是跳过offset行，而是取offset+N行，然后返回放弃前offset行，返回N行，那当offset特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行SQL改写。 </p><p>正例：先快速定位需要获取的id段，然后再关联： SELECT a.* FROM 表1 a, (select id from 表1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p></li><li><p>【推荐】 SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是consts最好。 </p><p>说明：</p><p> 1）consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 </p><p> 2）ref 指的是使用普通的索引（normal index）。 </p><p> 3）range 对索引进行范围检索。</p><p> 反例：explain表的结果，type=index，索引物理文件全扫描，速度非常慢，这个index级别比较range还低，与全表扫描是小巫见大巫。</p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。 </p><p>正例：如果where a=? and b=? ，如果a列的几乎接近于唯一值，那么只需要单建idx_a索引即可。 </p><p>说明：存在非等号和等号混合时，在建索引时，请把等号条件的列前置。如：where c&gt;? and d=? 那么即使c的区分度更高，也必须把d放在索引的最前列，即索引idx_d_c。</p></li><li><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p>【参考】创建索引时避免有如下极端误解： </p><p>1）宁滥勿缺。认为一个查询就需要建一个索引。 </p><p>2）宁缺勿滥。认为索引会消耗空间、严重拖慢更新和新增速度。 </p><p>3）抵制惟一索引。认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h5 id="三-SQL语句"><a href="#三-SQL语句" class="headerlink" title="(三) SQL语句"></a>(三) SQL语句</h5><ol><li><p>【强制】不要使用count(列名)或count(常量)来替代count(<em>)，count(</em>)是SQL92定义的标准统计行数的语法，跟数据库无关，跟NULL和非NULL无关。 说明：count(*)会统计值为NULL的行，而count(列名)不会统计此列为NULL值的行。</p></li><li><p>【强制】count(distinct col) 计算该列除NULL之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为NULL，那么即使另一列有不同的值，也返回为0。</p></li><li><p>【强制】当某一列的值全是NULL时，count(col)的返回结果为0，但sum(col)的返回结果为NULL，因此使用sum()时需注意NPE问题。 正例：可以使用如下方式来避免sum的NPE问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p></li><li><p>【强制】使用ISNULL()来判断是否为NULL值。 </p><p>说明：NULL与任何值的直接比较都为NULL。</p><p> 1） NULL&lt;&gt;NULL的返回结果是NULL，而不是false。</p><p> 2） NULL=NULL的返回结果是NULL，而不是true。 </p><p>3） NULL&lt;&gt;1的返回结果是NULL，而不是true。</p></li><li><p>【强制】 在代码中写分页查询逻辑时，若count为0应直接返回，避免执行后面的分页语句。</p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。 </p><p>说明：以学生和成绩的关系为例，学生表中的student_id是主键，那么成绩表中的student_id则为外键。如果更新学生表中的student_id，同时触发成绩表中的student_id更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p>【强制】数据订正（特别是删除、修改记录操作）时，要先select，避免出现误删除，确认无误才能执行更新语句。</p></li><li><p>【推荐】in操作能避免则避免，若实在避免不了，需要仔细评估in后边的集合元素数量，控制在1000个之内。</p></li><li><p>【参考】如果有国际化需要，所有的字符存储与表示，均以utf-8编码，注意字符统计函数的区别。</p><p> 说明： SELECT LENGTH(“轻松工作”)； 返回为12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为4 如果需要存储表情，那么选择utf8mb4来进行存储，注意它与utf-8编码的区别。</p></li><li><p>【参考】 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但TRUNCATE无事务且不触发trigger，有可能造成事故，故不建议在开发代码中使用此语句。 </p><p>说明：TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h5 id="四-ORM映射"><a href="#四-ORM映射" class="headerlink" title="(四) ORM映射"></a>(四) ORM映射</h5><ol><li><p>【强制】在表查询中，一律不要使用 * 作为查询的字段列表，需要哪些字段必须明确写明。</p><p> 说明：</p><p>1）增加查询分析器解析成本。</p><p>2）增减字段容易与resultMap配置不一致。</p><p>3）无用字段增加网络消耗，尤其是text类型的字段。</p></li><li><p>【强制】POJO类的布尔属性不能加is，而数据库字段必须加is_，要求在resultMap中进行字段与属性之间的映射。 </p><p>说明：参见定义POJO类以及数据库字段定义规定，在<resultmap>中增加映射，是必须的。在MyBatis Generator生成的代码中，需要进行对应的修改。</resultmap></p></li><li><p>【强制】不要用resultClass当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个POJO类与之对应。 </p><p>说明：配置映射关系，使字段与DO类解耦，方便维护。</p></li><li><p>【强制】sql.xml配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现SQL注入。</p></li><li><p>【强制】iBATIS自带的queryForList(String statementName,int start,int size)不推荐使用。 </p><p>说明：其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取start,size的子集合。<br>正例：Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();<br>map.put(“start”, start);<br>map.put(“size”, size);</p></li><li><p>【强制】不允许直接拿HashMap与Hashtable作为查询结果集的输出。 说明：resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的gmt_modified字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口。传入为POJO类，不管是不是自己的目标更新字段，都进行update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行SQL时，不要更新无改动的字段，一是易出错；二是效率低；三是增加binlog存储。</p></li><li><p>【参考】@Transactional事务不要滥用。事务会影响数据库的QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p>【参考】<isequal>中的compareValue是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isnotempty>表示不为空且不为null时执行；<isnotnull>表示不为null值时执行。</isnotnull></isnotempty></isequal></p></li></ol><h4 id="六、工程结构"><a href="#六、工程结构" class="headerlink" title="六、工程结构"></a>六、工程结构</h4><h5 id="一-应用分层"><a href="#一-应用分层" class="headerlink" title="(一) 应用分层"></a>(一) 应用分层</h5><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于Web层，也可以直接依赖于Service层，依此类推：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/clean.png" alt></p><ul><li><p>开放接口层：可直接封装Service方法暴露成RPC接口；通过Web封装成http接口；进行网关安全控制、流量控制等。</p></li><li><p>终端显示层：各个端的模板渲染并执行显示的层。当前主要是velocity渲染，JS渲染，JSP渲染，移动端展示等。</p></li><li><p>Web层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</p></li><li><p>Service层：相对具体的业务逻辑服务层。</p></li><li><p>Manager层：通用业务处理层，它有如下特征： </p><p> 1） 对第三方平台封装的层，预处理返回结果及转化异常信息；</p><p> 2） 对Service层通用能力的下沉，如缓存方案、中间件通用处理；</p><p> 3） 与DAO层交互，对多个DAO的组合复用。</p></li><li><p>DAO层：数据访问层，与底层MySQL、Oracle、Hbase等进行数据交互。</p></li><li><p>外部接口或第三方平台：包括其它部门RPC开放接口，基础平台，其它公司的HTTP接口。</p></li></ul></li><li><p>【参考】 （分层异常处理规约）在DAO层，产生的异常类型有很多，无法用细粒度的异常进行catch，使用catch(Exception e)方式，并throw new DAOException(e)，不需要打印日志，因为日志在Manager/Service层一定需要捕获并打印到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在Service层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果Manager层与Service同机部署，日志方式与DAO层处理一致，如果是单独部署，则采用与Service一致的处理方式。Web层绝不应该继续往上抛异常，因为已经处于顶层，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接<br>跳转到友好错误页面，加上用户容易理解的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p><ul><li>DO（Data Object）：此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>DTO（Data Transfer Object）：数据传输对象，Service或Manager向外传输的对象。</li><li>BO（Business Object）：业务对象，由Service层输出的封装业务逻辑的对象。</li><li>AO（Application Object）：应用对象，在Web层与Service层之间抽象的复用对象模型，极为贴近展示层，复用度不高。</li><li>VO（View Object）：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>Query：数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。</li></ul></li></ol><h5 id="二-二方库依赖"><a href="#二-二方库依赖" class="headerlink" title="(二) 二方库依赖"></a>(二) 二方库依赖</h5><ol><li><p>【强制】定义GAV遵从以下规则： </p><p>1） GroupID格式：com.{公司/BU }.业务线 [.子业务线]，最多4级。 </p><p>说明：{公司/BU} 例如：alibaba/taobao/tmall/aliexpress等BU一级；子业务线可选。</p><p> 正例：com.taobao.jstorm 或 com.alibaba.dubbo.register</p><p> 2） ArtifactID格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。 </p><p>正例：dubbo-client / fastjson-api / jstorm-tool </p><p>3） Version：详细规定参考下方。</p></li><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号 </p><p>1） 主版本号：产品方向改变，或者大规模API不兼容，或者架构不兼容升级。</p><p> 2） 次版本号：保持相对兼容性，增加主要功能特性，影响范围极小的API不兼容修改。 </p><p>3） 修订号：保持完全兼容性，修复BUG、新增次要功能特性等。 </p><p>说明： 注意起始版本号 必须 为： 1.0.0，而不是 ，而不是 ，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0</p></li><li><p>【强制】线上应用不要依赖SNAPSHOT版本（安全包除外）。 说明：不依赖SNAPSHOT版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它jar包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行dependency:resolve前后信息比对，如果仲裁结果完全不一致，那么通过dependency:tree命令，找出差异点，进行<excludes>排除jar包。</excludes></p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的POJO对象。</p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。 </p><p>说明：依赖springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p>【强制】禁止在子项目的pom依赖中出现相同的GroupId，相同的ArtifactId，但是不同的Version。 </p><p>说明：在本地调试时会使用各子项目指定的版本号，但是合并成一个war，只能有一个版本号出现在最后的lib目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。</p></li><li><p>【推荐】所有pom文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<dependencymanagement>语句块中。 </dependencymanagement></dependencies></p><p>说明：<dependencymanagement>里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version和scope都读取自父pom。而<dependencies>所有声明在主pom的<dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。</dependencies></dependencies></dependencymanagement></p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则： </p><p>1）精简可控原则。移除一切不必要的API和依赖，只包含 Service API、必要的领域模型对象、Utils类、常量、枚举等。如果依赖其它二方库，尽量是provided引入，让二方库使用者去依赖具体版本号；无log具体实现，只依赖日志框架。 </p><p>2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h5 id="三-服务器"><a href="#三-服务器" class="headerlink" title="(三) 服务器"></a>(三) 服务器</h5><ol><li><p>【推荐】高并发服务器建议调小TCP协议的time_wait超时时间。 </p><p>说明：操作系统默认240秒后，才会关闭处于time_wait状态的连接，在高并发访问下，服务器端会因为处于time_wait的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。</p><p>正例：在linux服务器上请通过变更/etc/sysctl.conf文件去修改该缺省值（秒）： net.ipv4.tcp_fin_timeout = 30</p></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为fd）。 </p><p>说明：主流操作系统的设计是将TCP/UDP连接采用与文件一样的方式去管理，即一个连接对应于一个fd。主流的linux服务器默认所支持最大fd数量为1024，当并发连接数很大时很容易因为fd不足而出现“open too many files”错误，导致新的连接无法建立。 建议将linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p></li><li><p>【推荐】给JVM环境参数设置-XX:+HeapDumpOnOutOfMemoryError参数，让JVM碰到OOM场景时输出dump信息。 </p><p>说明：OOM的发生是有概率的，甚至相隔数月才出现一例，出错时的堆内信息对解决问题非常有帮助。</p></li><li><p>【推荐】在线上生产环境，JVM的Xms和Xmx设置一样大小的内存容量，避免在GC 后调整堆大小带来的压力。</p></li><li><p>【参考】服务器内部重定向使用forward；外部重定向地址使用URL拼装工具类来生成，否则会带来URL维护不一致的问题和潜在的安全风险。</p></li></ol><h5 id="七、设计规约"><a href="#七、设计规约" class="headerlink" title="七、设计规约"></a>七、设计规约</h5><ol><li><p>【强制】存储方案和底层数据结构的设计获得评审一致通过，并沉淀成为文档。 </p><p>说明：有缺陷的底层数据结构容易导致系统风险上升，可扩展性下降，重构成本也会因历史数据迁移和系统平滑过渡而陡然增加，所以，存储方案和数据结构需要认真地进行设计和评审，生产环境提交执行后，需要进行double check。 正例：评审内容包括存储介质选型、表结构设计能否满足技术方案、存取性能和存储空间能否满足业务发展、表或字段之间的辩证关系、字段名称、字段类型、索引等；数据结构变更（如在原有表中新增字段）也需要进行评审通过后上线。</p></li><li><p>【强制】在需求分析阶段，如果与系统交互的User超过一类并且相关的User Case超过5个，使用用例图来表达更加清晰的结构化需求。</p></li><li><p>【强制】如果某个业务对象的状态超过3个，使用状态图来表达并且明确状态变化的各个触发条件。 </p><p>说明：状态图的核心是对象状态，首先明确对象有多少种状态，然后明确两两状态之间是否存在直接转换关系，再明确触发状态转换的条件是什么。 </p><p>正例：淘宝订单状态有已下单、待付款、已付款、待发货、已发货、已收货等。比如已下单与已收货这两种状态之间是不可能有直接转换关系的。</p></li><li><p>【强制】如果系统中某个功能的调用链路上的涉及对象超过3个，使用时序图来表达并且明确各调用环节的输入与输出。 </p><p>说明：时序图反映了一系列对象间的交互与协作关系，清晰立体地反映系统的调用纵深链路。 </p></li><li><p>【强制】如果系统中模型类超过5个，并且存在复杂的依赖关系，使用类图来表达并且明确类之间的关系。 </p><p>说明：类图像建筑领域的施工图，如果搭平房，可能不需要，但如果建造蚂蚁Z空间大楼，肯定需要详细的施工图。 </p></li><li><p>【强制】如果系统中超过2个对象之间存在协作关系，并且需要表示复杂的处理流程，使用活动图来表示。</p><p>说明：活动图是流程图的扩展，增加了能够体现协作关系的对象泳道，支持表示并发等。 </p></li><li><p>【推荐】需求分析与系统设计在考虑主干功能的同时，需要充分评估异常流程与业务边界。 </p><p>反例：用户在淘宝付款过程中，银行扣款成功，发送给用户扣款成功短信，但是支付宝入款时由于断网演练产生异常，淘宝订单页面依然显示未付款，导致用户投诉。</p></li><li><p>【推荐】类在设计与实现时要符合单一原则。 </p><p>说明：单一原则最易理解却是最难实现的一条规则，随着系统演进，很多时候，忘记了类设计的初衷。 </p></li><li><p>【推荐】谨慎使用继承的方式来进行扩展，优先使用聚合/组合的方式来实现。 </p><p>说明：不得已使用继承的话，必须符合里氏代换原则，此原则说父类能够出现的地方子类一定能够出现，比如，“把钱交出来”，钱的子类美元、欧元、人民币等都可以出现。 </p></li><li><p>【推荐】系统设计时，根据依赖倒置原则，尽量依赖抽象类与接口，有利于扩展与维护。 </p><p>说明：低层次模块依赖于高层次模块的抽象，方便系统间的解耦。 </p></li><li><p>【推荐】系统设计时，注意对扩展开放，对修改闭合。 </p><p>说明：极端情况下，交付的代码都是不可修改的，同一业务域内的需求变化，通过模块或类的扩展来实现。 </p></li><li><p>【推荐】系统设计阶段，共性业务或公共行为抽取出来公共模块、公共配置、公共类、公共方法等，避免出现重复代码或重复配置的情况。</p><p> 说明：随着代码的重复次数不断增加，维护成本指数级上升。 </p></li><li><p>【推荐】避免如下误解：敏捷开发 = 讲故事 + 编码 + 发布。 </p><p>说明：敏捷开发是快速交付迭代可用的系统，省略多余的设计方案，摒弃传统的审批流程，但核心关键点上的必要设计和文档沉淀是需要的。 反例：某团队为了业务快速发展，敏捷成了产品经理催进度的借口，系统中均是勉强能运行但像面条一样的代码，可维护性和可扩展性极差，一年之后，不得不进行大规模重构，得不偿失。 </p></li><li><p>【参考】系统设计主要目的是明确需求、理顺逻辑、后期维护，次要目的用于指导编码。</p><p> 说明：避免为了设计而设计，系统设计文档有助于后期的系统维护，所以设计结果需要进行分类归档保存。 </p></li><li><p>15.【参考】设计的本质就是识别和表达系统难点，找到系统的变化点，并隔离变化点。 </p><p>说明：世间众多设计模式目的是相同的，即隔离系统变化点。 </p></li><li><p>【参考】系统架构设计的目的： </p><ul><li>确定系统边界。 在技术层面上的做与不做</li><li>确定系统内模块之间的关。 依赖及宏观输入与出</li><li>确定指导后续设计与演化的原则。使子系统或模块在 确定指导后续设计与演化的原则。使子系统或模块在 确定指导后续设计与演化的原则。使子系统或模块在 规定的框架内继续演化。 </li><li>确定非功能性需求，非功能性需求是指安全性、可用性、可扩展性。</li></ul></li></ol><h4 id="附-：专有名词解释"><a href="#附-：专有名词解释" class="headerlink" title="附 ：专有名词解释"></a>附 ：专有名词解释</h4><ol><li>POJO（Plain Ordinary Java Object）: 在本手册中，POJO专指只有setter / getter / toString的简单类，包括DO/DTO/BO/VO等。 </li><li>GAV（GroupId、ArtifactctId、Version）: Maven坐标，是用来唯一标识jar包。</li><li>OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</li><li>ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指iBATIS, mybatis等框架。 </li><li>NPE（java.lang.NullPointerException）: 空指针异常。 </li><li>SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。 </li><li>IDE（Integrated Development Environment）: 用于提供程序开发环境的应用程序，一般包括代码编辑器、编译器、调试器和图形用户界面等工具，本《手册》泛指IntelliJ IDEA和eclipse。 </li><li>OOM（Out Of Memory）: 源于java.lang.OutOfMemoryError，当JVM没有足够的内存来为对象分配空间并且垃圾回收器也无法回收空间时，系统出现的严重状况。 </li><li>一方库: 本工程内部子项目模块依赖的库（jar包）。 </li><li>二方库: 公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar包）。 11. 三方库: 公司之外的开源库（jar包）。</li></ol><p>本文摘自 《阿里巴巴开发手册》</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MapReduce编程模型</title>
      <link href="/2018/07/29/MapReduce%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/07/29/MapReduce%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="MapReduce定义"><a href="#MapReduce定义" class="headerlink" title="MapReduce定义"></a>MapReduce定义</h4><p>MapReduce是面向大数据并行处理的计算模型、框架和平台，它隐含了以下三层含义：</p><p>1）MapReduce是一个基于集群的高性能并行计算平台（Cluster Infrastructure）。它允许用市场上普通的商用服务器构成一个包含数十、数百至数千个节点的分布和并行计算集群。</p><p>2）MapReduce是一个并行计算与运行软件框架（Software Framework）。它提供了一个庞大但设计精良的并行计算软件框架，能自动完成计算任务的并行化处理，自动划分计算数据和计算任务，在集群节点上自动分配和执行任务以及收集计算结果，将数据分布存储、数据通信、容错处理等并行计算涉及到的很多系统底层的复杂细节交由系统负责处理，大大减少了软件开发人员的负担。</p><p>3）MapReduce是一个并行程序设计模型与方法（Programming Model &amp; Methodology）。它借助于函数式程序设计语言Lisp的设计思想，提供了一种简便的并行程序设计方法，用Map和Reduce两个函数编程实现基本的并行计算任务，提供了抽象的操作和并行编程接口，以简单方便地完成大规模数据的编程和计算处理 [1]<a href> </a> 。</p><p><strong>MapReduce 既是一个编程模型，又是一个计算框架</strong>。其编程模型只包含 Map 和 Reduce 两个过程，map 的主要输入是一对 &lt;Key, Value&gt; 值，经过 map 计算后输出一对 &lt;Key, Value&gt; 值；然后将相同 Key 合并，形成 &lt;Key, Value 集合 &gt;；再将这个 &lt;Key, Value 集合 &gt; 输入 reduce，经过计算输出零个或多个 &lt;Key, Value&gt; 对。</p><p>同时，MapReduce 又是非常强大的，不管是关系代数运算（SQL 计算），还是矩阵运算（图计算），大数据领域几乎所有的计算需求都可以通过 MapReduce 编程来实现。</p><h4 id="MapReduce实例"><a href="#MapReduce实例" class="headerlink" title="MapReduce实例"></a>MapReduce实例</h4><p>以WordCount 为示例，来解读MapReduce 编程模型</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/MapReduce1.png" alt></p><p>简单说来，就是建一个 Hash 表，然后将字符串里的每个词放到这个 Hash 表里。如果这个词第一次放到 Hash 表，就新建一个 Key、Value 对，Key 是这个词，Value 是 1。如果 Hash 表里已经有这个词了，那么就给这个词的 Value + 1。</p><p>小数据量用单机统计词频很简单，但是如果想统计全世界互联网所有网页（数万亿计）的词频数（而这正是 Google 这样的搜索引擎的典型需求），不可能写一个程序把全世界的网页都读入内存，这时候就需要用 MapReduce 编程来解决。</p><p>WordCount 的 MapReduce 程序如下。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WordCount</span> <span class="token punctuation">{</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">TokenizerMapper</span>       <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token operator">&lt;</span>Object<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">static</span> IntWritable one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> Text word <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>Object key<span class="token punctuation">,</span> Text value<span class="token punctuation">,</span> Context context                    <span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>      StringTokenizer itr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringTokenizer</span><span class="token punctuation">(</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasMoreTokens</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        word<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">nextToken</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>word<span class="token punctuation">,</span> one<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">IntSumReducer</span>       <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token operator">&lt;</span>Text<span class="token punctuation">,</span>IntWritable<span class="token punctuation">,</span>Text<span class="token punctuation">,</span>IntWritable<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> IntWritable result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>Text key<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>IntWritable<span class="token operator">></span> values<span class="token punctuation">,</span>                       Context context                       <span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>      <span class="token keyword">int</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span>IntWritable val <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>        sum <span class="token operator">+=</span> val<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      result<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>      context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>MapReduce的核心是Map函数和一个Reduce函数。</p><p>map 函数的输入主要是一个 &lt;Key, Value&gt; 对，在这个例子里，Value 是要统计的所有文本中的一行数据，Key 在一般计算中都不会用到。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>Text key<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>IntWritable<span class="token operator">></span> values<span class="token punctuation">,</span>Context context<span class="token punctuation">)</span> </code></pre><p>这里 reduce 的输入参数 Values 就是由很多个 1 组成的集合，而 Key 就是具体的单词 word。</p><p>reduce 函数的计算过程是，将这个集合里的 1 求和，再将单词（word）和这个和（sum）组成一个 &lt;Key, Value&gt;，也就是 &lt;word, sum&gt; 输出。每一个输出就是一个单词和它的词频统计总和。</p><p>一个 map 函数可以针对一部分数据进行运算，这样就可以将一个大数据切分成很多块（这也正是 HDFS 所做的），MapReduce 计算框架为每个数据块分配一个 map 函数去计算，从而实现大数据的分布式计算。</p><p>假设有两个数据块的文本数据需要进行词频统计，MapReduce 计算过程如下图所示。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/MapReduce3.png" alt></p><p>以上就是 MapReduce 编程模型的主要计算过程和原理，但是这样一个 MapReduce 程序要想在分布式环境中执行，并处理海量的大规模数据，还需要一个计算框架，能够调度执行这个 MapReduce 程序，使它在分布式的集群中并行运行，而这个计算框架也叫 MapReduce。</p><h4 id="MapReduce实践"><a href="#MapReduce实践" class="headerlink" title="MapReduce实践"></a>MapReduce实践</h4><table><thead><tr><th>pageId</th><th>age</th></tr></thead><tbody><tr><td>1</td><td>25</td></tr><tr><td>2</td><td>25</td></tr><tr><td>1</td><td>32</td></tr><tr><td>2</td><td>25</td></tr></tbody></table><p>如果存储在 HDFS 中，每一行记录在 HDFS 对应一行文本，文本格式是</p><pre class=" language-text"><code class="language-text">1,252,251,322,25</code></pre><p>根据上面 WordCount 的示例，请你写一个 MapReduce 程序，得到下面这条 SQL 的计算结果。</p><pre class=" language-mysql"><code class="language-mysql">SELECT pageid, age, count(1) FROM pv_users GROUP BY pageid, age;</code></pre><p><strong>Map</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PageMapper</span> <span class="token keyword">extends</span> <span class="token class-name">Mapper</span><span class="token operator">&lt;</span>LongWritable<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> Text<span class="token punctuation">,</span> IntWritable<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">map</span><span class="token punctuation">(</span>LongWritable key<span class="token punctuation">,</span> Text value<span class="token punctuation">,</span> Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        String data <span class="token operator">=</span> value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> words <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String word <span class="token operator">:</span> words<span class="token punctuation">)</span> <span class="token punctuation">{</span>            context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Text</span><span class="token punctuation">(</span>word<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Reduce</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PageReducer</span> <span class="token keyword">extends</span> <span class="token class-name">Reducer</span><span class="token operator">&lt;</span>Text<span class="token punctuation">,</span>IntWritable<span class="token punctuation">,</span>Text<span class="token punctuation">,</span>IntWritable<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">reduce</span><span class="token punctuation">(</span>Text key<span class="token punctuation">,</span> Iterable<span class="token operator">&lt;</span>IntWritable<span class="token operator">></span> values<span class="token punctuation">,</span> Context context<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        <span class="token keyword">int</span> total<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>IntWritable value <span class="token operator">:</span> values<span class="token punctuation">)</span> <span class="token punctuation">{</span>            total<span class="token operator">=</span>total<span class="token operator">+</span>value<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        context<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">IntWritable</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong>Main</strong></p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PageMain</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException<span class="token punctuation">,</span> ClassNotFoundException<span class="token punctuation">,</span> InterruptedException <span class="token punctuation">{</span>        Job job <span class="token operator">=</span> Job<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setJarByClass</span><span class="token punctuation">(</span>PageMain<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setMapperClass</span><span class="token punctuation">(</span>PageMapper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setMapOutputKeyClass</span><span class="token punctuation">(</span>Text<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setMapOutputValueClass</span><span class="token punctuation">(</span>IntWritable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setReducerClass</span><span class="token punctuation">(</span>PageReducer<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setOutputKeyClass</span><span class="token punctuation">(</span>Text<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">setOutputValueClass</span><span class="token punctuation">(</span>IntWritable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileInputFormat<span class="token punctuation">.</span><span class="token function">setInputPaths</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FileOutputFormat<span class="token punctuation">.</span><span class="token function">setOutputPath</span><span class="token punctuation">(</span>job<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Path</span><span class="token punctuation">(</span>args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        job<span class="token punctuation">.</span><span class="token function">waitForCompletion</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis使用总结</title>
      <link href="/2018/07/10/Redis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <url>/2018/07/10/Redis%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>##### </p><p>Redis 典型问题</p><p><img src="https://raw.githubusercontent.com/gaohueric/blogpicture/master/redis.jpeg" alt></p><h5 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h5>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Storm详解与集群环境搭建</title>
      <link href="/2018/05/21/Storm%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/2018/05/21/Storm%E8%AF%A6%E8%A7%A3%E4%B8%8E%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h5 id="strom-概述"><a href="#strom-概述" class="headerlink" title="strom 概述"></a>strom 概述</h5><p>Apache Strom 是自由开源的分布式实时计算系统</p><ul><li>擅长处理海量数据</li><li>适用于数据实时处理而非批处理(比如Hadoop)</li><li>分布式系统，可以充分利用计算机集群资源</li><li>模型简单，易于适用</li></ul><a id="more"></a><h5 id="Strom-有以下几个核心概念："><a href="#Strom-有以下几个核心概念：" class="headerlink" title="Strom 有以下几个核心概念："></a>Strom 有以下几个核心概念：</h5><ul><li>Topolopy: 计算拓扑，包含了应用程序的逻辑</li><li>Stream: 消息流，关键抽象，没有边界的Tuple 序列</li><li>Spout:消息流的源头，Topolog的消息生产者</li><li>Bolt 消息处理单元，可以过滤，聚合，查询数据库</li><li>Stream grouping: 消息分发策略，一共有6种，定义每个Bolt接受何种输入</li><li>Reliability:可靠性，Strom 保证每个Tuple 都会被处理</li><li>Task : 任务，每个Spout 和 Bolt 都是一个任务，每个任务都是一个线程</li><li>Worker : 工作进程，每个工作进程中有多个Task.</li></ul><h5 id="Strom-计算模型"><a href="#Strom-计算模型" class="headerlink" title="Strom 计算模型"></a>Strom 计算模型</h5><p><img src="http://ogx75f0xj.bkt.clouddn.com/Screenshot%20of%20%E5%88%9D%E8%AF%86%20Apache%20Storm-%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2.jpg" alt></p><p> 计算模型比较</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/Screenshot%20of%20%E5%88%9D%E8%AF%86%20Apache%20Storm-%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2%20%281%29.jpg" alt></p><h5 id="Strom-优势"><a href="#Strom-优势" class="headerlink" title="Strom 优势"></a>Strom 优势</h5><ul><li>实时性</li><li>可伸缩性</li><li>容错性</li><li>确保数据不丢失</li><li>对多种程序设计语言的广泛支持</li></ul><h5 id="Strom-相关术语"><a href="#Strom-相关术语" class="headerlink" title="Strom 相关术语"></a>Strom 相关术语</h5><ol><li>Nimbus</li></ol><p>Strom 集群主节点，负责资源分配和任务调度</p><ol><li>Supervisor</li></ol><p>Strom 集群工作节点，接受Nimbus分配任务，管理Worker</p><ol><li>Worker </li></ol><p>Supervisor 下的工作进程，具体任务执行</p><ol><li>Task </li></ol><p>Worker下的 工作线程，0.8版本之后表示逻辑线程</p><ol><li>Topology</li></ol><p>实时计算逻辑，计算拓扑，由Spout 和Bolt组成的图状结构</p><ol><li>Spout</li></ol><p>Strom 编程模型中的消息源，可进行可靠传输(ACK/Fail 机制)</p><ol><li>Bolt </li></ol><p>Strom 编程模型中的处理组件，定义execute 方法进行实际的数据处理逻辑</p><ol><li>Stream</li></ol><p>拓扑中的消息流，传输的对象是Tuple</p><ol><li>Tuple </li></ol><p>一次消息传递的基本单元</p><ol><li>Stream Groupings 数据分组策略</li></ol><ul><li>Shuffle Grouping : 随机分组，保证bolt 接受的tuple 数据相同</li><li>Fields Grouping: 按字段分组，相同tuple会分到同一个bolt中。</li><li>All Grouping : 按字段分组，相同tuple会分到同一个bolt中</li><li>Global Grouping : 广播发送，每个tuple 会发送所有bolt中。</li><li>Non Grouping : 全局分组，所有tuple 发送给task_id 最小的bolt</li><li>Direct Grouping: 直接分组，需要手动制定bolt</li><li>Custom Grouping: 自定义分组，自己实现分组方式</li></ul><h5 id="Strom-原理架构"><a href="#Strom-原理架构" class="headerlink" title="Strom 原理架构"></a>Strom 原理架构</h5><p>Strom 架构图</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/Screenshot%20of%20Storm%20%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84-Storm%20%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A6%81-%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2.jpg" alt></p><p>数据处理流程图</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/Screenshot%20of%20Storm%20%E5%8E%9F%E7%90%86%E6%9E%B6%E6%9E%84-Storm%20%E4%BD%93%E7%B3%BB%E6%A6%82%E8%A6%81-%E6%9E%81%E5%AE%A2%E5%AD%A6%E9%99%A2%20%281%29.jpg" alt></p><h5 id="Storm-的扩展-：-与YARN结合"><a href="#Storm-的扩展-：-与YARN结合" class="headerlink" title="Storm 的扩展 ： 与YARN结合"></a>Storm 的扩展 ： 与YARN结合</h5><ol><li><p>YARN介绍：</p><p>YARN是Hadoop在2.0 中引入的资源管理器，Hadoop的资源管理组件</p><ul><li>Hadoop1.x 系列MapReduce 工作流程，JobTracker 负责资源管理以及任务调度，TaskTracer负责监控所在机器资源以及监控task执行情况。</li><li>架构存在的问题: JobTracker 单点故障，JobTrac ker 负荷过重，资源单一，资源分配不合理。</li><li>Hadoop 2.x 解决方案，资源管理与任务调度拆分，Yarn负责资源管理，YARN组成，ResouceManager,NodeManager ,ApplicationMaster.</li></ul><p>Strom 和YARN结合的优势</p><ul><li>资源的弹性计算</li><li>共享底层存储</li><li>支持多版本共存</li><li>​整体架构的统一</li></ul></li></ol><h4 id="Linux-搭建-Strom-集群"><a href="#Linux-搭建-Strom-集群" class="headerlink" title="Linux 搭建 Strom 集群"></a>Linux 搭建 Strom 集群</h4><h5 id="Linux-下安装配置Zookeeper"><a href="#Linux-下安装配置Zookeeper" class="headerlink" title="Linux 下安装配置Zookeeper"></a>Linux 下安装配置Zookeeper</h5><p>查看linux 内核版本，版本号</p><pre><code>uname -rcat /etc/redhat-release</code></pre><p>修改hostname </p><pre><code>vim /etc/hosts</code></pre><p>下载解压Zookeeper(git下载地址：<a href="mailto:git@git.coding.net" target="_blank" rel="noopener">git@git.coding.net</a>:gaohueric/SoftWare.git)</p><pre><code>tar -zxvf zookeeper-3.4.10.tar.gz </code></pre><p>进入zookeeper 目录下</p><pre><code>ls conf/</code></pre><p>拷贝示例配置文件</p><pre><code>cp conf/zoo_sample.cfg conf/zoo.cfg</code></pre><p>添加host映射</p><p>vim /etc/hosts</p><pre><code>127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4::1         localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.200.129 hadoop192.168.200.130 hadoop01192.168.200.131 hadoop02</code></pre><p>配置文件信息 ：</p><pre><code>tickTime=2000initLimit=10syncLimit=5dataDir=/usr/hadoop/zookeeper/zkdatadataLogDir=/usr/zookeeper/logsserver.1=hadoop:2888:3888server.2=hadoop01:2888:3888server.3=hadoop02:2888:3888clientPort=2181# the maximum number of client connections.# increase this if you need to handle more clients#maxClientCnxns=60## Be sure to read the maintenance section of the # administrator guide before turning on autopurge.## http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance## The number of snapshots to retain in dataDir#autopurge.snapRetainCount=3# Purge task interval in hours# Set to &quot;0&quot; to disable auto purge feature#autopurge.purgeInterval=1</code></pre><p>创建 dataDir </p><blockquote><p>mkdir /usr/hadoop/zookeeper/zkdata</p></blockquote><p>创建dataLogDir </p><blockquote><p>mkdir /usr/hadoop/zookeeper/logs</p></blockquote><p>创建pid文件 对应 三台服务器的server.X</p><p>server.1=hadoop:2888:3888<br>server.2=hadoop01:2888:3888<br>server.3=hadoop02:2888:3888</p><pre><code>echo &quot;1&quot; &gt; /usr/hadoop/zookeeper/zkdata/myidecho &quot;2&quot; &gt; /usr/hadoop/zookeeper/zkdata/myidecho &quot;3&quot; &gt; /usr/hadoop/zookeeper/zkdata/myid</code></pre><p>配置zookeeper 环境变量，先pwd获取安装路径</p><p>路径 ： /usr/hadoop/zookeeper/zookeeper-3.4.10</p><p>配置文件 ： </p><pre><code>vim /etc/profile添加export ZOOKEEPER_HOME=/usr/hadoop/zookeeper/zookeeper-3.4.10export PATH=$ZOOKEEPER_HOME/bin:$PATH执行命令让配置生效 . /etc/profile</code></pre><p>启动Zookeeper 服务</p><pre><code>zkServer.sh start</code></pre><p>查看启动信息命令</p><pre><code>zkServer.sh status</code></pre><h5 id="Linux-环境安装-Java-环境"><a href="#Linux-环境安装-Java-环境" class="headerlink" title="Linux  环境安装 Java 环境"></a>Linux  环境安装 Java 环境</h5><p>解压jdk：tar -zxvf   jdk-1.8XXX.gz</p><p>将下载的解压jdk 复制到 /usr/hadoop/java</p><p>配置环境变量：</p><pre><code>vim /etc/profile</code></pre><p>配置内容如下：</p><pre><code>export JAVA_HOME=/usr/hadoop/java/jdk1.8.0_171export JDK_HOME=$JAVA_HOMEexport PATH=$JAVA_HOME/bin:$PATH</code></pre><p>验证安装是否成功：</p><blockquote><p>java -version </p></blockquote><h5 id="Linux-环境下安装Python-源码文件安装"><a href="#Linux-环境下安装Python-源码文件安装" class="headerlink" title="Linux 环境下安装Python (源码文件安装)"></a>Linux 环境下安装Python (源码文件安装)</h5><ol><li>下载源码安装包文件 ： 下载地址：<a href="mailto:git@git.coding.net" target="_blank" rel="noopener">git@git.coding.net</a>:gaohueric/SoftWare.git</li><li>解压压缩包 ： tar -zvcf python-2.7.1XXX.tgz</li><li>执行配置文件 ：进入python 目录下执行 ./configure</li><li>执行编译命令 make </li><li>执行安装命令： make install</li><li>验证是否安装成功 ： python –version</li></ol><h5 id="安装-Storm"><a href="#安装-Storm" class="headerlink" title="安装 Storm"></a>安装 Storm</h5><pre><code>storm ui &gt;/dev/null 2&gt;&amp;1 &amp;storm nimbus &gt;/dev/null 2&gt;&amp;1 &amp;storm supervisor &gt;/dev/null 2&gt;&amp;1 &amp;-Djava.net.preferIPv4Stack=truevim /usr/hadoop/storm/apache-storm-1.1.2/conf/storm.yamlnohup storm supervisor &amp;nohup storm nimbus &amp;</code></pre><pre><code> storm.zookeeper.servers:     - &quot;hadoop&quot;     - &quot;hadoop01&quot;     - &quot;hadoop02&quot; nimbus.seeds: [&quot;hadoop&quot;] storm.local.dir: &quot;/usr/hadoop/storm/status&quot; supervisor.slots.ports:     - 6700     - 6701     - 6702     - 6703</code></pre><pre><code> storm.zookeeper.servers:      - &quot;hadoop&quot;     - &quot;hadoop01&quot;     - &quot;hadoop02&quot;   nimbus.host: &quot;hadoop&quot; storm.local.dir: &quot;/usr/hadoop/storm/status&quot; supervisor.slots.ports:     - 6700     - 6701     - 6702     - 6703</code></pre>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Storm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop详解</title>
      <link href="/2018/05/21/Hadoop%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/21/Hadoop%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="Hadoop-概述"><a href="#Hadoop-概述" class="headerlink" title="Hadoop 概述"></a>Hadoop 概述</h3><h5 id="Hadoop-简介"><a href="#Hadoop-简介" class="headerlink" title="Hadoop 简介"></a>Hadoop 简介</h5><p>Apache Hadoop是一款支持数据密集型分布式应用并以Apache 2.0许可协议发布的开源软件框架。它支持在商品硬件构建的大型集群上运行的应用程序。Hadoop是根据Google公司发表的MapReduce和Google档案系统的论文自行实作而成。<br><a id="more"></a></p><p>Hadoop框架透明地为应用提供可靠性和数据移动。它实现了名为MapReduce的编程范式：应用程序被分割成许多小部分，而每个部分都能在集群中的任意节点上执行或重新执行。此外，Hadoop还提供了分布式文件系统，用以存储所有计算节点的数据，这为整个集群带来了非常高的带宽。MapReduce和分布式文件系统的设计，使得整个框架能够自动处理节点故障。它使应用程序与成千上万的独立计算的电脑和PB级的数据。现在普遍认为整个Apache Hadoop“平台”包括Hadoop内核、MapReduce、Hadoop分布式文件系统（HDFS）以及一些相关项目，有Apache Hive和Apache HBase等等。</p><p>Hadoop的框架最核心的设计就是：HDFS和MapReduce.HDFS为海量的数据提供了存储，则MapReduce为海量的数据提供了计算。</p><h5 id="Hadoop-相关"><a href="#Hadoop-相关" class="headerlink" title="Hadoop 相关"></a>Hadoop 相关</h5><ul><li>Hadoop Common：在0.20及以前的版本中，包含HDFS、MapReduce和其他项目公共内容，从0.21开始HDFS和MapReduce被分离为独立的子项目，其余内容为Hadoop Common</li><li>HDFS：Hadoop分布式文件系统（Distributed File System）－HDFS（Hadoop Distributed File System）</li><li>MapReduce：并行计算框架，0.20前使用org.apache.hadoop.mapred旧接口，0.20版本开始引入org.apache.hadoop.mapreduce的新API</li><li>Apache HBase：分布式NoSQL列数据库，类似谷歌公司BigTable。</li><li>Apache Hive：构建于hadoop之上的数据仓库，通过一种类SQL语言HiveQL为用户提供数据的归纳、查询和分析等功能。Hive最初由Facebook贡献。</li><li>Apache Mahout：机器学习算法软件包。</li><li>Apache Sqoop：结构化数据（如关系数据库）与Apache Hadoop之间的数据转换工具。</li><li>Apache ZooKeeper：分布式锁设施，提供类似Google Chubby的功能，由Facebook贡献。</li><li>Apache Avro：新的数据序列化格式与传输工具，将逐步取代Hadoop原有的IPC机制。</li></ul><h5 id="Hadoop-优点"><a href="#Hadoop-优点" class="headerlink" title="Hadoop 优点"></a>Hadoop 优点</h5><ul><li>高可靠性。Hadoop按位存储和处理数据的能力值得人们信赖。</li><li>高扩展性。Hadoop是在可用的计算机集簇间分配数据并完成计算任务的，这些集簇可以方便地扩展到数以千计的节点中。</li><li>高效性。Hadoop能够在节点之间动态地移动数据，并保证各个节点的动态平衡，因此处理速度非常快。</li><li>低成本。与一体机、商用数据仓库以及QlikView、Yonghong Z-Suite等数据集市相比，hadoop是开源的，项目的软件成本因此会大大降低。</li></ul><h3 id="Hadoop-环境搭建-单机模式"><a href="#Hadoop-环境搭建-单机模式" class="headerlink" title="Hadoop 环境搭建(单机模式)"></a>Hadoop 环境搭建(单机模式)</h3><p>下载hadoop解压到　/usr/hadoop/hdfs 目录下</p><pre class=" language-java"><code class="language-java">$ tar zxvf hadoop<span class="token operator">-</span><span class="token number">2.6</span><span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">.</span>tar<span class="token punctuation">.</span>gz$ mv hadoop<span class="token operator">-</span><span class="token number">2.6</span><span class="token punctuation">.</span><span class="token number">0</span> <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs$ chmod <span class="token number">777</span> <span class="token operator">/</span>home<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs</code></pre><p>配置环境变量</p><pre class=" language-java"><code class="language-java">export HADOOP_HOME<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span>export PATH<span class="token operator">=</span>$PATH<span class="token operator">:</span>$HADOOP_HOME<span class="token operator">/</span>bin</code></pre><p>生效配置文件</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span> <span class="token operator">/</span>etc<span class="token operator">/</span>profile</code></pre><p>验证是否安装成功</p><pre><code>hadoop version</code></pre><p>创建输入的数据，暂时采用/etc/protocols文件作为测试</p><pre class=" language-java"><code class="language-java">$ cd <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span>$ mkdir input$ cp <span class="token operator">/</span>etc<span class="token operator">/</span>protocols <span class="token punctuation">.</span>/input</code></pre><p>测试 wordcount</p><pre class=" language-java"><code class="language-java">hadoop jar <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>share<span class="token operator">/</span>hadoop<span class="token operator">/</span>mapreduce<span class="token operator">/</span>sources<span class="token operator">/</span>hadoop<span class="token operator">-</span>mapreduce<span class="token operator">-</span>examples<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">-</span>sources<span class="token punctuation">.</span>jar org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>examples<span class="token punctuation">.</span>WordCount input output</code></pre><h3 id="Hadoop-伪分布式部署"><a href="#Hadoop-伪分布式部署" class="headerlink" title="Hadoop 伪分布式部署"></a>Hadoop 伪分布式部署</h3><p>注意： 在单机模式的前提下进行安装</p><h5 id="修改core-site-xml"><a href="#修改core-site-xml" class="headerlink" title="修改core-site.xml"></a>修改core-site.xml</h5><pre><code>$ vim /usr/hadoop/hdfs/hadoop-2.8.4/etc/hadoop/core-site.xml</code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">?</span>xml<span class="token operator">-</span>stylesheet type<span class="token operator">=</span><span class="token string">"text/xsl"</span> href<span class="token operator">=</span><span class="token string">"configuration.xsl"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>configuration<span class="token operator">></span>    <span class="token operator">&lt;</span>property<span class="token operator">></span>        <span class="token operator">&lt;</span>name<span class="token operator">></span>fs<span class="token punctuation">.</span>defaultFS<span class="token operator">&lt;</span><span class="token operator">/</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>hdfs<span class="token operator">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token operator">:</span><span class="token number">9000</span><span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span>    <span class="token operator">&lt;</span>property<span class="token operator">></span>        <span class="token operator">&lt;</span>name<span class="token operator">></span>hadoop<span class="token punctuation">.</span>tmp<span class="token punctuation">.</span>dir<span class="token operator">&lt;</span><span class="token operator">/</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token operator">/</span>home<span class="token operator">/</span>hadoop<span class="token operator">/</span>tmp<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>   <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span></code></pre><p>常用配置项说明：</p><ul><li>fs.defaultFS这是默认的HDFS路径。当有多个HDFS集群同时工作时，用户在这里指定默认HDFS集群，该值来自于hdfs-site.xml中的配置。</li><li>fs.default.name这是一个描述集群中NameNode结点的URI(包括协议、主机名称、端口号)，集群里面的每一台机器都需要知道NameNode的地址。DataNode结点会先在NameNode上注册，这样它们的数据才可以被使用。独立的客户端程序通过这个URI跟DataNode交互，以取得文件的块列表。</li><li>hadoop.tmp.dir 是hadoop文件系统依赖的基础配置，很多路径都依赖它。如果hdfs-site.xml中不配置namenode和datanode的存放位置，默认就放在/tmp/hadoop-${user.name}这个路径中。</li><li>更多说明请参考core-default.xml，包含配置文件所有配置项的说明和默认值。</li></ul><h5 id="修改hdfs-site-xml"><a href="#修改hdfs-site-xml" class="headerlink" title="修改hdfs-site.xml:"></a>修改hdfs-site.xml:</h5><pre><code>$ vim /usr/hadoop/hdfs/hadoop-2.8.4/etc/hadoop/hdfs-site.xml</code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">?</span>xml<span class="token operator">-</span>stylesheet type<span class="token operator">=</span><span class="token string">"text/xsl"</span> href<span class="token operator">=</span><span class="token string">"configuration.xsl"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>configuration<span class="token operator">></span>    <span class="token operator">&lt;</span>property<span class="token operator">></span>        <span class="token operator">&lt;</span>name<span class="token operator">></span>dfs<span class="token punctuation">.</span>replication<span class="token operator">&lt;</span><span class="token operator">/</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span><span class="token number">1</span><span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span></code></pre><p>常用配置项说明：</p><ul><li>dfs.replication它决定着系统里面的文件块的数据备份个数。对于一个实际的应用，它应该被设为3（这个数字并没有上限，但更多的备份可能并没有作用，而且会占用更多的空间）。少于三个的备份，可能会影响到数据的可靠性(系统故障时，也许会造成数据丢失)</li><li>dfs.data.dir这是DataNode结点被指定要存储数据的本地文件系统路径。DataNode结点上的这个路径没有必要完全相同，因为每台机器的环境很可能是不一样的。但如果每台机器上的这个路径都是统一配置的话，会使工作变得简单一些。默认的情况下，它的值为file://${hadoop.tmp.dir}/dfs/data这个路径只能用于测试的目的，因为它很可能会丢失掉一些数据。所以这个值最好还是被覆盖。</li><li>dfs.name.dir这是NameNode结点存储hadoop文件系统信息的本地系统路径。这个值只对NameNode有效，DataNode并不需要使用到它。上面对于/temp类型的警告，同样也适用于这里。在实际应用中，它最好被覆盖掉。</li><li>更多说明请参考hdfs-default.xml，包含配置文件所有配置项的说明和默认值。</li></ul><h5 id="修改mapred-site-xml"><a href="#修改mapred-site-xml" class="headerlink" title="修改mapred-site.xml:"></a>修改mapred-site.xml:</h5><pre class=" language-java"><code class="language-java">$ cp <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop<span class="token operator">/</span>mapred<span class="token operator">-</span>site<span class="token punctuation">.</span>xml<span class="token punctuation">.</span>template <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop<span class="token operator">/</span>mapred<span class="token operator">-</span>site<span class="token punctuation">.</span>xml$ vim <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop<span class="token operator">/</span>mapred<span class="token operator">-</span>site<span class="token punctuation">.</span>xml</code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span><span class="token operator">?</span>xml version<span class="token operator">=</span><span class="token string">"1.0"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">?</span>xml<span class="token operator">-</span>stylesheet type<span class="token operator">=</span><span class="token string">"text/xsl"</span> href<span class="token operator">=</span><span class="token string">"configuration.xsl"</span><span class="token operator">?</span><span class="token operator">></span><span class="token operator">&lt;</span>configuration<span class="token operator">></span>    <span class="token operator">&lt;</span>property<span class="token operator">></span>        <span class="token operator">&lt;</span>name<span class="token operator">></span>mapreduce<span class="token punctuation">.</span>framework<span class="token punctuation">.</span>name<span class="token operator">&lt;</span><span class="token operator">/</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>yarn<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span></code></pre><p>常用配置项说明：</p><ul><li>mapred.job.trackerJobTracker的主机（或者IP）和端口。</li><li>更多说明请参考mapred-default.xml，包含配置文件所有配置项的说明和默认值</li></ul><h5 id="修改yarn-site-xml"><a href="#修改yarn-site-xml" class="headerlink" title="修改yarn-site.xml:"></a>修改yarn-site.xml:</h5><pre class=" language-java"><code class="language-java">$ vim <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop<span class="token operator">/</span>yarn<span class="token operator">-</span>site<span class="token punctuation">.</span>xml</code></pre><pre class=" language-java"><code class="language-java"><span class="token operator">&lt;</span>configuration<span class="token operator">></span>    <span class="token operator">&lt;</span>property<span class="token operator">></span>        <span class="token operator">&lt;</span>name<span class="token operator">></span>yarn<span class="token punctuation">.</span>nodemanager<span class="token punctuation">.</span>aux<span class="token operator">-</span>services<span class="token operator">&lt;</span><span class="token operator">/</span>name<span class="token operator">></span>        <span class="token operator">&lt;</span>value<span class="token operator">></span>mapreduce_shuffle<span class="token operator">&lt;</span><span class="token operator">/</span>value<span class="token operator">></span>    <span class="token operator">&lt;</span><span class="token operator">/</span>property<span class="token operator">></span><span class="token operator">&lt;</span><span class="token operator">/</span>configuration<span class="token operator">></span></code></pre><p>常用配置项说明：</p><ul><li>yarn.nodemanager.aux-services通过该配置，用户可以自定义一些服务</li><li>更多说明请参考yarn-default.xml，包含配置文件所有配置项的说明和默认值</li></ul><h5 id="修改-hadoop-env-sh"><a href="#修改-hadoop-env-sh" class="headerlink" title="修改 hadoop-env.sh:"></a>修改 hadoop-env.sh:</h5><pre class=" language-java"><code class="language-java">$ vim <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop<span class="token operator">/</span>hadoop<span class="token operator">-</span>env<span class="token punctuation">.</span>sh </code></pre><p>修改 JAVA_HOME 如下：</p><pre class=" language-java"><code class="language-java">export JAVA_HOME<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>java<span class="token operator">/</span>jdk1<span class="token number">.8</span><span class="token punctuation">.</span>0_171export HADOOP_CONF_DIR<span class="token operator">=</span><span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>etc<span class="token operator">/</span>hadoop</code></pre><h5 id="格式化HDFS文件系统"><a href="#格式化HDFS文件系统" class="headerlink" title="格式化HDFS文件系统"></a>格式化HDFS文件系统</h5><pre class=" language-java"><code class="language-java">hadoop namenode <span class="token operator">-</span>format</code></pre><h5 id="Hadoop集群启动"><a href="#Hadoop集群启动" class="headerlink" title="Hadoop集群启动"></a>Hadoop集群启动</h5><p>进入hadoop sbin 目录下</p><p>启动hdfs守护进程，分别启动NameNode和DataNode</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span>/ start<span class="token operator">-</span>dfs<span class="token punctuation">.</span>sh</code></pre><p>启动yarn,使用如下命令启ResourceManager和NodeManager:</p><pre class=" language-java"><code class="language-java"><span class="token punctuation">.</span>/ start<span class="token operator">-</span>yarn<span class="token punctuation">.</span>sh</code></pre><p>检查是否运行成功</p><ul><li>输入：<a href="http://localhost:8088进入ResourceManager管理页面" target="_blank" rel="noopener">http://localhost:8088进入ResourceManager管理页面</a></li><li>输入：<a href="http://localhost:50070进入HDFS页面" target="_blank" rel="noopener">http://localhost:50070进入HDFS页面</a></li></ul><pre><code>可能出现的问题及调试方法：启动伪分布后，如果活跃节点显示为零，说明伪分布没有真正的启动。原因是有的时候数据结构出现问题会造成无法启动datanode。如果使用hadoop namenode -format重新格式化仍然无法正常启动，原因是/tmp中的文件没有清除，则需要先清除/tmp/hadoop/*再执行格式化，即可解决hadoop datanode无法启动的问题。具体步骤如下所示：</code></pre><pre class=" language-java"><code class="language-java"># 删除hadoop<span class="token operator">:</span><span class="token operator">/</span>tmp$ hadoop fs <span class="token operator">-</span>rmr <span class="token operator">/</span>tmp# 停止hadoop$ stop<span class="token operator">-</span>all<span class="token punctuation">.</span>sh# 删除<span class="token operator">/</span>tmp<span class="token operator">/</span>hadoop<span class="token operator">*</span>$ rm <span class="token operator">-</span>rf <span class="token operator">/</span>tmp<span class="token operator">/</span>hadoop<span class="token operator">*</span># 格式化$ hadoop namenode <span class="token operator">-</span>format# 启动hadoop$ start<span class="token operator">-</span>all<span class="token punctuation">.</span>sh</code></pre><h5 id="伪分布式测试wordcount"><a href="#伪分布式测试wordcount" class="headerlink" title="伪分布式测试wordcount"></a>伪分布式测试wordcount</h5><p>把文件拷贝到hdfs</p><pre class=" language-java"><code class="language-java">$ hadoop dfs <span class="token operator">-</span>mkdir <span class="token operator">-</span>p <span class="token operator">/</span>user<span class="token operator">/</span>hadoop<span class="token operator">/</span>input</code></pre><p>创建输入的数据，采用/etc/protocols文件作为测试</p><pre class=" language-java"><code class="language-java">$ hadoop dfs <span class="token operator">-</span>put <span class="token operator">/</span>etc<span class="token operator">/</span>protocols <span class="token operator">/</span>user<span class="token operator">/</span>hadoop<span class="token operator">/</span>input</code></pre><p> 执行Hadoop WordCount应用（词频统计）</p><pre class=" language-java"><code class="language-java"> hadoop jar <span class="token operator">/</span>usr<span class="token operator">/</span>hadoop<span class="token operator">/</span>hdfs<span class="token operator">/</span>hadoop<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">/</span>share<span class="token operator">/</span>hadoop<span class="token operator">/</span>mapreduce<span class="token operator">/</span>sources<span class="token operator">/</span>hadoop<span class="token operator">-</span>mapreduce<span class="token operator">-</span>examples<span class="token operator">-</span><span class="token number">2.8</span><span class="token punctuation">.</span><span class="token number">4</span><span class="token operator">-</span>sources<span class="token punctuation">.</span>jar org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>hadoop<span class="token punctuation">.</span>examples<span class="token punctuation">.</span>WordCount <span class="token operator">/</span>user<span class="token operator">/</span>hadoop<span class="token operator">/</span>input output</code></pre><p>关闭服务</p><pre class=" language-java"><code class="language-java">$ stop<span class="token operator">-</span>dfs<span class="token punctuation">.</span>sh$ stop<span class="token operator">-</span>yarn<span class="token punctuation">.</span>sh</code></pre><h3 id="hadoop-hdfs-dfs基本操作"><a href="#hadoop-hdfs-dfs基本操作" class="headerlink" title="hadoop hdfs dfs基本操作"></a>hadoop hdfs dfs基本操作</h3><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><p>​      使用命令：</p><p>hdfs dfs -ls /  这条执行会列出/目录下的文件和目录</p><p>hdfs dfs -ls -R /这条会列出/目录下的左右文件，由于有-R参数，会在文件夹和子文件夹下执行ls操作</p><h5 id="添加文件夹"><a href="#添加文件夹" class="headerlink" title="添加文件夹"></a>添加文件夹</h5><p>​      使用命令；</p><p>hdfs dfs -mkdir -p /xytest/testdata001/</p><p>这里需要注意的是，root用户是否拥有hdfs 的权限，如果有，我们可以继续操作，如果没有，我们可以直接使用hdfs用户，默认安装完cdh后，用户hdfs拥有所有的权限 <a href="http://blog.csdn.net/wild46cat/article/details/69664376" target="_blank" rel="noopener">http://blog.csdn.net/wild46cat/article/details/69664376</a></p><h5 id="增加文件"><a href="#增加文件" class="headerlink" title="增加文件"></a>增加文件</h5><p>​      使用命令：</p><p>hdfs dfs -copyFromLocal ~/123.txt /xytest/testdata001/</p><h5 id="查看hdfs文件中的内容"><a href="#查看hdfs文件中的内容" class="headerlink" title="查看hdfs文件中的内容"></a>查看hdfs文件中的内容</h5><p>​      使用命令：</p><p>hdfs dfs -cat /xytest/testdata001/123.txt</p><h5 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h5><p>使用命令：</p><p>hdfs dfs -rm -f /xytest/testdata001/123.txt</p><h5 id="删除文件夹"><a href="#删除文件夹" class="headerlink" title="删除文件夹"></a>删除文件夹</h5><p>​      使用命令：</p><p>hdfs dfs -rm -r /xytest/testdata001</p><p>参考文档</p><p><a href="http://hadoop.apache.org/docs/r2.6.5/hadoop-project-dist/hadoop-common/FileSystemShell.html#ls" target="_blank" rel="noopener">http://hadoop.apache.org/docs/r2.6.5/hadoop-project-dist/hadoop-common/FileSystemShell.html#ls</a></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8中的Streams API详解</title>
      <link href="/2018/05/01/Java8%E4%B8%AD%E7%9A%84Streams-API%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/05/01/Java8%E4%B8%AD%E7%9A%84Streams-API%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="什么是流"><a href="#什么是流" class="headerlink" title="什么是流"></a>什么是流</h4><blockquote><p>Stream 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 Iterator。原始版本的 Iterator，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 Stream，用户只要给出需要对其包含的元素执行什么操作，比如 “过滤掉长度大于 10 的字符串”、“获取每个字符串的首字母”等，Stream 会隐式地在内部进行遍历，做出相应的数据转换。</p></blockquote><a id="more"></a><p>Stream 就如同一个迭代器（Iterator），单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。</p><p>而和迭代器又不同的是，Stream 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。Stream 的并行操作依赖于 Java7 中引入的 Fork/Join 框架（JSR166y）来拆分任务和加速处理过程。</p><h4 id="流的构成"><a href="#流的构成" class="headerlink" title="流的构成"></a>流的构成</h4><p>当我们使用一个流的时候，通常包括三个基本步骤：</p><p>获取一个数据源（source）→ 数据转换→执行操作获取想要的结果，每次转换原有 Stream 对象不改变，返回一个新的 Stream 对象（可以有多次转换），这就允许对其操作可以像链条一样排列，变成一个管道</p><p>有多种方式生成 Stream Source</p><p>在 Java 7 中，如果要发现 type 为 grocery 的所有交易，然后返回以交易值降序排序好的交易 ID 集合，我们需要这样写：</p><p>java 7 的排序 取值实现</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Transaction<span class="token operator">></span> groceryTransactions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Arraylist</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Transaction t<span class="token operator">:</span> transactions<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">if</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Transaction<span class="token punctuation">.</span>GROCERY<span class="token punctuation">)</span><span class="token punctuation">{</span> groceryTransactions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>groceryTransactions<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Transaction t1<span class="token punctuation">,</span> Transaction t2<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> t2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> transactionIds <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span><span class="token punctuation">(</span>Transaction t<span class="token operator">:</span> groceryTransactions<span class="token punctuation">)</span><span class="token punctuation">{</span> transactionsIds<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>java 8 的排序 取值实现</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> transactionsIds <span class="token operator">=</span> transactions<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">filter</span><span class="token punctuation">(</span>t <span class="token operator">-</span><span class="token operator">></span> t<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Transaction<span class="token punctuation">.</span>GROCERY<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token function">comparing</span><span class="token punctuation">(</span>Transaction<span class="token operator">:</span><span class="token operator">:</span>getValue<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">map</span><span class="token punctuation">(</span>Transaction<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="流的使用详解"><a href="#流的使用详解" class="headerlink" title="流的使用详解"></a>流的使用详解</h4><p>简单说，对 Stream 的使用就是实现一个 filter-map-reduce 过程，产生一个最终结果，或者导致一个副作用（side effect）。</p><h4 id="流的构造与转换"><a href="#流的构造与转换" class="headerlink" title="流的构造与转换"></a>流的构造与转换</h4><p>下面提供最常见的几种构造 Stream 的样例。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. Individual values</span>Stream stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. Arrays</span>String <span class="token punctuation">[</span><span class="token punctuation">]</span> strArray <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">}</span><span class="token punctuation">;</span>stream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span>stream <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. Collections</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>strArray<span class="token punctuation">)</span><span class="token punctuation">;</span>stream <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：</p><p>IntStream、LongStream、DoubleStream。当然我们也可以用 Stream<integer>、Stream<long> &gt;、Stream<double>，但是 boxing 和 unboxing 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。</double></long></integer></p><h5 id="数值流的构造"><a href="#数值流的构造" class="headerlink" title="数值流的构造"></a>数值流的构造</h5><pre class=" language-java"><code class="language-java">IntStream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>IntStream<span class="token punctuation">.</span><span class="token function">range</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span>IntStream<span class="token punctuation">.</span><span class="token function">rangeClosed</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="流转换为其它数据结构"><a href="#流转换为其它数据结构" class="headerlink" title="流转换为其它数据结构"></a>流转换为其它数据结构</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 1. Array</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> strArray1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 2. Collection</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> list2 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>ArrayList<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Set set1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Stack stack1 <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>Stack<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 3. String</span>String str <span class="token operator">=</span> stream<span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="List相互转换-List-do2vo"><a href="#List相互转换-List-do2vo" class="headerlink" title="List相互转换(List do2vo)"></a>List相互转换(List do2vo)</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>HiveTableSpaceResVO<span class="token operator">></span> hiveTableSpaceResVOS <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>DsHiveTableSpaceDO<span class="token operator">></span> dsHiveTableSpaceDOS <span class="token operator">=</span> dsHiveTableSpaceDAO<span class="token punctuation">.</span><span class="token function">queryLargeSpace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hiveTableSpaceResVOS <span class="token operator">=</span> dsHiveTableSpaceDOS<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>HomePageMapper<span class="token operator">:</span><span class="token operator">:</span>spacedo2vo<span class="token punctuation">)</span><span class="token punctuation">.</span>    <span class="token function">collect</span><span class="token punctuation">(</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="流的操作"><a href="#流的操作" class="headerlink" title="流的操作"></a>流的操作</h4><p>接下来，当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><ul><li>Intermediate：</li></ul><p>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</p><ul><li>Terminal：</li></ul><p>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p><ul><li>Short-circuiting：</li></ul><p>anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 limit</p><p>我们下面看一下 Stream 的比较典型用法。</p><p><strong>map/flatMap</strong></p><p>我们先来看 map。如果你熟悉 scala 这类函数式语言，对这个方法应该很了解，它的作用就是把 input Stream 的每一个元素，映射成 output Stream 的另外一个元素。</p><h5 id="转换大写"><a href="#转换大写" class="headerlink" title="转换大写"></a>转换大写</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> output <span class="token operator">=</span> wordList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="平方数"><a href="#平方数" class="headerlink" title="平方数"></a>平方数</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> nums <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squareNums  <span class="token operator">=</span> nums<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n<span class="token operator">-</span><span class="token operator">></span>n<span class="token operator">*</span>n<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码生成一个整数 list 的平方数 {1, 4, 9, 16}。</p><p>从上面例子可以看出，map 生成的是个 1:1 映射，每个输入元素，都按照规则转换成为另外一个元素。还有一些场景，是一对多映射关系的，这时需要 flatMap。</p><pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> inputStream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>Stream<span class="token operator">&lt;</span>Integer<span class="token operator">></span> outputStream <span class="token operator">=</span> inputStream<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span><span class="token punctuation">(</span>childList<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> childList<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>flatMap 把 input Stream 中的层级结构扁平化，就是将最底层元素抽出来放到一起，最终 output 的新 Stream 里面已经没有 List 了，都是直接的数字。</p><h5 id="filter"><a href="#filter" class="headerlink" title="filter"></a><strong>filter</strong></h5><p>filter 对原始 Stream 进行某项测试，通过测试的元素被留下来生成一个新 Stream。</p><pre><code>Integer[] sixNums = {1, 2, 3, 4, 5, 6};Integer[] evens = Stream.of(sixNums).filter(n -&gt; n%2 == 0).toArray(Integer[]::new);</code></pre><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> output <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>line <span class="token operator">-</span><span class="token operator">></span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span>REGEXP<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这段代码首先把每行的单词用 flatMap 整理到新的 Stream，然后保留长度不为 0 的，就是整篇文章中的全部单词了。</p><h5 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a><strong>forEach</strong></h5><p>forEach 方法接收一个 Lambda 表达式，然后在 Stream 的每一个元素上执行该表达式。</p><h5 id="打印姓名（forEach-和-pre-java8-的对比）"><a href="#打印姓名（forEach-和-pre-java8-的对比）" class="headerlink" title="打印姓名（forEach 和 pre-java8 的对比）"></a>打印姓名（forEach 和 pre-java8 的对比）</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Java 8</span>roster<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Person<span class="token punctuation">.</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Pre-Java 8</span><span class="token keyword">for</span> <span class="token punctuation">(</span>Person p <span class="token operator">:</span> roster<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getGender</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Person<span class="token punctuation">.</span>Sex<span class="token punctuation">.</span>MALE<span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>对一个人员集合遍历，找出男性并打印姓名。可以看出来，forEach 是为 Lambda 而设计的，保持了最紧凑的风格。而且 Lambda 表达式本身是可以重用的，非常方便。当需要为多核系统优化时，可以 parallelStream().forEach()，只是此时原有元素的次序没法保证，并行的情况下将改变串行时操作的行为，此时 forEach 本身的实现不需要调整，而 Java8 以前的 for 循环 code 可能需要加入额外的多线程逻辑。</p><p>但一般认为，forEach 和常规 for 循环的差异不涉及到性能，它们仅仅是函数式风格与传统 Java 风格的差别。</p><p>另外一点需要注意，forEach 是 terminal 操作，因此它执行后，Stream 的元素就被“消费”掉了，你无法对一个 Stream 进行两次 terminal 运算。下面的代码是错误的：</p><p>相反，具有相似功能的 intermediate 操作 peek 可以达到上述目的。如下是出现在该 api javadoc 上的一个示例。</p><h5 id="peek-对每个元素执行操作并返回一个新的-Stream"><a href="#peek-对每个元素执行操作并返回一个新的-Stream" class="headerlink" title="peek 对每个元素执行操作并返回一个新的 Stream"></a>peek 对每个元素执行操作并返回一个新的 Stream</h5><pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> e<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Filtered value: "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mapped value: "</span> <span class="token operator">+</span> e<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>forEach 不能修改自己包含的本地变量值，也不能用 break/return 之类的关键字提前结束循环。</p><p><strong>findFirst</strong></p><p>这是一个 termimal 兼 short-circuiting 操作，它总是返回 Stream 的第一个元素，或者空。</p><p>这里比较重点的是它的返回值类型：Optional。这也是一个模仿 Scala 语言中的概念，作为一个容器，它可能含有某值，或者不包含。使用它的目的是尽可能避免 NullPointerException。</p><h5 id="Optional-的两个用例"><a href="#Optional-的两个用例" class="headerlink" title="Optional 的两个用例"></a>Optional 的两个用例</h5><pre class=" language-java"><code class="language-java">String strA <span class="token operator">=</span> <span class="token string">" abcd "</span><span class="token punctuation">,</span> strB <span class="token operator">=</span> null<span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span>strB<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getLength</span><span class="token punctuation">(</span>strA<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getLength</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">getLength</span><span class="token punctuation">(</span>strB<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Java 8</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Pre-Java 8</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>text <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getLength</span><span class="token punctuation">(</span>String text<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// Java 8</span><span class="token keyword">return</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Pre-Java 8</span><span class="token comment" spellcheck="true">// return if (text != null) ? text.length() : -1;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>在更复杂的 if (xx != null) 的情况中，使用 Optional 代码的可读性更好，而且它提供的是编译时检查，能极大的降低 NPE 这种 Runtime Exception 对程序的影响，或者迫使程序员更早的在编码阶段处理空值问题，而不是留到运行时再发现和调试。</p><p>Stream 中的 findAny、max/min、reduce 等方法等返回 Optional 值。还有例如 IntStream.average() 返回 OptionalDouble 等等。</p><p><strong>reduce</strong></p><p>这个方法的主要作用是把 Stream 元素组合起来。它提供一个起始值（种子），然后依照运算规则（BinaryOperator），和前面 Stream 的第一个、第二个、第 n 个元素组合。从这个意义上说，字符串拼接、数值的 sum、min、max、average 都是特殊的 reduce。例如 Stream 的 sum 就相当于</p><p>Integer sum = integers.reduce(0, (a, b) -&gt; a+b); 或</p><p>Integer sum = integers.reduce(0, Integer::sum);</p><p>也有没有起始值的情况，这时会把 Stream 的前面两个元素组合起来，返回的是 Optional。</p><h5 id="reduce-的用例"><a href="#reduce-的用例" class="headerlink" title="reduce 的用例"></a>reduce 的用例</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 字符串连接，concat = "ABCD"</span>String concat <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"C"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>concat<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 求最小值，minValue = -3.0</span><span class="token keyword">double</span> minValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1.5</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">3.0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Double<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> Double<span class="token operator">:</span><span class="token operator">:</span>min<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 求和，sumValue = 10, 有起始值</span><span class="token keyword">int</span> sumValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 求和，sumValue = 10, 无起始值</span>sumValue <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 过滤，字符串连接，concat = "ace"</span>concat <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"B"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">,</span> <span class="token string">"D"</span><span class="token punctuation">,</span> <span class="token string">"e"</span><span class="token punctuation">,</span> <span class="token string">"F"</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">filter</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> x<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span><span class="token string">"Z"</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">reduce</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span> String<span class="token operator">:</span><span class="token operator">:</span>concat<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码例如第一个示例的 reduce()，第一个参数（空白字符）即为起始值，第二个参数（String::concat）为 BinaryOperator。这类有起始值的 reduce() 都返回具体的对象。而对于第四个示例没有起始值的 reduce()，由于可能没有足够的元素，返回的是 Optional，请留意这个区别。</p><p><strong>limit/skip</strong></p><p>limit 返回 Stream 的前面 n 个元素；skip 则是扔掉前 n 个元素（它是由一个叫 subStream 的方法改名而来）</p><h5 id="limit-和-skip-对运行次数的影响"><a href="#limit-和-skip-对运行次数的影响" class="headerlink" title="limit 和 skip 对运行次数的影响"></a>limit 和 skip 对运行次数的影响</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testLimitAndSkip</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">10000</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Person<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token punctuation">{</span> <span class="token keyword">public</span> <span class="token keyword">int</span> no<span class="token punctuation">;</span> <span class="token keyword">private</span> String name<span class="token punctuation">;</span> <span class="token keyword">public</span> <span class="token function">Person</span> <span class="token punctuation">(</span><span class="token keyword">int</span> no<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">this</span><span class="token punctuation">.</span>no <span class="token operator">=</span> no<span class="token punctuation">;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> name<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果为：</p><pre class=" language-java"><code class="language-java">name1name2name3name4name5name6name7name8name9name10<span class="token punctuation">[</span>name4<span class="token punctuation">,</span> name5<span class="token punctuation">,</span> name6<span class="token punctuation">,</span> name7<span class="token punctuation">,</span> name8<span class="token punctuation">,</span> name9<span class="token punctuation">,</span> name10<span class="token punctuation">]</span></code></pre><p>这是一个有 10，000 个元素的 Stream，但在 short-circuiting 操作 limit 和 skip 的作用下，管道中 map 操作指定的 getName() 方法的执行次数为 limit 所限定的 10 次，而最终返回结果在跳过前 3 个元素后只有后面 7 个返回。</p><p>有一种情况是 limit/skip 无法达到 short-circuiting 目的的，就是把它们放在 Stream 的排序操作后，原因跟 sorted 这个 intermediate 操作有关：此时系统并不知道 Stream 排序后的次序如何，所以 sorted 中的操作看上去就像完全没有被 limit 或者 skip 一样。</p><h5 id="limit-和-skip-对-sorted-后的运行次数无影响"><a href="#limit-和-skip-对-sorted-后的运行次数无影响" class="headerlink" title="limit 和 skip 对 sorted 后的运行次数无影响"></a>limit 和 skip 对 sorted 后的运行次数无影响</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>List<span class="token operator">&lt;</span>Person<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>首先对 5 个元素的 Stream 排序，然后进行 limit 操作。输出结果为：</p><pre class=" language-java"><code class="language-java">name2name1name3name2name4name3name5name4<span class="token punctuation">[</span>stream<span class="token punctuation">.</span>StreamDW$Person<span class="token annotation punctuation">@816f27d</span><span class="token punctuation">,</span> stream<span class="token punctuation">.</span>StreamDW$Person<span class="token annotation punctuation">@87aac27</span><span class="token punctuation">]</span></code></pre><p>即虽然最后的返回元素数量是 2，但整个管道中的 sorted 表达式执行次数没有像前面例子相应减少。</p><p>最后有一点需要注意的是，对一个 parallel 的 Steam 管道来说，如果其元素是有序的，那么 limit 操作的成本会比较大，因为它的返回对象必须是前 n 个也有一样次序的元素。取而代之的策略是取消元素间的次序，或者不要用 parallel Stream。</p><p><strong>sorted</strong></p><p>对 Stream 的排序通过 sorted 进行，它比数组的排序更强之处在于你可以首先对 Stream 进行各类 map、filter、limit、skip 甚至 distinct 来减少元素数量后，再排序，这能帮助程序明显缩短执行时间。我们对清单 14 进行优化：</p><h5 id="排序前进行-limit-和-skip"><a href="#排序前进行-limit-和-skip" class="headerlink" title="排序前进行 limit 和 skip"></a>排序前进行 limit 和 skip</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span> persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>person<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>List<span class="token operator">&lt;</span>Person<span class="token operator">></span> personList2 <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> p1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>p2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>personList2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>结果会简单很多：</p><pre class=" language-java"><code class="language-java">name2name1<span class="token punctuation">[</span>stream<span class="token punctuation">.</span>StreamDW$Person<span class="token annotation punctuation">@6ce253f1</span><span class="token punctuation">,</span> stream<span class="token punctuation">.</span>StreamDW$Person<span class="token annotation punctuation">@53d8d10a</span><span class="token punctuation">]</span></code></pre><p>当然，这种优化是有 business logic 上的局限性的：即不要求排序后再取值。</p><p><strong>min/max/distinct</strong></p><p>min 和 max 的功能也可以通过对 Stream 元素先排序，再 findFirst 来实现，但前者的性能会更好，为 O(n)，而 sorted 的成本是 O(n log n)。同时它们作为特殊的 reduce 方法被独立出来也是因为求最大最小值是很常见的操作。</p><h5 id="找出最长一行的长度"><a href="#找出最长一行的长度" class="headerlink" title="找出最长一行的长度"></a>找出最长一行的长度</h5><pre class=" language-java"><code class="language-java">BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileReader</span><span class="token punctuation">(</span><span class="token string">"c:\\SUService.log"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> longest <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">mapToInt</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>length<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">getAsInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>longest<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>下面的例子则使用 distinct 来找出不重复的单词。</p><h5 id="找出全文的单词，转小写，并排序"><a href="#找出全文的单词，转小写，并排序" class="headerlink" title="找出全文的单词，转小写，并排序"></a>找出全文的单词，转小写，并排序</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> words <span class="token operator">=</span> br<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">flatMap</span><span class="token punctuation">(</span>line <span class="token operator">-</span><span class="token operator">></span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>line<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">filter</span><span class="token punctuation">(</span>word <span class="token operator">-</span><span class="token operator">></span> word<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toLowerCase<span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>br<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>words<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><strong>Match</strong></p><p>Stream 有三个 match 方法，从语义上说：</p><ul><li>allMatch：Stream 中全部元素符合传入的 predicate，返回 true</li><li>anyMatch：Stream 中只要有一个元素符合传入的 predicate，返回 true</li><li>noneMatch：Stream 中没有一个元素符合传入的 predicate，返回 true</li></ul><p>它们都不是要遍历全部元素才能返回结果。例如 allMatch 只要一个元素不满足条件，就 skip 剩下的所有元素，返回 false。 Person 类稍做修改，加入一个 age 属性和 getAge 方法。</p><h5 id="使用-Match"><a href="#使用-Match" class="headerlink" title="使用 Match"></a>使用 Match</h5><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">21</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">34</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token string">"name"</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">55</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isAllAdult <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">allMatch</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"All are adult? "</span> <span class="token operator">+</span> isAllAdult<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> isThereAnyChild <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">anyMatch</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Any child? "</span> <span class="token operator">+</span> isThereAnyChild<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">All are adult<span class="token operator">?</span> <span class="token boolean">false</span>Any child<span class="token operator">?</span> <span class="token boolean">true</span></code></pre><h3 id="进阶：自己生成流"><a href="#进阶：自己生成流" class="headerlink" title="进阶：自己生成流"></a>进阶：自己生成流</h3><p><strong>Stream.generate</strong></p><p>通过实现 Supplier 接口，你可以自己来控制流的生成。这种情形通常用于随机数、常量的 Stream，或者需要前后元素间维持着某种状态信息的 Stream。把 Supplier 实例传递给 Stream.generate() 生成的 Stream，默认是串行（相对 parallel 而言）但无序的（相对 ordered 而言）。由于它是无限的，在管道中，必须利用 limit 之类的操作限制 Stream 大小。</p><h5 id="生成-10-个随机整数"><a href="#生成-10-个随机整数" class="headerlink" title="生成 10 个随机整数"></a>生成 10 个随机整数</h5><pre class=" language-java"><code class="language-java">Random seed <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Supplier<span class="token operator">&lt;</span>Integer<span class="token operator">></span> random <span class="token operator">=</span> seed<span class="token operator">:</span><span class="token operator">:</span>nextInt<span class="token punctuation">;</span>Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span>random<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//Another way</span>IntStream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>System<span class="token punctuation">.</span><span class="token function">nanoTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Stream.generate() 还接受自己实现的 Supplier。例如在构造海量测试数据的时候，用某种自动的规则给每一个变量赋值；或者依据公式计算 Stream 的每个元素值。这些都是维持状态信息的情形。</p><h5 id="自实现-Supplier"><a href="#自实现-Supplier" class="headerlink" title="自实现 Supplier"></a>自实现 Supplier</h5><pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">PersonSupplier</span> <span class="token keyword">implements</span> <span class="token class-name">Supplier</span><span class="token operator">&lt;</span>Person<span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token keyword">private</span> Random random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> Person <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span>index<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token string">"StormTestUser"</span> <span class="token operator">+</span> index<span class="token punctuation">,</span> random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">StormTestUser1<span class="token punctuation">,</span> <span class="token number">9</span>StormTestUser2<span class="token punctuation">,</span> <span class="token number">12</span>StormTestUser3<span class="token punctuation">,</span> <span class="token number">88</span>StormTestUser4<span class="token punctuation">,</span> <span class="token number">51</span>StormTestUser5<span class="token punctuation">,</span> <span class="token number">22</span>StormTestUser6<span class="token punctuation">,</span> <span class="token number">28</span>StormTestUser7<span class="token punctuation">,</span> <span class="token number">81</span>StormTestUser8<span class="token punctuation">,</span> <span class="token number">51</span>StormTestUser9<span class="token punctuation">,</span> <span class="token number">4</span>StormTestUser10<span class="token punctuation">,</span> <span class="token number">76</span></code></pre><p><strong>Stream.iterate</strong></p><p>iterate 跟 reduce 操作很像，接受一个种子值，和一个 UnaryOperator（例如 f）。然后种子值成为 Stream 的第一个元素，f(seed) 为第二个，f(f(seed)) 第三个，以此类推</p><p><strong>生成一个等差数列</strong></p><pre class=" language-java"><code class="language-java">Stream<span class="token punctuation">.</span><span class="token function">iterate</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> n <span class="token operator">-</span><span class="token operator">></span> n <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">forEach</span><span class="token punctuation">(</span>x <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span></code></pre><p>输出结果：</p><pre><code>0 3 6 9 12 15 18 21 24 27</code></pre><p>与 Stream.generate 相仿，在 iterate 时候管道必须有 limit 这样的操作来限制 Stream 大小。</p><h3 id="进阶：用-Collectors-来进行-reduction-操作"><a href="#进阶：用-Collectors-来进行-reduction-操作" class="headerlink" title="进阶：用 Collectors 来进行 reduction 操作"></a>进阶：用 Collectors 来进行 reduction 操作</h3><p>java.util.stream.Collectors 类的主要作用就是辅助进行各类有用的 reduction 操作，例如转变输出为 Collection，把 Stream 元素进行归组。</p><h5 id="按照年龄归组"><a href="#按照年龄归组" class="headerlink" title="按照年龄归组"></a>按照年龄归组</h5><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> personGroups <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>Person<span class="token operator">:</span><span class="token operator">:</span>getAge<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Iterator it <span class="token operator">=</span> personGroups<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span> <span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> persons <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Age "</span> <span class="token operator">+</span> persons<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" = "</span> <span class="token operator">+</span> persons<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的 code，首先生成 100 人的信息，然后按照年龄归组，相同年龄的人放到同一个 list 中，可以看到如下的输出：</p><pre class=" language-java"><code class="language-java">Age <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">2</span>Age <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">2</span>Age <span class="token number">5</span> <span class="token operator">=</span> <span class="token number">2</span>Age <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">1</span>Age <span class="token number">9</span> <span class="token operator">=</span> <span class="token number">1</span>Age <span class="token number">11</span> <span class="token operator">=</span> <span class="token number">2</span></code></pre><h5 id="按照未成年人和成年人归组"><a href="#按照未成年人和成年人归组" class="headerlink" title="按照未成年人和成年人归组"></a>按照未成年人和成年人归组</h5><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Person<span class="token operator">>></span> children <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">generate</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PersonSupplier</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span> <span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>p <span class="token operator">-</span><span class="token operator">></span> p<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Children number: "</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Adult number: "</span> <span class="token operator">+</span> children<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>输出结果：</p><pre class=" language-java"><code class="language-java">Children number<span class="token operator">:</span> <span class="token number">23</span> Adult number<span class="token operator">:</span> <span class="token number">77</span></code></pre><p>在使用条件“年龄小于 18”进行分组后可以看到，不到 18 岁的未成年人是一组，成年人是另外一组。partitioningBy 其实是一种特殊的 groupingBy，它依照条件测试的是否两种结果来构造返回的数据结构，get(true) 和 get(false) 能即为全部的元素对象。</p><p>总之，Stream 的特性可以归纳为：</p><ul><li>不是数据结构</li></ul><ul><li>它没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>它也绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li></ul><ul><li>所有 Stream 的操作必须以 lambda 表达式为参数</li><li>不支持索引访问</li></ul><ul><li>你可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li></ul><ul><li>很容易生成数组或者 List</li><li>惰性化</li></ul><ul><li>很多 Stream 操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Intermediate 操作永远是惰性化的。</li></ul><ul><li>并行能力</li></ul><ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul><ul><li>可以是无限的<ul><li>集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成</li></ul></li></ul><p>参考链接： <a href="https://www.ibm.com/developerworks/cn/topics/" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/topics/</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 Java 线程池：ThreadPoolExecutor</title>
      <link href="/2018/02/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/"/>
      <url>/2018/02/18/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9AThreadPoolExecutor/</url>
      
        <content type="html"><![CDATA[<p>线程池介绍</p><p>在web开发中，服务器需要接受并处理请求，所以会为一个请求来分配一个线程进行处理，如果每次请求都创建一个线程的话实现起来非常简便，但是存在一个问题。</p><p>如果并发请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁线程，如此一来会大大降低系统的效率，可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p><p>线程池的目的就是执行完一个任务，并不销毁，而是可以继续执行其他任务。线程池为线程生命周期的开销和资源不足提供了解决方案，通过对多个任务重用线程，线程创建的开销别分摊到多个任务上。</p><p>线程池使用场景</p><ul><li>单个任务处理时间很短</li><li>需要处理的任务数量很大。</li></ul><p>使用线程池的好处</p><ul><li>降低资源消耗，通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度，当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性，线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，挑用和监控。</li></ul><p>java中的线程池利用ThreadPoolExecutor 类来实现的，接下来分析线程池的源码实现。</p><p>Executor 框架</p><p>Executor框架是一个根据一组执行策略调用、调度、执行和控制的异步任务的框架，目的是提供一种将任务提交与任务如何运行分离开来的机制。</p><ul><li>Executor： 一个运行新任务的简单接口</li><li>ExecutorService: 扩展了Executor接口。添加了一些用来管理执行器生命周期和任务生命周期的方法；</li><li>ScheduledExecutorService: 扩展了ExecutorService.支持Future和定期执行任务。</li></ul><p>Executor接口</p><pre><code>public interface Executor {    /**     * Executes the given command at some time in the future.  The command     * may execute in a new thread, in a pooled thread, or in the calling     * thread, at the discretion of the {@code Executor} implementation.     *     * @param command the runnable task     * @throws RejectedExecutionException if this task cannot be     * accepted for execution     * @throws NullPointerException if command is null     */    void execute(Runnable command);}</code></pre><p>Executor接口只有一个execute方法，用来替代通常创建或启动线程的方法。例如，使用Thread来创建并启动线程的代码如下：</p><pre><code>Thread t = new Thread();t.start();</code></pre><p>使用Executor来启动线程执行任务的代码如下：</p><pre><code>Thread t = new Thread();executor.execute(t);</code></pre><p>对于不同的Executor实现，execute()方法可能是创建一个新线程并立即启动，也有可能是使用已有的工作线程来运行传入的任务，也可能是根据设置线程的容量或者阻塞队列的容量来决定是否要将传入的线程放入阻塞队列中或者拒绝接受传入的线程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 并发编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java垃圾回收机制</title>
      <link href="/2018/01/29/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/01/29/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<h5 id="Java垃圾回收机制"><a href="#Java垃圾回收机制" class="headerlink" title="Java垃圾回收机制"></a>Java垃圾回收机制</h5><p>Java的自动内存管理只要针对对象内存的回收和对象内存的分配，同时，java自动内存管理最核心的功能时堆内存中对象的分配与回收。</p><p>JDK1.8之前的堆内存示意图：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm20.jpg" alt></p><p>从图示可以看出来，堆内存分为新生代，老年代，和永久代，新生代又被进一步分为：Eden区 + Survivor1区+Survivor2区。而在JDK1.8中移出整个永久代，取而代之的是一个叫元空间的区域(永久代使用的是JVM的堆内存空间，而元空间使用的是物理内存，直接受到本机的物理内存限制)</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm21.png" alt></p><p>对象优先在eden区分配</p><p>目前主流的垃圾收集器都会采用分代回收算法，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>大多数情况下，对象在新生代中eden区分配，当eden区没有足够的空间进行分配时,虚拟机将发起一次Mnior GC。</p><ul><li>新生代GC(Mnior GC) 指发生新生代的垃圾收集动作，Minor GC非常频繁。回收速度一般也比较快</li><li>老年代GC(Major GC/Full GC): 指发生在老年代的GC,出现了Major GC经常会伴随至少一次的Minor GC(并非绝对)，Major GC的速度一般都会比Minor GC的慢10倍以上。</li></ul><p>测试用例</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GCTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> allocation1<span class="token punctuation">,</span> allocation2<span class="token punctuation">;</span>        allocation1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">30900</span> <span class="token operator">*</span> <span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// allocation2 = new byte[900 * 1024];</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>添加的参数：<code>-XX:+PrintGCDetails</code> </p><p>控制台打印出</p><pre class=" language-java"><code class="language-java">Heap PSYoungGen      total 38400K<span class="token punctuation">,</span> used 4661K <span class="token punctuation">[</span><span class="token number">0x00000000d5d80000</span><span class="token punctuation">,</span> <span class="token number">0x00000000d8800000</span><span class="token punctuation">,</span> <span class="token number">0x0000000100000000</span><span class="token punctuation">)</span>  eden space 33280K<span class="token punctuation">,</span> <span class="token number">14</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d5d80000</span><span class="token punctuation">,</span><span class="token number">0x00000000d620d580</span><span class="token punctuation">,</span><span class="token number">0x00000000d7e00000</span><span class="token punctuation">)</span>  from space 5120K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d8300000</span><span class="token punctuation">,</span><span class="token number">0x00000000d8300000</span><span class="token punctuation">,</span><span class="token number">0x00000000d8800000</span><span class="token punctuation">)</span>  to   space 5120K<span class="token punctuation">,</span> <span class="token number">0</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x00000000d7e00000</span><span class="token punctuation">,</span><span class="token number">0x00000000d7e00000</span><span class="token punctuation">,</span><span class="token number">0x00000000d8300000</span><span class="token punctuation">)</span> ParOldGen       total 87552K<span class="token punctuation">,</span> used 30900K <span class="token punctuation">[</span><span class="token number">0x0000000081800000</span><span class="token punctuation">,</span> <span class="token number">0x0000000086d80000</span><span class="token punctuation">,</span> <span class="token number">0x00000000d5d80000</span><span class="token punctuation">)</span>  object space 87552K<span class="token punctuation">,</span> <span class="token number">35</span><span class="token operator">%</span> used <span class="token punctuation">[</span><span class="token number">0x0000000081800000</span><span class="token punctuation">,</span><span class="token number">0x000000008362d010</span><span class="token punctuation">,</span><span class="token number">0x0000000086d80000</span><span class="token punctuation">)</span> Metaspace       used 3496K<span class="token punctuation">,</span> capacity 4498K<span class="token punctuation">,</span> committed 4864K<span class="token punctuation">,</span> reserved 1056768K  <span class="token keyword">class</span> <span class="token class-name">space</span>    used 387K<span class="token punctuation">,</span> capacity 390K<span class="token punctuation">,</span> committed 512K<span class="token punctuation">,</span> reserved 1048576K</code></pre><h5 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h5><p>大对象就是需要大量连续内存空间的对象(比如： 字符串、数组)</p><p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。</p><h5 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h5><p>既然虚拟机采用了分代收集的实想来管理内存，那么内存回收时就必需能识别哪些对象应放在新生代，哪些对象应放在老年代中，为了实现这一点，虚拟机给每个对象一个对象年龄(Age)计数器</p><p>如果对象在eden出生并经过第一次Minor GC 后仍然能够存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并将对象年龄设为1,对象在Survivor中每熬过一次MinorGC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15岁)，就会被晋升到老年代中，对象晋升到老年代的年龄阀值，可以通过参数 -XX:MaxTenuringThreshold来设置</p><h5 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h5><p>为了更好的适应不同程序的内存情况，虚拟机不是永远要求对象年龄必须达到某个值才能进入老年代，如果Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需达到要求的年龄。</p><h5 id="判定对象是否已经死亡"><a href="#判定对象是否已经死亡" class="headerlink" title="判定对象是否已经死亡"></a>判定对象是否已经死亡</h5><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm25.jpg" alt></p><h5 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h5><p>给对象添加一个引用计数器，每当有一个地方引用它，计数器就加1;当引用失效，计数器就减一，任何时候计数器为0的对象就是不可能在被使用的。</p><p>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题，所谓对象之间的相互引用问题，如下列代码所示，除了对象objA 和objB相互引用着对方之外，这两个对象之间再无任何引用，但是他们因为相互引用对方，导致它们的引用计数器都不为0，于是引用计数器算法无法通知GC回收。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ReferenceCountingGc</span> <span class="token punctuation">{</span>    Object instance <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ReferenceCountingGc objA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ReferenceCountingGc objB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceCountingGc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        objA<span class="token punctuation">.</span>instance <span class="token operator">=</span> objB<span class="token punctuation">;</span>        objB<span class="token punctuation">.</span>instance <span class="token operator">=</span> objA<span class="token punctuation">;</span>        objA <span class="token operator">=</span> null<span class="token punctuation">;</span>        objB <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>可达性分析算法</p><p>这个算法的基本思想就是通过一系列的称为GC Roots 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连的话，就证明此对象不可用。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm26.jpg" alt></p><h4 id="谈一谈引用"><a href="#谈一谈引用" class="headerlink" title="谈一谈引用"></a>谈一谈引用</h4><blockquote><p> 问题： 强引用、软引用、弱引用、幻象引用有什么区别？具体使用场景是什么？</p></blockquote><p>不同的引用类型，主要体现的是<strong>对象不同的可达性（reachable）状态和对垃圾收集的影响</strong>。</p><p>所谓<strong>强引用</strong>（”Strong” Reference），就是我们最常见的普通对象引用，只要还有强引用指向一个对象，就能表明对象还“活着”，垃圾收集器不会碰这种对象。对于一个普通的对象，如果没有其他的引用关系，只要超过了引用的作用域或者显式地将相应（强）引用赋值为 null，就是可以被垃圾收集的了，当然具体回收时机还是要看垃圾收集策略。</p><p><strong>软引用</strong>（SoftReference），是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象。软引用通常用来实现内存敏感的缓存，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p><p><strong>弱引用</strong>（WeakReference）并不能使对象豁免垃圾收集，仅仅是提供一种访问在弱引用状态下对象的途径。这就可以用来构建一种没有特定约束的关系，比如，维护一种非强制性的映射关系，如果试图获取时对象还在，就使用它，否则重现实例化。它同样是很多缓存实现的选择。</p><p>对于<strong>幻象引用</strong>，有时候也翻译成虚引用，你不能通过它访问对象。幻象引用仅仅是提供了一种确保对象被 finalize 以后，做某些事情的机制，比如，通常用来做所谓的 Post-Mortem 清理机制，我在专栏上一讲中介绍的 Java 平台自身 Cleaner 机制等，也有人利用幻象引用监控对象的创建和销毁。</p><h5 id="对象可达性状态流转分析"><a href="#对象可达性状态流转分析" class="headerlink" title="对象可达性状态流转分析"></a>对象可达性状态流转分析</h5><p>首先，请你看下面流程图，我这里简单总结了对象生命周期和不同可达性状态，以及不同状态可能的改变关系，可能未必 100% 严谨，来阐述下可达性的变化。</p><p>​    <img src="https://github.com/gaohueric/blogpicture/raw/master/jvm27.png" alt></p><p>上图的具体状态，这是 Java 定义的不同可达性级别（reachability level），具体如下：</p><ul><li>强可达（Strongly Reachable），就是当一个对象可以有一个或多个线程可以不通过各种引用访问到的情况。比如，我们新创建一个对象，那么创建它的线程对它就是强可达。</li><li>软可达（Softly Reachable），就是当我们只能通过软引用才能访问到对象的状态。</li><li>弱可达（Weakly Reachable），类似前面提到的，就是无法通过强引用或者软引用访问，只能通过弱引用访问时的状态。这是十分临近 finalize 状态的时机，当弱引用被清除的时候，就符合 finalize 的条件了。</li><li>幻象可达（Phantom Reachable），上面流程图已经很直观了，就是没有强、软、弱引用关联，并且 finalize 过了，只有幻象引用指向这个对象的时候。</li><li>当然，还有一个最后的状态，就是不可达（unreachable），意味着对象可以被清除了。</li></ul><p>判断对象可达性，是 JVM 垃圾收集器决定如何处理对象的一部分考虑。</p><p>所有引用类型，都是抽象类 java.lang.ref.Reference 的子类，你可能注意到它提供了 get() 方法：</p><pre class=" language-java"><code class="language-java">T           <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>           Returns <span class="token keyword">this</span> reference object's reference</code></pre><p>除了幻象引用（因为 get 永远返回 null），如果对象还没有被销毁，都可以通过 get 方法获取原有对象。这意味着，利用软引用和弱引用，我们可以将访问到的对象，重新指向强引用，也就是人为的改变了对象的可达性状态！这也是为什么我在上面图里有些地方画了双向箭头。</p><p>所以，对于软引用、弱引用之类，垃圾收集器可能会存在二次确认的问题，以保证处于弱引用状态的对象，没有改变为强引用。</p><p>但是，你觉得这里有没有可能出现什么问题呢？</p><p>不错，如果我们错误的保持了强引用（比如，赋值给了 static 变量），那么对象可能就没有机会变回类似弱引用的可达性状态了，就会产生内存泄漏。所以，检查弱引用指向对象是否被垃圾收集，也是诊断是否有特定内存泄漏的一个思路，如果我们的框架使用到弱引用又怀疑有内存泄漏，就可以从这个角度检查。</p><h5 id="引用队列（ReferenceQueue）使用"><a href="#引用队列（ReferenceQueue）使用" class="headerlink" title="引用队列（ReferenceQueue）使用"></a>引用队列（ReferenceQueue）使用</h5><p>谈到各种引用的编程，就必然要提到引用队列。我们在创建各种引用并关联到响应对象时，可以选择是否需要关联引用队列，JVM 会在特定时机将引用 enqueue 到队列里，我们可以从队列里获取引用（remove 方法在这里实际是有获取的意思）进行相关后续逻辑。尤其是幻象引用，get 方法只返回 null，如果再不指定引用队列，基本就没有意义了。看看下面的示例代码。利用引用队列，我们可以在对象处于相应状态时（对于幻象引用，就是前面说的被 finalize 了，处于幻象可达状态），执行后期处理逻辑。</p><pre><code>Object counter = new Object();ReferenceQueue refQueue = new ReferenceQueue&lt;&gt;();PhantomReference&lt;Object&gt; p = new PhantomReference&lt;&gt;(counter, refQueue);counter = null;System.gc();try {    // Remove 是一个阻塞方法，可以指定 timeout，或者选择一直阻塞    Reference&lt;Object&gt; ref = refQueue.remove(1000L);    if (ref != null) {        // do something    }} catch (InterruptedException e) {    // Handle it}</code></pre><h5 id="显式地影响软引用垃圾收集"><a href="#显式地影响软引用垃圾收集" class="headerlink" title="显式地影响软引用垃圾收集"></a>显式地影响软引用垃圾收集</h5><p>前面泛泛提到了引用对垃圾收集的影响，尤其是软引用，到底 JVM 内部是怎么处理它的，其实并不是非常明确。那么我们能不能使用什么方法来影响软引用的垃圾收集呢？</p><p>答案是有的。软引用通常会在最后一次引用后，还能保持一段时间，默认值是根据堆剩余空间计算的（以 M bytes 为单位）。从 Java 1.3.1 开始，提供了 -XX:SoftRefLRUPolicyMSPerMB 参数，我们可以以毫秒（milliseconds）为单位设置。比如，下面这个示例就是设置为 3 秒（3000 毫秒）。</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span>SoftRefLRUPolicyMSPerMB<span class="token operator">=</span><span class="token number">3000</span></code></pre><p>这个剩余空间，其实会受不同 JVM 模式影响，对于 Client 模式，比如通常的 Windows 32 bit JDK，剩余空间是计算当前堆里空闲的大小，所以更加倾向于回收；而对于 server 模式 JVM，则是根据 -Xmx 指定的最大值来计算。</p><p>本质上，这个行为还是个黑盒，取决于 JVM 实现，即使是上面提到的参数，在新版的 JDK 上也未必有效，另外 Client 模式的 JDK 已经逐步退出历史舞台。所以在我们应用时，可以参考类似设置，但不要过于依赖它。</p><h5 id="诊断-JVM-引用情况"><a href="#诊断-JVM-引用情况" class="headerlink" title="诊断 JVM 引用情况"></a>诊断 JVM 引用情况</h5><p>如果你怀疑应用存在引用（或 finalize）导致的回收问题，可以有很多工具或者选项可供选择，比如 HotSpot JVM 自身便提供了明确的选项（PrintReferenceGC）去获取相关信息，我指定了下面选项去使用 JDK 8 运行一个样例应用：</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCDetails <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintGCTimeStamps <span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>PrintReferenceGC</code></pre><p>这是 JDK 8 使用 ParrallelGC 收集的垃圾收集日志，各种引用数量非常清晰。</p><pre class=" language-java"><code class="language-java"><span class="token number">0.403</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token function">GC</span> <span class="token punctuation">(</span>Allocation Failure<span class="token punctuation">)</span> <span class="token number">0.871</span><span class="token operator">:</span> <span class="token punctuation">[</span>SoftReference<span class="token punctuation">,</span> <span class="token number">0</span> refs<span class="token punctuation">,</span> <span class="token number">0.0000393</span> secs<span class="token punctuation">]</span><span class="token number">0.871</span><span class="token operator">:</span> <span class="token punctuation">[</span>WeakReference<span class="token punctuation">,</span> <span class="token number">8</span> refs<span class="token punctuation">,</span> <span class="token number">0.0000138</span> secs<span class="token punctuation">]</span><span class="token number">0.871</span><span class="token operator">:</span> <span class="token punctuation">[</span>FinalReference<span class="token punctuation">,</span> <span class="token number">4</span> refs<span class="token punctuation">,</span> <span class="token number">0.0000094</span> secs<span class="token punctuation">]</span><span class="token number">0.871</span><span class="token operator">:</span> <span class="token punctuation">[</span>PhantomReference<span class="token punctuation">,</span> <span class="token number">0</span> refs<span class="token punctuation">,</span> <span class="token number">0</span> refs<span class="token punctuation">,</span> <span class="token number">0.0000085</span> secs<span class="token punctuation">]</span><span class="token number">0.871</span><span class="token operator">:</span> <span class="token punctuation">[</span>JNI Weak Reference<span class="token punctuation">,</span> <span class="token number">0.0000071</span> secs<span class="token punctuation">]</span><span class="token punctuation">[</span>PSYoungGen<span class="token operator">:</span> 76272K<span class="token operator">-</span><span class="token operator">></span><span class="token function">10720K</span><span class="token punctuation">(</span>141824K<span class="token punctuation">)</span><span class="token punctuation">]</span> 128286K<span class="token operator">-</span><span class="token operator">></span><span class="token function">128422K</span><span class="token punctuation">(</span>316928K<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.4683919</span> secs<span class="token punctuation">]</span> <span class="token punctuation">[</span>Times<span class="token operator">:</span> user<span class="token operator">=</span><span class="token number">1.17</span> sys<span class="token operator">=</span><span class="token number">0.03</span><span class="token punctuation">,</span> real<span class="token operator">=</span><span class="token number">0.47</span> secs<span class="token punctuation">]</span></code></pre><p><strong>注意：JDK 9 对 JVM 和垃圾收集日志进行了广泛的重构</strong>，类似 PrintGCTimeStamps 和 PrintReferenceGC 已经不再存在，我在专栏后面的垃圾收集主题里会更加系统的阐述。</p><h5 id="Reachability-Fence"><a href="#Reachability-Fence" class="headerlink" title="Reachability Fence"></a>Reachability Fence</h5><p>除了我前面介绍的几种基本引用类型，我们也可以通过底层 API 来达到强引用的效果，这就是所谓的设置<strong>reachability fence</strong>。</p><p>为什么需要这种机制呢？考虑一下这样的场景，按照 Java 语言规范，如果一个对象没有指向强引用，就符合垃圾收集的标准，有些时候，对象本身并没有强引用，但是也许它的部分属性还在被使用，这样就导致诡异的问题，所以我们需要一个方法，在没有强引用情况下，通知 JVM 对象是在被使用的。说起来有点绕，我们来看看 Java 9 中提供的案例。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span> <span class="token keyword">private</span> <span class="token keyword">static</span> ExternalResource<span class="token punctuation">[</span><span class="token punctuation">]</span> externalResourceArray <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">int</span> myIndex<span class="token punctuation">;</span> <span class="token function">Resource</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     myIndex <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>     externalResourceArray<span class="token punctuation">[</span>myIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     externalResourceArray<span class="token punctuation">[</span>myIndex<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">try</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 需要被保护的代码</span>     <span class="token keyword">int</span> i <span class="token operator">=</span> myIndex<span class="token punctuation">;</span>     Resource<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>externalResourceArray<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 调用 reachbilityFence，明确保障对象 strongly reachable</span>     Reference<span class="token punctuation">.</span><span class="token function">reachabilityFence</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span>ExternalResource ext<span class="token punctuation">)</span> <span class="token punctuation">{</span>    ext<span class="token punctuation">.</span>status <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>方法 action 的执行，依赖于对象的部分属性，所以被特定保护了起来。否则，如果我们在代码中像下面这样调用，那么就可能会出现困扰，因为没有强引用指向我们创建出来的 Resource 对象，JVM 对它进行 finalize 操作是完全合法的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">new</span> <span class="token class-name">Resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>类似的书写结构，在异步编程中似乎是很普遍的，因为异步编程中往往不会用传统的“执行 -&gt; 返回 -&gt; 使用”的结构。</p><p>在 Java 9 之前，实现类似类似功能相对比较繁琐，有的时候需要采取一些比较隐晦的小技巧。幸好，java.lang.ref.Reference 给我们提供了新方法，它是 JEP 193: Variable Handles 的一部分，将 Java 平台底层的一些能力暴露出来：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">reachabilityFence</span><span class="token punctuation">(</span>Object ref<span class="token punctuation">)</span></code></pre><p>在 JDK 源码中，reachabilityFence 大多使用在 Executors 或者类似新的 HTTP/2 客户端代码中，大部分都是异步调用的情况。编程中，可以按照上面这个例子，将需要 reachability 保障的代码段利用 try-finally 包围起来，在 finally 里明确声明对象强可达。</p><h4 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h4><h5 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h5><p>算法分为“标记”和“清除”阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。它是最基础的收集算法，效率也很高，但是会带来两个明显的问题：</p><ul><li>效率问题</li><li>空间问题(标记清除后会产生大量不连续的内存碎片)</li></ul><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm27.jpg" alt></p><h5 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h5><p>为了解决效率问题，复制收集算法出现了，它可以将内存分为大小相同的两块，每次使用其中的一块，当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉，这样使每次的内存回收都是对内存区间的一半进行回收。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm28.jpg" alt></p><h5 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h5><p>根据老年代的特点特出了一种标记算法，标记过程仍然与 标记清除算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm29.jpg" alt></p><h5 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h5><p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块，一般将java堆分为新生代和老年代，这样我们就 可以 根据各个年代的特点选择合适的垃圾收集算法。</p><p>比如 在新生代中，每次收集都会有大量的对象死去，所以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集，而老年代的对象存活几率比较高，而且没有额外的空间对它进行分配担保，所以我们必须选择标记清除或标记整理算法进行垃圾收集。</p><h4 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h4><h5 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h5><p>Serial(串行)收集器是最基本、历史最悠久的垃圾收集器了，该收集器是一个单线程收集器，它的单线程的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其它所有的工作线程(“Stop The World”) 直到它收集结束。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm99.jpg" alt></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法</strong></p><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p><h5 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h5><p>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为(控制参数，收集算法，回收策略)和Serial收集器完全一样。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm98.jpg" alt></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器(真正意义上的并发收集器)配合工作。</p><p>并行和并发概念：</p><ul><li>并行： 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li><li>并发：  指用户线程与垃圾收集线程同时只需(但不一定是并行，可能会交替执行)，用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul><h5 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h5><p>Parallel Scavenge收集器类似于ParNew收集器，那么它有什么特别之处呢？</p><pre class=" language-java"><code class="language-java"><span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseParallelGC     使用Parallel收集器<span class="token operator">+</span> 老年代串行<span class="token operator">-</span>XX<span class="token operator">:</span><span class="token operator">+</span>UseParallelOldGC    使用Parallel收集器<span class="token operator">+</span> 老年代并行</code></pre><p>Parallen Scavenge收集器关注点在吞吐量(高效利用CPU),CMS等垃圾收集器的关注点更多的是用户线程的停顿时间(提高用户体验)，所谓吞吐量就是CPU用于运行哟呼代码的时间与CPU总消耗时间的比值，Parallel Scavenge 收集器提供了很多参数供用户找到合适的停顿时间或最大的吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm97.jpg" alt></p><p>新生代采用复制算法，老年代采用标记—整理算法</p><h5 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h5><p>Serial收集器的老年代版本，它同样是一个单线程收集器，它主要有两大用途，一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><h5 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h5><p>Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法，在注重吞吐量以及CPU资源的场合，都可以优先考虑Parallel Scavenge收集器和Parallel Old收集器。</p><h5 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h5><p>CMS(Concurrent Mark Sweep) 收集器是一种以获取最短回收停顿时间为目标的收集器，它非常符合在注重用户体验的应用上使用</p><p>CMS收集器是HotSpot虚拟机第一框真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程同时工作。</p><p>从名字中的Mark Sweep 这两个词可以看出，CMS收集器是一种标记-清除算法实现的，它的运作过程相比于前面几张垃圾收集器来说更加复杂一些，整个过程分为四个步骤。</p><ul><li>初始标记： 暂停所有的其它线程，并记录下直接与root相连的对象，速度很快。</li><li>并发标记：同时开启GC和用户线程，用一个闭包结构去记录可达对象，单在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象，因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性，所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>重新标记：重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时候稍长，远远比并发标记阶段短。</li><li>并发清除： 开启用户线程，同时GC线程开始对位标记的区域做清扫。</li></ul><h5 id><a href="#" class="headerlink" title></a><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm96.jpg" alt></h5><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点： 并发收集，低停顿，但是它有下面三个明显的缺点：</p><ul><li>对CPU资源敏感</li><li>无法处理浮动垃圾</li><li>它使用的回收算法，标记-清除算法会导致收集结束时产生大量的空间碎片。</li></ul><h5 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h5><p>Gl(Garbage-First) 是一款面向服务器的垃圾收集器，主要针对配备多颗处理器以及大容量内存的机器，以及高概率满足GC停顿时间要求的同时，还具备高吞吐量性能特征</p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存模型</title>
      <link href="/2018/01/22/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
      <url>/2018/01/22/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="Java内存模型的定义"><a href="#Java内存模型的定义" class="headerlink" title="Java内存模型的定义"></a>Java内存模型的定义</h4><p>在多核系统中,处理器一般有一层或者多层的缓存,这些的缓存通过加速数据访问（因为数据距离处理器更近）和降低共享内存在总线上的通讯（因为本地缓存能够满足许多内存操作）来提高CPU性能.缓存能够大大提升性能,但是它们也带来了许多挑战.例如，当两个CPU同时检查相同的内存地址时会发生什么?在什么样的条件下它们会看到相同的值?</p><p>在处理器层面上，内存模型定义了一个充要条件，“让当前的处理器可以看到其他处理器写入到内存的数据”以及“其他处理器可以看到当前处理器写入到内存的数据”。有些处理器有很强的内存模型(strong memory model)，能够让所有的处理器在任何时候任何指定的内存地址上都可以看到完全相同的值。而另外一些处理器则有较弱的内存模型（weaker memory model），在这种处理器中，必须使用内存屏障（一种特殊的指令）来刷新本地处理器缓存并使本地处理器缓存无效，目的是为了让当前处理器能够看到其他处理器的写操作或者让其他处理器能看到当前处理器的写操作。这些内存屏障通常在lock和unlock操作的时候完成。内存屏障在高级语言中对程序员是不可见的。</p><p>在强内存模型下，有时候编写程序可能会更容易，因为减少了对内存屏障的依赖。但是即使在一些最强的内存模型下，内存屏障仍然是必须的。设置内存屏障往往与我们的直觉并不一致。近来处理器设计的趋势更倾向于弱的内存模型，因为弱内存模型削弱了缓存一致性，所以在多处理器平台和更大容量的内存下可以实现更好的可伸缩性</p><p>“一个线程的写操作对其他线程可见”这个问题是因为编译器对代码进行重排序导致的。例如，只要代码移动不会改变程序的语义，当编译器认为程序中移动一个写操作到后面会更有效的时候，编译器就会对代码进行移动。如果编译器推迟执行一个操作，其他线程可能在这个操作执行完之前都不会看到该操作的结果，这反映了缓存的影响。</p><p>此外，写入内存的操作能够被移动到程序里更前的时候。在这种情况下，其他的线程在程序中可能看到一个比它实际发生更早的写操作。所有的这些灵活性的设计是为了通过给编译器，运行时或硬件灵活性使其能在最佳顺序的情况下来执行操作。在内存模型的限定之内，我们能够获取到更高的性能。</p><h4 id="Java内存模型的抽象"><a href="#Java内存模型的抽象" class="headerlink" title="Java内存模型的抽象"></a>Java内存模型的抽象</h4><p>Java 线程之间的通信由 Java 内存模型（本文简称为 JMM）控制，JMM 决定一个线程对共享变量的写入何时对另一个线程可见。从抽象的角度来看，JMM 定义了线程和主内存之间的抽象关系：线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读 / 写共享变量的副本。本地内存是 JMM 的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java 内存模型的抽象示意图如下：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm.png" alt></p><p>从上图来看，线程A与线程B之间要通信的话，必须要经历下面两个步骤：</p><ul><li>首先，线程A把本地内存A中更新过的共享变量刷新到主内存中取。</li><li>然后，线程B到主内存中去读取线程A之前已经更新过的共享变量</li></ul><p>如下图所示</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm2.png" alt></p><p>本地内存A和B有主内存中共享变量x的副本，假设初始时，这三个内存中的x值都为0，线程A在执行时，把更新后的X值(假设值为1)临时存放在自己的本地内存A中，当线程A和线程B需要通信时，线程A首先会把自己本地内存中修改后的x值刷新到主内存中，此时内存中的x值变为了1，随后，线程B到主内存中取读取线程A更新后的x值，此时线程B的本地内存的x值也变为了1.</p><p>从整体来看，这两个步骤实质上是线程A在想线程B发送消息，二期这个通信过程必须要经过主内存，JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</p><h4 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h4><p>在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序，重排序分三种类型。</p><ul><li>编译器优化的重排序，编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li><li>指令级并行的重排序，现代处理器采用了指令级的并行计算来将多条指令重叠执行，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序，由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。</li></ul><p>以下是源代码到最终实际执行的指令序列，会分别经历下面三种重排序。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm3.png" alt></p><p>1属于编译器重排序，2和3属于处理器重排序，这些重排序都可能会导致多线程程序出现内存可见性问题，对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序，对于处理器重排序，JMM的处理器重排序规则会要求java编译器在生成指令序列时，插入特定类型的内存屏障指令，通过内存屏障指令来禁止特定类型的处理器重排序</p><p>JMM属于语言级的内存模型，它确保在不同的编译器和不同的处理器平台上，通过禁止特定类型的编译器重排序和处理器重排序，为程序员提供一致的内存可见性保证。</p><p><strong>处理器重排序与内存屏障指令</strong></p><p>现代的处理器使用写缓存区来临时保存向内存写入的数据，写缓存区可以保证指令流水线持续运行，它可以避免由于处理器停顿下来等待向内存写入数据而产生的延迟，同时，通过以批处理的方式刷新写缓存区，以及合并写缓存区中对同一内存地址的多次写，可以减少对内存总线的占用，虽然写缓存区有这么多好处，但每个处理器的写缓存区，仅仅对它所在的处理器可见，这个特性会对内存操作的执行顺序产生重要的影响：处理器对内存的读/写操作的执行顺序，不一定与内存实际发生的读/写操作顺序一致。</p><p>示例：</p><table><thead><tr><th>Processor A</th><th>Processor B</th></tr></thead><tbody><tr><td>a = 1; //A1                                                                                                                               x = b; //A2</td><td>b = 2; //B1                                 y = a; //B2</td></tr><tr><td>初始状态：a = b = 0                                                                                               处理器允许执行后得到结果：x = y = 0</td></tr></tbody></table><p>假设处理器 A 和处理器 B 按程序的顺序并行执行内存访问，最终却可能得到 x = y = 0 的结果。具体的原因如下</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm5.png" alt></p><p>这里处理器 A 和处理器 B 可以同时把共享变量写入自己的写缓冲区（A1，B1），然后从内存中读取另一个共享变量（A2，B2），最后才把自己写缓存区中保存的脏数据刷新到内存中（A3，B3）。当以这种时序执行时，程序就可以得到 x = y = 0 的结果。</p><p>从内存操作实际发生的顺序来看，直到处理器 A 执行 A3 来刷新自己的写缓存区，写操作 A1 才算真正执行了。虽然处理器 A 执行内存操作的顺序为：A1-&gt;A2，但内存操作实际发生的顺序却是：A2-&gt;A1。此时，处理器 A 的内存操作顺序被重排序了（处理器 B 的情况和处理器 A 一样，这里就不赘述了）。</p><p>这里的关键是，由于写缓冲区仅对自己的处理器可见，它会导致处理器执行内存操作的顺序可能会与内存实际的操作执行顺序不一致。由于现代的处理器都会使用写缓冲区，因此现代的处理器都会允许对写 - 读操做重排序。</p><h4 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h4><p>从 JDK5 开始，java 使用新的 JSR -133 内存模型（本文除非特别说明，针对的都是 JSR- 133 内存模型）。JSR-133 提出了 happens-before 的概念，通过这个概念来阐述操作之间的内存可见性。如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 happens-before 关系。这里提到的两个操作既可以是在一个线程之内，也可以是在不同线程之间。 与程序员密切相关的 happens-before 规则如下：</p><ul><li>程序顺序规则：一个线程中的每个操作，happens- before 于该线程中的任意后续操作。</li><li>监视器锁规则：对一个监视器锁的解锁，happens- before 于随后对这个监视器锁的加锁。</li><li>volatile 变量规则：对一个 volatile 域的写，happens- before 于任意后续对这个 volatile 域的读。</li><li>传递性：如果 A happens- before B，且 B happens- before C，那么 A happens- before C。</li></ul><p>注意，两个操作之间具有 happens-before 关系，并不意味着前一个操作必须要在后一个操作之前执行！happens-before 仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前（the first is visible to and ordered before the second）。happens- before 的定义很微妙，后文会具体说明 happens-before 为什么要这么定义。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm6.png" alt></p><h5 id="数据依赖性"><a href="#数据依赖性" class="headerlink" title="数据依赖性"></a>数据依赖性</h5><p>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作就存在数据依赖性</p><p>数据依赖性分下列三种类型</p><table><thead><tr><th>名称</th><th>代码示例</th><th>说明</th></tr></thead><tbody><tr><td>写后读</td><td>a = 1;b = a;</td><td>写一个变量之后，再读这个位置。</td></tr><tr><td>写后写</td><td>a = 1;a = 2;</td><td>写一个变量之后，再写这个变量。</td></tr><tr><td>读后写</td><td>a = b;b = 1;</td><td>读一个变量之后，再写这个变量。</td></tr></tbody></table><p>上面三种情况，只要重排序两个操作的执行顺序，程序的执行结果将会被改变。</p><p>编译器和处理器可能会对操作做重排序，编译器和处理器在重排序时，会遵守数据依赖性，编译器和处理器不会改变存在数据依赖关系的两个操作对的执行顺序。</p><p>注意： 这里所所的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。</p><h5 id="as-if-serial-语义"><a href="#as-if-serial-语义" class="headerlink" title="as-if-serial 语义"></a>as-if-serial 语义</h5><p>as-if-serial 语义的意思是指:不管怎么重排序(编译器和处理器为了提高并行度)，(单线程)程序的执行结果都不会被改变，编译器，runtime和处理器都必须遵循as-if-serial语义。</p><p>为了遵守as-if-serial 语义，编译器和处理不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果，但是，如果操作之间不存在数据依赖关系，这些操作可能被编译器和处理器重排序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">double</span> pi <span class="token operator">=</span> <span class="token number">3.14</span>； <span class="token comment" spellcheck="true">//A</span><span class="token keyword">double</span> r <span class="token operator">=</span> <span class="token number">1.0</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//B</span><span class="token keyword">double</span> area <span class="token operator">=</span> pi<span class="token operator">*</span>r<span class="token operator">*</span>r<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//C</span></code></pre><p>上述依赖关系为 A ,B =&gt; C ，A和C之间存在数据依赖关系，同时B和C之间也存在数据依赖关系，因此在最终执行的指令序列中，C不能被重排序到A和B的前面，因为C排到A和B的前面，程序的结果会被改变，但A和B之间没有数据依赖关系，编译器和处理器可以重排序A和B之间的执行顺序。</p><p>as-if-serial语义把单线程程序保护了起来，遵守as-if-serial语义的编译器，runtime和处理器共同为编写单线程的程序员创建了一个幻觉：单线程程序是按程序的顺序来执行的，as-if-serial语义使单线程程序员无需担心重排序会干扰他们，也无需担心内存可见性问题。</p><h5 id="程序顺序规则"><a href="#程序顺序规则" class="headerlink" title="程序顺序规则"></a>程序顺序规则</h5><p>根据happens-before的程序顺序规则，上面计算圆的面积的实例代码中存在三个happens-before关系：</p><ul><li>A happens-before B</li><li>B happens-before C</li><li>A happens-before C</li></ul><p>这里的第三个happens-before关系，是根据happens-before的传递性推导出来的。</p><p>这里A happens-before B，但实际执行时B却可以排在A之前执行，如果A happens-before B，JMM并不要求A一定要在B之前执行，JMM仅仅要求前一个操作对后一个操作可见，且前一个操作按顺序排在第二个操作之前，这里操作A的执行结果不需要对操作B可见，而且重排序操作A和操作B后执行的结果，与操作A和操作B 按happens-before顺序执行的结果一致，在这种情况下，JMM会认为这种重排序并不非法，JMM允许这种重排序。</p><h5 id="重排序对多线程的影响"><a href="#重排序对多线程的影响" class="headerlink" title="重排序对多线程的影响"></a>重排序对多线程的影响</h5><p>实例代码</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ReorderExample</span> <span class="token punctuation">{</span><span class="token keyword">int</span> a <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">//1</span>    flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">//2</span><span class="token punctuation">}</span>Public <span class="token keyword">void</span> <span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//3</span>        <span class="token keyword">int</span> i <span class="token operator">=</span>  a <span class="token operator">*</span> a<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//4</span>        ……    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>flag 变量是个标记，用来标识变量a是否已被写入，这里假设有两个线程A和B,A首先执行writer()方法，随后B线程接着执行reader()方法，线程B在执行操作4的时候，能否看到线程A在操作1对共享变量a的写入？</p><p>答案是不一定能看到。</p><p>由于操作1 和操作2 没有数据依赖关系，编译器和处理器可以对着两个操作重排序，同样，操作3和操作4 没有数据依赖关系，编译器和处理器也可以对着两个操作重排序。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm11.png" alt></p><p>操作1和操作2做了重排序，程序执行时，线程A首先写标记变量flag，随后线程B读这个变量，由于条件判断为真，线程B将读取变量a,此时，变量a还根本没有被线程A写入，在这里多线程 程序的语义被重排序破坏了。</p><p>再看看操作3和4 重排序会有什么影响。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm12.png" alt></p><p>在程序中，操作3和操作4存在控制依赖关系，当代码中存在控制依赖性时，会影响指令序列执行的并行对，为此，编译器和处理器会采用猜测执行来克服控制相关并行度的影响，以处理器的猜测执行为例，执行线程B的处理器可以提前读取并计算a*a，然后把计算结果临时保存到一个名为重排序缓冲的硬件缓存中，当接下来操作3的条件判断为真时，就把该计算结果写入变量i中。</p><h4 id="顺序一致性"><a href="#顺序一致性" class="headerlink" title="顺序一致性"></a>顺序一致性</h4><h5 id="数据竞争与顺序一致性保证"><a href="#数据竞争与顺序一致性保证" class="headerlink" title="数据竞争与顺序一致性保证"></a>数据竞争与顺序一致性保证</h5><p>在程序未正确同步时，就会存在数据竞争，java内存模型规范对数据竞争定义如下。</p><ul><li>在一个线程中写一个变量</li><li>在另一个线程读同一个变量</li><li>而且写和读没有通过同步来排序</li></ul><p>当代码中包含数据竞争时，程序的执行往往产生违法直觉的结果，如果一个多线程程序能正确同步，这个程序将是一个没有数据竞争的程序。</p><p>JMM对正确同步的多线程程序的内存一致性做了如下保证</p><ul><li>如果程序时正确同步的，程序的执行将具有顺序一致性，即程序的执行结果与该程序的顺序一致性内存模型中的结果相同，这里的同步时指广义上的同步，包括对常用同步原语（lock,volatile和final）的正确使用。</li></ul><h5 id="顺序一致性内存模型"><a href="#顺序一致性内存模型" class="headerlink" title="顺序一致性内存模型"></a>顺序一致性内存模型</h5><p>顺序一致性内存模型是一个被计算机科学家理想化的理论参考模型，它为程序员提供了极强的可见性保障，顺序一致性内存模型有两大特征。</p><ul><li>一个线程中的所有操作必须按照程序的顺序来执行</li><li>所有线程都只能看到一个单一的操作执行顺序，在顺序一致性内存模型中，每个操作都必须原子执行且立即对所有线程可见</li></ul><p>视图如下：</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jmm13.png" alt></p><p>参考链接： <a href="https://www.infoq.cn/article/java-memory-model-1" target="_blank" rel="noopener">https://www.infoq.cn/article/java-memory-model-1</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域简介</title>
      <link href="/2018/01/20/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/01/20/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<h4 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h4><blockquote><p>本节介绍Java虚拟机内存的各个区域、讲解这些区域的作用、服务对象以及其中可能产生的问题。</p></blockquote><p><img src="https://github.com/gaohueric/picture/raw/master/20190119.png" alt></p><h5 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h5><p>程序计数器时一块较小的内存空间，它可以看作是当前线程所指向的字节码的行号指示器    </p><p>当多线程运行时，每个线程切换后需要知道上一次所运行的状态、位置。由此也可以看出程序计数器时每个线程私有的。</p><p>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有 一个独立的程序计数器，各线程之前计数器互不影响，独立存储，我们称这类内存区域为<strong>线程私有</strong>的内存</p><p>注意： 程序计数器时唯一一个不会出现OutOfMenoryError的内存区域，它的生命周期随着线程的创建而创建，随着线程池的结束而死亡。</p><h5 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h5><p>描叙的是java方法执行的内存模型： 每个方法被执行的时候都会创建一个“栈帧” 用于存储局部变量表、操作数栈、动态链接、方法出口等信息，每一个方法从调用至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。生命周期与线程相同，是线程<strong>私有</strong>的。</p><p>局部变量表存放了编译器可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(引用指针，并非对象本省)，其中64位长度的long和double类型的数据会占用2个局部变量的空间，其余数据类型只占一个。局部变量表所需要的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量是完全确定的，在运行期间栈帧不会改变局部变量表的大小空间。</p><p>Java虚拟机栈会出现两种异常： StackOverFlowError 和OutOfMenoryError</p><ul><li>StackOverFlowError: 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过Java虚拟机栈的最大深度的时候，就抛出StackOverflowError异常。</li><li>OutOfMenoryError: 若java虚拟机的内存大小允许动态扩展，并且线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMenoryError 异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><h5 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h5><p>与虚拟机栈基本类似，区别在于虚拟机栈为虚拟机执行的java方法服务，而本地方法栈为Native方法服务。在HotSpot虚拟中中和java虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表，操作数栈，动态链接，出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现StackOverFlowError 和OutOfMenoryError 两种异常。</p><h5 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h5><p>也叫java堆，GC堆是java虚拟机所管理的内存中最大的一块内存区域，也是被各个线程共享的内存区域，在JVM启动时创建，该内存区域存放了对象实例以及数组(所有new的对象)，其大小通过-Xms(最小值)和-Xmx(最大值)参数设置，-Xms为JVM启动时说起的最小内存，默认为操作系统物理内存的1/64但小于1G,-Xmx 为JVM可申请的最大内存，默认为物理内存的1/4 但小于1G,默认当空余堆内存小于40%时，JVM会增大Heap到-Xmx指定的大小，可通过<code>-XX:MinHeapFreeRation=</code>来指定这个比列；当空余堆内存大于70%时，JVM会减小heap的大小到-Xms指定的大小，可通过<code>XX:MaxHeapFreeRation=</code>来指定这个比列，对于运行系统，为避免在运行时频繁调整Heap的大小，通常-Xms与-Xmx的值设成一样。</p><p>由于现在收集器都采用分代收集算法，堆被划分为新生代和老年代，新生代主要存储新创建的对象和尚未进入老年代的对象，老年代存储经过多次新生代GC(Minor GC) 仍然存活的对象。</p><p><strong>新生代</strong>： 程序新创建的对象都是从新生代分配内存，新生代由Eden Space 和两块相同大小的Survivor Space 构成，可通过-Xmn参数来指定新生代的大小，也可以通过-XX:SurvivorRation来调整Eden Space 以及Survivor Space的大小。</p><p><strong>老年代</strong>： 用于存放经过多次新生代GC仍然存活的对象，例如缓存对象，新建的对象也有可能直接进入老年代，主要有两种情况：</p><ul><li>大对象，可通过启动参数设置 -XX:PretenureSizeThreshold=1024 来代表超过多大时就不在新生代分配，而是直接在老年代分配。</li><li>大的数组对象，并且数组中无引用外部对象，老年代所占的内存大小为-Xmx对应的值减去-Xmn对应的值。</li></ul><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm1.jpg" alt></p><pre class=" language-java"><code class="language-java">Young Generation        即图中的Eden <span class="token operator">+</span> From Space <span class="token operator">+</span> To SpaceEden                    存放新生的对象Survivor Space          有两个，存放每次垃圾回收后存活的对象Old Generation          Tenured Generation 即图中的Old Space                         主要存放应用程序中生命周期长的存活对象</code></pre><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm2.jpg" alt></p><h5 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h5><p><strong>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</strong></p><p>默认最小值为16MB，最大值为64MB，可以通过<code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 参数限制方法区的大小。</p><p>HotSpot 虚拟机中方法区也常被称为 <strong>“永久代”</strong>，本质上两者并不等价。仅仅是因为 HotSpot 虚拟机设计团队用永久代来实现方法区而已，这样 HotSpot 虚拟机的垃圾收集器就可以像管理 Java 堆一样管理这部分内存了。但是这并不是一个好主意，因为这样更容易遇到内存溢出问题。</p><p><strong>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</strong></p><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm3.jpg" alt></p><h5 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h5><p>直接内存又称为 <code>Direct Memory（堆外内存）</code>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致OutOfMemoryError异常出现。</p><p>JDK1.4中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><h5 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h5><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm5.png" alt></p><p>① <strong>类加载检查</strong>： 虚拟机遇到一个new指令的时候，首先去检查这个指令的参数是否能在常量池中定位到这个类的符号引用 ，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p>② <strong>分配内存</strong>： 在类加载检查通过后，接下来虚拟机将未新生对象分配内存，对象所需要的内存大小在类加载完成后就可以确定了，为对象分配空间的任务等同于把一块确定大小的内存从java堆中划分出来，分配方式由“指针碰撞” 和空闲列表两种，选择哪种分配方式由java堆是否规整决定，而java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p><p><strong>内存分配的两种方式：</strong></p><p>选择哪种内存分配方法取决于堆内存是否规整，二java堆内存是否规整取决于GC收集器的算法是”标记清除”还是标记整理。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm6.jpg" alt></p><p><strong>内存分配并发问题</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，在实际的开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方法来保证线程安全</p><ul><li>CAS+失败重试： CAS是乐观锁的一种实现方式，所谓乐观锁就是每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用CAS配上失败重试的方法保证更新操作的原子性</li><li>TLAB: 为每一个线程预先在Eden区分配一块内存，JVM在给线程中的对象分配内存时，首先咋iTLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已经用尽的时候，再采用上述的CAS进行内存分配。</li></ul><p>③ <strong>初始化零值</strong></p><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(不包括对象头)，这一步操作保证了对象的实例字段在java代码可以不赋初始值就直接使用，程序能访问到这些字段的数据类型锁对象的零值。</p><p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h5 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h5><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><p><strong>Hotspot虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的自身运行时数据</strong>（哈希码、GC分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p><p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p><p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为Hotspot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数（1倍或2倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p><h5 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h5><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><p><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息； </p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm9.jpg" alt></p></li><li><p><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</p></li></ol><p><img src="https://github.com/gaohueric/blogpicture/raw/master/jvm10.jpg" alt></p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><p>扩展参考链接：</p><p><a href="https://iamjohnnyzhuang.github.io/java/2016/07/12/Java%E5%A0%86%E5%92%8C%E6%A0%88%E7%9C%8B%E8%BF%99%E7%AF%87%E5%B0%B1%E5%A4%9F.html" target="_blank" rel="noopener">Java堆和栈看这篇就够</a><br><a href="https://www.zhihu.com/question/29833675" target="_blank" rel="noopener">Java虚拟机的堆、栈、堆栈如何去理解？</a><br><a href="https://mritd.me/2016/03/22/Java-%E5%86%85%E5%AD%98%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0/" target="_blank" rel="noopener">Java 内存之方法区和运行时常量池</a><br><a href="https://www.jianshu.com/p/50be08b54bee" target="_blank" rel="noopener">从0到1起步-跟我进入堆外内存的奇妙世界</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2017/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2017/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="OSI与TCP/IP各层的结构与功能,都有哪些协议"></a>OSI与TCP/IP各层的结构与功能,都有哪些协议</h4><p>五层协议的体系结构</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/net.png" alt></p><h5 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h5><p>应用层(application-layer)的任务是通过应用进程间的交互来完成特定网络应用，应用层协议定义的是应用进程间的通信和交互的规则，对于不同的网路应用需要不同的应用层协议，在互联网中应用层协议很多，如域名系统DNS，支持万维网应用的HTTP协议，支持电子邮件的SMTP协议等等，我们把应用层交互的数据单元称为报文。</p><ul><li>域名系统: 域名系统(Domain Name System 缩写DNS)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的 一个分布式数据库，能够使用更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串，例如： 一个公司的Web网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称，例如 百度域名： <a href="http://www.baiducom" target="_blank" rel="noopener">www.baiducom</a></li><li>HTTP写协议： 超文本传输协议(HTTP,HyperText Transfer Protocol) 是互联网上应用最为广泛的一种网络协议，所有的WWW(万维网)文件都必须遵守这个标准，设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。</li></ul><h5 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h5><p>运输层(ransport layer) 的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务，应用进程利用该服务传送应用层报文，通用的是指并不针对某一个特定的网路应用，而是多种应用可以使用同一个运输层服务，由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能，所谓复用就是指多个应用进程可同时使用下面运输层的服务，分用和复用相反。</p><p>运输层主要使用以下两种协议：</p><ul><li>传输控制协议TCP(Transmission Control Protocol) 提供面向连接的，可靠的数据传输服务。</li><li>用户数据协议UDP(User Datagram Protocol) 提供无连接的，尽力最大努力的数据传输服务(不保证数据传输的可靠性)</li></ul><p><strong>UDP的主要特点</strong></p><ul><li>UDP是无连接的</li><li>UDP使用尽最大努力交付，即不保证可靠交互，因此主机不需要维持复杂的链接状态</li><li>UDP是面向报文的</li><li>UDP没用拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低(对实时应用很有用，如直播，实时视频会议等)</li><li>UDP支持一对一，一对多，多对一的多对多的交互通信</li><li>UDP的首部开销小，只有8个字节，比TCP的20个字节的首部要短。</li></ul><p><strong>TCP的主要特点</strong></p><ul><li>TCP是面向连接的</li><li>每一条TCP连接只能有两个端点，每一条TCP连接只能是点对点的(一对一)</li><li>TCP提供可靠交付的服务，通过TCP连接传送的数据，无差错，不丢失，不重复，并且按序到达。</li><li>TCP提供全双工通信，TCP允许通信双方的应用进程在任何时候都能发送数据，TCP的两端都设有发送缓存和接收缓存，用来临时存放双方通信的数据；</li><li>面向字节流，TCP中的流(Stream) 指的是流入进程或从进程流出的字节序列，面向字节流的含义是： 虽然应用程序和TCP的交互是一次一个数据块(大小不等)，但TCP把应用程序交下来额数据仅仅看成是一连串的无结构的字节流</li></ul><h5 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h5><p>在计算机网络中进行通信的两个计算机之间可能会经过很多数据链路，也可能还要经过很多通信子网，网络层的任务就是选择合适的网间路由和交换节点，确保数据及时传送，在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送，在TCP/IP体系结构中，由于网络层使用IP协议，因此分组也叫IP数据报，简称数据报。</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h5 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h5><p><strong>数据链路层(data link layer) 通常简称为链路层，两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议</strong>，在两个相邻节点之间传送数据时,数据链路层将网络层交下来的IP数据报组装成帧，在两个相邻节点间的链路上传送帧，每一帧包括数据和必要的控制信息(如同步信息、地址信息、差错控制等)</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始到哪个比特结束，这样，数据链路层在收到一个帧后，就可从中提取数据部分，上交网络层，控制信息还使接收端能够检测到所收到的帧中有无差错，如果发现差错，数据链路层就简单的丢弃这个出错的帧，以避免继续在网络中传送下去白白浪费网络资源，如果需要改正数据在链路层传输时出现差错，那么就要采用可靠传输协议来纠正出现的差错，这种方法会使链路层的协议复杂些。</p><h5 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h5><p>在物理层上所传送的数据单位是比特，物理层(physical layer) 的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽具体传输介质和物理设备的差异，使其上面的数据链路层不必考虑网络的具体传输介质是什么，透明传送比特流表示经过实际电路传送后的比特流没有发送变化，对传送的比特流来说，这个电路是看不见的。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/net10.gif" alt></p><h4 id="TCP-三次握手和四次挥手"><a href="#TCP-三次握手和四次挥手" class="headerlink" title="TCP 三次握手和四次挥手"></a>TCP 三次握手和四次挥手</h4><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><p><img src="https://github.com/gaohueric/blogpicture/raw/master/net7.jpg" alt></p><p><strong>简单示意图</strong></p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><p><strong>为什么要三次握手</strong></p><p>三次握手的目的是建立可靠的通信信道，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认值机与对方的发送与接收是否正常。</p><p>第一次握手： Client什么都不能确认；Server确认了对方发送正常</p><p>第二次握手： Client确认了： 自己发送正常、接收正常，对方发送正常、接收正常；Server确认了： 自己接收正常，对方发送正常；</p><p>第三次握手：Client确认了：自己发送正常、接收正常，对方发送正常、接收正常；Server确认了，自己发送正常，接收正常，对方发送接收正常。</p><p><strong>为什么要传回SYN</strong></p><p>接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><blockquote><p>SYN是TCP/IP建立连接时使用的握手信号，在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN-ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应，这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p></blockquote><p>传了SYN,为啥还要传ACK</p><p>双方通信无误必须是两者相互发送信息都无误，传了SYN，证明发送发到接收发的通道没有问题，但是接收方到发送发的通道还需要ACK信号来进行验证。</p><p><strong>断开一个TCP连接要四次挥手</strong></p><ul><li>客户端： 发送一个FIN,用来关闭客户端到服务器的数据传送</li><li>服务器： 收到这个FIN,它发回一个ACK,确认序号为收到的序号加1，和SYN一样，一个FIN将占用一个序号</li><li>服务器： 关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端： 发回ACK报文确认，并将确认序号设置为收到序号加1</li></ul><p><img src="https://github.com/gaohueric/blogpicture/raw/master/net11.jpg" alt></p><p><strong>为什么要四次挥手</strong></p><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态，当另一方也没有数据再发送的时候则发出释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Map的基本用法</title>
      <link href="/2017/11/08/Map%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2017/11/08/Map%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href>Map</a>是一个由键值对组成的数据结构，且在集合中每个键是唯一的。下面就以K和V来代表键和值，来说明一下java中关于Map的九大问题。</p></blockquote><a id="more"></a><h5 id="将Map转换为List"><a href="#将Map转换为List" class="headerlink" title="将Map转换为List"></a>将Map转换为List</h5><p>在java中Map接口提供了三种集合获取方式：Key set,，value set， and key-value set.。它们都可以通过构造方法或者addAll()方法来转换为<a href>List</a>类型。下面代码就说明了如何从Map中构造ArrayLis</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// key list</span>List keyList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// value list</span>List valueList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">valueSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// key-value list</span>List entryList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="通过Entry-遍历Map"><a href="#通过Entry-遍历Map" class="headerlink" title="通过Entry 遍历Map"></a>通过Entry 遍历Map</h5><p>java中这种以键值对存在的方式被称为<a href>Map.Entry</a>。Map.entrySet()返回的是一个key-value 集合，这是一种非常高效的遍历方式。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">for</span><span class="token punctuation">(</span>Entry entry<span class="token operator">:</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// get key</span>  K key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// get value</span>  V value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Iterator 我们也经常用到</p><pre class=" language-java"><code class="language-java">Iterator itr <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">while</span><span class="token punctuation">(</span>itr<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  Entry entry <span class="token operator">=</span> itr<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// get key</span>  K key <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// get value</span>  V value <span class="token operator">=</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><h5 id="通过Key来对Map排序"><a href="#通过Key来对Map排序" class="headerlink" title="通过Key来对Map排序"></a>通过Key来对Map排序</h5><p>　　排序需要对Map的ke进行频繁的操作，一种方式就是通过比较器(comparator )来实现：</p><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Entry e1<span class="token punctuation">,</span> Entry e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> e1<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　另外一种方法就是通过<a href>SortedMap</a>，但必须要实现<a href>Comparable</a>接口。</p><pre class=" language-java"><code class="language-java">SortedMap sortedMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeMap</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>K k1<span class="token punctuation">,</span> K k2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> k1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>sortedMap<span class="token punctuation">.</span><span class="token function">putAll</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="对value对Map进行排序"><a href="#对value对Map进行排序" class="headerlink" title="对value对Map进行排序"></a>对value对Map进行排序</h5><p>　　这与上一点有些类似，代码如下：</p><pre class=" language-java"><code class="language-java">List list <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">entrySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Collections<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Comparator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">compare</span><span class="token punctuation">(</span>Entry e1<span class="token punctuation">,</span> Entry e2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> e1<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e2<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h5 id="初始化一个static-的常量Map"><a href="#初始化一个static-的常量Map" class="headerlink" title="初始化一个static 的常量Map"></a>初始化一个static 的常量Map</h5><p>　　当你希望创建一个全局静态Map的时候，我们有以下两种方式，而且是线程安全的。<br>而在Test1中，我们虽然声明了map是静态的，但是在初始化时，我们依然可以改变它的值，就像Test1.map.put(3,”three”);<br>在Test2中，我们通过一个内部类，将其设置为不可修改，那么当我们运行Test2.map.put(3,”three”)的时候，它就会抛出一个<a href>UnsupportedOperationException</a> 异常来禁止你修改。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test1</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map map<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token punctuation">{</span>    map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test2</span> <span class="token punctuation">{</span>  <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Map map<span class="token punctuation">;</span>  <span class="token keyword">static</span> <span class="token punctuation">{</span>    Map aMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    aMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    aMap<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    map <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">unmodifiableMap</span><span class="token punctuation">(</span>aMap<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="HashMap-TreeMap-and-Hashtable之间的不同"><a href="#HashMap-TreeMap-and-Hashtable之间的不同" class="headerlink" title="HashMap, TreeMap, and Hashtable之间的不同"></a>HashMap, TreeMap, and Hashtable之间的不同</h5><p>　　在Map接口中，共有三种实现：HashMap，TreeMap，Hashtable。</p><p>　　它们之间各有不同，详细内容请参考《 <a href>HashMap vs. TreeMap vs. Hashtable vs. LinkedHashMap</a>》一文。</p><h5 id="Map中的反向查询"><a href="#Map中的反向查询" class="headerlink" title="Map中的反向查询"></a>Map中的反向查询</h5><p>　　我们在Map添加一个键值对后，意味着这在Map中键和值是一一对应的，一个键就是对应一个值。但是有时候我们需要反向查询，比如通过某一个值来查找它的键，这种数据结构被称为<a href>bidirectional map</a>，遗憾的是JDK并没有对其支持。</p><p>　　Apache和Guava 共同提供了这种<a href>bidirectional map</a>实现，它在实现中它规定了键和值都是必须是1:1的关系。</p><h5 id="对Map的复制"><a href="#对Map的复制" class="headerlink" title="对Map的复制"></a>对Map的复制</h5><p>　　java中提供了很多方法都可以实现对一个Map的复制，但是那些方法不见得会时时同步。简单说，就是一个Map发生的变化，而复制的那个依然保持原样。下面是一个比较高效的实现方法：</p><pre class=" language-java"><code class="language-java">Map copiedMap <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">synchronizedMap</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>　　当然还有另外一个方法，那就是克隆。但是我们的java鼻祖Josh Bloch却不推荐这种方式，他曾经在一次访谈中说过关于Map克隆的问题：在很多类中都提供了克隆的方法，因为人们确实需要。但是克隆非常有局限性，而且在很多时候造成了不必要的影响。（原文《<a href>Copy constructor versus cloning</a>》）</p><h5 id="创建一个空的Map"><a href="#创建一个空的Map" class="headerlink" title="创建一个空的Map"></a>创建一个空的Map</h5><p>如果这个map被置为不可用，可以通过以下实现</p><pre class=" language-java"><code class="language-java">map <span class="token operator">=</span> Collections<span class="token punctuation">.</span><span class="token function">emptyMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>相反，我们会用到的时候，就可以直接</p><pre class=" language-java"><code class="language-java">map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java常用关键字解析</title>
      <link href="/2017/10/29/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/"/>
      <url>/2017/10/29/Java%E5%B8%B8%E7%94%A8%E5%85%B3%E9%94%AE%E5%AD%97%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>该篇总结了Java中常用的一些关键字的用法和原理。该篇总结了Java中常用的一些关键字的用法和原理。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息队列ActiveMQ</title>
      <link href="/2017/10/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97ActiveMQ/"/>
      <url>/2017/10/22/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97ActiveMQ/</url>
      
        <content type="html"><![CDATA[<p>摘要 ：</p><blockquote><p>JMS（JAVA Message Service,java消息服务）API是一个消息服务的标准或者说是规范，允许应用程序组件基于JavaEE平台创建、发送、接收和读取消息。<br><a id="more"></a><br>它使分布式通信耦合度更低，消息服务更加可靠以及异步性。Java 消息机制 JMS ,ActiveMQ 是Apache出品，最流行的，能力强劲的开源消息总线.</p></blockquote><h5 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h5><p>JMS是java的消息服务，JMS的客户端之间可以通过JMS服务进行异步的消息传输。</p><h5 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h5><pre><code>○ Point-to-Point(P2P)○ Publish/Subscribe(Pub/Sub)</code></pre><h5 id="P2P"><a href="#P2P" class="headerlink" title="P2P"></a>P2P</h5><ol><li>P2P模式图 </li></ol><p><img src="http://ogx75f0xj.bkt.clouddn.com/20150630220509535%20%281%29.jpg" alt></p><ol start="2"><li><p>涉及到的概念  </p><ul><li><p>消息队列（Queue）</p></li><li><p>发送者(Sender)</p></li><li><p>接收者(Receiver)</p></li><li><p>每个消息都被发送到一个特定的队列，接收者从队列中获取消息。队列保留着消息，直到他们被消费或超时</p></li></ul></li></ol><ol start="3"><li><p>P2P的特点</p><ul><li>每个消息只有一个消费者（Consumer）(即一旦被消费，消息就不再在消息队列中)</li><li>发送者和接收者之间在时间上没有依赖性，也就是说当发送者发送了消息之后，不管接收者有没有正在运行，它不会影响到消息被发送到队列</li><li>接收者在成功接收消息之后需向队列应答成功</li></ul><p>如果你希望发送的每个消息都应该被成功处理的话，那么你需要P2P模式</p><h5 id="Pub-Sub"><a href="#Pub-Sub" class="headerlink" title="Pub/Sub"></a>Pub/Sub</h5><ol><li><p>Pub/Sub模式图 </p><p><img src="http://ogx75f0xj.bkt.clouddn.com/20150630221227522.jpg" alt></p></li><li><p>涉及到的概念  </p><ul><li>主题（Topic）</li><li>发布者（Publisher）</li><li>订阅者（Subscriber）<br>客户端将消息发送到主题。多个发布者将消息发送到Topic,系统将这些消息传递给多个订阅者</li></ul></li><li><p>Pub/Sub的特点</p><ul><li>每个消息可以有多个消费者</li><li>发布者和订阅者之间有时间上的依赖性。针对某个主题（Topic）的订阅者，它必须创建一个订阅者之后，才能消费发布者的消息，而且为了消费消息，订阅者必须保持运行的状态。</li><li>为了缓和这样严格的时间相关性，JMS允许订阅者创建一个可持久化的订阅。这样，即使订阅者没有被激活（运行），它也能接收到发布者的消息。</li></ul><p>如果你希望发送的消息可以不被做任何处理、或者被一个消息者处理、或者可以被多个消费者处理的话，那么可以采用Pub/Sub模型</p><h5 id="消息的消费"><a href="#消息的消费" class="headerlink" title="消息的消费"></a>消息的消费</h5><p>在JMS中，消息的产生和消息是异步的。对于消费来说，JMS的消息者可以通过两种方式来消费消息。 </p><ul><li><p>同步<br>订阅者或接收者调用receive方法来接收消息，receive方法在能够接收到消息之前（或超时之前）将一直阻塞 </p></li><li><p>异步 </p><p>订阅者或接收者可以注册为一个消息监听器。当消息到达之后，系统自动调用监听器的onMessage方法。</p></li></ul><h5 id="JMS编程模型"><a href="#JMS编程模型" class="headerlink" title="JMS编程模型"></a>JMS编程模型</h5><ol><li><p>ConnectionFactory</p><p>创建Connection对象的工厂，针对两种不同的jms消息模型，分别有QueueConnectionFactory和TopicConnectionFactory两种。可以通过JNDI来查找ConnectionFactory对象。</p></li><li><p>Destination</p><p>Destination的意思是消息生产者的消息发送目标或者说消息消费者的消息来源。对于消息生产者来说，它的Destination是某个队列（Queue）或某个主题（Topic）;对于消息消费者来说，它的Destination也是某个队列或主题（即消息来源）。</p><p>所以，Destination实际上就是两种类型的对象：Queue、Topic可以通过JNDI来查找Destination。</p></li><li><p>Connection</p><p>Connection表示在客户端和JMS系统之间建立的链接（对TCP/IP socket的包装）。Connection可以产生一个或多个Session。跟ConnectionFactory一样，Connection也有两种类型：QueueConnection和TopicConnection。</p></li><li><p>Session</p><p>Session是我们操作消息的接口。可以通过session创建生产者、消费者、消息等。Session提供了事务的功能。当我们需要使用session发送/接收多个消息时，可以将这些发送/接收动作放到一个事务中。同样，也分QueueSession和TopicSession。</p></li><li><p>消息的生产者</p><p>消息生产者由Session创建，并用于将消息发送到Destination。同样，消息生产者分两种类型：QueueSender和TopicPublisher。可以调用消息生产者的方法（send或publish方法）发送消息。</p></li><li><p>消息消费者</p><p>消息消费者由Session创建，用于接收被发送到Destination的消息。两种类型：QueueReceiver和TopicSubscriber。可分别通过session的createReceiver(Queue)或createSubscriber(Topic)来创建。当然，也可以session的creatDurableSubscriber方法来创建持久化的订阅者。</p></li><li><p>MessageListener</p><p>消息监听器。如果注册了消息监听器，一旦消息到达，将自动调用监听器的onMessage方法。EJB中的MDB（Message-Driven Bean）就是一种MessageListener。</p></li><li><p>JMS的好处</p><ul><li>提供消息灵活性</li><li>松散耦合</li><li>异步性</li></ul></li></ol><h5 id="队列模式-代码示例"><a href="#队列模式-代码示例" class="headerlink" title="队列模式 代码示例"></a>队列模式 代码示例</h5><p>消息生产者</p><pre><code>package com.ly.teacms.biz.jms;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * Created with IntelliJ IDEA. * Description:消息队列 * @author: eric * Date: 2017-10-22 * Time: 13:58 */public class AppProducer {    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;    private static final String queueName = &quot;queue-test6&quot;;    public static void main(String[] args) throws Exception {        //创建ConnectionFactory        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_BROKER_URL);        //创建Connection        Connection connection = connectionFactory.createConnection();        //启动连接        connection.start();        //创建会话        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);        //创建一个目标        Destination destination = session.createQueue(queueName);        //创建一个生产者        MessageProducer producer = session.createProducer(destination);        sendMessage(session,producer);        //关闭连接        connection.close();    }    public static void sendMessage(Session session,MessageProducer messageProducer) throws Exception{        for (int i = 0; i &lt; 100; i++) {            //创建一条文本消息            TextMessage message = session.createTextMessage(&quot;ActiveMQ 发送消息&quot; +i);            System.out.println(&quot;发送消息：Activemq 发送消息&quot; + i);            //通过消息生产者发出消息            messageProducer.send(message);        }    }}</code></pre><p>消费者</p><pre><code>package com.ly.teacms.biz.jms;import org.apache.activemq.ActiveMQConnection;import org.apache.activemq.ActiveMQConnectionFactory;import javax.jms.*;/** * Created with IntelliJ IDEA. * Description: * 消费者 * @author: eric * Date: 2017-10-22 * Time: 15:02 */public class AppConsumer {    private static final String url = &quot;tcp://127.0.0.1:61616&quot;;    private static final String queueName = &quot;queue-test5&quot;;    public static void main(String[] args) throws JMSException {        //创建ConnectionFactory        ConnectionFactory connectionFactory = new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_BROKER_URL);        //创建Connection        Connection connection = connectionFactory.createConnection();        //启动连接        connection.start();        //创建会话        Session session = connection.createSession(false, Session.AUTO_ACKNOWLEDGE);        //创建一个目标        Destination destination = session.createQueue(queueName);        //创建一个消费者        MessageConsumer consumer = session.createConsumer(destination);        //创建一个监听器        consumer.setMessageListener(new MessageListener() {            @Override            public void onMessage(Message message) {                TextMessage textMessage = (TextMessage) message;                try {                    System.out.println(&quot;接受消息&quot; + textMessage.getText());                } catch (JMSException e) {                    e.printStackTrace();                }            }        });    }}</code></pre></li></ol></li></ol><p>主题模式(Topic) 代码示例</p><p>修改为topic </p><pre><code> Destination destination = session.createTopic(topicName);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 基础组件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>提取多层嵌套JSON类型数据</title>
      <link href="/2017/07/22/%E6%8F%90%E5%8F%96%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97JSON%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/"/>
      <url>/2017/07/22/%E6%8F%90%E5%8F%96%E5%A4%9A%E5%B1%82%E5%B5%8C%E5%A5%97JSON%E7%B1%BB%E5%9E%8B%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<p>提取多层嵌套JSON类型数据,解析多层嵌套数据,JSON与对象相互装换，JSON序列化以及反序列化操作。</p><a id="more"></a><p>数据实例：</p><pre><code>{    &quot;error&quot;: 0,    &quot;status&quot;: &quot;success&quot;,    &quot;results&quot;: [        {            &quot;currentCity&quot;: &quot;青岛&quot;,            &quot;index&quot;: [                {                    &quot;title&quot;: &quot;穿衣&quot;,                    &quot;zs&quot;: &quot;较冷&quot;,                    &quot;tipt&quot;: &quot;穿衣指数&quot;,                    &quot;des&quot;: &quot;建议着厚外套加毛衣等服装。年老体弱者宜着大衣、呢外套加羊毛衫。&quot;                },                {                    &quot;title&quot;: &quot;紫外线强度&quot;,                    &quot;zs&quot;: &quot;中等&quot;,                    &quot;tipt&quot;: &quot;紫外线强度指数&quot;,                    &quot;des&quot;: &quot;属中等强度紫外线辐射天气，外出时建议涂擦SPF高于15、PA+的防晒护肤品，戴帽子、太阳镜。&quot;                }            ]        }    ]}</code></pre><p>代码如下</p><pre><code>package com.iteam.test;import net.sf.json.JSONArray;import net.sf.json.JSONObject;public class Test {public static void main(String[] args) {    String s = &quot;{\&quot;error\&quot;:0,\&quot;status\&quot;:\&quot;success\&quot;,\&quot;results\&quot;:[{\&quot;currentCity\&quot;:\&quot;青岛\&quot;,\&quot;index\&quot;:[{\&quot;title\&quot;:\&quot;穿衣\&quot;,\&quot;zs\&quot;:\&quot;较冷\&quot;,\&quot;tipt\&quot;:\&quot;穿衣指数\&quot;,\&quot;des\&quot;:\&quot;建议着厚外套加毛衣等服装。年老体弱者宜着大衣、呢外套加羊毛衫。\&quot;},{\&quot;title\&quot;:\&quot;紫外线强度\&quot;,\&quot;zs\&quot;:\&quot;最弱\&quot;,\&quot;tipt\&quot;:\&quot;紫外线强度指数\&quot;,\&quot;des\&quot;:\&quot;属弱紫外线辐射天气，无需特别防护。若长期在户外，建议涂擦SPF在8-12之间的防晒护肤品。\&quot;}],}]}&quot;;    JSONObject jsonObject = JSONObject.fromObject(s);    //提取出error为 0    int error = jsonObject.getInt(&quot;error&quot;);    System.out.println(&quot;error:&quot; + error);    //提取出status为 success    String status = jsonObject.getString(&quot;status&quot;);    System.out.println(&quot;status:&quot; + status);        //注意：results中的内容带有中括号[]，所以要转化为JSONArray类型的对象    JSONArray result = jsonObject.getJSONArray(&quot;results&quot;);    for (int i = 0; i &lt; result.size(); i++) {        //提取出currentCity为 青岛        String currentCity = result.getJSONObject(i).getString(&quot;currentCity&quot;);        System.out.println(&quot;currentCity:&quot; + currentCity);        //注意：index中的内容带有中括号[]，所以要转化为JSONArray类型的对象        JSONArray index = result.getJSONObject(i).getJSONArray(&quot;index&quot;);        for (int j = 0; j &lt; index.size(); j++) {            String title = index.getJSONObject(j).getString(&quot;title&quot;);            System.out.println(&quot;title:&quot; + title);            String zs = index.getJSONObject(j).getString(&quot;zs&quot;);            System.out.println(&quot;zs:&quot; + zs);            String tipt = index.getJSONObject(j).getString(&quot;tipt&quot;);            System.out.println(&quot;tipt:&quot; + tipt);            String des = index.getJSONObject(j).getString(&quot;des&quot;);            System.out.println(&quot;des:&quot; + des);        }    }}}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识java爬虫</title>
      <link href="/2017/07/22/%E5%88%9D%E8%AF%86java%E7%88%AC%E8%99%AB/"/>
      <url>/2017/07/22/%E5%88%9D%E8%AF%86java%E7%88%AC%E8%99%AB/</url>
      
        <content type="html"><![CDATA[<p>通过HttpClientUtil 工具类进行爬取网页,解析网页，解析json数据,通过Io流保存解析好的数据</p><a id="more"></a><p>代码如下：</p><pre><code>package com.ly.spider.http;import com.alibaba.fastjson.JSONArray;import com.alibaba.fastjson.JSONObject;import org.apache.http.impl.client.CloseableHttpClient;import java.util.ArrayList;import java.util.HashMap;import java.util.List;import java.util.Map;/** * Created by Eric on 2017/7/5. */public class SpiderImpl {    public static void main(String[] args) throws Exception {        SpiderImpl spider = new SpiderImpl();        spider.checkStatus();    }    public String checkStatus() throws  Exception{        StringBuilder stringBuilder = new StringBuilder();        Map&lt;String,String&gt; headerMap = new HashMap&lt;String,String&gt;();        headerMap.put(&quot;Host&quot;,&quot;www.wdzj.com&quot;);        headerMap.put(&quot;Connection&quot;,&quot;keep-alive&quot;);        headerMap.put(&quot;Upgrade-Insecure-Requests&quot;,&quot;1&quot;);        headerMap.put(&quot;User-Agent&quot;,&quot;Mozilla/5.0 (Windows NT 6.3; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&quot;);        headerMap.put(&quot;Accept-Encoding&quot;,&quot;gzip, deflate, sdch&quot;);        headerMap.put(&quot;Accept-Language&quot;,&quot;zh-CN,zh;q=0.8&quot;);        headerMap.put(&quot;Accept&quot;,&quot;application/json, text/javascript, */*; q=0.01&quot;);        CloseableHttpClient httpClient = HttpClientUtil.getDefaultHttpClient();        String[] column_key = { &quot;platName&quot;, &quot;cityName&quot;,                &quot;term&quot;, &quot;serviceAttitude&quot; };        Map&lt;String,Object&gt; paramMap = new HashMap&lt;String,Object&gt;();        List&lt;String&gt; list = new ArrayList&lt;&gt;();        for(int i=1;i&lt;191;i++) {            paramMap.put(&quot;params&quot;, &quot;&quot;);            paramMap.put(&quot;sort&quot;, &quot;0&quot;);            paramMap.put(&quot;currPage&quot;, i);            HttpContext context = HttpClientUtil.doPost(httpClient,&quot;http://www.wdzj.com/front_select-plat&quot;,paramMap,headerMap);            String responseContent = HttpClientUtil.getResponseContent(context);            list.add(responseContent);        }        JSONArray jsonArray = JSONArray.parseArray(list.toString());        for(int i=0;i&lt;jsonArray.size();i++){            String result = jsonArray.getJSONObject(i).getString(&quot;list&quot;);            JSONArray jsonArray1 = JSONArray.parseArray(result);            for (int j=0;j&lt;jsonArray1.size();j++){                for (Object json: jsonArray1) {                    JSONObject itemJson = (JSONObject) json;                    for (String column : column_key) {                        stringBuilder.append(itemJson.get(column) + &quot;\t&quot;);                    }                    stringBuilder.append(&quot;\n&quot;);                }            }        }        String filePath = &quot;F:\\Test\\tests.txt&quot;;        String value =stringBuilder.toString();        String encoding = &quot;utf-8&quot;;        IOUtil.writeFile(filePath,value,encoding);        System.out.println(&quot;success&quot;);        return null;    }}</code></pre><p>IOUtils 工具类,用于保存解析好的数据到本地</p><pre><code>package com.ly.spider.http;import java.io.File;import java.io.FileOutputStream;import java.io.IOException;/** * 文件IO * * @author zel * */public class IOUtil {    public static void writeFile(String filePath, String value, String encoding) {        FileOutputStream fos = null;        try {            fos = new FileOutputStream(new File(filePath));            fos.write(value.getBytes(encoding));            fos.close();        } catch (Exception e) {            e.printStackTrace();        } finally {            if (fos != null) {                try {                    fos.close();                } catch (IOException e) {                    e.printStackTrace();                }            }        }    }    public static void main(String[] args) {        String filePath = &quot;test.txt&quot;;        String value = &quot;hello world,123&quot;;        String encoding = &quot;utf-8&quot;;        IOUtil.writeFile(filePath, value, encoding);        System.out.println(&quot;done!&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HttpClientUtil工具类</title>
      <link href="/2017/06/22/HttpClientUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
      <url>/2017/06/22/HttpClientUtil%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>HttpClientUtil工具类,用于进行Post、Get请求,HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。</p><a id="more"></a><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>ly<span class="token punctuation">.</span>spider<span class="token punctuation">.</span>http<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>ly<span class="token punctuation">.</span>spider<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>Proxy<span class="token punctuation">;</span><span class="token keyword">import</span> com<span class="token punctuation">.</span>ly<span class="token punctuation">.</span>spider<span class="token punctuation">.</span>proxy<span class="token punctuation">.</span>ProxyContainer<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpHost<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpResponse<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>HttpStatus<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>NameValuePair<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>ClientProtocolException<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>HttpClient<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>config<span class="token punctuation">.</span>CookieSpecs<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>config<span class="token punctuation">.</span>RequestConfig<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>UrlEncodedFormEntity<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>HttpGet<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>HttpPost<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>client<span class="token punctuation">.</span>methods<span class="token punctuation">.</span>HttpRequestBase<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>conn<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>SSLConnectionSocketFactory<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>StringEntity<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>MultipartEntity<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>content<span class="token punctuation">.</span>FileBody<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>entity<span class="token punctuation">.</span>mime<span class="token punctuation">.</span>content<span class="token punctuation">.</span>StringBody<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span>CloseableHttpClient<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>impl<span class="token punctuation">.</span>client<span class="token punctuation">.</span>HttpClients<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>message<span class="token punctuation">.</span>BasicNameValuePair<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>SSLContexts<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>http<span class="token punctuation">.</span>util<span class="token punctuation">.</span>EntityUtils<span class="token punctuation">;</span><span class="token keyword">import</span> javax<span class="token punctuation">.</span>net<span class="token punctuation">.</span>ssl<span class="token punctuation">.</span>SSLContext<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>File<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>IOException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>Charset<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>HashMap<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>List<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Map<span class="token punctuation">;</span><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>commons<span class="token punctuation">.</span>lang3<span class="token punctuation">.</span>StringUtils<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** * httpclient 简单工具类 * * @author eric * @version $Id: HttpClientUtil.java, v 0.1 2016年5月10日 上午9:59:38 tkj09938 Exp $ */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HttpClientUtil</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 处理get请求     *     * @param httpClient     * @param url     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doGet</span><span class="token punctuation">(</span>HttpClient httpClient<span class="token punctuation">,</span> String url<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doGet</span><span class="token punctuation">(</span>httpClient<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理get请求     *     * @param client     * @param url     * @param params     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doGet</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doGet</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理get请求     *     * @param client     * @param url     * @param params     * @param headers     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doGet</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">,</span>                                    Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        StringBuffer param <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuffer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>params <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> params<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token operator">++</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    param<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"?"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    param<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"&amp;"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                param<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"="</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        HttpGet getRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpGet</span><span class="token punctuation">(</span>url <span class="token operator">+</span> param<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initHttpHeader</span><span class="token punctuation">(</span>getRequest<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>getRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpContext</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> getRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理空参post     *     * @param client     * @param url     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doPost</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理带有表单参数的post     *     * @param client     * @param url     * @param params     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doPost</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理带有表单参数和消息头的post     *     * @param client     * @param url     * @param params     * @param headers     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">,</span>                                     Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        HttpPost postRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initHttpHeader</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 构造表单参数</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>params <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>params<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            List<span class="token operator">&lt;</span>NameValuePair<span class="token operator">></span> pairList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>NameValuePair<span class="token operator">></span><span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> params<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    NameValuePair pair <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BasicNameValuePair</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    pairList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>pair<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            postRequest<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">UrlEncodedFormEntity</span><span class="token punctuation">(</span>pairList<span class="token punctuation">,</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        HttpResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpContext</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理mulitipart表单     *     * @param client     * @param url     * @param params     * @param headers     * @return     * @throws IOException     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"deprecation"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPostMultipartData</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">,</span>                                                  Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        HttpPost postRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initHttpHeader</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>        MultipartEntity multipartEntity <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MultipartEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> params<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                multipartEntity<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">StringBody</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String<span class="token punctuation">)</span> params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> Charset<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">File</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                multipartEntity<span class="token punctuation">.</span><span class="token function">addPart</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">FileBody</span><span class="token punctuation">(</span><span class="token punctuation">(</span>File<span class="token punctuation">)</span> params<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        postRequest<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span>multipartEntity<span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpContext</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理其他类型post     *     * @param client     * @param url     * @param param     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> String param<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doPost</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> param<span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理其他类型post     *     * @param client     * @param url     * @param param     * @param headers     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">doPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> String param<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span>            <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        HttpPost postRequest <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HttpPost</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">initHttpHeader</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>        StringEntity stringEn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringEntity</span><span class="token punctuation">(</span>param<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        postRequest<span class="token punctuation">.</span><span class="token function">setEntity</span><span class="token punctuation">(</span>stringEn<span class="token punctuation">)</span><span class="token punctuation">;</span>        HttpResponse response <span class="token operator">=</span> client<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span>postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpContext</span><span class="token punctuation">(</span>response<span class="token punctuation">,</span> postRequest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 初始化http消息头     *     * @param client     * @param headers     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">initHttpHeader</span><span class="token punctuation">(</span>HttpRequestBase request<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>headers <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>headers<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>String key <span class="token operator">:</span> headers<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>StringUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    request<span class="token punctuation">.</span><span class="token function">addHeader</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> headers<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 解析http响应状态码     *     * @param httpResponse     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getResponseCode</span><span class="token punctuation">(</span>HttpResponse httpResponse<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>httpResponse <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> httpResponse<span class="token punctuation">.</span><span class="token function">getStatusLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getStatusCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用默认的编码解析http响应实体     *     * @param httpResponse     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getResponseContent</span><span class="token punctuation">(</span>HttpContext httpContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getResponseContent</span><span class="token punctuation">(</span>httpContext<span class="token punctuation">,</span> <span class="token string">"UTF-8"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 将http 响应实体解析为字节数组     *     * @param httpResponse     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getResponseContentBytes</span><span class="token punctuation">(</span>HttpContext httpContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> EntityUtils<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            EntityUtils<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            httpContext<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以特定的字符集编码解析http响应实体     *     * @param httpResponse     * @param charset     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getResponseContent</span><span class="token punctuation">(</span>HttpContext httpContext<span class="token punctuation">,</span> String charset<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        String result <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> EntityUtils<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> charset<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> e<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>            EntityUtils<span class="token punctuation">.</span><span class="token function">consume</span><span class="token punctuation">(</span>httpContext<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEntity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            httpContext<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取默认的httpClient     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CloseableHttpClient <span class="token function">getDefaultHttpClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RequestConfig config <span class="token operator">=</span> RequestConfig<span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCookieSpec</span><span class="token punctuation">(</span>CookieSpecs<span class="token punctuation">.</span>STANDARD_STRICT<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setConnectTimeout</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSocketTimeout</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> HttpClients<span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDefaultRequestConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取使用云代理的httpClient     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CloseableHttpClient <span class="token function">getHttpClientWithProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        RequestConfig config <span class="token operator">=</span> RequestConfig<span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setCookieSpec</span><span class="token punctuation">(</span>CookieSpecs<span class="token punctuation">.</span>STANDARD_STRICT<span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">setConnectTimeout</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSocketTimeout</span><span class="token punctuation">(</span><span class="token number">30000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setProxy</span><span class="token punctuation">(</span><span class="token function">getProxyHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> HttpClients<span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setDefaultRequestConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 代理主机（公共云代理）     *     * @return     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> HttpHost <span class="token function">getProxyHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Proxy proxy <span class="token operator">=</span> ProxyContainer<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">HttpHost</span><span class="token punctuation">(</span>proxy<span class="token punctuation">.</span><span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> proxy<span class="token punctuation">.</span><span class="token function">getPort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"http"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取使用认证代理（公共拨号代理）的httpClient;     *     * @return     */</span>    <span class="token comment" spellcheck="true">/*public static CloseableHttpClient getHttpClientWithAuthProxy() {        RequestConfig config = RequestConfig.custom().setCookieSpec(CookieSpecs.STANDARD_STRICT)                .setConnectTimeout(10000).setSocketTimeout(30000).setProxy(getProxyHost()).build();        CredentialsProvider credsProvider = new BasicCredentialsProvider();// 创建认证        credsProvider.setCredentials(                new AuthScope(AdslProxyHelper.getProxy().getHost(), AdslProxyHelper.getProxy().getPort()),                new UsernamePasswordCredentials(AdslProxyHelper.getProxy().getUsername(),                        AdslProxyHelper.getProxy().getPassword()));// 用户名和密码        return HttpClients.custom().setDefaultCredentialsProvider(credsProvider).setDefaultRequestConfig(config)                .build();    }*/</span>    <span class="token comment" spellcheck="true">/**     * 校验http响应是否为200     *     * @param response     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkResponseCodeOk</span><span class="token punctuation">(</span>HttpResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> HttpStatus<span class="token punctuation">.</span>SC_OK <span class="token operator">==</span> <span class="token function">getResponseCode</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 校验http响应是否为302     *     * @param response     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkResponseRedirect</span><span class="token punctuation">(</span>HttpResponse response<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">return</span> HttpStatus<span class="token punctuation">.</span>SC_MOVED_TEMPORARILY <span class="token operator">==</span> <span class="token function">getResponseCode</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取重定向地址     * @param response     * @return     * @throws Exception     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">getRedirectUrl</span><span class="token punctuation">(</span>HttpContext context<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception<span class="token punctuation">{</span>        String redirectUrl <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResponse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getFirstHeader</span><span class="token punctuation">(</span><span class="token string">"Location"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">abortHttpContex</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> redirectUrl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 释放掉链接     *     * @param context     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">abortHttpContex</span><span class="token punctuation">(</span>HttpContext context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        context<span class="token punctuation">.</span><span class="token function">getRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">abort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理https的get请求     *     * @param url     * @return     * @throws IOException     * @throws ClientProtocolException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">httpsGet</span><span class="token punctuation">(</span>String url<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClientProtocolException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        HttpClient client <span class="token operator">=</span> <span class="token function">createSSLInsecureClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doGet</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理https的get请求     *     * @param url     * @return     * @throws IOException     * @throws ClientProtocolException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">httpsGet</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClientProtocolException<span class="token punctuation">,</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doGet</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理https的post请求     *     * @param url     * @param params     * @param headers     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">httpsPost</span><span class="token punctuation">(</span>String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span>            <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        HttpClient client <span class="token operator">=</span> <span class="token function">createSSLInsecureClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">doPost</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 处理https的post请求     *     * @param client     * @param url     * @param params     * @param headers     * @return     * @throws IOException     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> HttpContext <span class="token function">httpsPost</span><span class="token punctuation">(</span>HttpClient client<span class="token punctuation">,</span> String url<span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> params<span class="token punctuation">,</span>                                        Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span> headers<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">doPost</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> url<span class="token punctuation">,</span> params<span class="token punctuation">,</span> headers<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 创建 SSL连接     *     * @return     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> CloseableHttpClient <span class="token function">createSSLInsecureClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SSLContext sslContext <span class="token operator">=</span> SSLContexts<span class="token punctuation">.</span><span class="token function">createSystemDefault</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        SSLConnectionSocketFactory sslsf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SSLConnectionSocketFactory</span><span class="token punctuation">(</span>sslContext<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> HttpClients<span class="token punctuation">.</span><span class="token function">custom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setSSLSocketFactory</span><span class="token punctuation">(</span>sslsf<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">build</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java正则表达式</title>
      <link href="/2017/05/09/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2017/05/09/java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<blockquote><p>正则表达式是对字符串操作的一种逻辑公式,用事先定义好的一些特定字符,及这些特定字符的组合,组成一个规则字符串.<br><a id="more"></a></p></blockquote><h4 id="正则表达式用途"><a href="#正则表达式用途" class="headerlink" title="正则表达式用途"></a>正则表达式用途</h4><p>正则表达式应用还是很多的。比如我们常用来验证电话号码格式、邮箱格式等涉及到有一定格式的数据验证操作；比如使用正则表达式找到指定字符并进行删除、替换等操作；比如在一个字符串中按照正则表达式的条件，找到子串，提取位置等 </p><h4 id="正则表达式常用语法"><a href="#正则表达式常用语法" class="headerlink" title="正则表达式常用语法"></a>正则表达式常用语法</h4><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描叙</th></tr></thead><tbody><tr><td style="text-align:left">\</td><td style="text-align:left">将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\n’ 匹配一个换行符。序列 ‘\‘ 匹配 “\” 而 “(“ 则匹配 “(“。</td></tr><tr><td style="text-align:left">^</td><td style="text-align:left">匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\n’ 或 ‘\r’ 之后的位置。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\n’ 或 ‘\r’ 之前的位置。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 中的”do” 。? 等价于 {0,1}。</td></tr><tr><td style="text-align:left">{n}</td><td style="text-align:left">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:left">{n,}</td><td style="text-align:left">n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。</td></tr><tr><td style="text-align:left">{n,m}</td><td style="text-align:left">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。</td></tr><tr><td style="text-align:left">?</td><td style="text-align:left">当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。</td></tr><tr><td style="text-align:left">.</td><td style="text-align:left">匹配除 “\n” 之外的任何单个字符。要匹配包括 ‘\n’ 在内的任何字符，请使用象 ‘[.\n]’ 的模式。</td></tr><tr><td style="text-align:left">(pattern)</td><td style="text-align:left">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。</td></tr><tr><td style="text-align:left">(?:pattern)</td><td style="text-align:left">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (\</td><td>) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y\</td><td>ies) 就是一个比 ‘industry\</td><td>industries’ 更简略的表达式。</td></tr><tr><td style="text-align:left">(?=pattern)</td><td style="text-align:left">正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，’Windows (?=95\</td><td>98\</td><td>NT\</td><td>2000)’ 能匹配 “Windows 2000” 中的 “Windows” ，但不能匹配 “Windows 3.1” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</td></tr><tr><td style="text-align:left">(?!pattern)</td><td style="text-align:left">负向预查，在任何不匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如’Windows (?!95\</td><td>98\</td><td>NT\</td><td>2000)’ 能匹配 “Windows 3.1” 中的 “Windows”，但不能匹配 “Windows 2000” 中的 “Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td></tr><tr><td style="text-align:left">x\</td><td style="text-align:left">y</td><td>匹配 x 或 y。例如，’z\</td><td>food’ 能匹配 “z” 或 “food”。’(z\</td><td>f)ood’ 则匹配 “zood” 或 “food”。</td></tr><tr><td style="text-align:left">[xyz]</td><td style="text-align:left">字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。</td></tr><tr><td style="text-align:left">[^xyz]</td><td style="text-align:left">负值字符集合。匹配未包含的任意字符。例如， ‘[^abc]’ 可以匹配 “plain” 中的’p’。</td></tr><tr><td style="text-align:left">[a-z]</td><td style="text-align:left">字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。</td></tr><tr><td style="text-align:left">[^a-z]</td><td style="text-align:left">负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\B</td><td style="text-align:left">匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\cx</td><td style="text-align:left">匹配由 x 指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。</td></tr><tr><td style="text-align:left">\d</td><td style="text-align:left">匹配一个数字字符。等价于 [0-9]。</td></tr><tr><td style="text-align:left">\D</td><td style="text-align:left">匹配一个非数字字符。等价于 [^0-9]。</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">匹配一个换页符。等价于 \x0c 和 \cL。</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">匹配一个换行符。等价于 \x0a 和 \cJ。</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">匹配一个回车符。等价于 \x0d 和 \cM。</td></tr><tr><td style="text-align:left">\s</td><td style="text-align:left">匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\S</td><td style="text-align:left">匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">匹配一个制表符。等价于 \x09 和 \cI。</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">匹配一个垂直制表符。等价于 \x0b 和 \cK。</td></tr><tr><td style="text-align:left">\w</td><td style="text-align:left">匹配包括下划线的任何单词字符。等价于’[A-Za-z0-9_]’。</td></tr><tr><td style="text-align:left">\W</td><td style="text-align:left">匹配任何非单词字符。等价于 ‘[^A-Za-z0-9_]’。</td></tr><tr><td style="text-align:left">\xn</td><td style="text-align:left">匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\x41’ 匹配 “A”。’\x041’ 则等价于 ‘\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。.</td></tr><tr><td style="text-align:left">\num</td><td style="text-align:left">匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\1’ 匹配两个连续的相同字符。</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。</td></tr><tr><td style="text-align:left">\nm</td><td style="text-align:left">标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</td></tr><tr><td style="text-align:left">\un</td><td style="text-align:left">匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)。</td></tr></tbody></table><h4 id="字符转义"><a href="#字符转义" class="headerlink" title="字符转义"></a>字符转义</h4><p>如果想匹配元字符本身或者正则中的一些特殊字符，使用<code>\</code>转义。例如匹配<code>*</code>这个字符则使用<code>\*</code>，匹配<code>\</code>这个字符，使用<code>\\</code>。</p><p>需要转义的字符：<code>$</code>, <code>(</code>, <code>)</code>, <code>*</code>, <code>+</code>, <code>.</code>, <code>[</code>, <code>]</code>, <code>?</code>, <code>\</code>, <code>^</code>, <code>{</code>, <code>}</code>, <code>|</code></p><h4 id="贪婪与懒惰"><a href="#贪婪与懒惰" class="headerlink" title="贪婪与懒惰"></a>贪婪与懒惰</h4><p>当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配<strong>尽可能多</strong>的字符。考虑这个表达式：a.<em>b，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索</em>aabab*的话，它会匹配整个字符串aabab。这被称为<strong>贪婪</strong>匹配。</p><p>有时，我们更需要<strong>懒惰</strong>匹配，也就是匹配<strong>尽可能少</strong>的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号?。这样.*?就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：</p><p>a.<em>?b匹配最短的，以a开始，以b结束的字符串。如果把它应用于</em>aabab*的话，它会匹配aab（第一到第三个字符）和ab（第四到第五个字符）。</p><p>属于贪婪模式的量词，也叫做匹配优先量词，包括：</p><p>“<strong>{m,n}</strong>”、“<strong>{m,}</strong>”、“<strong>?</strong>”、“<strong>*</strong>”和“<strong>+</strong>”。</p><pre><code>  // Greedy quantifiers    String match = find(&quot;A.*c&quot;, &quot;AbcAbc&quot;);  // AbcAbc    match = find(&quot;A.+&quot;, &quot;AbcAbc&quot;);          // AbcAbc    // Nongreedy quantifiers    match = find(&quot;A.*?c&quot;, &quot;AbcAbc&quot;);        // Abc    match = find(&quot;A.+?&quot;, &quot;AbcAbc&quot;);         // Abc    // Returns the first substring in input that matches the pattern.    // Returns null if no match found.    public static String find(String patternStr, CharSequence input) {        Pattern pattern = Pattern.compile(patternStr);        Matcher matcher = pattern.matcher(input);        if (matcher.find()) {            return matcher.group();        }        return null;    }</code></pre><p><strong>懒惰限定符</strong></p><table><thead><tr><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>*?</td><td>重复任意次，但尽可能少重复</td></tr><tr><td>+?</td><td>重复1次或更多次，但尽可能少重复</td></tr><tr><td>??</td><td>重复0次或1次，但尽可能少重复</td></tr><tr><td>{n,m}?</td><td>重复n到m次，但尽可能少重复</td></tr><tr><td>{n,}?</td><td>重复n次以上，但尽可能少重复</td></tr></tbody></table><h4 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h4><p>我们已经提到了怎么重复单个字符（直接在字符后面加上限定符就行了）；但如果想要重复多个字符又该怎么办？你可以用小括号来指定子表达式(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，你也可以对子表达式进行其它一些操作(后面会有介绍)。</p><p><code>(\d{1,3 .}\){3}\d{1,3}</code>是一个简单的IP地址匹配表达式。要理解这个表达式，请按下列顺序分析它：\d{1,3}匹配 1 到 3 位的数字，(\d{1,3}.){3}匹配三位数字加上一个英文句号(这个整体也就是这个分组)重复 3 次，最后再加上一个一到三位的数字(\d{1,3})。</p><p>不幸的是，它也将匹配 256.300.888.999 这种不可能存在的 IP 地址。如果能使用算术比较的话，或许能简单地解决这个问题，但是正则表达式中并不提供关于数学的任何功能，所以只能使用冗长的分组，选择，字符类来描述一个正确的 IP 地址：<code>((2[0-4]\d|25[0-5]|[01]?\d\d?)\.){3}(2[0-4]\d|25[0-5]|[01]?\d\d?)</code>。</p><p><strong>常用分组语法</strong></p><table><thead><tr><th>分类</th><th>代码/语法</th><th>说明</th></tr></thead><tbody><tr><td>捕获</td><td>(exp)</td><td>匹配exp,并捕获文本到自动命名的组里</td></tr><tr><td></td><td>(?<name>exp)</name></td><td>匹配exp,并捕获文本到名称为name的组里，也可以写成(?’name’exp)</td></tr><tr><td></td><td>(?:exp)</td><td>匹配exp,不捕获匹配的文本，也不给此分组分配组号</td></tr><tr><td>零宽断言</td><td>(?=exp)</td><td>匹配exp前面的位置</td></tr><tr><td></td><td>(?&lt;=exp)</td><td>匹配exp后面的位置</td></tr><tr><td></td><td>(?!exp)</td><td>匹配后面跟的不是exp的位置</td></tr><tr><td></td><td>(?&lt;!exp)</td><td>匹配前面不是exp的位置</td></tr><tr><td></td><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table><h4 id="零宽断言"><a href="#零宽断言" class="headerlink" title="零宽断言"></a>零宽断言</h4><p>接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像<code>\b</code>,<code>^</code>,<code>$</code>那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：</p><p><code>(?=exp)</code>也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式 exp。比如<code>\b\w+(?=ing\b)</code>，匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分)，如查找<code>I&#39;m singing while you&#39;re dancing.</code>时，它会匹配 sing 和 danc。</p><p><code>(?&lt;=exp)</code>也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式 exp。比如<code>(?&lt;=\bre)\w+\b</code>会匹配以 re 开头的单词的后半部分(除了 re 以外的部分)，例如在查找 reading a book 时，它匹配 ading。</p><p>假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了)，你可以这样查找需要在前面和里面添加逗号的部分：<code>((?&lt;=\d)\d{3})+\b</code>，用它对 1234567890 进行查找时结果是 234567890。</p><p>下面这个例子同时使用了这两种断言：<code>(?&lt;=\s)\d+(?=\s)</code>匹配以空白符间隔的数字(再次强调，不包括这些空白符)。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gson-Java-Json序列化和反序列化</title>
      <link href="/2017/03/25/Gson-Java-Json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/2017/03/25/Gson-Java-Json%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>背景介绍</p><p>Google的Gson库,Gson是一个非常强大的库，可以将JSON格式的数据转化为Java对象，也支持将Java对象转成JSON数据格式</p><a id="more"></a><p>Maven项目添加</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;       &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;       &lt;artifactId&gt;gson&lt;/artifactId&gt;      &lt;version&gt;2.8.0&lt;/version&gt;       &lt;scope&gt;compile&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre><p>实例代码</p><pre><code>public class Translate {    public static void main(String[] args) {        UserSample userSample = new UserSample();        userSample.setAge(24);        userSample.setDeveloper(true);        userSample.setEmail(&quot;1085669445@qq.com&quot;);        userSample.setName(&quot;gaohu&quot;);        //对象序列化为JSon        Gson gson = new Gson();        String sout = gson.toJson(userSample);        System.out.println(sout);        //字符串反序列化为对象        String userJson =      {&#39;age&#39;:26,&#39;email&#39;:&#39;norman@futurestud.io&#39;,&#39;isDeveloper&#39;:true,&#39;name&#39;:&#39;Norman&#39;}&quot;;        //通过 fromJson() 方法将JSON映射成一个 Java 对象：        UserSample object = gson.fromJson(userJson, UserSample.class);        System.out.println(object);    }}</code></pre><p>输出</p><pre><code>{&quot;name&quot;:&quot;gaohu&quot;,&quot;email&quot;:&quot;1085669445@qq.com&quot;,&quot;age&quot;:24,&quot;isDeveloper&quot;:true} com.ly.flight.ticketsell.biz.service.test.UserSample@7fbe847c</code></pre><p>注意第二个参数的传递，否则，Gson 不知道将 JSON 转换成什么类型。Debug模式可以看到</p><h4 id="Gson-Arrays-和-Lists-对象映射"><a href="#Gson-Arrays-和-Lists-对象映射" class="headerlink" title="Gson - Arrays 和 Lists 对象映射"></a>Gson - Arrays 和 Lists 对象映射</h4><p>数组和列表对象的映射</p><p>Array和List差异</p><p>在Java中两者实现方式不同，使用哪一种数据类型取决于你的实际需求，但在序列化这个问题上,Gson并不关心这两种数据结构的具体实现</p><p>在Json数据格式中,不存在数组等结构，只是Java 的具体实现使这两种数据类型有很大不同，但是在上层它们表示出相同的结构，接下来，我们将重新理解这两种数据类型。</p><p>Array和List序列化</p><p>model</p><pre><code>public class RestaurantWithMenu {     String name;    List&lt;RestaurantMenuItem&gt; menu;    //RestaurantMenuItem[] menu; // alternative, either one is fine}public class RestaurantMenuItem {     String description;    float price;}</code></pre><p>通过嵌套对象的方式即可，在 Java Model 中包含要映射变量的引用就可以了，要注意名字和JSON中字段名相同。</p><p>JSON 格式如下：</p><pre><code>{    &quot;name&quot;: &quot;Future Studio Steak House&quot;,    &quot;menu&quot;: [    ...    ]}</code></pre><p>与嵌套对象类似，我们没有 menu 的直接值，相反，JSON 中通过 “[]” 来包含一个对象，如上所述，在 JSON 数据中，数组和 List 结构是没有区别的。</p><p>menu 中包含一些对象，在我们那的 model 中，menu 只是其中的一个变量，我们先来手动生成一个完整的 JSON 数据。</p><p>通过下面这种方式，我们来模拟一个完整的 restaurant 数据：</p><pre><code>List&lt;RestaurantMenuItem&gt; menu = new ArrayList&lt;&gt;();menu.add(new RestaurantMenuItem(&quot;Spaghetti&quot;, 7.99f));menu.add(new RestaurantMenuItem(&quot;Steak&quot;, 12.99f));menu.add(new RestaurantMenuItem(&quot;Salad&quot;, 5.99f));RestaurantWithMenu restaurant = new RestaurantWithMenu(&quot;Future Studio Steak House&quot;, menu);Gson gson = new Gson();String restaurantJson = gson.toJson(restaurant);</code></pre><pre><code>{    &quot;menu&quot;: [    {        &quot;description&quot;: &quot;Spaghetti&quot;,        &quot;price&quot;: 7.99    },    {        &quot;description&quot;: &quot;Steak&quot;,        &quot;price&quot;: 12.99    },    {        &quot;description&quot;: &quot;Salad&quot;,        &quot;price&quot;: 5.99        }    ],    &quot;name&quot;: &quot;Future Studio Steak House&quot;}</code></pre><p>如我们预料，我们得到了想要的数据，按照字母顺序，menu 排在了name 的前面,根据 “[]” 标志 List 开始，根据 “{}” 标志对象开始。</p><p>但是我们并不是总是将 List 嵌套在对象中，我们可能会直接得到一个 List，Gson 也是支持直接序列化一个 List。</p><pre><code>String menuJson = gson.toJson(menu);</code></pre><p>输出</p><pre><code>[    {        &quot;description&quot;: &quot;Spaghetti&quot;,        &quot;price&quot;: 7.99    },    {        &quot;description&quot;: &quot;Steak&quot;,        &quot;price&quot;: 12.99    },    {        &quot;description&quot;: &quot;Salad&quot;,        &quot;price&quot;: 5.99    }]</code></pre><p>来看下数据中的不同，JSON 中的 “[“ 表示一个对象列表开始，”{“ 表示一个对象开始了，我们应该记住 JSON 数据中格式差别。</p><h5 id="数组和List反序列化"><a href="#数组和List反序列化" class="headerlink" title="数组和List反序列化"></a>数组和List反序列化</h5><p>首先看解析成数组，通过 Gson 的 gson.fromJson 方法，我们很简单的将 GSON 解析成数组，注意这里传递的参数是 Founder[].class 而不是Founder.class ,如下：</p><pre><code>String founderJson = &quot;[{&#39;name&#39;: &#39;Christian&#39;,&#39;flowerCount&#39;: 1}, {&#39;name&#39;: &#39;Marcus&#39;, &#39;flowerCount&#39;: 3}, {&#39;name&#39;: &#39;Norman&#39;, &#39;flowerCount&#39;: 2}]&quot;;Gson gson = new Gson();Founder[] founderArray = gson.fromJson(founderJson, Founder[].class);</code></pre><h3 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h3><p>实际开发中，我们更多的是转成一个 ArrayList，但是，我们不能像解析数组那样传入 List<founder>，为了让Gson知道我们要解析的数据类型，我们必须传递给它一个Type，内部根据 TypeToken 来区分要解析的类型。例如：</founder></p><pre><code>Type founderListType = new TypeToken&lt;ArrayList&lt;Founder&gt;&gt;(){}.getType();</code></pre><pre><code>String founderJson = &quot;[{&#39;name&#39;: &#39;Christian&#39;,&#39;flowerCount&#39;: 1}, {&#39;name&#39;: &#39;Marcus&#39;, &#39;flowerCount&#39;: 3}, {&#39;name&#39;: &#39;Norman&#39;, &#39;flowerCount&#39;: 2}]&quot;;Gson gson = new Gson();Type founderListType = new TypeToken&lt;ArrayList&lt;Founder&gt;&gt;(){}.getType();List&lt;Founder&gt; founderList = gson.fromJson(founderJson, founderListType);</code></pre><p>列表存在 Model 类中的一个好处就是，我们在使用Gson解析时不再需要传递 TypeToken，直接穿入类即可。</p><pre><code> String generalInfoJson = &quot;{&#39;name&#39;: &#39;Future Studio Dev Team&#39;,  &#39;meun&#39;: [{&#39;description&#39;: &#39;Christian&#39;, &#39;price&#39;: 1 }, {&#39;description&#39;: &#39;Marcus&#39;,&#39;price&#39;: 3 }, {&#39;description&#39;: &#39;Norman&#39;,&#39;price&#39;: 2 }]}&quot;;        ReStaurantMenu reStaurantMenu = gson.fromJson(generalInfoJson, ReStaurantMenu.class);        System.out.println(reStaurantMenu);</code></pre><h4 id="List-中嵌套-List"><a href="#List-中嵌套-List" class="headerlink" title="List 中嵌套 List"></a>List 中嵌套 List</h4><p>Gson 也可以解析 List 中嵌套 List 数据结构，看下面这个例子，例如：</p><pre><code>public class GeneralInfo {    String name;    String website;    List&lt;FounderWithPets&gt; founders;}public class FounderWithPets {    String name;    int flowerCount;    List&lt;Pet&gt; pets;}public class Pet {    String name;    List&lt;Toy&gt; toys;}</code></pre><h4 id="Java-Map-序列化"><a href="#Java-Map-序列化" class="headerlink" title="Java Map 序列化"></a>Java Map 序列化</h4><p>在介绍使用 Gson 解析一些基本数据结构之后，我们来看下如何使用Gson 来序列化和反序列化 Java 中的 Map 数据类型。</p><p>实例 HashMap</p><pre><code>HashMap&lt;String, List&lt;String&gt;&gt; employees = new HashMap&lt;&gt;();employees.put(&quot;A&quot;, Arrays.asList(&quot;Andreas&quot;, &quot;Arnold&quot;, &quot;Aden&quot;));employees.put(&quot;C&quot;, Arrays.asList(&quot;Christian&quot;, &quot;Carter&quot;));employees.put(&quot;M&quot;, Arrays.asList(&quot;Marcus&quot;, &quot;Mary&quot;));</code></pre><p>输出</p><pre><code>{&quot;A&quot;:[&quot;Andres&quot;,&quot;Arnold&quot;,&quot;Aden&quot;],&quot;B&quot;:[&quot;Christian&quot;,&quot;Carter&quot;],&quot;C&quot;:[&quot;Marus&quot;,&quot;Mary&quot;]}</code></pre><p>正如 Java Map 结构一样，每个 Key 对应这个一个集合。</p><h4 id="Java-Map-反序列化"><a href="#Java-Map-反序列化" class="headerlink" title="Java Map 反序列化"></a>Java Map 反序列化</h4><p>和上面 JSON 数据对比，我们发现有些不一样，这里的 key 是变化的，而不像 List 那样是固定的字段名</p><pre><code>{    &quot;1$&quot;: {       &quot;amount&quot;: 1,        &quot;currency&quot;: &quot;Dollar&quot;    },    &quot;2$&quot;: {       &quot;amount&quot;: 2,        &quot;currency&quot;: &quot;Dollar&quot;    },    &quot;3€&quot;: {        &quot;amount&quot;: 3,        &quot;currency&quot;: &quot;Euro&quot;    }}</code></pre><p>Json 数据中包含三个对象，每个对象有自己的值，但是我们发现 Json 数据更像一个 Map 结构1​ ,3€ 是key</p><p>以下是区分 JSON 数据类型的一些简单的方法：</p><p>根据你的文档解释或者应用场景键和值是否是一种类型键和值是否是动态的我们假设本例子就是一个map结构的数据，之前我们使用TypeToken来标志过list类型，这里我们需要创建一个map类型的TypeToken类型。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java8新特性</title>
      <link href="/2017/03/23/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2017/03/23/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<p>背景介绍：</p><p>毫无疑问，<a href="http://www.oracle.com/technetwork/java/javase/8train-relnotes-latest-2153846.html" target="_blank" rel="noopener">Java 8发行版</a>是自Java 5（发行于2004，已经过了相当一段时间了）以来最具革命性的版本。Java 8 为Java语言、编译器、类库、开发工具与JVM（Java虚拟机）带来了大量新特性。在这篇教程中，我们将一一探索这些变化，并用真实的例子说明它们适用的场景。<br><a id="more"></a></p><p>Java语言的新特性</p><h5 id="Lambda表达式与Functional接口"><a href="#Lambda表达式与Functional接口" class="headerlink" title="Lambda表达式与Functional接口"></a>Lambda表达式与Functional接口</h5><p>Lambda表达式（也称为闭包）是整个Java 8发行版中最受期待的在Java语言层面上的改变，Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中），或者把代码看成数据：函数式程序员对这一概念非常熟悉。在JVM平台上的很多语言（Groovy，<a href="http://www.javacodegeeks.com/tutorials/scala-tutorials/" target="_blank" rel="noopener">Scala</a>，……）从一开始就有Lambda，但是Java程序员不得不使用毫无新意的匿名类来代替lambda。</p><p>关于Lambda设计的讨论占用了大量的时间与社区的努力。可喜的是，最终找到了一个平衡点，使得可以使用一种即简洁又紧凑的新方式来构造Lambdas。在最简单的形式中，一个lambda可以由用逗号分隔的参数列表、–&gt;符号与函数体三部分表示。例如：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; System.out.println( e ) );</code></pre><p>注意：e的类型是编译器推测出来的,同时,也可以通过把参数类型与参数包括在括号中的形式直接给出参数的类型</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( ( String e ) -&gt; System.out.println( e ) );</code></pre><p>在某些情况下lambda的函数体会更加复杂,这时可以把函数体放到一对花括号中,就像在Java中定义普通函数一样,例如：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach( e -&gt; {    System.out.print( e );    System.out.print( e );} );</code></pre><p>Lambda可以引用类的成员变量与局部变量（如果这些变量不是final的话，它们会被隐含的转为final，这样效率更高）。例如，下面两个代码片段是等价的：</p><pre><code>String separator = &quot;,&quot;;Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).forEach(( String e ) -&gt; System.out.print( e + separator ));</code></pre><p>Lambda可能会返回一个值。返回值的类型也是由编译器推测出来的。如果lambda的函数体只有一行的话，那么没有必要显式使用return语句。下面两个代码片段是等价的：</p><pre><code>Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; e1.compareTo( e2 ) );//等价于Arrays.asList( &quot;a&quot;, &quot;b&quot;, &quot;d&quot; ).sort( ( e1, e2 ) -&gt; {    int result = e1.compareTo( e2 );    return result; } );</code></pre><p>语言设计者投入了大量精力来思考如何使现有的函数友好地支持lambda。最终采取的方法是：增加函数式接口的概念。函数式接口就是一个具有一个方法的普通接口。像这样的接口，可以被隐式转换为lambda表达式。java.lang.Runnable与java.util.concurrent.Callable是函数式接口最典型的两个例子。在实际使用过程中，函数式接口是容易出错的：如有某个人在接口定义中增加了另一个方法，这时，这个接口就不再是函数式的了，并且编译过程也会失败。为了克服函数式接口的这种脆弱性并且能够明确声明接口作为函数式接口的意图，Java 8增加了一种特殊的注解@FunctionalInterface（Java 8中所有类库的已有接口都添加了@FunctionalInterface注解）。让我们看一下这种函数式接口的定义：</p><pre><code>@FunctionalInterfacepublic interface Functional {    void method();}</code></pre><p>Tips:  默认方法与静态方法并不影响函数式接口的契约，可以任意使用：</p><pre><code>@FunctionalInterfacepublic interface FunctionalDefaultMethods {    void method();      default void defaultMethod() {                }        }</code></pre><p>Lambda是Java 8最大的卖点。它具有吸引越来越多程序员到Java平台上的潜力，并且能够在纯Java语言环境中提供一种优雅的方式来支持函数式编程。更多详情可以参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="接口的默认方法与静态方法"><a href="#接口的默认方法与静态方法" class="headerlink" title="接口的默认方法与静态方法"></a>接口的默认方法与静态方法</h4><p>Java 8用默认方法与静态方法这两个新概念来扩展接口的声明。<a href="http://www.javacodegeeks.com/2014/04/java-8-default-methods-what-can-and-can-not-do.html" target="_blank" rel="noopener">默认方法</a>使接口有点像Traits（Scala中特征(trait)类似于Java中的Interface，但它可以包含实现代码，也就是目前Java8新增的功能），但与传统的接口又有些不一样，它允许在已有的接口中添加新方法，而同时又保持了与旧版本代码的兼容性。</p><p>默认方法与抽象方法不同之处在于抽象方法必须要求实现，但是默认方法则没有这个要求。相反，每个接口都必须提供一个所谓的默认实现，这样所有的接口实现者将会默认继承它（如果有必要的话，可以覆盖这个默认实现）。让我们看看下面的例子：</p><pre><code>private interface Defaulable {    // Interfaces now allow default methods, the implementer may or     // may not implement (override) them.    default String notRequired() {         return &quot;Default implementation&quot;;     }        }private static class DefaultableImpl implements Defaulable {}private static class OverridableImpl implements Defaulable {    @Override    public String notRequired() {        return &quot;Overridden implementation&quot;;    }}</code></pre><p>Defaulable接口用关键字default声明了一个默认方法notRequired()，Defaulable接口的实现者之一DefaultableImpl实现了这个接口，并且让默认方法保持原样。Defaulable接口的另一个实现者OverridableImpl用自己的方法覆盖了默认方法。</p><p>Java 8带来的另一个有趣的特性是接口可以声明（并且可以提供实现）静态方法。例如：</p><pre><code>private interface DefaulableFactory {    // Interfaces now allow static methods    static Defaulable create( Supplier&lt; Defaulable &gt; supplier ) {        return supplier.get();    }}</code></pre><p>默认方法与静态方法黏合到一起。</p><pre><code>public static void main( String[] args ) {    Defaulable defaulable = DefaulableFactory.create( DefaultableImpl::new );    System.out.println( defaulable.notRequired() );    defaulable = DefaulableFactory.create( OverridableImpl::new );    System.out.println( defaulable.notRequired() );}</code></pre><p>这个程序的控制台输出如下：</p><pre><code>Default implementationOverridden implementation</code></pre><p>在JVM中，默认方法的实现是非常高效的，并且通过字节码指令为方法调用提供了支持。默认方法允许继续使用现有的Java接口，而同时能够保障正常的编译过程。这方面好的例子是大量的方法被添加到java.util.Collection接口中去：stream()，parallelStream()，forEach()，removeIf()，……</p><p>尽管默认方法非常强大，但是在使用默认方法时我们需要小心注意一个地方：在声明一个默认方法前，请仔细思考是不是真的有必要使用默认方法，因为默认方法会带给程序歧义，并且在复杂的继承体系中容易产生编译错误。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用提供了非常有用的语法，可以直接引用已有Java类或对象（实例）的方法或构造器。与lambda联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</p><p>定义了4个方法的Car这个类作为例子，区分Java中支持的4种不同的方法引用。</p><pre><code>public static class Car {    public static Car create( final Supplier&lt; Car &gt; supplier ) {        return supplier.get();    }                  public static void collide( final Car car ) {        System.out.println( &quot;Collided &quot; + car.toString() );    }    public void follow( final Car another ) {        System.out.println( &quot;Following the &quot; + another.toString() );    }    public void repair() {           System.out.println( &quot;Repaired &quot; + this.toString() );    }}</code></pre><p>第一种方法引用是构造器引用，它的语法是Class::new，或者更一般的Class&lt; T &gt;::new。请注意构造器没有参数。</p><pre><code>final Car car = Car.create( Car::new );final List&lt; Car &gt; cars = Arrays.asList( car );</code></pre><p>第二种方法引用是静态方法引用，它的语法是Class::static_method。请注意这个方法接受一个Car类型的参数。</p><pre><code>cars.forEach( Car::collide );</code></pre><p>第三种方法引用是特定类的任意对象的方法引用，它的语法是Class::method。请注意，这个方法没有参数。</p><pre><code>cars.forEach( Car::repair );</code></pre><p>最后，第四种方法引用是特定对象的方法引用，它的语法是instance::method。请注意，这个方法接受一个Car类型的参数</p><pre><code>final Car police = Car.create( Car::new );cars.forEach( police::follow );</code></pre><p>运行上面的Java程序在控制台上会有下面的输出（Car的实例可能不一样）：</p><pre><code>Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197dRepaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197dFollowing the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</code></pre><p>关于方法引用的更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h4><p>自从Java 5引入了<a href="http://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html" target="_blank" rel="noopener">注解</a>机制，这一特性就变得非常流行并且广为使用。然而，使用注解的一个限制是相同的注解在同一位置只能声明一次，不能声明多次。Java 8打破了这条规则，引入了重复注解机制，这样相同的注解可以在同一地方声明多次。</p><p>重复注解机制本身必须用@Repeatable注解。事实上，这并不是语言层面上的改变，更多的是编译器的技巧，底层的原理保持不变。让我们看一个快速入门的例子：</p><pre><code>package com.javacodegeeks.java8.repeatable.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Repeatable;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;public class RepeatingAnnotations {    @Target( ElementType.TYPE )    @Retention( RetentionPolicy.RUNTIME )    public @interface Filters {        Filter[] value();    }    @Target( ElementType.TYPE )    @Retention( RetentionPolicy.RUNTIME )    @Repeatable( Filters.class )    public @interface Filter {        String value();    };    @Filter( &quot;filter1&quot; )    @Filter( &quot;filter2&quot; )    public interface Filterable {            }    public static void main(String[] args) {        for( Filter filter: Filterable.class.getAnnotationsByType( Filter.class ) ) {            System.out.println( filter.value() );        }    }}</code></pre><p>正如我们看到的，这里有个使用@Repeatable( Filters.class )注解的注解类Filter，Filters仅仅是Filter注解的数组，但Java编译器并不想让程序员意识到Filters的存在。这样，接口Filterable就拥有了两次Filter（并没有提到Filter）注解。</p><p>同时，反射相关的API提供了新的函数getAnnotationsByType()来返回重复注解的类型（请注意Filterable.class.getAnnotation( Filters.class )经编译器处理后将会返回Filters的实例）。</p><p>程序输出结果如下：</p><pre><code>filter1filter2</code></pre><p>更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="更好的类型推测机制"><a href="#更好的类型推测机制" class="headerlink" title="更好的类型推测机制"></a>更好的类型推测机制</h4><p>Java 8在类型推测方面有了很大的提高。在很多情况下，编译器可以推测出确定的参数类型，这样就能使代码更整洁。让我们看一个例子：</p><pre><code>package com.javacodegeeks.java8.type.inference;public class Value&lt; T &gt; {    public static&lt; T &gt; T defaultValue() {         return null;     }    public T getOrDefault( T value, T defaultValue ) {        return ( value != null ) ? value : defaultValue;    }}</code></pre><p>这里是Value&lt; String &gt;类型的用法。</p><pre><code>package com.javacodegeeks.java8.type.inference;public class TypeInference {    public static void main(String[] args) {        final Value&lt; String &gt; value = new Value&lt;&gt;();        value.getOrDefault( &quot;22&quot;, Value.defaultValue() );    }}</code></pre><p>Value.defaultValue()的参数类型可以被推测出，所以就不必明确给出。在Java 7中，相同的例子将不会通过编译，正确的书写方式是 Value.&lt; String &gt;defaultValue()。</p><h4 id="扩展注解的支持"><a href="#扩展注解的支持" class="headerlink" title="扩展注解的支持"></a>扩展注解的支持</h4><p>Java 8扩展了注解的上下文。现在几乎可以为任何东西添加注解：局部变量、泛型类、父类与接口的实现，就连方法的异常也能添加注解。下面演示几个例子：</p><pre><code>package com.javacodegeeks.java8.annotations;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import java.util.ArrayList;import java.util.Collection;public class Annotations {    @Retention( RetentionPolicy.RUNTIME )    @Target( { ElementType.TYPE_USE, ElementType.TYPE_PARAMETER } )    public @interface NonEmpty {            }    public static class Holder&lt; @NonEmpty T &gt; extends @NonEmpty Object {        public void method() throws @NonEmpty Exception {                   }    }    @SuppressWarnings( &quot;unused&quot; )    public static void main(String[] args) {        final Holder&lt; String &gt; holder = new @NonEmpty Holder&lt; String &gt;();               @NonEmpty Collection&lt; @NonEmpty String &gt; strings = new ArrayList&lt;&gt;();           }}</code></pre><p>ElementType.TYPE_USE和ElementType.TYPE_PARAMETER是两个新添加的用于描述适当的注解上下文的元素类型。在Java语言中，注解处理API也有小的改动来识别新增的类型注解。</p><h4 id="Java编译器的新特性"><a href="#Java编译器的新特性" class="headerlink" title="Java编译器的新特性"></a>Java编译器的新特性</h4><p>很长一段时间里，Java程序员一直在发明不同的方式使得<a href="http://www.javacodegeeks.com/2014/04/constructormethod-parameters-metadata-available-via-reflection-in-jdk-8.html" target="_blank" rel="noopener">方法参数的名字能保留在Java字节码</a>中，并且能够在运行时获取它们（比如，<a href="https://github.com/paul-hammant/paranamer" target="_blank" rel="noopener">Paranamer类库</a>）。最终，在Java 8中把这个强烈要求的功能添加到语言层面（通过反射API与Parameter.getName()方法）与字节码文件（通过新版的javac的–parameters选项）中。</p><pre><code>package com.javacodegeeks.java8.parameter.names;import java.lang.reflect.Method;import java.lang.reflect.Parameter;public class ParameterNames {    public static void main(String[] args) throws Exception {        Method method = ParameterNames.class.getMethod( &quot;main&quot;, String[].class );        for( final Parameter parameter: method.getParameters() ) {            System.out.println( &quot;Parameter: &quot; + parameter.getName() );        }    }}</code></pre><p>如果不使用–parameters参数来编译这个类，然后运行这个类，会得到下面的输出：</p><pre><code>Parameter: arg0</code></pre><p>对于<a href="http://www.javacodegeeks.com/tag/apache-maven/" target="_blank" rel="noopener">有经验的Maven用户</a>，通过maven-compiler-plugin的配置可以将-parameters参数添加到编译器中去。</p><pre><code>&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;    &lt;version&gt;3.1&lt;/version&gt;    &lt;configuration&gt;        &lt;compilerArgument&gt;-parameters&lt;/compilerArgument&gt;        &lt;source&gt;1.8&lt;/source&gt;        &lt;target&gt;1.8&lt;/target&gt;    &lt;/configuration&gt;&lt;/plugin&gt;</code></pre><p>此外，Parameter类有一个很方便的方法isNamePresent()来验证是否可以获取参数的名字。</p><h4 id="Java-类库的新特性"><a href="#Java-类库的新特性" class="headerlink" title="Java 类库的新特性"></a>Java 类库的新特性</h4><p>Java 8 通过增加大量新类，扩展已有类的功能的方式来改善对并发编程、函数式编程、日期/时间相关操作以及其他更多方面的支持。</p><p>到目前为止，<a href="http://examples.javacodegeeks.com/java-basics/exceptions/java-lang-nullpointerexception-how-to-handle-null-pointer-exception/" target="_blank" rel="noopener">臭名昭著的空指针异常</a>是导致Java应用程序失败的最常见原因。以前，为了解决空指针异常，<a href="http://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">Google公司著名的Guava项目</a>引入了Optional类，Guava通过使用检查空值的方式来防止代码污染，它鼓励程序员写更干净的代码。受到<a href="http://code.google.com/p/guava-libraries/" target="_blank" rel="noopener">Google Guava</a>的启发，Optional类已经成为Java 8类库的一部分。</p><p>Optional实际上是个容器：它可以保存类型T的值，或者仅仅保存null。Optional提供很多有用的方法，这样我们就不用显式进行空值检测。更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">官方文档</a>。</p><p>我们下面用两个小例子来演示如何使用Optional类：一个允许为空值，一个不允许为空值。</p><pre><code>Optional&lt; String &gt; fullName = Optional.ofNullable( null );System.out.println( &quot;Full Name is set? &quot; + fullName.isPresent() );        System.out.println( &quot;Full Name: &quot; + fullName.orElseGet( () -&gt; &quot;[none]&quot; ) ); System.out.println( fullName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );</code></pre><p>如果Optional类的实例为非空值的话，isPresent()返回true，否从返回false。为了防止Optional为空值，orElseGet()方法通过回调函数来产生一个默认值。map()函数对当前Optional的值进行转化，然后返回一个新的Optional实例。orElse()方法和orElseGet()方法类似，但是orElse接受一个默认值而不是一个回调函数。下面是这个程序的输出：</p><pre><code>Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>另一个例子：</p><pre><code>Optional&lt; String &gt; firstName = Optional.of( &quot;Tom&quot; );System.out.println( &quot;First Name is set? &quot; + firstName.isPresent() );        System.out.println( &quot;First Name: &quot; + firstName.orElseGet( () -&gt; &quot;[none]&quot; ) ); System.out.println( firstName.map( s -&gt; &quot;Hey &quot; + s + &quot;!&quot; ).orElse( &quot;Hey Stranger!&quot; ) );System.out.println();</code></pre><p>输出</p><pre><code>First Name is set? trueFirst Name: TomHey Tom!</code></pre><p>更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="Stream"><a href="#Stream" class="headerlink" title="Stream"></a>Stream</h4><p>最新添加的<a href="http://www.javacodegeeks.com/2014/05/the-effects-of-programming-with-java-8-streams-on-algorithm-performance.html" target="_blank" rel="noopener">Stream API</a>（java.util.stream） 把真正的函数式编程风格引入到Java中。这是目前为止对Java类库最好的补充，因为Stream API可以极大提供Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p><p>Stream API极大简化了集合框架的处理（但它的处理的范围不仅仅限于集合框架的处理，这点后面我们会看到）。让我们以一个简单的Task类为例进行介绍：</p><pre><code>public class Streams  {    private enum Status {        OPEN, CLOSED    };    private static final class Task {        private final Status status;        private final Integer points;        Task( final Status status, final Integer points ) {            this.status = status;            this.points = points;        }        public Integer getPoints() {            return points;        }        public Status getStatus() {            return status;        }        @Override        public String toString() {            return String.format( &quot;[%s, %d]&quot;, status, points );        }    }}</code></pre><p>Task类有一个分数的概念（或者说是伪复杂度），其次是还有一个值可以为OPEN或CLOSED的状态.让我们引入一个Task的小集合作为演示例子：</p><pre><code>final Collection&lt; Task &gt; tasks = Arrays.asList(    new Task( Status.OPEN, 5 ),    new Task( Status.OPEN, 13 ),    new Task( Status.CLOSED, 8 ) );</code></pre><p>这个例子和第一个例子很相似，但这个例子的不同之处在于这个程序是并行运行的，其次使用reduce方法来算最终的结果。下面是这个例子在控制台的输出：</p><pre><code>Total points (all tasks): 26.0</code></pre><p>经常会有这个一个需求：我们需要按照某种准则来对集合中的元素进行分组。Stream也可以处理这样的需求，下面是一个例子</p><pre><code>// Group tasks by their statusfinal Map&lt; Status, List&lt; Task &gt; &gt; map = tasks    .stream()    .collect( Collectors.groupingBy( Task::getStatus ) );System.out.println( map );</code></pre><p>这个例子的控制台输出如下：</p><pre><code>{CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]}</code></pre><p>让我们来计算整个集合中每个task分数（或权重）的平均值来结束task的例子。</p><pre><code>// Calculate the weight of each tasks (as percent of total points) final Collection&lt; String &gt; result = tasks    .stream()                                        // Stream&lt; String &gt;    .mapToInt( Task::getPoints )                     // IntStream    .asLongStream()                                  // LongStream    .mapToDouble( points -&gt; points / totalPoints )   // DoubleStream    .boxed()                                         // Stream&lt; Double &gt;    .mapToLong( weigth -&gt; ( long )( weigth * 100 ) ) // LongStream    .mapToObj( percentage -&gt; percentage + &quot;%&quot; )      // Stream&lt; String&gt;     .collect( Collectors.toList() );                 // List&lt; String &gt; System.out.println( result );</code></pre><p>下面是这个例子的控制台输出：</p><pre><code>[19%, 50%, 30%]</code></pre><p>最后，就像前面提到的，Stream API不仅仅处理Java集合框架。像从文本文件中逐行读取数据这样典型的I/O操作也很适合用Stream API来处理。下面用一个例子来应证这一点。</p><pre><code>final Path path = new File( filename ).toPath();try( Stream&lt; String &gt; lines = Files.lines( path, StandardCharsets.UTF_8 ) ) {    lines.onClose( () -&gt; System.out.println(&quot;Done!&quot;) ).forEach( System.out::println );}</code></pre><p>对一个stream对象调用onClose方法会返回一个在原有功能基础上新增了关闭功能的stream对象，当对stream对象调用close()方法时，与关闭相关的处理器就会执行。</p><p>Stream API、<a href="http://www.importnew.com/11908.html#lambdaAndFunctional" target="_blank" rel="noopener">Lambda表达式</a>与<a href="http://www.importnew.com/11908.html#methodReferences" target="_blank" rel="noopener">方法引用</a>在<a href="http://www.importnew.com/11908.html#defaultAndStaticMethod" target="_blank" rel="noopener">接口默认方法与静态方法</a>的配合下是Java 8对现代软件开发范式的回应。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/collections/streams/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="4-3-Date-Time-API-JSR-310"><a href="#4-3-Date-Time-API-JSR-310" class="headerlink" title="4.3 Date/Time API (JSR 310)"></a>4.3 Date/Time API (JSR 310)</h4><p>Java 8通过发布<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">新的Date-Time API (JSR 310)</a>来进一步加强对日期与时间的处理。对日期与时间的操作一直是Java程序员最痛苦的地方之一。标准的 java.util.Date以及后来的java.util.Calendar一点没有改善这种情况（可以这么说，它们一定程度上更加复杂）。</p><p>这种情况直接导致了<a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a>——一个可替换标准日期/时间处理且功能非常强大的Java API的诞生。Java 8<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">新的Date-Time API (JSR 310)</a>在很大程度上受到<a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a>的影响，并且吸取了其精髓。新的java.time包涵盖了<a href="http://www.javacodegeeks.com/2014/03/whats-new-in-java-8-date-api.html" target="_blank" rel="noopener">所有处理日期，时间，日期/时间，时区，时刻（instants），过程（during）与时钟（clock）的操作</a>。在设计新版API时，十分注重与旧版API的兼容性：不允许有任何的改变（从java.util.Calendar中得到的深刻教训）。如果需要修改，会返回这个类的一个新实例。</p><p>让我们用例子来看一下新版API主要类的使用方法。第一个是Clock类，它通过指定一个时区，然后就可以获取到当前的时刻，日期与时间。Clock可以替换System.currentTimeMillis()与TimeZone.getDefault()。</p><pre><code>// Get the system clock as UTC offset final Clock clock = Clock.systemUTC();System.out.println( clock.instant() );System.out.println( clock.millis() );</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>2014-04-12T15:19:29.282Z1397315969360</code></pre><p>我们需要关注的其他类是LocaleDate与LocalTime。LocaleDate只持有ISO-8601格式且无时区信息的日期部分。相应的，LocaleTime只持有ISO-8601格式且无时区信息的时间部分。LocaleDate与LocalTime都可以从Clock中得到。</p><pre><code>// Get the local date and local timefinal LocalDate date = LocalDate.now();final LocalDate dateFromClock = LocalDate.now( clock );System.out.println( date );System.out.println( dateFromClock );// Get the local date and local timefinal LocalTime time = LocalTime.now();final LocalTime timeFromClock = LocalTime.now( clock );System.out.println( time );System.out.println( timeFromClock );</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>2014-04-122014-04-1211:25:54.56815:25:54.568</code></pre><p>LocaleDateTime把LocaleDate与LocaleTime的功能合并起来，它持有的是ISO-8601格式无时区信息的日期与时间。下面是一个<a href="http://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">快速入门</a>的例子。</p><pre><code>// Get the local date/timefinal LocalDateTime datetime = LocalDateTime.now();final LocalDateTime datetimeFromClock = LocalDateTime.now( clock );System.out.println( datetime );System.out.println( datetimeFromClock );</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>2014-04-12T11:37:52.3092014-04-12T15:37:52.309</code></pre><p>如果你需要特定时区的日期/时间，那么ZonedDateTime是你的选择。它持有ISO-8601格式具具有时区信息的日期与时间。下面是一些不同时区的例子：</p><pre><code>// Get the zoned date/timefinal ZonedDateTime zonedDatetime = ZonedDateTime.now();final ZonedDateTime zonedDatetimeFromClock = ZonedDateTime.now( clock );final ZonedDateTime zonedDatetimeFromZone = ZonedDateTime.now( ZoneId.of( &quot;America/Los_Angeles&quot; ) );System.out.println( zonedDatetime );System.out.println( zonedDatetimeFromClock );System.out.println( zonedDatetimeFromZone );</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>2014-04-12T11:47:01.017-04:00[America/New_York]2014-04-12T15:47:01.017Z2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</code></pre><p>最后，让我们看一下Duration类：在秒与纳秒级别上的一段时间。Duration使计算两个日期间的不同变的十分简单。下面让我们看一个这方面的例子。</p><pre><code>// Get duration between two datesfinal LocalDateTime from = LocalDateTime.of( 2014, Month.APRIL, 16, 0, 0, 0 );final LocalDateTime to = LocalDateTime.of( 2015, Month.APRIL, 16, 23, 59, 59 );final Duration duration = Duration.between( from, to );System.out.println( &quot;Duration in days: &quot; + duration.toDays() );System.out.println( &quot;Duration in hours: &quot; + duration.toHours() );</code></pre><p>上面的例子计算了两个日期2014年4月16号与2014年4月16号之间的过程。下面是程序在控制台上的输出：</p><pre><code>Duration in days: 365Duration in hours: 8783</code></pre><p>对Java 8在日期/时间API的改进整体印象是非常非常好的。一部分原因是因为它建立在“久战杀场”的<a href="http://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a>基础上，另一方面是因为用来大量的时间来设计它，并且这次程序员的声音得到了认可。更多详情请参考<a href="http://docs.oracle.com/javase/tutorial/datetime/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="4-4-JavaScript引擎Nashorn"><a href="#4-4-JavaScript引擎Nashorn" class="headerlink" title="4.4 JavaScript引擎Nashorn"></a>4.4 JavaScript引擎Nashorn</h4><p>Nashorn，一个新的JavaScript引擎随着Java 8一起公诸于世，它允许在JVM上开发运行某些JavaScript应用。Nashorn就是javax.script.ScriptEngine的另一种实现，并且它们俩遵循相同的规则，允许Java与JavaScript相互调用。下面看一个例子：</p><pre><code>ScriptEngineManager manager = new ScriptEngineManager();ScriptEngine engine = manager.getEngineByName( &quot;JavaScript&quot; );System.out.println( engine.getClass().getName() );System.out.println( &quot;Result:&quot; + engine.eval( &quot;function f() { return 1; }; f() + 1;&quot; ) );</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>jdk.nashorn.api.scripting.NashornScriptEngineResult: 2</code></pre><p><a href="undefined">我们在后面的</a><a href="http://www.importnew.com/11908.html#newJavaTool" target="_blank" rel="noopener">Java新工具</a>章节会再次谈到Nashorn。</p><h4 id="4-5-Base64"><a href="#4-5-Base64" class="headerlink" title="4.5 Base64"></a>4.5 Base64</h4><p>在Java 8中，<a href="http://www.javacodegeeks.com/2014/04/base64-in-java-8-its-not-too-late-to-join-in-the-fun.html" target="_blank" rel="noopener">Base64编码</a>已经成为Java类库的标准。它的使用十分简单，下面让我们看一个例子：</p><pre><code>package com.javacodegeeks.java8.base64;import java.nio.charset.StandardCharsets;import java.util.Base64;public class Base64s {    public static void main(String[] args) {        final String text = &quot;Base64 finally in Java 8!&quot;;        final String encoded = Base64            .getEncoder()            .encodeToString( text.getBytes( StandardCharsets.UTF_8 ) );        System.out.println( encoded );        final String decoded = new String(             Base64.getDecoder().decode( encoded ),            StandardCharsets.UTF_8 );        System.out.println( decoded );    }}</code></pre><p>程序在控制台上输出了编码后的字符与解码后的字符：</p><pre><code>QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==Base64 finally in Java 8!</code></pre><p>Base64类同时还提供了对URL、MIME友好的编码器与解码器（Base64.getUrlEncoder() / Base64.getUrlDecoder(), Base64.getMimeEncoder() / Base64.getMimeDecoder()）。</p><h4 id="4-6-并行（parallel）数组"><a href="#4-6-并行（parallel）数组" class="headerlink" title="4.6 并行（parallel）数组"></a>4.6 并行（parallel）数组</h4><p>Java 8增加了大量的新方法来对数组进行并行处理。可以说，最重要的是parallelSort()方法，因为它可以在多核机器上极大提高数组排序的速度。下面的例子展示了新方法（parallelXxx）的使用。</p><pre><code>package com.javacodegeeks.java8.parallel.arrays;import java.util.Arrays;import java.util.concurrent.ThreadLocalRandom;public class ParallelArrays {    public static void main( String[] args ) {        long[] arrayOfLong = new long [ 20000 ];                Arrays.parallelSetAll( arrayOfLong,             index -&gt; ThreadLocalRandom.current().nextInt( 1000000 ) );        Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();        Arrays.parallelSort( arrayOfLong );             Arrays.stream( arrayOfLong ).limit( 10 ).forEach(             i -&gt; System.out.print( i + &quot; &quot; ) );        System.out.println();    }}</code></pre><p>上面的代码片段使用了parallelSetAll()方法来对一个有20000个元素的数组进行随机赋值。然后，调用parallelSort方法。这个程序首先打印出前10个元素的值，之后对整个数组排序。这个程序在控制台上的输出如下（请注意数组元素是随机生产的）：</p><pre><code>Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793</code></pre><h4 id="4-7-并发（Concurrency）"><a href="#4-7-并发（Concurrency）" class="headerlink" title="4.7 并发（Concurrency）"></a>4.7 并发（Concurrency）</h4><p>在新增Stream机制与lambda的基础之上，在java.util.concurrent.ConcurrentHashMap中加入了一些新方法来支持聚集操作。同时也在java.util.concurrent.ForkJoinPool类中加入了一些新方法来支持共有资源池（common pool）（请查看<a href="http://academy.javacodegeeks.com/course/java-concurrency-essentials/" target="_blank" rel="noopener">我们关于Java 并发的免费课程</a>）。</p><p>新增的java.util.concurrent.locks.StampedLock类提供一直基于容量的锁，这种锁有三个模型来控制读写操作（它被认为是不太有名的java.util.concurrent.locks.ReadWriteLock类的替代者）。</p><p>在java.util.concurrent.atomic包中还增加了下面这些类：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h3 id="5-新的Java工具"><a href="#5-新的Java工具" class="headerlink" title="5. 新的Java工具"></a>5. 新的Java工具</h3><p>Java 8也带来了一些新的命令行工具。在这节里我们将会介绍它们中最有趣的部分。</p><h4 id="5-1-Nashorn引擎-jjs"><a href="#5-1-Nashorn引擎-jjs" class="headerlink" title="5.1 Nashorn引擎: jjs"></a>5.1 Nashorn引擎: jjs</h4><p>jjs是个基于Nashorn引擎的命令行工具。它接受一些JavaScript源代码为参数，并且执行这些源代码。例如，我们创建一个具有如下内容的func.js文件：</p><pre><code>function f() {      return 1; }; print( f() + 1 );</code></pre><p>我们可以把这个文件作为参数传递给jjs使得这个文件可以在命令行中执行：</p><pre><code>jjs func.js</code></pre><p>下面是程序在控制台上的输出：</p><pre><code>2</code></pre><p>更多详情请参考<a href="http://docs.oracle.com/javase/8/docs/technotes/tools/unix/jjs.html" target="_blank" rel="noopener">官方文档</a></p><h4 id="5-2-类依赖分析器jdeps"><a href="#5-2-类依赖分析器jdeps" class="headerlink" title="5.2 类依赖分析器jdeps"></a>5.2 类依赖分析器jdeps</h4><p>jdeps是一个很有用的命令行工具。它可以显示Java类的包级别或类级别的依赖。它接受一个.class文件，一个目录，或者一个jar文件作为输入。jdeps默认把结果输出到系统输出（控制台）上。</p><p>下面我们查看现阶段较流行的<a href="http://projects.spring.io/spring-framework/" target="_blank" rel="noopener">Spring框架</a>类库的依赖报告，为了简化这个例子，我们只分析一个jar文件：<strong>org.springframework.core-3.0.5.RELEASE.jar</strong></p><p>这个命令输出的内容很多，所以这里我们只选取一小部分。依赖信息按照包名进行分组。如果依赖不在classpath中，那么就会显示<strong>not found</strong>。</p><pre><code>org.springframework.core-3.0.5.RELEASE.jar -&gt; C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)      -&gt; java.io                                                  -&gt; java.lang                                                -&gt; java.lang.annotation                                     -&gt; java.lang.ref                                            -&gt; java.lang.reflect                                        -&gt; java.util                                                -&gt; java.util.concurrent                                     -&gt; org.apache.commons.logging                         not found      -&gt; org.springframework.asm                            not found      -&gt; org.springframework.asm.commons                    not found   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)      -&gt; java.lang                                                -&gt; java.lang.annotation                                     -&gt; java.lang.reflect                                        -&gt; java.util</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识VueJs</title>
      <link href="/2017/03/23/%E5%88%9D%E8%AF%86VueJs/"/>
      <url>/2017/03/23/%E5%88%9D%E8%AF%86VueJs/</url>
      
        <content type="html"><![CDATA[<h5 id="MVVM模式"><a href="#MVVM模式" class="headerlink" title="MVVM模式"></a>MVVM模式</h5><p><strong>ViewModel是Vue.js的核心，它是一个Vue实例。</strong>Vue实例是作用于某一个HTML元素上的，这个元素可以是HTML的body元素，也可以是指定了id的某个元素。</p><p>当创建了ViewModel后，双向绑定是如何达成的呢？</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/4c7de75e-e946-4424-8461-2e5585c4bd42.png" alt="img"></p><a id="more"></a><p>首先，我们将上图中的DOM Listeners和Data Bindings看作两个工具，它们是实现双向绑定的关键。从View侧看，ViewModel中的DOM Listeners工具会帮我们监测页面上DOM元素的变化，如果有变化，则更改Model中的数据；从Model侧看，当我们更新Model中的数据时，Data Bindings工具会帮我们更新页面中的DOM元素。</p><p>Demo代码</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;!--这是我们的View--&gt;        &lt;div id=&quot;app&quot;&gt;            {{ message }}        &lt;/div&gt;    &lt;/body&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        // 这是我们的Model        var exampleData = {            message: &#39;Hello World!&#39;        }        // 创建一个 Vue 实例或 &quot;ViewModel&quot;        // 它连接 View 与 Model        new Vue({            el: &#39;#app&#39;,            data: exampleData        })    &lt;/script&gt;&lt;/html&gt;</code></pre><p>使用Vue的过程就是定义MVVM各个组成部分的过程的过程。</p><ol><li><strong>定义View</strong></li><li><strong>定义Model</strong></li><li><strong>创建一个Vue实例或”ViewModel”，它用于连接View和Model</strong></li></ol><p>在创建Vue实例时，需要传入一个<strong>选项对象</strong>，选项对象可以包含数据、挂载元素、方法、模生命周期钩子等等。</p><p>在这个示例中，<strong>选项对象</strong>的<strong>el属性</strong>指向View，el: ‘#app’ 表示该Vue实例将挂载到 …这个元素；<strong>data属性</strong>指向Model，data: exampleData`表示我们的Model是exampleData对象。Vue.js有多种数据绑定的语法，最基础的形式是文本插值，使用一对大括号语法，在运行时会被数据对象的message属性替换，所以页面上会输出”Hello World!”。</p><p>Vue.js已经更新到2.0版本了，但由于还不是正式版，本文的代码都是1.0.25版本的。</p><h3 id="双向绑定示例"><a href="#双向绑定示例" class="headerlink" title="双向绑定示例"></a>双向绑定示例</h3><p>MVVM模式本身是实现了双向绑定的，在Vue.js中可以使用<code>v-model</code>指令在表单元素上创建双向数据绑定。</p><pre><code>&lt;!--这是我们的View--&gt;&lt;div id=&quot;app&quot;&gt;    &lt;p&gt;{{ message }}&lt;/p&gt;    &lt;input type=&quot;text&quot; v-model=&quot;message&quot;/&gt;&lt;/div&gt;</code></pre><p>将message绑定到文本框，当更改文本框的值时， 中的内容也会被更新。</p><p>Vue实例的data属性指向exampleData，它是一个引用类型，改变了exampleData对象的属性，同时也会影响Vue实例的data属性。</p><p>Vue.js的常用指令</p><p>Vue.js提供了一些常用的内置指令，接下来我们将介绍以下几个内置指令：</p><ul><li>v-if指令</li><li>v-show指令</li><li>v-else指令</li><li>v-for指令</li><li>v-bind指令</li><li>v-on指令</li></ul><p>Vue.js具有良好的扩展性，我们也可以开发一些自定义的指令</p><p>v-if 指令</p><p><code>v-if</code>是条件渲染指令，它根据表达式的真假来删除和插入元素，它的基本语法如下：</p><pre><code>v-if=&quot;expression&quot;</code></pre><p>expression是一个返回bool值的表达式，表达式可以是一个bool属性，也可以是一个返回bool的运算式。例如：</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt;            &lt;h1 v-if=&quot;yes&quot;&gt;Yes!&lt;/h1&gt;            &lt;h1 v-if=&quot;no&quot;&gt;No!&lt;/h1&gt;            &lt;h1 v-if=&quot;age &gt;= 25&quot;&gt;Age: {{ age }}&lt;/h1&gt;            &lt;h1 v-if=&quot;name.indexOf(&#39;jack&#39;) &gt;= 0&quot;&gt;Name: {{ name }}&lt;/h1&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;                var vm = new Vue({            el: &#39;#app&#39;,            data: {                yes: true,                no: false,                age: 28,                name: &#39;keepfool&#39;            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre><h2 id="v-show指令"><a href="#v-show指令" class="headerlink" title="v-show指令"></a>v-show指令</h2><p><code>v-show</code>也是条件渲染指令，和v-if指令不同的是，使用<code>v-show</code>指令的元素始终会被渲染到HTML，它只是简单地为元素设置CSS的style属性。</p><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;    &lt;head&gt;        &lt;meta charset=&quot;UTF-8&quot;&gt;        &lt;title&gt;&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;div id=&quot;app&quot;&gt;            &lt;h1&gt;Hello, Vue.js!&lt;/h1&gt;            &lt;h1 v-show=&quot;yes&quot;&gt;Yes!&lt;/h1&gt;            &lt;h1 v-show=&quot;no&quot;&gt;No!&lt;/h1&gt;            &lt;h1 v-show=&quot;age &gt;= 25&quot;&gt;Age: {{ age }}&lt;/h1&gt;            &lt;h1 v-show=&quot;name.indexOf(&#39;jack&#39;) &gt;= 0&quot;&gt;Name: {{ name }}&lt;/h1&gt;        &lt;/div&gt;    &lt;/body&gt;    &lt;script src=&quot;js/vue.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var vm = new Vue({            el: &#39;#app&#39;,            data: {                yes: true,                no: false,                age: 28,                name: &#39;keepfool&#39;            }        })    &lt;/script&gt;&lt;/html&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA利用HttpClient进行post get请求(HTTPS)</title>
      <link href="/2017/03/21/JAVA%E5%88%A9%E7%94%A8HttpClient%E8%BF%9B%E8%A1%8Cpost-get%E8%AF%B7%E6%B1%82-HTTPS/"/>
      <url>/2017/03/21/JAVA%E5%88%A9%E7%94%A8HttpClient%E8%BF%9B%E8%A1%8Cpost-get%E8%AF%B7%E6%B1%82-HTTPS/</url>
      
        <content type="html"><![CDATA[<p><a href="http://blog.csdn.net/rongyongfeikai2/article/details/41659353" target="_blank" rel="noopener">JAVA利用HttpClient进行POST请求（HTTPS）</a></p><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><p>用HttpClient包进行请求，同时由于请求的URL是HTTPS的，为了避免需要证书，所以用一个类继承DefaultHttpClient类，忽略校验过程。</p><a id="more"></a><p>写一个SSLClient类,继承至HttpClient</p><pre><code>import java.security.cert.CertificateException;  import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext;  import javax.net.ssl.TrustManager;  import javax.net.ssl.X509TrustManager;  import org.apache.http.conn.ClientConnectionManager;  import org.apache.http.conn.scheme.Scheme;  import org.apache.http.conn.scheme.SchemeRegistry;  import org.apache.http.conn.ssl.SSLSocketFactory;  import org.apache.http.impl.client.DefaultHttpClient;  //用于进行Https请求的HttpClient  public class SSLClient extends DefaultHttpClient{      public SSLClient() throws Exception{          super();          SSLContext ctx = SSLContext.getInstance(&quot;TLS&quot;);          X509TrustManager tm = new X509TrustManager() {                  @Override                  public void checkClientTrusted(X509Certificate[] chain,                          String authType) throws CertificateException {                  }                  @Override                  public void checkServerTrusted(X509Certificate[] chain,                          String authType) throws CertificateException {                  }                  @Override                  public X509Certificate[] getAcceptedIssuers() {                      return null;                  }          };          ctx.init(null, new TrustManager[]{tm}, null);          SSLSocketFactory ssf = new SSLSocketFactory(ctx,SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);          ClientConnectionManager ccm = this.getConnectionManager();          SchemeRegistry sr = ccm.getSchemeRegistry();          sr.register(new Scheme(&quot;https&quot;, 443, ssf));      }  }  </code></pre><h4 id><a href="#" class="headerlink" title=" "></a> </h4><h4 id="写一个利用HttpClient发送post请求的类"><a href="#写一个利用HttpClient发送post请求的类" class="headerlink" title="写一个利用HttpClient发送post请求的类"></a>写一个利用HttpClient发送post请求的类</h4><pre><code>import java.util.ArrayList;  import java.util.Iterator;  import java.util.List;  import java.util.Map;  import java.util.Map.Entry;  import org.apache.http.HttpEntity;  import org.apache.http.HttpResponse;  import org.apache.http.NameValuePair;  import org.apache.http.client.HttpClient;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.util.EntityUtils;  /*  * 利用HttpClient进行post请求的工具类,键值对方式组装数据  */  public class HttpClientUtil {      public String doPost(String url,Map&lt;String,String&gt; map,String charset){          HttpClient httpClient = null;          HttpPost httpPost = null;          String result = null;          try{              httpClient = new SSLClient();              httpPost = new HttpPost(url);              //设置参数              List&lt;NameValuePair&gt; list = new ArrayList&lt;NameValuePair&gt;();              Iterator iterator = map.entrySet().iterator();              while(iterator.hasNext()){                  Entry&lt;String,String&gt; elem = (Entry&lt;String, String&gt;) iterator.next();                  list.add(new BasicNameValuePair(elem.getKey(),elem.getValue()));              }              if(list.size() &gt; 0){                  UrlEncodedFormEntity entity = new UrlEncodedFormEntity(list,charset);                  httpPost.setEntity(entity);              }              HttpResponse response = httpClient.execute(httpPost);              if(response != null){                  HttpEntity resEntity = response.getEntity();                  if(resEntity != null){                      result = EntityUtils.toString(resEntity,charset);                  }              }          }catch(Exception ex){              ex.printStackTrace();          }          return result;      }  }  </code></pre><h4 id="写一个利用HttpClient发送post请求的类-数据以from-表单的方式提交"><a href="#写一个利用HttpClient发送post请求的类-数据以from-表单的方式提交" class="headerlink" title="写一个利用HttpClient发送post请求的类 ,数据以from 表单的方式提交"></a>写一个利用HttpClient发送post请求的类 ,数据以from 表单的方式提交</h4><pre><code>package com.ly.flight.suppliercore.biz.common.util;import org.apache.http.HttpEntity;import org.apache.http.HttpResponse;import org.apache.http.client.HttpClient;import org.apache.http.client.methods.HttpPost;import org.apache.http.entity.StringEntity;import org.apache.http.util.EntityUtils;/*  * 利用HttpClient进行post请求的工具类  */public class HttpClientUtil {    public String doPost(String url, String data) {        HttpClient httpClient = null;        HttpPost httpPost = null;        String result = null;        try {            httpClient = new SSLClient();            httpPost = new HttpPost(url);            HttpEntity httpEntity=new StringEntity(data);            httpPost.setEntity(httpEntity);            httpPost.setHeader(&quot;Content-Type&quot;,&quot;application/x-www-form-urlencoded;charset=utf-8&quot;);            HttpResponse response = httpClient.execute(httpPost);            if (response != null) {                HttpEntity resEntity = response.getEntity();                if (resEntity != null) {                    result = EntityUtils.toString(resEntity);                }            }        } catch (Exception ex) {            ex.printStackTrace();        }        return result;    }}</code></pre><h4 id="调用Post请求的测试代码"><a href="#调用Post请求的测试代码" class="headerlink" title="调用Post请求的测试代码"></a>调用Post请求的测试代码</h4><pre><code>import java.util.HashMap;  import java.util.Map;  //对接口进行测试  public class TestMain {      private String url = &quot;https://192.168.1.101/&quot;;      private String charset = &quot;utf-8&quot;;      private HttpClientUtil httpClientUtil = null;      public TestMain(){          httpClientUtil = new HttpClientUtil();      }      public void test(){          String httpOrgCreateTest = url + &quot;httpOrg/create&quot;;          Map&lt;String,String&gt; createMap = new HashMap&lt;String,String&gt;();          createMap.put(&quot;authuser&quot;,&quot;*****&quot;);          createMap.put(&quot;authpass&quot;,&quot;*****&quot;);          createMap.put(&quot;orgkey&quot;,&quot;****&quot;);          createMap.put(&quot;orgname&quot;,&quot;****&quot;);          String httpOrgCreateTestRtn = httpClientUtil.doPost(httpOrgCreateTest,createMap,charset);          System.out.println(&quot;result:&quot;+httpOrgCreateTestRtn);      }      public static void main(String[] args){          TestMain main = new TestMain();          main.test();      }  }  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库分页详解</title>
      <link href="/2017/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/03/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E9%A1%B5%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>数据库分页详解,包含mysql sqlserver oracle等主流数据库</p><a id="more"></a><p>Mysql 与SqlServer 数据库分页</p><h4 id="Mysql数据库分页查询"><a href="#Mysql数据库分页查询" class="headerlink" title="Mysql数据库分页查询"></a>Mysql数据库分页查询</h4><p>Mysql的limit用法</p><p>​     在我们使用查询语句的时候，经常要返回前几条或者中间某几行数据，这个时候怎么办呢？不用担心，<a href="http://www.blogjava.net/yemen/articles/229521.html" target="_blank" rel="noopener"><strong>mysql</strong></a>已经为我们提供了这样一个功能。</p><p>sql代码</p><pre><code>SELECT * FROM table LIMIT [offset,] rows | rows OFFSET offset  </code></pre><p>​    LIMIT 子句可以被用于强制 SELECT 语句返回指定的记录数。LIMIT 接受一个或两个数字参数。参数必须是一个整数常量。如果给定两个参数，第一个参数指定第一个返回记录行的偏移量，第二个参数指定返回记录行的最大数目。初始记录行的偏移量是 0(而不是 1)： 为了与 PostgreSQL 兼容，MySQL 也支持句法： LIMIT # OFFSET #</p><p>sql代码</p><pre><code>mysql&gt; SELECT * FROM table LIMIT 5,10; // 检索记录行 6-15  //为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为 -1：   mysql&gt; SELECT * FROM table LIMIT 95,-1; // 检索记录行 96-last.  //如果只给定一个参数，它表示返回最大的记录行数目：   mysql&gt; SELECT * FROM table LIMIT 5; //检索前 5 个记录行  //换句话说，LIMIT n 等价于 LIMIT 0,n。  </code></pre><h4 id="分页语句性能分析"><a href="#分页语句性能分析" class="headerlink" title="分页语句性能分析"></a>分页语句性能分析</h4><p>sql代码 (最基本的分页方式)</p><pre><code>SELECT ... FROM ... WHERE ... ORDER BY ... LIMIT ...  </code></pre><p>​          在中小数据量的情况下，这样的SQL足够用了，唯一需要注意的问题就是确保使用了索引：举例来说，如果实际SQL类似下面语句，那么在category_id, id两列上建立复合索引比较好：</p><p>sql代码</p><pre><code>SELECT * FROM articles WHERE category_id = 123 ORDER BY id LIMIT 50, 10  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HttpClient 发送get post请求和数据解析及详解</title>
      <link href="/2017/02/21/HttpClient-%E5%8F%91%E9%80%81get-post%E8%AF%B7%E6%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E8%AF%A6%E8%A7%A3/"/>
      <url>/2017/02/21/HttpClient-%E5%8F%91%E9%80%81get-post%E8%AF%B7%E6%B1%82%E5%92%8C%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90%E5%8F%8A%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>HttpClient 发送get post 请求和数据解析以及使用详解</p><p>HttpClient相比传统JDK自带的URLConnection，增加了易用性和灵活性（具体区别，日后我们再讨论），它不仅是客户端发送Http请求变得容易，而且也方便了开发人员<a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">测试</a>接口（基于Http协议的），即提高了开发的效率，也方便提高代码的健壮性。因此熟练掌握HttpClient是很重要的必修内容，掌握HttpClient后，相信对于Http协议的了解会更加深入。</p><a id="more"></a><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>HttpClient是Apache Jakarta Common下的子项目，用来提供高效的、最新的、功能丰富的支持HTTP协议的客户端编程工具包，并且它支持HTTP协议最新的版本和建议。HttpClient已经应用在很多的项目中，比如Apache Jakarta上很著名的另外两个开源项目Cactus和HTMLUnit都使用了HttpClient。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>基于标准、纯净的<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>语言。实现了Http1.0和Http1.1</li></ul><ul><li>以可扩展的面向对象的结构实现了Http全部的方法（GET, POST, PUT, DELETE, HEAD, OPTIONS, and TRACE）。</li><li>支持HTTPS协议。</li><li>通过Http代理建立透明的连接。</li><li>利用CONNECT方法通过Http代理建立隧道的https连接。</li><li>Basic, Digest, NTLMv1, NTLMv2, NTLM2 Session, SNPNEGO/Kerberos认证方案。</li><li>插件式的自定义认证方案。</li><li>便携可靠的套接字工厂使它更容易的使用第三方解决方案。</li><li>连接管理器支持多线程应用。支持设置最大连接数，同时支持设置每个主机的最大连接数，发现并关闭过期的连接。</li><li>自动处理Set-Cookie中的Cookie。</li><li>插件式的自定义Cookie策略。</li><li>Request的输出流可以避免流中内容直接缓冲到socket服务器。</li><li>Response的输入流可以有效的从socket服务器直接读取相应内容。</li><li>在http1.0和http1.1中利用KeepAlive保持持久连接。</li><li>直接获取服务器发送的response code和 headers。</li><li>设置连接超时的能力。</li><li>实验性的支持http1.1 response caching。</li><li>源代码基于Apache License 可免费获取。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>使用HttpClient 发送请求</p><ul><li>创建HttpClient 对象</li><li>创建请求方法的实例,并指定请求的URL,如果需要发送GET请求,创建HttpGet对象,如果需要发送POST请求,创建HttpPost对象。</li><li>如果需要发送请求参数,可调用HttpGet、HttpPost 共同的setParams(HttpParams params) 方法来添加请求参数,对于HttpPost对象而言,也可以调用setEntity(HttpEntity entity)方法来设置请求参数。</li><li>调用HttpClient对象的execute(HttpUriRequest request)发送请求,该方法返回一个HttpResponse.</li><li>调用HttpResponse的getAllHeader()、getHeaders(String name)等方法可以获取服务器的响应头,调用HttpResponse的getEntity()方法可以获取HttpEntity对象,该对象包装了服务器的响应内容，程序可通过该对象获取服务器响应的内容</li><li>释放连接,无论执行方法是否成功，都必须释放连接。</li></ul><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><pre><code>package com.ly.flight.suppliercore;/** *  *  * @author gh43690 * @version $Id: HttpClientTest.java, v 0.1 2017年3月21日 下午3:21:47 gh43690 Exp $ */import java.io.IOException;import org.apache.http.HttpEntity;import org.apache.http.ParseException;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.methods.CloseableHttpResponse;import org.apache.http.client.methods.HttpGet;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.util.EntityUtils;import org.junit.Test;public class HttpClientTest {    @Test    public void jUnitTest() {        httpGet();    }    //get方法    public void httpGet() {        CloseableHttpClient httpClient = HttpClients.createDefault();        try {            //创建httpGet            HttpGet httpGet = new HttpGet(&quot;http://www.baidu.com&quot;);            System.out.println(&quot;executing request&quot; + httpGet.getURI());            //执行get请求            CloseableHttpResponse response = httpClient.execute(httpGet);            try {                //获取响应实体                HttpEntity entity = response.getEntity();                System.out.println(&quot;-------------------&quot;);                //打印响应状态                System.out.println(response.getStatusLine());                if (entity != null) {                    System.out.println(&quot;Response content length&quot; + entity.getContentLength());                    //打印响应内容                    System.out.println(&quot;Response content&quot; + EntityUtils.toString(entity));                    //打印响应头                    System.out.println(&quot;Response content&quot; + entity.getContent());                    System.out.println(&quot;Response Contentype&quot; + entity.getContentType());                    System.out.println(&quot;Response ContenEncoding&quot; + entity.getContentEncoding());                }                System.out.println(&quot;--------------&quot;);            } finally {                response.close();            }        } catch (ClientProtocolException e) {            e.printStackTrace();        } catch (ParseException e) {            e.printStackTrace();        } catch (IOException e) {            e.printStackTrace();        } finally {            //关闭连接，释放资源            try {                httpClient.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}//Post 提交方式 发送 post请求访问本地应用并根据传递参数不同返回不同结果  public void doPost(){        CloseableHttpClient httpClient = HttpClients.createDefault();        HttpPost httpPost = new HttpPost(&quot;http://www.baidu.com&quot;);        //创建参数队列        List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;();        formparams.add(new BasicNameValuePair(&quot;type&quot;, &quot;house&quot;));        UrlEncodedFormEntity uefEnetity;        try {            uefEnetity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);            httpPost.setEntity(uefEnetity);            System.out.println(&quot;executing request&quot;+httpPost.getURI());            CloseableHttpResponse response = httpClient.execute(httpPost);          try {             HttpEntity entity = response.getEntity();             if(entity != null){                 System.out.println(&quot;-------------------&quot;);                 System.out.println(&quot;Response contentlength&quot;+entity.getContentLength());                 System.out.println(&quot;Response Content&quot;+EntityUtils.toString(entity));                 System.out.println(&quot;--------------------&quot;);             }        }           finally {            response.close();        }        }          catch (ClientProtocolException e) {            e.printStackTrace();        }       catch (UnsupportedEncodingException e1) {            e1.printStackTrace();        }        catch (IOException e) {          e.printStackTrace();        }        finally{            //关闭连接释放资源            try {                httpClient.close();            } catch (Exception e) {                e.printStackTrace();            }        }    }     /**      * post方式提交表单（模拟用户登录请求）      */      public void postForm() {          // 创建默认的httpClient实例.            CloseableHttpClient httpclient = HttpClients.createDefault();          // 创建httppost            HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceJ.action&quot;);          // 创建参数队列            List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;();          formparams.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;));          formparams.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;));          UrlEncodedFormEntity uefEntity;          try {              uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);              httppost.setEntity(uefEntity);              System.out.println(&quot;executing request &quot; + httppost.getURI());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  HttpEntity entity = response.getEntity();                  if (entity != null) {                      System.out.println(&quot;--------------------------------------&quot;);                      System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity, &quot;UTF-8&quot;));                      System.out.println(&quot;--------------------------------------&quot;);                  }              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (UnsupportedEncodingException e1) {              e1.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              // 关闭连接,释放资源                try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }      /**      * 上传文件      */      public void upload() {          CloseableHttpClient httpclient = HttpClients.createDefault();          try {              HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceFile.action&quot;);              FileBody bin = new FileBody(new File(&quot;F:\\image\\sendpix0.jpg&quot;));              StringBody comment = new StringBody(&quot;A binary file of some kind&quot;, ContentType.TEXT_PLAIN);              HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(&quot;bin&quot;, bin).addPart(&quot;comment&quot;, comment).build();              httppost.setEntity(reqEntity);              System.out.println(&quot;executing request &quot; + httppost.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  HttpEntity resEntity = response.getEntity();                  if (resEntity != null) {                      System.out.println(&quot;Response content length: &quot; + resEntity.getContentLength());                  }                  EntityUtils.consume(resEntity);              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }  }</code></pre><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><pre><code>import java.io.File;  import java.io.FileInputStream;  import java.io.IOException;  import java.io.UnsupportedEncodingException;  import java.security.KeyManagementException;  import java.security.KeyStore;  import java.security.KeyStoreException;  import java.security.NoSuchAlgorithmException;  import java.security.cert.CertificateException;  import java.util.ArrayList;  import java.util.List;  import javax.net.ssl.SSLContext;  import org.apache.http.HttpEntity;  import org.apache.http.NameValuePair;  import org.apache.http.ParseException;  import org.apache.http.client.ClientProtocolException;  import org.apache.http.client.entity.UrlEncodedFormEntity;  import org.apache.http.client.methods.CloseableHttpResponse;  import org.apache.http.client.methods.HttpGet;  import org.apache.http.client.methods.HttpPost;  import org.apache.http.conn.ssl.SSLConnectionSocketFactory;  import org.apache.http.conn.ssl.SSLContexts;  import org.apache.http.conn.ssl.TrustSelfSignedStrategy;  import org.apache.http.entity.ContentType;  import org.apache.http.entity.mime.MultipartEntityBuilder;  import org.apache.http.entity.mime.content.FileBody;  import org.apache.http.entity.mime.content.StringBody;  import org.apache.http.impl.client.CloseableHttpClient;  import org.apache.http.impl.client.HttpClients;  import org.apache.http.message.BasicNameValuePair;  import org.apache.http.util.EntityUtils;  import org.junit.Test;  public class HttpClientTest {      @Test      public void jUnitTest() {          get();      }      /**      * HttpClient连接SSL      */      public void ssl() {          CloseableHttpClient httpclient = null;          try {              KeyStore trustStore = KeyStore.getInstance(KeyStore.getDefaultType());              FileInputStream instream = new FileInputStream(new File(&quot;d:\\tomcat.keystore&quot;));              try {                  // 加载keyStore d:\\tomcat.keystore                    trustStore.load(instream, &quot;123456&quot;.toCharArray());              } catch (CertificateException e) {                  e.printStackTrace();              } finally {                  try {                      instream.close();                  } catch (Exception ignore) {                  }              }              // 相信自己的CA和所有自签名的证书              SSLContext sslcontext = SSLContexts.custom().loadTrustMaterial(trustStore, new TrustSelfSignedStrategy()).build();              // 只允许使用TLSv1协议              SSLConnectionSocketFactory sslsf = new SSLConnectionSocketFactory(sslcontext, new String[] { &quot;TLSv1&quot; }, null,                      SSLConnectionSocketFactory.BROWSER_COMPATIBLE_HOSTNAME_VERIFIER);              httpclient = HttpClients.custom().setSSLSocketFactory(sslsf).build();              // 创建http请求(get方式)              HttpGet httpget = new HttpGet(&quot;https://localhost:8443/myDemo/Ajax/serivceJ.action&quot;);              System.out.println(&quot;executing request&quot; + httpget.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httpget);              try {                  HttpEntity entity = response.getEntity();                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  if (entity != null) {                      System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                      System.out.println(EntityUtils.toString(entity));                      EntityUtils.consume(entity);                  }              } finally {                  response.close();              }          } catch (ParseException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } catch (KeyManagementException e) {              e.printStackTrace();          } catch (NoSuchAlgorithmException e) {              e.printStackTrace();          } catch (KeyStoreException e) {              e.printStackTrace();          } finally {              if (httpclient != null) {                  try {                      httpclient.close();                  } catch (IOException e) {                      e.printStackTrace();                  }              }          }      }      /**      * post方式提交表单（模拟用户登录请求）      */      public void postForm() {          // 创建默认的httpClient实例.            CloseableHttpClient httpclient = HttpClients.createDefault();          // 创建httppost            HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceJ.action&quot;);          // 创建参数队列            List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;();          formparams.add(new BasicNameValuePair(&quot;username&quot;, &quot;admin&quot;));          formparams.add(new BasicNameValuePair(&quot;password&quot;, &quot;123456&quot;));          UrlEncodedFormEntity uefEntity;          try {              uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);              httppost.setEntity(uefEntity);              System.out.println(&quot;executing request &quot; + httppost.getURI());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  HttpEntity entity = response.getEntity();                  if (entity != null) {                      System.out.println(&quot;--------------------------------------&quot;);                      System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity, &quot;UTF-8&quot;));                      System.out.println(&quot;--------------------------------------&quot;);                  }              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (UnsupportedEncodingException e1) {              e1.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              // 关闭连接,释放资源                try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }      /**      * 发送 post请求访问本地应用并根据传递参数不同返回不同结果      */      public void post() {          // 创建默认的httpClient实例.            CloseableHttpClient httpclient = HttpClients.createDefault();          // 创建httppost            HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceJ.action&quot;);          // 创建参数队列            List&lt;namevaluepair&gt; formparams = new ArrayList&lt;namevaluepair&gt;();          formparams.add(new BasicNameValuePair(&quot;type&quot;, &quot;house&quot;));          UrlEncodedFormEntity uefEntity;          try {              uefEntity = new UrlEncodedFormEntity(formparams, &quot;UTF-8&quot;);              httppost.setEntity(uefEntity);              System.out.println(&quot;executing request &quot; + httppost.getURI());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  HttpEntity entity = response.getEntity();                  if (entity != null) {                      System.out.println(&quot;--------------------------------------&quot;);                      System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity, &quot;UTF-8&quot;));                      System.out.println(&quot;--------------------------------------&quot;);                  }              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (UnsupportedEncodingException e1) {              e1.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              // 关闭连接,释放资源                try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }      /**      * 发送 get请求      */      public void get() {          CloseableHttpClient httpclient = HttpClients.createDefault();          try {              // 创建httpget.                HttpGet httpget = new HttpGet(&quot;http://www.baidu.com/&quot;);              System.out.println(&quot;executing request &quot; + httpget.getURI());              // 执行get请求.                CloseableHttpResponse response = httpclient.execute(httpget);              try {                  // 获取响应实体                    HttpEntity entity = response.getEntity();                  System.out.println(&quot;--------------------------------------&quot;);                  // 打印响应状态                    System.out.println(response.getStatusLine());                  if (entity != null) {                      // 打印响应内容长度                        System.out.println(&quot;Response content length: &quot; + entity.getContentLength());                      // 打印响应内容                        System.out.println(&quot;Response content: &quot; + EntityUtils.toString(entity));                  }                  System.out.println(&quot;------------------------------------&quot;);              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (ParseException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              // 关闭连接,释放资源                try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }      /**      * 上传文件      */      public void upload() {          CloseableHttpClient httpclient = HttpClients.createDefault();          try {              HttpPost httppost = new HttpPost(&quot;http://localhost:8080/myDemo/Ajax/serivceFile.action&quot;);              FileBody bin = new FileBody(new File(&quot;F:\\image\\sendpix0.jpg&quot;));              StringBody comment = new StringBody(&quot;A binary file of some kind&quot;, ContentType.TEXT_PLAIN);              HttpEntity reqEntity = MultipartEntityBuilder.create().addPart(&quot;bin&quot;, bin).addPart(&quot;comment&quot;, comment).build();              httppost.setEntity(reqEntity);              System.out.println(&quot;executing request &quot; + httppost.getRequestLine());              CloseableHttpResponse response = httpclient.execute(httppost);              try {                  System.out.println(&quot;----------------------------------------&quot;);                  System.out.println(response.getStatusLine());                  HttpEntity resEntity = response.getEntity();                  if (resEntity != null) {                      System.out.println(&quot;Response content length: &quot; + resEntity.getContentLength());                  }                  EntityUtils.consume(resEntity);              } finally {                  response.close();              }          } catch (ClientProtocolException e) {              e.printStackTrace();          } catch (IOException e) {              e.printStackTrace();          } finally {              try {                  httpclient.close();              } catch (IOException e) {                  e.printStackTrace();              }          }      }  }&lt;/namevaluepair&gt;&lt;/namevaluepair&gt;&lt;/namevaluepair&gt;&lt;/namevaluepair&gt;  </code></pre>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse-Tomcat-远程端口调试</title>
      <link href="/2016/12/27/Eclipse-Tomcat-%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%B0%83%E8%AF%95/"/>
      <url>/2016/12/27/Eclipse-Tomcat-%E8%BF%9C%E7%A8%8B%E7%AB%AF%E5%8F%A3%E8%B0%83%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>Eclipse不仅可以调试本地代码，也可以远程调试部署在服务器上的项目代码，这点在调试本地无法重现的问题上意义尤为重大。<br><strong>Window中修改 startup.bat文件，添加：</strong><br><a id="more"></a></p><pre><code>SET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8005 //可不添加echo tomcat ready to debug address 8055SET JAVA_OPTS=%JAVA_OPTS% -Dfile.encoding=UTF-8</code></pre><h5 id="参数说明："><a href="#参数说明：" class="headerlink" title="参数说明："></a>参数说明：</h5><p>-Xdebug                              ： 启用调试模式</p><p>-Xrunjdwp<sub-options>  : 加载JVM的JPDA参考实现库</sub-options></p><p>transport=dt_socket           ：Socket连接，可选dt_shmem 通过共享内存的方式连接到调试服务器</p><p>address=8000                     ：调试服务器监听的端口</p><p>server=y                             ： 是否是服务器端，n为客户端</p><p>suspend=n                         ： 启动过程是否加载暂停，y为启动时暂停，方便调试启动过程</p><p><strong>启动tomcat，看看tomcat是否启动成功，</strong></p><p>如果启动成功，tomcat日志文件(catalina.out)中会有如下输出：</p><p>Listening for transport dt_socket at address: 8000</p><p><strong>使用eclipse调试：</strong></p><p><img src="http://ogx75f0xj.bkt.clouddn.com/20130703190215906.png" alt></p><p><img src="http://ogx75f0xj.bkt.clouddn.com/20130703190253421.png" alt></p><p>点击debug，就可进行调试了</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/20130703190326031.png" alt></p><p>剩下的就和普通调试一样了。断点直接在源代码中添加就行</p><p><strong>5、可能出现的连接问题：</strong></p><p>Failed to connect to remote VM. Connection refused.</p><p>Connection refused: connect。</p><p><img src="http://ogx75f0xj.bkt.clouddn.com/20130703190417750.png" alt></p><p>出现如图所示的情况可能是已经建立了一个连接了。</p><p>附件： startup.bat 源码</p><pre><code>@echo offrem Licensed to the Apache Software Foundation (ASF) under one or morerem contributor license agreements.  See the NOTICE file distributed withrem this work for additional information regarding copyright ownership.rem The ASF licenses this file to You under the Apache License, Version 2.0rem (the &quot;License&quot;); you may not use this file except in compliance withrem the License.  You may obtain a copy of the License atremrem     http://www.apache.org/licenses/LICENSE-2.0remrem Unless required by applicable law or agreed to in writing, softwarerem distributed under the License is distributed on an &quot;AS IS&quot; BASIS,rem WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.rem See the License for the specific language governing permissions andrem limitations under the License.rem ---------------------------------------------------------------------------rem Start script for the CATALINA Serverrem ---------------------------------------------------------------------------setlocalSET CATALINA_OPTS=-server -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=8005 echo tomcat ready to debug address 8055SET JAVA_OPTS=%JAVA_OPTS% -Dfile.encoding=UTF-8rem Guess CATALINA_HOME if not definedset &quot;CURRENT_DIR=%cd%&quot;if not &quot;%CATALINA_HOME%&quot; == &quot;&quot; goto gotHomeset &quot;CATALINA_HOME=%CURRENT_DIR%&quot;if exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHomecd ..set &quot;CATALINA_HOME=%cd%&quot;cd &quot;%CURRENT_DIR%&quot;:gotHomeif exist &quot;%CATALINA_HOME%\bin\catalina.bat&quot; goto okHomeecho The CATALINA_HOME environment variable is not defined correctlyecho This environment variable is needed to run this programgoto end:okHomeset &quot;EXECUTABLE=%CATALINA_HOME%\bin\catalina.bat&quot;rem Check that target executable existsif exist &quot;%EXECUTABLE%&quot; goto okExececho Cannot find &quot;%EXECUTABLE%&quot;echo This file is needed to run this programgoto end:okExecrem Get remaining unshifted command line arguments and save them in theset CMD_LINE_ARGS=:setArgsif &quot;&quot;%1&quot;&quot;==&quot;&quot;&quot;&quot; goto doneSetArgsset CMD_LINE_ARGS=%CMD_LINE_ARGS% %1shiftgoto setArgs:doneSetArgscall &quot;%EXECUTABLE%&quot; start %CMD_LINE_ARGS%:end</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅析VO、DTO、DO、PO的概念、区别和用处</title>
      <link href="/2016/12/23/%E6%B5%85%E6%9E%90VO%E3%80%81DTO%E3%80%81DO%E3%80%81PO%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E5%A4%84/"/>
      <url>/2016/12/23/%E6%B5%85%E6%9E%90VO%E3%80%81DTO%E3%80%81DO%E3%80%81PO%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E5%8C%BA%E5%88%AB%E5%92%8C%E7%94%A8%E5%A4%84/</url>
      
        <content type="html"><![CDATA[<h5 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h5><p>VO（View Object）：视图对象，用于展示层，它的作用是把某个指定页面（或组件）的所有数据封装起来。 </p><a id="more"></a><p>DTO（Data Transfer Object）：数据传输对象，这个概念来源于J2EE的设计模式，原来的目的是为了EJB的分布式应用提供粗粒度的数据实体，以减少分布式调用的次数，从而提高分布式调用的性能和降低网络负载，但在这里，我泛指用于展示层与服务层之间的数据传输对象。 </p><p>DO（Domain Object）：领域对象，就是从现实世界中抽象出来的有形或无形的业务实体。<br>PO（Persistent Object）：持久化对象，它跟持久层（通常是关系型<a href="http://lib.csdn.net/base/mysql" target="_blank" rel="noopener">数据库</a>）的<a href="http://lib.csdn.net/base/datastructure" target="_blank" rel="noopener">数据结构</a>形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段（或若干个）就对应PO的一个（或若干个）属性。</p><h5 id="VO-和TO的区别"><a href="#VO-和TO的区别" class="headerlink" title="VO 和TO的区别"></a>VO 和TO的区别</h5><p>大家可能会有个疑问（在笔者参与的项目中，很多程序员也有相同的疑惑）：既然DTO是展示层与服务层之间传递数据的对象，为什么还需要一个VO呢？对！对于绝大部分的应用场景来说，DTO和VO的属性值基本是一致的，而且他们通常都是POJO，因此没必要多此一举，但不要忘记这是实现层面的思维，对于设计层面来说，概念上还是应该存在VO和DTO，因为两者有着本质的区别，DTO代表服务层需要接收的数据和返回的数据，而VO代表展示层需要显示的数据。        用一个例子来说明可能会比较容易理解：例如服务层有一个getUser的方法返回一个系统用户，其中有一个属性是gender(性别)，对于服务层来说，它只从语义上定义：1-男性，2-女性，0-未指定，而对于展示层来说，它可能需要用“帅哥”代表男性，用“美女”代表女性，用“秘密”代表未指定。说到这里，可能你还会反驳，在服务层直接就返回“帅哥美女”不就行了吗？对于大部分应用来说，这不是问题，但设想一下，如果需求允许客户可以定制风格，而不同风格对于“性别”的表现方式不一样，又或者这个服务同时供多个客户端使用（不同门户），而不同的客户端对于表现层的要求有所不同，那么，问题就来了。再者，回到设计层面上分析，从职责单一原则来看，服务层只负责业务，与具体的表现形式无关，因此，它返回的DTO，不应该出现与表现形式的耦合。        理论归理论，这到底还是分析设计层面的思维，是否在实现层面必须这样做呢？一刀切的做法往往会得不偿失，下面我马上会分析应用中如何做出正确的选择。</p><h5 id="VO与DTO的应用"><a href="#VO与DTO的应用" class="headerlink" title="VO与DTO的应用"></a>VO与DTO的应用</h5><pre><code>   上面只是用了一个简单的例子来说明VO与DTO在概念上的区别，本节将会告诉你如何在应用中做出正确的选择。    在以下才场景中，我们可以考虑把VO与DTO二合为一（注意：是实现层面）： </code></pre><p>当需求非常清晰稳定，而且客户端很明确只有一个的时候，没有必要把VO和DTO区分开来，这时候VO可以退隐，用一个DTO即可，为什么是VO退隐而不是DTO？回到设计层面，服务层的职责依然不应该与展示层耦合，所以，对于前面的例子，你很容易理解，DTO对于“性别”来说，依然不能用“帅哥美女”，这个转换应该依赖于页面的脚本（如<a href="http://lib.csdn.net/base/javascript" target="_blank" rel="noopener">JavaScript</a>）或其他机制（JSTL、EL、CSS）<br>即使客户端可以进行定制，或者存在多个不同的客户端，如果客户端能够用某种技术（脚本或其他机制）实现转换，同样可以让VO退隐</p><p>以下场景需要优先考虑VO、DTO并存：<br>上述场景的反面场景<br>因为某种技术原因，比如某个框架（如Flex）提供自动把POJO转换为UI中某些Field时，可以考虑在实现层面定义出VO，这个权衡完全取决于使用框架的自动转换能力带来的开发和维护效率提升与设计多一个VO所多做的事情带来的开发和维护效率的下降之间的比对。<br>如果页面出现一个“大视图”，而组成这个大视图的所有数据需要调用多个服务，返回多个DTO来组装（当然，这同样可以通过服务层提供一次性返回一个大视图的DTO来取代，但在服务层提供一个这样的方法是否合适，需要在设计层面进行权衡）。</p><h5 id="DTO与DO的区别"><a href="#DTO与DO的区别" class="headerlink" title="DTO与DO的区别"></a>DTO与DO的区别</h5><pre><code> 首先是概念上的区别，DTO是展示层和服务层之间的数据传输对象（可以认为是两者之间的协议），而DO是对现实世界各种业务角色的抽象，这就引出了两者在数据上的区别，例如UserInfo和User（对于DTO和DO的命名规则，请参见笔者前面的一篇博文），对于一个getUser方法来说，本质上它永远不应该返回用户的密码，因此UserInfo至少比User少一个password的数据。而在领域驱动设计中，正如第一篇系列文章所说，DO不是简单的POJO，它具有领域业务逻辑。</code></pre><p>DTO与DO的应用<br>       从上一节的例子中，细心的读者可能会发现问题：既然getUser方法返回的UserInfo不应该包含password，那么就不应该存在password这个属性定义，但如果同时有一个createUser的方法，传入的UserInfo需要包含用户的password，怎么办？在设计层面，展示层向服务层传递的DTO与服务层返回给展示层的DTO在概念上是不同的，但在实现层面，我们通常很少会这样做（定义两个UserInfo，甚至更多），因为这样做并不见得很明智，我们完全可以设计一个完全兼容的DTO，在服务层接收数据的时候，不该由展示层设置的属性（如订单的总价应该由其单价、数量、折扣等决定），无论展示层是否设置，服务层都一概忽略，而在服务层返回数据时，不该返回的数据（如用户密码），就不设置对应的属性。<br>       对于DO来说，还有一点需要说明：为什么不在服务层中直接返回DO呢？这样可以省去DTO的编码和转换工作，原因如下：<br>两者在本质上的区别可能导致彼此并不一一对应，一个DTO可能对应多个DO，反之亦然，甚至两者存在多对多的关系。<br>DO具有一些不应该让展示层知道的数据<br>DO具有业务方法，如果直接把DO传递给展示层，展示层的代码就可以绕过服务层直接调用它不应该访问的操作，对于基于AOP拦截服务层来进行访问控制的机制来说，这问题尤为突出，而在展示层调用DO的业务方法也会因为事务的问题，让事务难以控制。<br>对于某些ORM框架（如<a href="http://lib.csdn.net/base/javaee" target="_blank" rel="noopener">hibernate</a>）来说，通常会使用“延迟加载”技术，如果直接把DO暴露给展示层，对于大部分情况，展示层不在事务范围之内（Open session in view在大部分情况下不是一种值得推崇的设计），如果其尝试在Session关闭的情况下获取一个未加载的关联对象，会出现运行时异常（对于Hibernate来说，就是LazyInitiliaztionException）。<br>从设计层面来说，展示层依赖于服务层，服务层依赖于领域层，如果把DO暴露出去，就会导致展示层直接依赖于领域层，这虽然依然是单向依赖，但这种跨层依赖会导致不必要的耦合。</p><p>对于DTO来说，也有一点必须进行说明，就是DTO应该是一个“扁平的二维对象”，举个例子来说明：如果User会关联若干个其他实体（例如Address、Account、Region等），那么getUser()返回的UserInfo，是否就需要把其关联的对象的DTO都一并返回呢？如果这样的话，必然导致数据传输量的大增，对于分布式应用来说，由于涉及数据在网络上的传输、序列化和反序列化，这种设计更不可接受。如果getUser除了要返回User的基本信息外，还需要返回一个AccountId、AccountName、RegionId、RegionName，那么，请把这些属性定义到UserInfo中，把一个“立体”的对象树“压扁”成一个“扁平的二维对象”，笔者目前参与的项目是一个分布式系统，该系统不管三七二十一，把一个对象的所有关联对象都转换为相同结构的DTO对象树并返回，导致性能非常的慢。</p><h5 id="DO与PO的区别"><a href="#DO与PO的区别" class="headerlink" title="DO与PO的区别"></a>DO与PO的区别</h5><pre><code>DO和PO在绝大部分情况下是一一对应的，PO是只含有get/set方法的POJO，但某些场景还是能反映出两者在概念上存在本质的区别： </code></pre><p>DO在某些场景下不需要进行显式的持久化，例如利用策略模式设计的商品折扣策略，会衍生出折扣策略的接口和不同折扣策略实现类，这些折扣策略实现类可以算是DO，但它们只驻留在静态内存，不需要持久化到持久层，因此，这类DO是不存在对应的PO的。<br>同样的道理，某些场景下，PO也没有对应的DO，例如老师Teacher和学生Student存在多对多的关系，在关系数据库中，这种关系需要表现为一个中间表，也就对应有一个TeacherAndStudentPO的PO，但这个PO在业务领域没有任何现实的意义，它完全不能与任何DO对应上。这里要特别声明，并不是所有多对多关系都没有业务含义，这跟具体业务场景有关，例如：两个PO之间的关系会影响具体业务，并且这种关系存在多种类型，那么这种多对多关系也应该表现为一个DO，又如：“角色”与“资源”之间存在多对多关系，而这种关系很明显会表现为一个DO——“权限”。<br>某些情况下，为了某种持久化策略或者性能的考虑，一个PO可能对应多个DO，反之亦然。例如客户Customer有其联系信息Contacts，这里是两个一对一关系的DO，但可能出于性能的考虑（极端情况，权作举例），为了减少数据库的连接查询操作，把Customer和Contacts两个DO数据合并到一张数据表中。反过来，如果一本图书Book，有一个属性是封面cover，但该属性是一副图片的二进制数据，而某些查询操作不希望把cover一并加载，从而减轻磁盘IO开销，同时假设ORM框架不支持属性级别的延迟加载，那么就需要考虑把cover独立到一张数据表中去，这样就形成一个DO对应对个PO的情况。<br>PO的某些属性值对于DO没有任何意义，这些属性值可能是为了解决某些持久化策略而存在的数据，例如为了实现“乐观锁”，PO存在一个version的属性，这个version对于DO来说是没有任何业务意义的，它不应该在DO中存在。同理，DO中也可能存在不需要持久化的属性。</p><h5 id="DO与PO的应用"><a href="#DO与PO的应用" class="headerlink" title="DO与PO的应用"></a>DO与PO的应用</h5><pre><code>由于ORM框架的功能非常强大而大行其道，而且JavaEE也推出了JPA规范，现在的业务应用开发，基本上不需要区分DO与PO，PO完全可以通过JPA，Hibernate Annotations/hbm隐藏在DO之中。虽然如此，但有些问题我们还必须注意： </code></pre><p>对于DO中不需要持久化的属性，需要通过ORM显式的声明，如：在JPA中，可以利用@Transient声明。<br>对于PO中为了某种持久化策略而存在的属性，例如version，由于DO、PO合并了，必须在DO中声明，但由于这个属性对DO是没有任何业务意义的，需要让该属性对外隐藏起来，最常见的做法是把该属性的get/set方法私有化，甚至不提供get/set方法，但对于Hibernate来说，这需要特别注意，由于Hibernate从数据库读取数据转换为DO时，是利用反射机制先调用DO的空参数构造函数构造DO实例，然后再利用JavaBean的规范反射出set方法来为每个属性设值，如果不显式声明set方法，或把set方法设置为private，都会导致Hibernate无法初始化DO，从而出现运行时异常，可行的做法是把属性的set方法设置为protected。<br>对于一个DO对应多个PO，或者一个PO对应多个DO的场景，以及属性级别的延迟加载，Hibernate都提供了很好的支持，请参考Hibnate的相关资料。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是反射</title>
      <link href="/2016/10/11/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/"/>
      <url>/2016/10/11/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%8D%E5%B0%84/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>“<strong>反射（Reflection）能够让运行于JVM中的程序检测和修改运行时的行为。</strong>”这个概念常常会和内省（Introspection）混淆，以下是这两个术语在Wikipedia中的解释：</p><a id="more"></a><ul><li>内省用于在运行时检测某个对象的类型和其包含的属性</li><li>反射用于在运行时检测和修改某个对象的结构及其行为</li></ul><p>从它们的定义可以看出，内省是反射的一个子集。有些语言支持内省，但并不支持反射，如C++</p><ul><li>内省示例：instanceof 运算符用于检测某个对象是否属于特定的类</li></ul><pre><code>if (obj instanceof Dog) {    Dog d = (Dog) obj;    d.bark();}</code></pre><ul><li>反射示例：Class.forName()方法可以通过类或接口的名称（一个字符串或完全限定名）来获取对应的Class对象。forName方法会触发类的初始化</li></ul><pre><code>// 使用反射Class&lt;?&gt; c = Class.forName(&quot;classpath.and.classname&quot;);Object dog = c.newInstance();Method m = c.getDeclaredMethod(&quot;bark&quot;, new Class&lt;?&gt;[0]);m.invoke(dog);</code></pre><ul><li>在Java中，反射更接近于内省，因为你无法改变一个对象的结构。虽然一些API可以用来修改方法和属性的可见性，但并不能修改结构</li></ul><h3 id="为什么需要反射"><a href="#为什么需要反射" class="headerlink" title="为什么需要反射"></a>为什么需要反射</h3><p>反射能够让我们：</p><ul><li>在运行时检测对象的类型</li><li>动态构造某个类的对象</li><li>检测类的属性和方法</li><li>任意调用对象的方法</li><li>修改构造函数、方法、属性的可见性</li><li>以及其他</li></ul><p><strong>反射是框架中常用的方法</strong></p><ul><li>例如，<a href="http://www.programcreek.com/2012/02/junit-tutorial-2-annotations/" target="_blank" rel="noopener">JUnit</a> 通过反射来遍历包含 @Test 注解的方法，并在运行单元测试时调用它们。（这个连接中包含了一些<a href="http://www.programcreek.com/2012/02/junit-tutorial-2-annotations/" target="_blank" rel="noopener">JUnit</a> 的使用案例）</li></ul><p>对于Web框架，开发人员在配置文件中定义他们对各种接口和类的实现。通过反射机制，框架能够快速地动态初始化所需要的类</p><ul><li>例如，Spring框架使用如下的配置文件：</li></ul><pre><code>&lt;bean id=&quot;someID&quot; class=&quot;com.programcreek.Foo&quot;&gt;    &lt;property name=&quot;someField&quot; value=&quot;someValue&quot; /&gt;&lt;/bean&gt;</code></pre><ul><li>当Spring容器处理元素时，会使用Class.forName(“com.programcreek.Foo”)来初始化这个类，并再次使用反射获取元素对应的setter方法，为对象的属性赋值</li><li>Servlet也会使用相同的机制：</li></ul><pre><code>&lt;servlet&gt;    &lt;servlet-name&gt;someServlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;com.programcreek.WhyReflectionServlet&lt;/servlet-class&gt;&lt;servlet&gt;</code></pre><h3 id="处理泛型"><a href="#处理泛型" class="headerlink" title="处理泛型"></a>处理泛型</h3><ul><li>Java 5中引入了泛型的概念之后，Java反射API也做了相应的修改，以提供对泛型的支持。由于类型擦除机制的存在，泛型类中的类型参数等信息，在运行时刻是不存在的。JVM看到的都是原始类型。对此，Java 5对Java类文件的格式做了修订，添加了Signature属性，用来包含不在JVM类型系统中的类型信息。 在运行时刻，JVM会读取Signature属性的内容并提供给反射API来使用。比如在代码中声明了一个域是List类型的，虽然在运行时刻其类型会变成原始类型List，但是仍然可以通过反射来获取到所用的实际的类型参数</li></ul><pre><code>Field field = Pair.class.getDeclaredField(&quot;myList&quot;); //myList的类型是List Type type = field.getGenericType(); if (type instanceof ParameterizedType) {         ParameterizedType paramType = (ParameterizedType) type;         Type[] actualTypes = paramType.getActualTypeArguments();         for (Type aType : actualTypes) {                 if (aType instanceof Class) {                     Class clz = (Class) aType;                         System.out.println(clz.getName()); //输出java.lang.String                 }         } }</code></pre><h3 id="Class类"><a href="#Class类" class="headerlink" title="Class类"></a>Class类</h3><p>在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息跟踪着这个对象所属的类。可以通过专门的Java类访问这些信息，保存这些信息的类被称为<strong>Class类</strong>。获取Class对象的三种方法：</p><ol><li><p>通过调用Object类中的getClass()方法返回一个Class对象</p><pre><code>Object myObject = new Object();Class myObjectClass = myObject.getClass();</code></pre></li><li><p>通过调用静态方法forName获得类名对应的Class对象</p><pre><code>String className = &quot;java.util.Date&quot;;Class cl = Class.forName(className);</code></pre></li></ol><p>注意：在使用<code>Class.forName()</code>方法时，必须提供一个类的全名，这个全名包括类所在的包的名字。</p><ol><li>如果在调用该方法时，没有找到该路径的类，将会抛出ClassNotFoundException。获得Class对象的第三种方法非常简单，如果<code>T</code>是任意的Java类型，<code>T.class</code>将代表匹配的类对象<code>Class cl1 = Date.class;Class cl2 = int.class;</code></li></ol><p>补充：可通过下面方式访问类的父类</p><pre><code>Object myObject = new Object();Class myObjectClass = myObject.getSuperclass();</code></pre><h3 id="获取类名"><a href="#获取类名" class="headerlink" title="获取类名"></a>获取类名</h3><p>通过Class对象可以获取两个版本的类名：</p><ol><li><p>通过getName()方法返回类的全限定类名(包含包名)：</p><pre><code>Class aClass = ... //获取Class对象String className = aClass.getName();</code></pre></li><li><p>通过getSimpleName()方法返回类名(不包含包名)</p><pre><code>Class aClass = ... //获取Class对象String className = aClass.getSimpleName();</code></pre></li></ol><h3 id="获取修饰符"><a href="#获取修饰符" class="headerlink" title="获取修饰符"></a>获取修饰符</h3><p>可以通过Class对象的<code>getModifiers()</code>方法来访问一个类的修饰符，该方法通过返回一个整型数值，用不同的位开关描述public/private/static等修饰符的使用状况。</p><pre><code>Class aClass = ... //获取Class对象int modifiers = aClass.getModifiers();</code></pre><p>还可以使用Modifier类中的isPublic、isPrivate或isFinal判断方法或构造器是否是public、private或final。</p><pre><code>Modifier.isAbstract(int modifiers);Modifier.isFinal(int modifiers);Modifier.isInterface(int modifiers);Modifier.isNative(int modifiers);Modifier.isPrivate(int modifiers);Modifier.isProtected(int modifiers);Modifier.isPublic(int modifiers);Modifier.isStatic(int modifiers);Modifier.isStrict(int modifiers);Modifier.isSynchronized(int modifiers);Modifier.isTransient(int modifiers);Modifier.isVolatile(int modifiers);</code></pre><h3 id="获取包信息"><a href="#获取包信息" class="headerlink" title="获取包信息"></a>获取包信息</h3><p>可通过以下方式获取包信息：</p><pre><code>...Object object = new Object();Class cl = object.getClass();System.out.println(cl.getPackage());.../*outputpackage java.lang, Java Platform API Specification, version 1.7*/</code></pre><h3 id="获取实现的接口集合"><a href="#获取实现的接口集合" class="headerlink" title="获取实现的接口集合"></a>获取实现的接口集合</h3><p>可通过调用Class对象的<code>getInterfaces()</code>方法获取一个类实现的接口集合</p><pre><code>Class aClass = ... //获取Class对象Class[] interfaces = aClass.getInterfaces();</code></pre><p>注意：getInterfaces()方法仅仅只返回当前类所实现的接口，不包括当前类的父类所实现的接口。</p><h3 id="获取构造器"><a href="#获取构造器" class="headerlink" title="获取构造器"></a>获取构造器</h3><p>可通过调用Class对象的<code>getConstructors()</code>方法获取一个类的构造函数</p><pre><code>Class aClass = ... //获取Class对象Constructor[] constructors = aClass.getConstructors();</code></pre><p>返回的Constructor数组包含每一个声明为<code>public</code>的构造方法。</p><hr><p>还可以通过给定的构造方法的参数类型获取指定的构造方法，如下：返回的构造方法的方法参数为String类型</p><pre><code>Class aClass = ... //获取Class对象Constructor constructor = aClass.getConstructor(new Class[]{String.class});</code></pre><p>注意：如果没有指定的构造方法能匹配给定的方法参数，则会抛出<code>NoSuchMethodException</code>异常。</p><hr><p>还可以获取指定构造方法的方法参数信息</p><pre><code>Constructor constructor = ... //获取Constructor对象Class[] parameterTypes = constructor.getParameterTypes();</code></pre><hr><p>利用Constructor对象实例化一个类</p><pre><code>Constructor constructor = ... //获取Constructor对象Class[] parameterTypes = constructor.getParameterTypes();</code></pre><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>可通过调用Class对象的<code>getMethods()</code>方法获取一个类的所有方法</p><pre><code>Class aClass = ...//获取Class对象Method[] methods = aClass.getMethods();</code></pre><p>返回的Method对象数组包含了指定类中声明为public的所有变量集合。</p><hr><p>还可以通过具体的参数类型来获取指定的方法</p><pre><code>Class  aClass = ...//获取Class对象Method method = aClass.getMethod(&quot;doSomething&quot;, new Class[]{String.class});</code></pre><p>注意：如果根据给定的方法名称以及参数类型无法匹配到相应的方法，则会抛出NoSuchMethodException</p><hr><p>获取指定方法的方法参数以及返回类型</p><pre><code>Method method = ... //获取Class对象Class[] parameterTypes = method.getParameterTypes();Class returnType = method.getReturnType();</code></pre><hr><p>通过Method对象调用方法</p><pre><code>//获取一个方法名为doSomesthing，参数类型为String的方法Method method = MyObject.class.getMethod(&quot;doSomething&quot;, String.class);Object returnValue = method.invoke(null, &quot;parameter-value1&quot;);</code></pre><h3 id="获取变量"><a href="#获取变量" class="headerlink" title="获取变量"></a>获取变量</h3><p>可通过调用Class对象的<code>getFields()</code>方法获取一个类的成员变量</p><pre><code>Class aClass = ... //获取Class对象Field[] method = aClass.getFields();</code></pre><p>返回的Field对象数组包含了指定类中声明为<code>public</code>的所有变量集合</p><hr><p>还可以通过具体的变量名称获取指定的变量</p><pre><code>Class aClass = ... //获取Class对象Field[] method = aClass.getFields(&quot;someField&quot;);</code></pre><p>注意：在调用<code>getField()</code>方法时，如果根据给定的方法参数没有找到对应的变量，那么就会抛出<code>NoSuchFieldException</code></p><hr><p>通过调用<code>Field</code>对象的<code>getName()</code>方法获取它的变量名称</p><pre><code>Field field = ... //获取Field对象String fieldName = field.getName();</code></pre><hr><p>通过调用<code>Field</code>对象<code>getType()</code>方法来获取一个变量的类型（如String, int等等）</p><pre><code>Class aClass = ... //获取Class对象Field field = aClass.getField(&quot;someField&quot;);Object fieldType = field.getType();</code></pre><hr><p>通过调用<code>Field.get()</code>或<code>Field.set()</code>方法获取或设置(get/set)变量值</p><pre><code>Class  aClass = MyObject.classField field = aClass.getField(&quot;someField&quot;);MyObject objectInstance = new MyObject();Object value = field.get(objectInstance);field.set(objetInstance, value);</code></pre><h3 id="获取指定类的getters和setters"><a href="#获取指定类的getters和setters" class="headerlink" title="获取指定类的getters和setters"></a>获取指定类的getters和setters</h3><ul><li>Getter：Getter方法的名字以get开头，没有方法参数，返回一个值</li><li>Setter：Setter方法的名字以set开头，有一个方法参数</li></ul><p>一个获取getter方法和setter方法的例子:</p><pre><code>public static void printGettersSetters(Class aClass){  Method[] methods = aClass.getMethods();  for(Method method : methods){    if(isGetter(method)) System.out.println(&quot;getter: &quot; + method);    if(isSetter(method)) System.out.println(&quot;setter: &quot; + method);  }}public static boolean isGetter(Method method){  if(!method.getName().startsWith(&quot;get&quot;))      return false;  if(method.getParameterTypes().length != 0)   return false;  if(void.class.equals(method.getReturnType()) return false;  return true;}public static boolean isSetter(Method method){  if(!method.getName().startsWith(&quot;set&quot;)) return false;  if(method.getParameterTypes().length != 1) return false;  return true;}</code></pre><h3 id="获取私有变量"><a href="#获取私有变量" class="headerlink" title="获取私有变量"></a>获取私有变量</h3><p>可以通过调用<code>Class.getDeclaredField(String name)</code>方法或者<code>Class.getDeclaredFields()</code>方法获取私有变量和受保护变量，不包括超类的成员；<code>Class.getField(String name)</code>和<code>Class.getFields()</code>只会返回公有变量，其中包括超类的公有变量，而无法获取私有变量。</p><pre><code>public class PrivateObject {  private String privateString = null;  public PrivateObject(String privateString) {    this.privateString = privateString;  }}/**********************************************************************/PrivateObject privateObject = new PrivateObject(&quot;The Private Value&quot;);Field privateStringField = PrivateObject.class.            getDeclaredField(&quot;privateString&quot;);privateStringField.setAccessible(true);String fieldValue = (String) privateStringField.get(privateObject);System.out.println(&quot;fieldValue = &quot; + fieldValue);</code></pre><p>这个例子会输出”fieldValue = The Private Value”，<code>The Private Value</code>是<code>PrivateObject</code>实例的<code>privateString</code>私有变量的值，注意调用<code>PrivateObject.class.getDeclaredField(&quot;privateString&quot;)</code>方法会返回一个私有变量，这个方法返回的变量是定义在<code>PrivateObject</code>类中的而不是在它的父类中定义的变量。注意：<code>privateStringField.setAccessible(true)</code>这行代码，通过调用<code>setAccessible()</code>方法会关闭指定类Field实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p><h3 id="获取私有方法"><a href="#获取私有方法" class="headerlink" title="获取私有方法"></a>获取私有方法</h3><p>可以通过调用<code>Class.getDeclaredMethod(String name, Class[] parameterTypes)</code>或者<code>Class.getDeclaredMethods()</code>方法获取私有方法，不包括超类的成员；<code>Class.getMethod(String name, Class[] parameterTypes)</code>和<code>Class.getMethods()</code>方法，只会返回公有的方法，其中包括超类的公有方法，而无法获取私有方法。</p><pre><code>public class PrivateObject {  private String privateString = null;  public PrivateObject(String privateString) {    this.privateString = privateString;  }  private String getPrivateString(){    return this.privateString;  }}/*******************************************************************/PrivateObject privateObject = new PrivateObject(&quot;The Private Value&quot;);Method privateStringMethod = PrivateObject.class.        getDeclaredMethod(&quot;getPrivateString&quot;, null);privateStringMethod.setAccessible(true);String returnValue = (String)        privateStringMethod.invoke(privateObject, null);System.out.println(&quot;returnValue = &quot; + returnValue);</code></pre><p>这个例子会输出<code>&quot;returnValue = The Private Value&quot;</code>，<code>The Private Value</code>是<code>PrivateObject</code>实例的<code>getPrivateString()</code>方法的返回值。<code>PrivateObject.class.getDeclaredMethod(&quot;privateString&quot;)</code>方法会返回一个私有方法，这个方法是定义在<code>PrivateObject</code>类中的而不是在它的父类中定义的。注意：Method.setAcessible(true)这行代码，通过调用setAccessible()方法会关闭指定类的Method实例的反射访问检查，这行代码执行之后不论是私有的、受保护的以及包访问的作用域，你都可以在任何地方访问，即使你不在他的访问权限作用域之内。但是你如果你用一般代码来访问这些不在你权限作用域之内的代码依然是不可以的，在编译的时候就会报错。</p><h3 id="获取注解"><a href="#获取注解" class="headerlink" title="获取注解"></a>获取注解</h3><p><strong>什么是注解？</strong>注解是Java 5的一个新特性。注解是插入你代码中的一种注释或者说是一种元数据（meta data）。这些注解信息可以在编译期使用预编译工具进行处理（pre-compiler tools），也可以在运行期使用Java反射机制进行处理。下面是一个类注解的例子：</p><pre><code>@MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)public class TheClass {}</code></pre><p>在TheClass类定义的上面有一个@MyAnnotation的注解。注解的定义与接口的定义相似，下面是MyAnnotation注解的定义：</p><pre><code>@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyAnnotation {  public String name();  public String value();}</code></pre><p>在interface前面的@符号表名这是一个注解，一旦你定义了一个注解之后你就可以将其应用到你的代码中。</p><blockquote><p>说明：在注解定义中的两个指示@Retention(RetentionPolicy.RUNTIME)和@Target(ElementType.TYPE)，说明了这个注解该如何使用。</p><ol><li>@Retention(RetentionPolicy.RUNTIME)表示这个注解可以在运行期通过反射访问。如果你没有在注解定义的时候使用这个指示那么这个注解的信息不会保留到运行期，这样反射就无法获取它的信息。</li><li>@Target(ElementType.TYPE) 表示这个注解只能用在类型上面（比如类跟接口）。你同样可以把Type改为Field或者Method，或者你可以不用这个指示，这样的话你的注解在类，方法和变量上就都可以使用了。</li></ol></blockquote><hr><p><strong>类注解</strong>下是一个访问类注解的例子</p><pre><code>Class aClass = TheClass.class;Annotation[] annotations = aClass.getAnnotations();for(Annotation annotation : annotations){    if(annotation instanceof MyAnnotation){        MyAnnotation myAnnotation = (MyAnnotation) annotation;        System.out.println(&quot;name: &quot; + myAnnotation.name());        System.out.println(&quot;value: &quot; + myAnnotation.value());    }}</code></pre><p>你还可以像下面这样指定访问一个类的注解</p><pre><code>Class aClass = TheClass.class;Annotation annotation = aClass.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation){    MyAnnotation myAnnotation = (MyAnnotation) annotation;    System.out.println(&quot;name: &quot; + myAnnotation.name());    System.out.println(&quot;value: &quot; + myAnnotation.value());}</code></pre><hr><p><strong>方法注解</strong>下面是一个方法注解的例子</p><pre><code>public class TheClass {  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)  public void doSomething(){}}</code></pre><p>你可以像这样访问方法注解：</p><pre><code>Method method = ... //获取方法对象Annotation[] annotations = method.getDeclaredAnnotations();for(Annotation annotation : annotations){    if(annotation instanceof MyAnnotation){        MyAnnotation myAnnotation = (MyAnnotation) annotation;        System.out.println(&quot;name: &quot; + myAnnotation.name());        System.out.println(&quot;value: &quot; + myAnnotation.value());    }}</code></pre><p>你可以像这样访问指定的方法注解</p><pre><code>Method method = ... // 获取方法对象Annotation annotation = method.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation){    MyAnnotation myAnnotation = (MyAnnotation) annotation;    System.out.println(&quot;name: &quot; + myAnnotation.name());    System.out.println(&quot;value: &quot; + myAnnotation.value());}</code></pre><hr><p><strong>参数注解</strong>方法参数也可以添加注解，就像下面这样</p><pre><code>public class TheClass {  public static void doSomethingElse(        @MyAnnotation(name=&quot;aName&quot;, value=&quot;aValue&quot;) String parameter){  }}</code></pre><p>你可以通过Method对象来访问方法参数注解</p><pre><code>Method method = ... //获取方法对象Annotation[][] parameterAnnotations = method.getParameterAnnotations();Class[] parameterTypes = method.getParameterTypes();int i=0;for(Annotation[] annotations : parameterAnnotations){  Class parameterType = parameterTypes[i++];  for(Annotation annotation : annotations){    if(annotation instanceof MyAnnotation){        MyAnnotation myAnnotation = (MyAnnotation) annotation;        System.out.println(&quot;param: &quot; + parameterType.getName());        System.out.println(&quot;name : &quot; + myAnnotation.name());        System.out.println(&quot;value: &quot; + myAnnotation.value());    }  }}</code></pre><p>需要注意的是Method.getParameterAnnotations()方法返回一个注解类型的二维数组，每一个方法的参数包含一个注解数组。</p><hr><p><strong>变量注解</strong>下面是一个变量注解的例子</p><pre><code>public class TheClass {  @MyAnnotation(name=&quot;someName&quot;,  value = &quot;Hello World&quot;)  public String myField = null;}</code></pre><p>你可以像这样来访问变量的注解</p><pre><code>Field field = ... //获取方法对象&lt;/pre&gt;&lt;pre&gt;Annotation[] annotations = field.getDeclaredAnnotations();for(Annotation annotation : annotations){ if(annotation instanceof MyAnnotation){ MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(&quot;name: &quot; + myAnnotation.name()); System.out.println(&quot;value: &quot; + myAnnotation.value()); }}</code></pre><p>你可以像这样访问指定的变量注解</p><pre><code>Field field = ...//获取方法对象&lt;/pre&gt;&lt;pre&gt;Annotation annotation = field.getAnnotation(MyAnnotation.class);if(annotation instanceof MyAnnotation){ MyAnnotation myAnnotation = (MyAnnotation) annotation; System.out.println(&quot;name: &quot; + myAnnotation.name()); System.out.println(&quot;value: &quot; + myAnnotation.value());}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信接口JS-SDK开发测试</title>
      <link href="/2016/08/25/%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3JS-SDK%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95/"/>
      <url>/2016/08/25/%E5%BE%AE%E4%BF%A1%E6%8E%A5%E5%8F%A3JS-SDK%E5%BC%80%E5%8F%91%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>微信接口JS-SDK开发测试</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/Coding%20%E5%8D%9A%E5%AE%A2%2810%29.jpg" alt></p><a id="more"></a><p>1、先注册一个微信公众号，然后在公众号设置的功能设置里填写JS接口安全域名</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%871%E5%BE%AE%E4%BF%A1.png" alt="img"></p><p>2、 在页面中引入JS文件 </p><pre><code>&lt;script type=&quot;text/javascript&quot; src=&quot;http://res.wx.qq.com/open/js/jweixin-1.1.0.js&quot;&gt;&lt;/script&gt;</code></pre><p>3、通过config接口注入权限验证配置</p><pre><code>wx.config({    debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。    appId: &#39;&#39;, // 必填，公众号的唯一标识    timestamp: , // 必填，生成签名的时间戳    nonceStr: &#39;&#39;, // 必填，生成签名的随机串    signature: &#39;&#39;,// 必填，签名，见附录1    jsApiList: [] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2});</code></pre><p>注意： AppId和AppSecret在微信平台公众号后台的基本配置里获取。</p><p>其他参数通过一个 签名算法获取，代码如下</p><pre><code>import java.util.UUID;import java.util.Map;import java.util.HashMap;import java.util.Formatter;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.io.UnsupportedEncodingException;  class Sign {    public static void main(String[] args) {        String jsapi_ticket = &quot;&quot;;        // 注意 URL 一定要动态获取，不能 hardcode        String url = &quot;http://spring-d7f71.coding.io/&quot;;        Map&lt;String, String&gt; ret = sign(jsapi_ticket, url);        for (Map.Entry entry : ret.entrySet()) {            System.out.println(entry.getKey() + &quot;, &quot; + entry.getValue());        }    };    public static Map&lt;String, String&gt; sign(String jsapi_ticket, String url) {        Map&lt;String, String&gt; ret = new HashMap&lt;String, String&gt;();        String nonce_str = create_nonce_str();        String timestamp = create_timestamp();        String string1;        String signature = &quot;&quot;;        //注意这里参数名必须全部小写，且必须有序        string1 = &quot;jsapi_ticket=&quot; + jsapi_ticket +                  &quot;&amp;noncestr=&quot; + nonce_str +                  &quot;&amp;timestamp=&quot; + timestamp +                  &quot;&amp;url=&quot; + url;        System.out.println(string1);        try        {            MessageDigest crypt = MessageDigest.getInstance(&quot;SHA-1&quot;);            crypt.reset();            crypt.update(string1.getBytes(&quot;UTF-8&quot;));            signature = byteToHex(crypt.digest());        }        catch (NoSuchAlgorithmException e)        {            e.printStackTrace();        }        catch (UnsupportedEncodingException e)        {            e.printStackTrace();        }        ret.put(&quot;url&quot;, url);        ret.put(&quot;jsapi_ticket&quot;, jsapi_ticket);        ret.put(&quot;nonceStr&quot;, nonce_str);        ret.put(&quot;timestamp&quot;, timestamp);        ret.put(&quot;signature&quot;, signature);        return ret;    }    private static String byteToHex(final byte[] hash) {        Formatter formatter = new Formatter();        for (byte b : hash)        {            formatter.format(&quot;%02x&quot;, b);        }        String result = formatter.toString();        formatter.close();        return result;    }    private static String create_nonce_str() {        return UUID.randomUUID().toString();    }    private static String create_timestamp() {        return Long.toString(System.currentTimeMillis() / 1000);    }}</code></pre><p>4 、signature的获取方式</p><p>① 先获取access token，有两种方式获取</p><p>通过后台在线调试工具获取</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87acct1.png" alt="img"></p><p>② 通过<a href="https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</a> 获取，在URL中填写APPID和APPSECRET 会返回一个 json数据，其中有access_token.</p><p> ③ 用第一步拿到的access_token 采用http GET方式请求获得jsapi_ticket（有效期7200秒，开发者必须在自己的服务全局缓存jsapi_ticket）：<a href="https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi" target="_blank" rel="noopener">https://api.weixin.qq.com/cgi-bin/ticket/getticket?access_token=ACCESS_TOKEN&amp;type=jsapi</a></p><p>访问后会返回一个json数据,从中获取jsapi_ticket ,然后填入签名算法中获取所有参数。</p><p>5 、 参考官方文档，配置JS文件，添加相应的功能，最后上传到服务器进行测试(部分代码，地理位置测试)。</p><pre><code>&lt;%--  Created by IntelliJ IDEA.  User: Eric  Date: 2016/8/22  Time: 10:45  To change this template use File | Settings | File Templates.--%&gt;&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;微信接口开发测试&lt;/title&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initital-scale=1&quot;&gt;&lt;/head&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;http://res.wx.qq.com/open/js/jweixin-1.1.0.js&quot;&gt;&lt;/script&gt;&lt;script&gt;     wx.config({      debug: true,      appId: &#39;wxde3b68929a66f1d0&#39;,      timestamp: 1472108577,      nonceStr: &#39;9363b896-acd0-4b05-a5a4-f79c7419761d&#39;,      signature: &#39;0520367302ec40bb8b2eb71384730fea187a8558&#39;,      jsApiList: [        &#39;openLocation&#39;,        &#39;getLocation&#39;,      ]  });wx.ready(function () {  // 1 判断当前版本是否支持指定 JS 接口，支持批量判断  document.querySelector(&#39;#checkJsApi&#39;).onclick = function () {    wx.checkJsApi({      jsApiList: [        &#39;getNetworkType&#39;,        &#39;previewImage&#39;      ],      success: function (res) {        alert(JSON.stringify(res));      }    });  };  // 7 地理位置接口  // 7.1 查看地理位置  document.querySelector(&#39;#openLocation&#39;).onclick = function () {    wx.openLocation({      latitude: 23.099994,      longitude: 113.324520,      name: &#39;花神大厦&#39;,      address: &#39;南京软件谷花神大厦208&#39;,      scale: 14,      infoUrl: &#39;http://weixin.qq.com&#39;    });  };  // 7.2 获取当前地理位置  document.querySelector(&#39;#getLocation&#39;).onclick = function () {    wx.getLocation({      success: function (res) {        alert(JSON.stringify(res));      },      cancel: function (res) {        alert(&#39;用户拒绝授权获取地理位置&#39;);      }    });  };  &lt;/script&gt;  &lt;body ontouchstart=&quot;&quot;&gt;    &lt;div class=&quot;wxapi_container&quot;&gt;    &lt;div class=&quot;wxapi_index_container&quot;&gt;    &lt;ul class=&quot;label_box lbox_close wxapi_index_list&quot;&gt;    &lt;li class=&quot;label_item wxapi_index_item&quot;&gt;&lt;a class=&quot;label_inner&quot; href=&quot;#menu-location&quot;&gt;地理位置接口&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;    &lt;/div&gt;    &lt;div class=&quot;lbox_close wxapi_form&quot;&gt;     &lt;h3 id=&quot;menu-location&quot;&gt;地理位置接口&lt;/h3&gt;    &lt;span class=&quot;desc&quot;&gt;使用微信内置地图查看位置接口&lt;/span&gt;    &lt;button class=&quot;btn btn_primary&quot; id=&quot;openLocation&quot;&gt;openLocation&lt;/button&gt;    &lt;span class=&quot;desc&quot;&gt;获取地理位置接口&lt;/span&gt;    &lt;button class=&quot;btn btn_primary&quot; id=&quot;getLocation&quot;&gt;getLocation&lt;/button&gt;     &lt;/div&gt;    &lt;/div&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><p>6 、 测试结果如下</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87cs1.png" alt="img"></p><p>7、 真机扫二维码进行接口测试</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/Screenshot_2016-08-25-16-47-01.png" alt="img"></p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/Screenshot_2016-08-25-16-46-46.png" alt="img"></p><p>参考官网链接：<a href="http://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3" target="_blank" rel="noopener">http://qydev.weixin.qq.com/wiki/index.php?title=%E5%BE%AE%E4%BF%A1JS-SDK%E6%8E%A5%E5%8F%A3</a></p><p>  注意看附录。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDEA下Log4j 使用教程</title>
      <link href="/2016/08/20/IDEA%E4%B8%8BLog4j-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2016/08/20/IDEA%E4%B8%8BLog4j-%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>Log4j是Apache的一个开源项目，通过使用Log4j,我们可以控制日志信息输送的目的地是控制台、文件、GUI主件、甚至是套接口服务器；我们可以通过配置文件控制每一条日志的输出格式，通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程，可以通过一个配置文件来灵活地进行配置，而不需要修改应用的代码。</p><a id="more"></a><h5 id="一、配置过程"><a href="#一、配置过程" class="headerlink" title="一、配置过程"></a>一、配置过程</h5><p><strong>1、通过Maven 的pom.xml 导入log4j的jar包。</strong></p><p><strong>2、 在src/main/resources下创建log4j.properties文件，配置属性。</strong></p><p><strong>3、配置根Logger,Logger 负责处理日志记录的大部分操作</strong></p><p>其语法为：log4j.rootLogger = [level], appenderName,appenderName,….</p><p>其中，level的日志记录的优先级，分为 OFF、FATAL、ERROR、WRAN、INFO、DEBUG、ALL或者自定义的级别。我们常使用四个级别,优先级从高到低分别是 ERROR、WRAN、INFO、DEBUG。通过定义级别，可以控制应用程序中相应级别的日志信息的开关，比如定义了INFO的级别，只有高于这个级别才进行处理, 而低于INFO级别的DEBUG的日志信息将不会被打印出来。ALL: 打印所有的日志, OFF: 关闭所有的日子输出, appenderName 就是指日志信息输出到哪个地方, 可以同时指定多个输出地, 如控制台(Console)、文件(Files)等,还可以根据天数或者文件大小产生新的文件，可以以流的形式发送到其它地方等。</p><p><strong>4、配置日志信息输出目的地 Appender,Appender 负责控制日志记录操作的输出</strong></p><p><strong>语法为：</strong></p><p>log4j.appender.appenderName = fully.qualified.name.of.appender.class log4j.appender.appenderName.option1 = value1 … log4j.appender.appenderName.optionN = valueN 这里的appenderName为在第一步里定义的，可任意起名。</p><p><strong>5、其中,Log4j 提供的appender有以下几种：</strong></p><p>org.apache.log4j.ConsoleAppender(控制台)</p><p>org.apache.log4j.FileAppender(文件)</p><p>org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件)</p><p>org.apache.log4j.RollingFileAppender(文件大小到指定尺寸的时候产生一个新文件),可通过log4j.appender.R.MaxFileSize=100kb设置文件大小,还可通过log4j.appender.R.MaxBackupIndex=1设置为保存一个备份文件。</p><p>org.apache.log4j.WriterAppender(将日志信息已流格式发送到任意指定的地方)</p><p>例如: log4j.appender.stdout=org.apache.log4j.ConsoleAppender 定义一个名为stdout的输出目的地，ConsoleAppender为控制台。</p><p><strong>6、 配置日志信息的格式(布局)Layout, Layout 负责格式化Appender的输出</strong></p><p>语法为：</p><p>log4j.appender.appenderName.layout = fully.qualified.name.of.layout.class<br>log4j.appender.appenderName.layout.option1 = value1<br>…<br>log4j.appender.appenderName.layout.optionN = valueN</p><p>其中, Log4j提供的layout有以下几种：</p><p>org.apache.log4j.HTMLLayout(已HTML表格形式布局)</p><p>org.apache.log4j.PatternLayout(可以灵活地指定布局模式)</p><p>org.apache.log4j.SimpleLayout(包含日志信息的级别 和信息字符串)</p><p>org.apache.log4j.TTCCLayout(包含日志产生的时间、线程、类别等等信息)</p><p><strong>7、关于格式化日志</strong></p><p>Log4j采用类似C语言中的printf函数的打印格式格式化日志信息，打印参数如下：</p><p>%m 输出代码中指定的消息</p><p>%M 输出打印该条日志的方法名</p><p>%p 输出优先级, 即DEBUG, INFO, WARN, ERROR, FATAL; </p><p>%r 输出自应用启动到输出 该log信息耗费的毫秒数;</p><p>%c 输出所属的类目, 通常就是所在类的全名</p><p>%t 输出产生该日志事件的线程名</p><p>%n 输出一个回车换行符, windows平台为”rn“ , Unix平台为”n“;</p><p>%d 输出日志时间点的日期或时间, 默认格式为ISO8601,也可以在其后指定格式,比如： %d{yyyy-MM-dd HH:mm:ss,SSS},输出类似：2016-8-20 22:52:55,921;</p><p>%|输出日志事件的发生位置,及在代码中的行数。</p><h5 id="二、配置文件详解-代码"><a href="#二、配置文件详解-代码" class="headerlink" title="二、配置文件详解(代码)"></a>二、配置文件详解(代码)</h5><pre><code>###设置###log4j.rootLogger = debug,stdout,D,E### 输出信息到控制台 ###log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target = System.outlog4j.appender.stdout.layout = org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern = [%-5p] %d{yyyy-MM-dd HH:mm:ss,SSS} method:%l%n%m%n### 输出DEBUG 级别以上的日志到文件F://logs/debug.log ###log4j.appender.D = org.apache.log4j.FileAppenderlog4j.appender.D.File = F:/logs/debug.loglog4j.appender.D.Append = truelog4j.appender.D.Threshold = DEBUGlog4j.appender.D.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss} [%t:%r] - [%p] %m%n### 输出ERROR 级别以上的日志文件到 文件F://logs.error.log ###log4j.appender.E = org.apache.log4j.FileAppenderlog4j.appender.E.File = F://logs/error.loglog4j.appender.E.Append = truelog4j.appender.E.Threshold = ERRORlog4j.appender.E.layout = org.apache.log4j.PatternLayoutlog4j.appender.E.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss} [%t:%r] - [%p] %m%n</code></pre><p>代码注释如下</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/log4j.png" alt></p><h5 id="三、写测试文件"><a href="#三、写测试文件" class="headerlink" title="三、写测试文件"></a>三、写测试文件</h5><pre><code>import org.apache.log4j.Logger;/** * Created by Gaohu on 2016-8-20 */public class Log4JTest {    private static  final Logger LOGGER = Logger.getLogger(Log4JTest.class);    public static void  main(String[] agrs){        // 记录debug级别的信息        LOGGER.debug(&quot;This is debug message.&quot;);        // 记录info级别的信息        LOGGER.info(&quot;This is info message.&quot;);        // 记录warn级别的信息        LOGGER.info(&quot;This is warn message.&quot;);        // 记录error级别的信息        LOGGER.error(&quot;This is error message.&quot;);    }}</code></pre><h5 id="四、测试结果如下"><a href="#四、测试结果如下" class="headerlink" title="四、测试结果如下"></a>四、测试结果如下</h5><p>在F盘下生成了debug.log 和 error.log 两个文件,文件记录了日志信息。</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/IDEA%E4%B8%8BLog4j%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B-IT%E5%A4%A7%E9%81%93%20%282%29.jpg" alt></p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87431.png" alt></p><p>参考文件链接：<a href="http://www.cnblogs.com/ITtangtang/p/3926665.html" target="_blank" rel="noopener">http://www.cnblogs.com/ITtangtang/p/3926665.html</a></p><p>​                           <a href="http://www.blogjava.net/gdws/articles/263160.html" target="_blank" rel="noopener">http://www.blogjava.net/gdws/articles/263160.html</a></p><p>​                       </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Maven 项目部署学习</title>
      <link href="/2016/08/19/Maven-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0/"/>
      <url>/2016/08/19/Maven-%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>相对于传统的项目，Maven下管理和构建项目非常方便与简单, Maven搭建详解。</p><a id="more"></a><h5 id="Maven骨架创建Java-Web项目"><a href="#Maven骨架创建Java-Web项目" class="headerlink" title="Maven骨架创建Java Web项目"></a>Maven骨架创建Java Web项目</h5><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/xxii-b-maven-hello-world-project-1.gif" alt="img"></p><p>注意： 在创建项目过程中，Maven会去中央仓库下载依赖或组件，可能有一点延迟。</p><h5 id="启动Java-Web-项目"><a href="#启动Java-Web-项目" class="headerlink" title="启动Java Web 项目"></a>启动Java Web 项目</h5><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/xxii-b-maven-hello-world-project-2.gif" alt="img"></p><p><strong>特别注意:</strong> 这里在Properties中添加一个参数<code>archetypeCatalog=internal</code>，不加这个参数，在maven生成骨架的时候将会非常慢，有时候会直接卡住。这里开始没注意,一直等,坑啊。。</p><p><strong>解释：</strong> </p><p>archetypeCatalog表示插件使用的archetype元数据，不加这个参数时默认为remote，local，即中央仓库archetype元数据，由于中央仓库的archetype太多了，所以导致很慢，指定internal来表示仅使用内部元数据。</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/20150131214447.png" alt></p><p>在main文件夹下新建一个java文件夹,把它设为源代码文件夹。</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/20150131215824.png" alt></p><p>设置artifact。</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/20150131220648.png" alt></p><p>设置tomcat</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/20150131224727.png" alt></p><p>Maven组件来管理项目，通过pom.xml 配置文件，可以引入所需要的架包。如下是引入SpringMVC的包。</p><h5 id="启动Tomcat-服务器-，部署项目，最后成功运行。"><a href="#启动Tomcat-服务器-，部署项目，最后成功运行。" class="headerlink" title="启动Tomcat 服务器 ，部署项目，最后成功运行。"></a>启动Tomcat 服务器 ，部署项目，最后成功运行。</h5><p>pom.xml 引入springMVC代码如下</p><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;  &lt;groupId&gt;com.my.web&lt;/groupId&gt;  &lt;artifactId&gt;maven&lt;/artifactId&gt;  &lt;packaging&gt;war&lt;/packaging&gt;  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;  &lt;name&gt;maven Maven Webapp&lt;/name&gt;  &lt;url&gt;http://maven.apache.org&lt;/url&gt;  &lt;dependencies&gt;    &lt;dependency&gt;      &lt;groupId&gt;junit&lt;/groupId&gt;      &lt;artifactId&gt;junit&lt;/artifactId&gt;      &lt;version&gt;3.8.1&lt;/version&gt;      &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-core&lt;/artifactId&gt;      &lt;version&gt;4.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-web&lt;/artifactId&gt;      &lt;version&gt;4.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;      &lt;version&gt;2.5&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;      &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;      &lt;version&gt;2.1&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;      &lt;version&gt;4.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework&lt;/groupId&gt;      &lt;artifactId&gt;spring-test&lt;/artifactId&gt;      &lt;version&gt;4.1.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;javax.servlet&lt;/groupId&gt;      &lt;artifactId&gt;jstl&lt;/artifactId&gt;      &lt;version&gt;1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;      &lt;artifactId&gt;spring-data-jpa&lt;/artifactId&gt;      &lt;version&gt;1.7.3.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate.javax.persistence&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-jpa-2.0-api&lt;/artifactId&gt;      &lt;version&gt;1.0.1.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.hibernate&lt;/groupId&gt;      &lt;artifactId&gt;hibernate-entitymanager&lt;/artifactId&gt;      &lt;version&gt;4.3.11.Final&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;mysql&lt;/groupId&gt;      &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;      &lt;version&gt;5.1.27&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;      &lt;groupId&gt;org.json&lt;/groupId&gt;      &lt;artifactId&gt;json&lt;/artifactId&gt;      &lt;version&gt;20070829&lt;/version&gt;    &lt;/dependency&gt;  &lt;/dependencies&gt;  &lt;build&gt;    &lt;finalName&gt;maven&lt;/finalName&gt;  &lt;/build&gt;&lt;/project&gt;</code></pre><p>参考文件链接：<a href="http://mark.leanote.com/post/%E4%BD%BF%E7%94%A8IntelliJ-IDEA-14%E5%92%8CMaven%E5%88%9B%E5%BB%BAjava-web%E9%A1%B9%E7%9B%AE" target="_blank" rel="noopener">http://mark.leanote.com/post/%E4%BD%BF%E7%94%A8IntelliJ-IDEA-14%E5%92%8CMaven%E5%88%9B%E5%BB%BAjava-web%E9%A1%B9%E7%9B%AE</a></p><p>​                           <a href="http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/maven-project-introduce.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/intellij-idea-tutorial/maven-project-introduce.html</a></p><p>​                           </p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>管理Bean</title>
      <link href="/2016/08/09/%E7%AE%A1%E7%90%86Bean/"/>
      <url>/2016/08/09/%E7%AE%A1%E7%90%86Bean/</url>
      
        <content type="html"><![CDATA[<h4 id="管理Bean"><a href="#管理Bean" class="headerlink" title="管理Bean"></a>管理Bean</h4><p>spring的bean容器到底是什么呢？<br>从表面上看就是一个类+一个xml文档，就是ApplicatonContext这个类和spring的配置文件beans.xml。我们经常就是写下面这样的语句<br><a id="more"></a></p><h4 id="Bean-自动装配的5种模式"><a href="#Bean-自动装配的5种模式" class="headerlink" title="Bean 自动装配的5种模式"></a>Bean 自动装配的5种模式</h4><p>① 使用buName模式</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; autowire=&quot;byName&quot;&gt;</code></pre><p>② 使用constructor模式</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; autowire=&quot;constructor&quot;&gt;</code></pre><p>③ 使用no模式</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; autowire=&quot;no&quot;&gt;</code></pre><p>④ 使用byType模式</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; autowire=&quot;byType&quot;&gt;</code></pre><p>⑤ 使用autodetect模式</p><p>autodetect 模式指的是通过对Bean检查内部类来选择constructor或byType，如果先找到constructor就用constructor；如果没有constructor，而找到byType，就用byType。</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; autowire=&quot;autodetect&quot;&gt;</code></pre><h4 id="Bean依赖检查的4种模式"><a href="#Bean依赖检查的4种模式" class="headerlink" title="Bean依赖检查的4种模式"></a>Bean依赖检查的4种模式</h4><p>在自动装配中，因为是隐式的，不像前面通过ref的属性指定依赖那么直接，所以开发人员很难看出Bean的每个属性是否都设定完成，这时就要借助依赖检查来实现查看Bean的每个属性是否都设定完成的功能。</p><p>① 使用simple模式</p><p>simple 模式指的是对基本类型，字符串和集合进行依赖检查。</p><pre><code>&lt;bean id=&quot;HelloWorld&quot; class=&quot;com.imau.HelloWorld&quot; dependency-check=&quot;simple&quot;&gt;</code></pre><p>② 使用object模式</p><p>object模式指的是对依赖的对象进行依赖检查。</p><p>③ 使用all模式</p><p>all模式指的是对全部属性进行依赖检查</p><p>④ 使用none模式</p><p>none模式指的是不进行依赖检查</p><p>总结:一般情况下，依赖检查和自动装配结合使用，当开发人员想查看Bean的每个属性是否都设定完成的时候，依赖检查的作用显得更大，当依赖检查和自动装配结合使用时，依赖检查会在自动装配完成后发生。但Bean的属性都有默认的值，或者不需要对Bean的属性是否都被设置到Bean上检查时，依赖检查的作用就不是很大。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之快速排序</title>
      <link href="/2016/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>基本思想：</strong>选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,<br><a id="more"></a><br>一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。</p><p><strong>快速排序</strong>是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 <em>n</em> 个项目要<strong>Ο</strong>(<em>n</em> log <em>n</em>)次比较。在最坏状况下则需要<strong>Ο</strong>(<em>n</em>2)次比较，但这种状况并不常见。事实上，快速排序通常明显比其他<strong>Ο</strong>(<em>n</em> log <em>n</em>) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤</strong>：</h4><p>1 从数列中挑出一个元素，称为 “基准”（pivot），</p><p>2 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作。</p><p>3 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序。</p><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87%E5%BF%AB%E9%80%9F2.png" alt></p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E8%BF%87%E7%A8%8B.png" alt></p><h4 id="算法实现-java"><a href="#算法实现-java" class="headerlink" title="算法实现(java):"></a>算法实现(java):</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token operator">=</span><span class="token punctuation">{</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">23</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 0表示第0个数，9表示长度</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">int</span> pivot<span class="token operator">=</span><span class="token function">partition</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//将数组分为两部分</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">//递归排序左子数组</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> pivot<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">//递归排序右子数组</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token keyword">int</span> low<span class="token punctuation">,</span><span class="token keyword">int</span> high<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> pivot<span class="token operator">=</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//枢轴记录</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">>=</span>pivot<span class="token punctuation">)</span>                high<span class="token operator">--</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">//交换比枢轴小的记录到左端</span>            <span class="token keyword">while</span><span class="token punctuation">(</span>low<span class="token operator">&lt;</span>high <span class="token operator">&amp;&amp;</span> a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">&lt;=</span>pivot<span class="token punctuation">)</span>                low<span class="token operator">++</span><span class="token punctuation">;</span>            a<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token operator">=</span>a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//交换比枢轴小的记录到右端</span>        <span class="token punctuation">}</span>        a<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token operator">=</span>pivot<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//扫描完成，枢轴到位</span>        <span class="token keyword">return</span> low<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//返回的是枢轴的位置</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><p><strong>时间复杂度：</strong></p><p>可以看出，每一次调用partition()方法都需要扫描一遍数组长度（注意，在递归的时候这个长度并不是原数组的长度n，而是被分隔出来的小数组，即n*(2^(-i))），其中i为调用深度。而在这一层同样长度的数组有2^i个。那么，每层排序大约需要O(n)复杂度。而一个长度为n的数组，调用深度最多为log(n)层。二者相乘，得到快速排序的平均复杂度为O(n ㏒n)。<br>通常，快速排序被认为是在所有同数量级的排序方法中，平均性能最好。<br>从代码中可以很容易地看出，快速排序单个栈的空间复杂度不高，每次调用partition方法时，其额外开销只有O(1)。所以，最好情形下快速排序空间复杂度大约为O(㏒n)。</p><p><strong>空间复杂度：</strong></p><p>很明显，其空间复杂度为O(㏒n)。</p><p><strong>算法优化</strong></p><p>上面这个快速排序算法可以说是最基本的快速排序，因为它并没有考虑任何输入数据。但是，我们很容易发现这个算法的缺陷：这就是在我们输入数据基本有序甚至完全有序的时候，这算法退化为冒泡排序，不再是O(n㏒n)，而是O(n^2)了。</p><p>究其根源，在于我们的代码实现中，每次只从数组第一个开始取。如果我们采用“三者取中”，即arr[low],arr[high],arr[（low+high）/2]三者的中值作为枢轴记录，则可以大大提高快速排序在最坏情况下的性能。但是，我们仍然无法将它在数组有序情形下的性能提高到O(n)。还有一些方法可以不同程度地提高快速排序在最坏情况下的时间性能。</p><p>此外，快速排序需要一个递归栈，通常情况下这个栈不会很深，为log(n)级别。但是，如果每次划分的两个数组长度严重失衡，则为最坏情况，栈的深度将增加到O(n)。此时，由栈空间带来的空间复杂度不可忽略。如果加上额外变量的开销，这里甚至可能达到恐怖的O(n^2)空间复杂度。所以，快速排序的最差空间复杂度不是一个定值，甚至可能不在一个级别。</p><p>为了解决这个问题，我们可以在每次划分后比较两端的长度，并先对<strong>短</strong>的序列进行排序（<em>目的是先结束这些栈以释放空间</em>），可以将最大深度降回到O(㏒n)级别。</p><p><strong>算法稳定性</strong></p><p>快速排序并不是稳定的。这是因为我们无法保证相等的数据按顺序被扫描到和按顺序存放。</p><p><strong>算法适用场景</strong></p><p>快速排序在大多数情况下都是适用的，尤其在数据量大的时候性能优越性更加明显。但是在必要的时候，需要考虑下优化以提高其在最坏情况下的性能。</p><p><strong>快排的非递归实现</strong></p><p>按照通常的理论，我们知道递归算法一般比较直观自然，容易理解和书写；而非递归算法一般更为晦涩，但是性能比递归算法更优良，因为其省去了大量的函数调用开销。快速排序肯定有非递归实现的版本，例如<a href="http://www.cnblogs.com/zhangchaoyang/articles/2234815.html" target="_blank" rel="noopener">这篇博客</a>。有趣的是，这位作者认为快速排序的非递归实现比递归还要慢，并做出了分析。</p><p>快速排序的Java非递归实现当然有，通常都是用自己实现的栈来模拟递归操作（实际上，前面两位使用C++的同学也是如此做的）。但是我并不认为它们比递归的方式有极大的性能提升，反而丢失了可读性，晦涩难懂。因此，我个人不提倡使用非递归方式。</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之选择排序</title>
      <link href="/2016/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/03/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>基本思想：</strong>在要排序的一组数中，选出最小的一个数与第一个位置的数交换；然后在剩下的数当中再找最小的与第二个位置的数交换，<br><a id="more"></a><br>如此循环到倒数第二个数和最后一个数比较为止。</p><p>选择排序(Selection sort)也是一种简单直观的排序算法。</p><p>选择排序是通过遍历每一次都找出最小（最大）的数查找出来放在第一位，然后从第二个元素开始重复上边的动作即可完成排序。选择排序的时间复杂度为哦（n^2），且为非稳定排序算法。</p><h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤</strong>：</h4><p>1）首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p><p>2）再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p><p>3）重复第二步，直到所有元素均排序完毕</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%9B%BE%E7%89%87%E5%A3%AB%E5%A4%A7%E5%A4%AB1.png" alt></p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h4 id="算法实现-java"><a href="#算法实现-java" class="headerlink" title="算法实现(java):"></a>算法实现(java):</h4><pre><code>public class ChoseSort {    public static void main(String[] args) {        int[] a={5,2,0,7,1,9};        choseSort(a);        for(int i=0;i&lt;a.length;i++){            System.out.println(a[i]);        }    }    public static void choseSort(int[] a){        int i,j,lowindex;        for(i=0;i&lt;a.length;i++){             lowindex=i;//将i设为最小值，然后从i+1开始遍历，有小于的交互            j=i+1;            while(j&lt;a.length){                if(a[lowindex]&gt;a[j]){                    lowindex=j;                }                j++;            }            int temp=a[i];            a[i]=a[lowindex];            a[lowindex]=temp;        }    }}</code></pre><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><p><strong>时间复杂度：</strong></p><p>简单选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。<br>就<strong>交换次数</strong>而言，在最好情况下，交换次数为<code>0</code>；在最坏的情况下，交换次数为<code>n-1</code>。<br>无论最好最坏情况，其<strong>比较次数</strong>都是一样多的，基于最终的排序时间是比较和交换的次数总和，其时间复杂度为Θ(n2)。<br>在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p><p><strong>空间复杂度：</strong></p><p>很明显，其空间复杂度为Θ(1)。</p><p><strong>稳定性：</strong></p><p>选择排序是不稳定的</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之冒泡排序</title>
      <link href="/2016/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
      <url>/2016/08/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>冒泡排序（Bubble Sort）</strong>也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。</p><a id="more"></a><p>走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><h4 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a><strong>算法步骤</strong>：</h4><p>1）比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p><p>2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p><p>3）针对所有的元素重复以上的步骤，除了最后一个。</p><p>4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p><p><img src="http://7xv8gw.com1.z0.glb.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt></p><h4 id="算法实现-java"><a href="#算法实现-java" class="headerlink" title="算法实现(java):"></a>算法实现(java):</h4><pre><code>public class BubbleSort {    public static void main(String[] args) {        int[] a={2,6,4,9,1,0,8,3};        bubbleSort(a);        for(int i=0;i&lt;a.length;i++){            System.out.println(a[i]);        }    }    public static void bubbleSort(int[] a){        int i,j;        for(i=0;i&lt;a.length;i++){            for(j=1;j&lt;a.length-i;j++){                if(a[j-1]&gt;a[j]){                    int temp=a[j];                    a[j]=a[j-1];                    a[j-1]=temp;                }            }        }    }}</code></pre><h4 id="算法分析："><a href="#算法分析：" class="headerlink" title="算法分析："></a>算法分析：</h4><p><strong>时间复杂度：</strong></p><p>在最好情况下，即要排序的数组本身就是有序的，则其时间复杂度为Θ(n)；<br>在最坏的情况下，即要排序的数组是逆序的，其时间复杂度为Θ(n2)。</p><p><strong>空间复杂度：</strong></p><p>很明显，其空间复杂度为Θ(1)。</p><p><strong>稳定性：</strong></p><p>冒泡排序是稳定的</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>java集合框架</title>
      <link href="/2016/07/27/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
      <url>/2016/07/27/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h4 id="java集合框架"><a href="#java集合框架" class="headerlink" title="java集合框架"></a>java集合框架</h4><h4 id="①-定义："><a href="#①-定义：" class="headerlink" title="① 定义："></a><strong>① 定义</strong>：</h4><p>集合(collection)就是一个存储一组对象的容器对象，一般将这些对象称为集合的元素(element)，Java集合框架支持三种类型的集合：规则集(set),线性表(list)和图(map),他们分别定义在接口Set、LIst、和Map中。Set的实例存储一组互不相同的元素，List的实例存储一组顺序排列的元素，Map的实例存储一组对象，每个对象都有一个关键的键。Java集合框架中主要接口和类的关系如下图，这些接口和类提供一组完整的API,可以有效的存储和处理对象构成的集合。</p><a id="more"></a><h4 id="②-接口：Collection"><a href="#②-接口：Collection" class="headerlink" title="② 接口：Collection"></a><strong>② 接口：Collection</strong></h4><p>Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素（Elements）。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java SDK不提供直接继承自Collection的类，Java SDK提供的类都是继承自Collection的“子接口”如List和Set。</p><p>所有实现Collection接口的类都必须提供两个标准的构造函数：无参数的构造函数用于创建一个空的Collection，有一个Collection参数的构造函数用于创建一个新的Collection，这个新的Collection与传入的Collection有相同的元素。后一个构造函数允许用户复制一个Collection。</p><p>主要的一个接口方法：boolean add(Ojbect c)</p><p>虽然返回的是boolean，但不是表示添加成功与否，这个返回值表示的意义是add()执行后，集合的内容是否改变了（就是元素的数量、位置等有无变化）。类似的addAll，remove，removeAll，remainAll也是一样的。</p><h4 id="③-用Iterator模式实现遍历集合"><a href="#③-用Iterator模式实现遍历集合" class="headerlink" title="③ 用Iterator模式实现遍历集合"></a><strong>③ 用Iterator模式实现遍历集合</strong></h4><p>Collection有一个重要的方法：iterator()，返回一个Iterator（迭代器），用于遍历集合的所有元素。Iterator模式可以把访问逻辑从不同的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。典型的用法如下：</p><p>Iterator it = collection.iterator(); // 获得一个迭代器</p><p>while(it.hasNext()) {</p><p>Object obj = it.next(); // 得到下一个元素</p><p>}</p><p>不需要维护遍历集合的“指针”，所有的内部状态都由Iterator来维护，而这个Iterator由集合类通过工厂方法生成。</p><p>每一种集合类返回的Iterator具体类型可能不同，但它们都实现了Iterator接口，因此，我们不需要关心到底是哪种Iterator，它只需要获得这个Iterator接口即可，这就是接口的好处，面向对象的威力。</p><p>要确保遍历过程顺利完成，必须保证遍历过程中不更改集合的内容（Iterator的remove()方法除外），所以，确保遍历可靠的原则是：只在一个线程中使用这个集合，或者在多线程中对遍历代码进行同步。</p><h4 id="④-由Collection接口派生的两个接口是List和Set。"><a href="#④-由Collection接口派生的两个接口是List和Set。" class="headerlink" title="④ 由Collection接口派生的两个接口是List和Set。"></a><strong>④ 由Collection接口派生的两个接口是List和Set。</strong></h4><h5 id="List接口"><a href="#List接口" class="headerlink" title="List接口"></a><strong>List接口</strong></h5><p>List是有序的Collection，使用此接口能够精确的控制每个元素插入的位置。用户能够使用索引（元素在List中的位置，类似于数组下标）来访问List中的元素，这类似于Java的数组。和下面要提到的Set不同，List允许有相同的元素。</p><p>除了具有Collection接口必备的iterator()方法外，List还提供一个listIterator()方法，返回一个ListIterator接口，和标准的Iterator接口相比，ListIterator多了一些add()之类的方法，允许添加，删除，设定元素，还能向前或向后遍历。</p><h4 id="⑤-实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。"><a href="#⑤-实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。" class="headerlink" title="*⑤ 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。**"></a>*⑤ 实现List接口的常用类有LinkedList，ArrayList，Vector和Stack。**</h4><h5 id="LinkedList类"><a href="#LinkedList类" class="headerlink" title="LinkedList类"></a><strong>LinkedList类</strong></h5><p>LinkedList实现了List接口，允许null元素。此外LinkedList提供额外的get，remove，insert方法在LinkedList的首部或尾部。这些操作使LinkedList可被用作堆栈（stack），队列（queue）或双向队列（deque）。</p><p>注意LinkedList没有同步方法。如果多个线程同时访问一个List，则必须自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：</p><p>List list = Collections.synchronizedList(new LinkedList(…));</p><h5 id="ArrayList类"><a href="#ArrayList类" class="headerlink" title="ArrayList类"></a><strong>ArrayList类</strong></h5><p>ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。</p><p>size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。</p><p>每个ArrayList实例都有一个容量（Capacity）默认为10，即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</p><p>和LinkedList一样，ArrayList也是非同步的（unsynchronized）。</p><h5 id="Vector类（线程安全）"><a href="#Vector类（线程安全）" class="headerlink" title="Vector类（线程安全）"></a><strong>Vector类</strong>（线程安全）</h5><p>Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</p><h5 id="Stack-类（线程安全）"><a href="#Stack-类（线程安全）" class="headerlink" title="Stack 类（线程安全）"></a><strong>Stack 类</strong>（线程安全）</h5><p>Stack继承自Vector，实现一个后进先出的堆栈。Stack提供5个额外的方法使得Vector得以被当作堆栈使用。基本的push和pop方法，还有peek方法得到栈顶的元素，empty方法测试堆栈是否为空，search方法检测一个元素在堆栈中的位置。Stack刚创建后是空栈。</p><h5 id="Set接口"><a href="#Set接口" class="headerlink" title="Set接口"></a><strong>Set接口</strong></h5><p>Set是一种不包含重复的元素的Collection，即任意的两个元素e1和e2都有e1.equals(e2)=false，Set最多有一个null元素。</p><p>很明显，Set的构造函数有一个约束条件，传入的Collection参数不能包含重复的元素。</p><p>请注意：必须小心操作可变对象（Mutable Object）。如果一个Set中的可变元素改变了自身状态导致Object.equals(Object)=true将导致一些问题。</p><h5 id="Map接口"><a href="#Map接口" class="headerlink" title="Map接口"></a><strong>Map接口</strong></h5><p>请注意，Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同的key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当作一组key集合，一组value集合，或者一组key-value映射。</p><p>Hashtable类</p><p>Hashtable继承Map接口，实现一个key-value映射的哈希表。任何非空（non-null）的对象都可作为key或者value。</p><p>添加数据使用put(key, value)，取出数据使用get(key)，这两个基本操作的时间开销为常数。</p><p>Hashtable通过initial capacity和load factor两个参数调整性能。通常缺省的load factor 0.75较好地实现了时间和空间的均衡。增大load factor可以节省空间但相应的查找时间将增大，这会影响像get和put这样的操作。</p><p>使用Hashtable的简单示例如下，将1，2，3放到Hashtable中，他们的key分别是”one”，”two”，”three”：</p><p>Hashtable numbers = new Hashtable();</p><p>numbers.put(“one”, new Integer(1));</p><p>numbers.put(“two”, new Integer(2));</p><p>numbers.put(“three”, new Integer(3));</p><p>要取出一个数，比如2，用相应的key：</p><p>Integer n = (Integer)numbers.get(“two”);</p><p>System.out.println(“two = ” + n);</p><p>由于作为key的对象将通过计算其散列函数来确定与之对应的value的位置，因此任何作为key的对象都必须实现hashCode和equals方法。hashCode和equals方法继承自根类Object，如果你用自定义的类当作key的话，要相当小心，按照散列函数的定义，如果两个对象相同，即obj1.equals(obj2)=true，则它们的hashCode必须相同，但如果两个对象不同，则它们的hashCode不一定不同，如果两个不同对象的hashCode相同，这种现象称为冲突，冲突会导致操作哈希表的时间开销增大，所以尽量定义好的hashCode()方法，能加快哈希表的操作。</p><p>如果相同的对象有不同的hashCode，对哈希表的操作会出现意想不到的结果（期待的get方法返回null），要避免这种问题，只需要牢记一条：要同时复写equals方法和hashCode方法，而不要只写其中一个。</p><p>Hashtable是同步的（线程安全）。</p><h5 id="HashMap类"><a href="#HashMap类" class="headerlink" title="HashMap类"></a><strong>HashMap类</strong></h5><p>HashMap和Hashtable类似，不同之处在于HashMap是非同步的，并且允许null，即null value和null key。，但是将HashMap视为Collection时（values()方法可返回Collection），其迭代器操作时间开销和HashMap的容量成比例。因此，如果迭代操作的性能相当重要的话，不要将HashMap的初始化容量设得过高，或者load factor过低。</p><h5 id="WeakHashMap类"><a href="#WeakHashMap类" class="headerlink" title="WeakHashMap类"></a><strong>WeakHashMap类</strong></h5><p>WeakHashMap是一种改进的HashMap，它对key实行“弱引用”，如果一个key不再被外部所引用，那么该key可以被GC回收。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>·如果涉及到堆栈，队列等操作，应该考虑用List，对于需要快速插入，删除元素，应该使用LinkedList，如果需要快速随机访问元素，应该使用ArrayList。</p><p>·如果程序在单线程环境中，或者访问仅仅在一个线程中进行，考虑非同步的类，其效率较高，如果多个线程可能同时操作一个类，应该使用同步的类。</p><p>·要特别注意对哈希表的操作，作为key的对象要正确覆写equals和hashCode方法。</p><p>·尽量返回接口而非实际的类型，如返回List而非ArrayList，这样如果以后需要将ArrayList换成LinkedList时，客户端代码不用改变。这就是针对抽象编程。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring框架</title>
      <link href="/2016/05/15/spring/"/>
      <url>/2016/05/15/spring/</url>
      
        <content type="html"><![CDATA[<h1 id="Spring-框架的组成"><a href="#Spring-框架的组成" class="headerlink" title="Spring 框架的组成"></a>Spring 框架的组成</h1><ol><li>core模块<br>Core模块是框架的核心类库,Spring 所有的功能均依赖该类库,Core 模块主要实现了IOC功能。 Spring的所有功能都是借助IoC实现的。</li></ol><a id="more"></a><ol start="2"><li><p>AOP模块<br>AOP模块Spring的AOP库，提供了AOP机制，并提供各种各样常用的拦截器，允许自定义，配置方法拦截器，拦截对象。</p></li><li><p>ORM 模块<br>ORM模块提供对常用ORM框架的管理，辅助支持，Spring 支持Hibernate，IBatis,JDO 等各种ORM框架。Spring 并不提供资金的ORM实现，只是对现有的ORM框架进行封装，并提供对它们的管理，例如事物管理等。</p></li><li><p>DAO 模块<br>DAO 模块提供JDBC 的支持，对JDBC进行了封装，允许JDBC使用Spring 的资源，并能统一管理JDBC的事物，Spring 也不提供JDBC实现。</p></li><li><p>WEB模块<br>web模块提供对Struts，WebWork，JSF等各种Web框架的支持，Spring能够管理这些框架，将Spring的资源如数据源，Bean等注射给框架，也能在执行方法前后插入Spring的拦截器。</p></li><li><p>Context 模块<br>Context模块提供框架式Bean访问方法，其他程序通过Context访问Spring的Bean资源，类似于JNDI。</p></li><li><p>Web MVC 模块<br>Web MVC模块Spring 提供一套轻量级的MVC实现，在Spring框架中，开发者可以选择Struts作为MVC框架，也可以使用Spring自带的MVC框架，Spring MVC 与Struts等框架相比，更加简洁，灵活。</p></li></ol><h3 id="Spring-的Core模块"><a href="#Spring-的Core模块" class="headerlink" title="Spring 的Core模块"></a>Spring 的Core模块</h3><ol><li>BeanFactory工厂</li></ol><h5 id="代码（实例化BeanFactory-工厂）"><a href="#代码（实例化BeanFactory-工厂）" class="headerlink" title="代码（实例化BeanFactory 工厂）"></a>代码（实例化BeanFactory 工厂）</h5><pre><code>ClassPathResource res  = new ClassPathResource(&quot;applicationContext.xml&quot;);//获取配置资源XmlBeanFactory factory = new XmlBeanFactory(res);//获取对象工厂IService hello=(IService) factory.getBean(&quot;service&quot;);//获取对象factory.destroySingletons();//销毁对象</code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构之插入排序</title>
      <link href="/2016/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/"/>
      <url>/2016/03/09/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<blockquote><p>栈实际上也是线性表，只不过是一种特殊的线性表。其特殊性在于栈的基本操作是线性表操作的子集，他们的操作受限于线性表，可称为限定性的数据结构。</p></blockquote><a id="more"></a><p><strong>栈(stack)是限定仅在表尾进行插入和删除操作的线性表，它是一种后进先出(Last in First out ,LIFO)的线性表</strong></p><p><strong>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，我们就应该首选“栈”这种数据结构</strong>。</p><h5 id="栈的特性"><a href="#栈的特性" class="headerlink" title="栈的特性"></a>栈的特性</h5><ul><li>允许插入和删除的一段称为<strong>栈顶(top)</strong>，另外一段称为<strong>栈底(bottom)</strong>。</li><li>不含任何数据元素的栈称为<strong>空栈</strong>。</li><li>栈的元素必须<strong>后进先出</strong>。</li></ul><h5 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h5><ul><li>插入操作<br>栈的插入操作(Push)，叫做<strong>进栈</strong>，也称<strong>压栈、入栈</strong>。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
